

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>قالب‌بندی</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/Gitab/" aria-current="page">خانه</a>
        <a href="/Gitab/books/list-books">کتاب‌ها</a>
       <a href="/Gitab/translator.html">مترجمین</a>
        <a href="/Gitab/giter.html">گیتر</a>
      </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>۵ قالب‌بندی</h1>
<p><img src="../../../assets/image/05/img-5.1.png" alt=""></p>
<div dir='rtl'>
<p>هنگامی‌که دیگران شروع می‌کنند به بررسی زیر و بم کد، می‌خواهیم آن‌ها را تحت تأثیر منظم بودن ، قوام و توجه به جزئیاتی که درک می‌کنند تحت تأثیر قرار دهیم. می‌خواهیم با نظم تحت‌تاثیر قرارگیرند. وقتی‌که به ماژول‌ها دقت می‌کنند، ابروهایشان بالا رود. می‌خواهیم بفهمند که افراد حرفه‌ای پشت کار بوده‌اند. اگر در عوض، توده کدی بینند که گویی توسط تعدادی ملوان مست نوشته شده‌است، به احتمال زیاد نتیجه می‌گیرند که همین عدم توجه به جزئیات، بر دیگر جنبه‌های پروژه نیز حاکم است.</p>
<p>باید مراقب باشید که کد شما به خوبی قالب‌بندی شود. باید مجموعه‌ای از قوانین ساده را انتخاب کنید که بر فرمت کد شما حاکم باشد، و سپس باید آن قوانین را به طور مداوم اعمال کنید. اگر در یک تیم کار می‌کنید ، تیم باید با یک مجموعه از قوانین قالب‌بندی موافقت کند و همه اعضا، آن را رعایت کنند. داشتن ابزاری خودکار که بتواند آن قوانین قالب‌بندی را برای شما اعمال کند، می‌تواند کمک‌کننده باشد.</p>
<h2>هدف قالب‌بندی</h2>
<p>اول از همه، بگذارید واضح باشیم. قالب‌بندی کد مهم است. بسیار مهم است که نادیده گرفته‌نشود و بسیار مهم است که مثل یک رفتار مذهبی به آن اهمیت دهید. قالب‌بندی کد مربوط به ارتباطات است و ارتباطات، مهمترین بخش برای توسعه‌دهندگان حرفه‌ای است.</p>
<p>شاید فکر کرده باشید که &quot;به نتیجه رساندن&quot; مهمترین بخش برای یک توسعه‌دهنده حرفه‌ای است. با این حال امیدوارم تاکنون این کتاب شما را از این ایده خارج کرده‌باشد. عملکردی که امروز ایجاد می کنید شانس زیادی برای تغییر در نسخه بعدی دارد ، اما خوانایی کد شما تأثیر عمیقی در تمام تغییراتی خواهد داشت که ایجاد می‌شود. شیوه کد نویسی و خوانایی مواردی را ایجاد می کند که مدت ها بعد از تغییر کد اصلی، بر حفظ و توسعه آن تأثیر می گذارد. سبک و نظم شما زنده می ماند ، حتی اگر کد شما اینگونه نباشد.</p>
<p>بنابراین چه موارد قالب‌بندی به ما کمک می‌کند تا بهترین ارتباط را برقرار کنیم؟</p>
<h2>قالب بندی عمودی</h2>
<p>بیایید با اندازه عمودی شروع کنیم. یک فایل منبع چقدر باید بزرگ باشد؟ در جاوا ، اندازه فایل با اندازه کلاس ارتباط نزدیک دارد. وقتی در مورد کلاس صحبت کنیم ، درباره اندازه کلاس صحبت خواهیم کرد. در حال حاضر بگذارید فقط اندازه فایل را در نظر بگیریم.</p>
<p>بزرگترین فایل‌های منبع جاوا چقدر بزرگ هستند؟ به نظر می‌رسد که طیف وسیعی از اندازه‌ها و تفاوت‌های قابل توجه در سبک وجود دارد. شکل 5-1 برخی از این تفاوت‌ها را نشان می‌دهد.</p>
<p>هفت پروژه مختلف به تصویر کشیده شده است.Junit, FitNesse, testNG, Time and Money, JDepend, Ant, و Tomcat. خطوط موجود در کادرها حداقل و حداکثر طول فایل را در هر پروژه نشان می‌دهد. این کادر تقریباً یک سوم فایل‌ها (یک انحراف استاندارد) را نشان می دهد. وسط جعبه، میانگین است. بنابراین متوسط اندازه فایل در پروژه FitNesse حدود 65 خط است و حدود یک سوم پرونده ها بین 40 تا 100 خط است. بزرگترین فایل در FitNesse حدود 400 خط و کوچکترین آن 6 خط است. توجه داشته باشید که این مقیاس لگاریتمی است، بنابراین اختلاف کم در موقعیت عمودی نشانگر اختلاف بسیار بزرگ در اندازه مطلق است.</p>
</div>
<p align="center">
  <img src=../../../assets/image/05/img-5.2.png/>
</p>
<div dir='rtl'>
توزیع طول فایل در مقیاس لگاریتمی (box height = sigma)
<p>Junit ، FitNesse و Time and Money از فایل‌های نسبتاً کمی تشکیل شده اند. هیچکدام بیش از 500 خط نیستند و بیشتر این فایل‌ها کمتر از 200 خط هستند. از طرف دیگر ، Tomcat و Ant دارای برخی از فایل‌ها هستند که چندین هزار خط طول دارند و نزدیک به نیمی از آنها بیش از 200 خط هستند.</p>
<p>برای ما چه معنایی دارد؟ به نظر می‌رسد امکان ساخت سیستم های قابل توجهی وجود دارد (FitNesse نزدیک به 50000 خط است) از فایل‌هایی که معمولاً 200 خط طول دارند و حد بالایی آنها 500 است. اگرچه این یک قانون سخت و سریع نیست ، اما باید بسیار مورد توجه قرار گیرد که درک فایل‌های کوچک معمولاً آسانتر از فایل‌های بزرگ است.</p>
<h3>استعاره روزنامه</h3>
<p>به یک مقاله خوش نوشت روزنامه فکر کنید. آن را به صورت عمودی می خوانید. در بالا، یک عنوان وجود دارد که به شما بگویید داستان از چه قرار است و به شما امکان می‌دهد تصمیم بگیرید که آیا مطلبی است که می خواهید بخوانید یا نه. پاراگراف اول خلاصه ای از کل داستان را به شما می دهد و تمام جزئیات را پنهان می کند. وقتی به سمت پایین ادامه می دهید ، جزئیات بیشتر می‌شوند، تا زمانی که همه تاریخ‌ها ، نام‌ها ، نقل قول‌ها ، ادعاها و سایر جزئیات را دارید.</p>
<p>دوست داریم که یک فایل منبع مانند مقاله روزنامه باشد. نام باید ساده، اما توضیحی باشد. این نام به خودی خود باید کافی باشد تا به ما بگوید آیا در ماژول درستی هستیم یا نه. بالاترین قسمت‌های فایل منبع باید مفاهیم و الگوریتم‌های سطح بالایی را ارائه دهند. با حرکت به سمت پایین جزئیات باید افزایش یابد تا اینکه در پایان، توابع و جزئیات پایین‌ترین سطح را در فایل منبع پیدا کنیم.</p>
<p>یک روزنامه از مقالات زیادی تشکیل شده است؛ بیشتر آنها بسیار کوچک هستند. بعضی از آنها کمی بزرگتر هستند. تعداد کمی از آنها درحد یک صفحه هستند. این باعث می شود روزنامه قابل استفاده باشد. اگر روزنامه فقط یک داستان طولانی بود که شامل مجموعه‌ای بی‌نظم از واقعیت‌ها‌، تاریخ‌ها و نام‌ها بود‌، به‌راحتی آن را نمی‌خواندیم.</p>
<h3>گشودگی عمودی بین مفاهیم</h3>
<p>تقریباً همه کد‌ها از چپ به راست و بالا به پایین خوانده می‌شوند. هر سطر بیانگر یک عبارت یا بند است و هر گروه از خطوط بیانگر یک تفکر کامل است. این افکار را باید با خطوط خالی از یکدیگر جدا کرد.</p>
<p>برای مثال ، لیست 5-1 را در نظر بگیرید. خطوط خالی‌ای وجود دارد که تعریف پکیج ، import(ها) و هر یک از توابع را جدا می کند. این قانون بسیار ساده، تأثیر پیش‌بینی شده‌ای در طرح بصری کد دارد. هر خط خالی، یک نشانه بصری است که مفهوم جدید و جداگانه‌ای را مشخص می‌کند. هنگامی که لیست را اسکن می‌کنید ، چشمتان به اولین خطی می‌رود که بعد یک خط خالی آمده.</p>
</div>
<p>Listing 5-1</p>
<p>BoldWidget.java</p>
<pre class="hljs"><code><span class="hljs-keyword">package</span> fitnesse.wikitext.widgets;

<span class="hljs-keyword">import</span> java.util.regex.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BoldWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentWidget</span> {
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REGEXP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#x27;&#x27;&#x27;.+?&#x27;&#x27;&#x27;&quot;</span>;
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;&#x27;&#x27;&#x27;(.+?)&#x27;&#x27;&#x27;&quot;</span>,
  Pattern.MULTILINE + Pattern.DOTALL
 );

 <span class="hljs-keyword">public</span> <span class="hljs-title function_">BoldWidget</span><span class="hljs-params">(ParentWidget parent, String text)</span> <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-built_in">super</span>(parent);
  <span class="hljs-type">Matcher</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> pattern.matcher(text);
  match.find();
  addChildWidgets(match.group(<span class="hljs-number">1</span>));
 }

 <span class="hljs-keyword">public</span> String <span class="hljs-title function_">render</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;&lt;b&gt;&quot;</span>);
  html.append(childHtml()).append(<span class="hljs-string">&quot;&lt;/b&gt;&quot;</span>);
  <span class="hljs-keyword">return</span> html.toString();
 }
}
</code></pre>
<div dir='rtl'>
<p>حذف آن خطوط خالی، مانند لیست 5-2، تأثیر قابل ملاحظه ای در خوانایی کد دارد.</p>
</div>
<p>Listing 5-2</p>
<p>BoldWidget.java</p>
<pre class="hljs"><code><span class="hljs-keyword">package</span> fitnesse.wikitext.widgets;
<span class="hljs-keyword">import</span> java.util.regex.*;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BoldWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentWidget</span> {
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REGEXP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#x27;&#x27;&#x27;.+?&#x27;&#x27;&#x27;&quot;</span>;
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;&#x27;&#x27;&#x27;(.+?)&#x27;&#x27;&#x27;&quot;</span>,
 Pattern.MULTILINE + Pattern.DOTALL);
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">BoldWidget</span><span class="hljs-params">(ParentWidget parent, String text)</span> <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-built_in">super</span>(parent);
  <span class="hljs-type">Matcher</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> pattern.matcher(text);
  match.find();
  addChildWidgets(match.group(<span class="hljs-number">1</span>));
 }
 <span class="hljs-keyword">public</span> String <span class="hljs-title function_">render</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;&lt;b&gt;&quot;</span>);
  html.append(childHtml()).append(<span class="hljs-string">&quot;&lt;/b&gt;&quot;</span>);
  <span class="hljs-keyword">return</span> html.toString();
 }
}
</code></pre>
<div dir='rtl'>
<p>هنگامی که چشم خود را متمرکز نکنید این اثر حتی بیشتر نمایان می شود. در مثال اول، گروه‌بنهدی‌های مختلف خطوط، واضح‌اند، درحالی‌که مثال دوم، به نظر می رسد درهم و برهم است. تفاوت این دو لیست درمقدار کمی از گشودگی عمودی است.</p>
<h3>تراکم عمودی</h3>
<p>اگر گشودگی، مفاهیم را از هم جدا کند ، پس تراکم عمودی به معنای یک ارتباط نزدیک است. بنابراین خطوط کدی که کاملاً با هم مرتبط هستند، باید به صورت عمودی متراکم به نظر برسند. توجه کنید که چگونه کامنت‌های بی فایده در لیست 5-3 ارتباط نزدیک دو متغیر نمونه را از بین می‌برد.</p>
</div>
<p>Listing 5-3</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReporterConfig</span> {

 <span class="hljs-comment">/**
 * The class name of the reporter listener
 */</span>
 <span class="hljs-keyword">private</span> String m_className;
 
 <span class="hljs-comment">/**
 * The properties of the reporter listener
 */</span>
 <span class="hljs-keyword">private</span> List&lt;Property&gt; m_properties = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Property&gt;();
 
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addProperty</span><span class="hljs-params">(Property property)</span> {
  m_properties.add(property);
 }
}
</code></pre>
<div dir='rtl'>
<p>خواندن لیست 5-4 بسیار راحت‌تر است. این در یک &quot;نگاه&quot; قرار می‌گیرد ، یا حداقل برای من اینطور است. بدون اینکه خیلی سر یا چشمهایم را حرکت دهم، می توانم به آن نگاه کنم و ببینم که این یک کلاس با دو متغیر و یک تابع است. لیست قبلی من را مجبور می‌کند تا از حرکت چشم و سر بسیار بیشتری برای رسیدن به سطح درک مشابه استفاده کنم.</p>
</div>
<p>Listing 5-4</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReporterConfig</span> {
 <span class="hljs-keyword">private</span> String m_className;
 <span class="hljs-keyword">private</span> List&lt;Property&gt; m_properties = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Property&gt;();
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addProperty</span><span class="hljs-params">(Property property)</span> {
  m_properties.add(property);
 }
}
</code></pre>
<div dir='rtl'>
<h3>فاصله عمودی</h3>
<p>تابحال شده که در کلاسی پرسه بزنید، از یک تابع به تابع دیگر بروید، سورس فایل را بالا و پایین کنید، ارتباط و عملکرد توابع را بفهمید اما نهایتا گیج شوید؟ آیا تابحال برای فهمیدن تعریف یک متغیر یا تابع به زنجیره‌ای از وراثت برخورد کرده‌اید؟ این ناامیدکننده است زیرا شما در حال فهمیدن این هستید که سیستم چه کاری انجام می دهد ، اما وقت و انرژی ذهنی خود را صرف این می کنید که مکانها را بیابید و به خاطر بسپارید.</p>
<p>مفاهیمی که ارتباط تنگاتنگی دارند باید به صورت عمودی نزدیک به یکدیگر نگه داشته شوند [G10]. واضح است که این قانون برای مفاهیمی که در فایل‌های جداگانه قرار دارند کار نمی کند. اما در این صورت مفاهیم نزدیک به هم را نباید در فایل‌های مختلف جدا کرد ، مگر اینکه دلیل خیلی خوبی داشته باشید. در واقع ، این یکی از دلایلی است که باید از متغیرهای محافظت شده اجتناب شود.</p>
<p>برای آن دسته از مفاهیمی که چنان با هم مرتبط هستند که در همان پرونده منبع قرار دارند ، تفکیک عمودی آنها باید معیاری برای میزان اهمیت هر یک برای قابل درک بودن دیگری باشد. می‌خواهیم از اجبار خوانندگان خود برای جستجوی فایل‌ها و کلاس‌های منبع جلوگیری کنیم.</p>
<p><strong>تعریف متغیر</strong> متغیرها باید تا حد امکان نزدیک به کاربرد آنها تعریف شوند. از آنجا که توابع ما بسیار کوتاه هستند ، متغیرهای محلی باید در بالای هر تابع ظاهر شوند ، مانند این تابع longish از Junit4.3.1.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readPreferences</span><span class="hljs-params">()</span> {
 InputStream is= <span class="hljs-literal">null</span>;
 <span class="hljs-keyword">try</span> {
  is= <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(getPreferencesFile());
  setPreferences(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>(getPreferences()));
  getPreferences().load(is);
 } <span class="hljs-keyword">catch</span> (IOException e) {
  <span class="hljs-keyword">try</span> {
   <span class="hljs-keyword">if</span> (is != <span class="hljs-literal">null</span>)
   is.close();
  } <span class="hljs-keyword">catch</span> (IOException e1) {
  }
 }
}
</code></pre>
<div dir='rtl'>
<p>متغیرهای کنترلی برای حلقه‌ها معمولاً باید در عبارت حلقه اعلان شوند ، همانطور که در این تابع کوچک زیبا از همان منبع وجود دارد.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countTestCases</span><span class="hljs-params">()</span> {
 <span class="hljs-type">int</span> count= <span class="hljs-number">0</span>;
 <span class="hljs-keyword">for</span> (Test each : tests)
 count += each.countTestCases();
 <span class="hljs-keyword">return</span> count;
}
</code></pre>
<div dir='rtl'>
<p>در موارد نادر ، یک متغیر ممکن است در بالای یک بلوک یا درست قبل از حلقه در یک تابع طولانی اعلام شود. چنین متغیری را می توانید از وسط یک تابع بسیار طولانی در TestNG در این قطعه مشاهده کنید.</p>
</div>
<pre class="hljs"><code>...
<span class="hljs-keyword">for</span> (XmlTest test : m_suite.getTests()) {
  <span class="hljs-type">TestRunner</span> <span class="hljs-variable">tr</span> <span class="hljs-operator">=</span> m_runnerFactory.newTestRunner(<span class="hljs-built_in">this</span>, test);
  tr.addListener(m_textReporter);
  m_testRunners.add(tr);
  invoker = tr.getInvoker();
  <span class="hljs-keyword">for</span> (ITestNGMethod m : tr.getBeforeSuiteMethods()) {
   beforeSuiteMethods.put(m.getMethod(), m);
  }
  <span class="hljs-keyword">for</span> (ITestNGMethod m : tr.getAfterSuiteMethods()) {
   afterSuiteMethods.put(m.getMethod(), m);
  }
}
...
</code></pre>
<div dir='rtl'>
<p><strong>متغیرهای نمونه</strong> از طرف دیگر، باید در بالای کلاس اعلام شود. نباید فاصله عمودی این متغیرها را افزایش داد، زیرا در یک کلاس خوب طراحی شده، اگر نه همه ، بسیاری از متدهای کلاس از آنها استفاده می‌کنند.</p>
<p>بحث های زیادی در مورد اینکه متغیرهای نمونه باید به کجا بروند وجود داشته است. در C ++ معمولاً قانون به اصطلاح قیچی را اجرا می‌کنیم که همه متغیرهای نمونه را در پایین قرار می‌دهد. با این حال ، قرارداد رایج در جاوا این است که همه آن‌ها را در بالای کلاس قرار دهید. من دلیلی برای پیروی از هر قرارداد دیگری نمی‌بینم. نکته مهم این است که متغیرهای نمونه در یک مکان شناخته شده اعلام شوند. همه باید بدانند که برای دیدن تعاریف به کجا مراجعه کنند.</p>
<p>به عنوان مثال ، مورد عجیب کلاس TestSuite را در JUnit 4.3.1 در نظر بگیرید. من این کلاس را بسیار ضعیف کردم تا نکته را بیان کنم. اگر نگاهی به نیمه لیست بیندازید ، دو متغیر نمونه  در آنجا تعریف شده. پنهان‌کردن آن‌ها در مکان بهتر دشوار خواهد بود. شخصی که این کد را می خواند باید در تعریف‌ها تصادفی بلغزد (همانطور که من این کار را کردم).</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSuite</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Test</span> {
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> Test <span class="hljs-title function_">createTest</span><span class="hljs-params">(Class&lt;? extends TestCase&gt; theClass,
 String name)</span> {
  ...
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Constructor&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestCase</span>&gt;
 getTestConstructor(Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestCase</span>&gt; theClass)
 <span class="hljs-keyword">throws</span> NoSuchMethodException {
  ...
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test <span class="hljs-title function_">warning</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String message)</span> {
  ...
 }
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">exceptionToString</span><span class="hljs-params">(Throwable t)</span> {
  ...
 }
 <span class="hljs-keyword">private</span> String fName;
 <span class="hljs-keyword">private</span> Vector&lt;Test&gt; fTests= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;Test&gt;(<span class="hljs-number">10</span>);
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestSuite</span><span class="hljs-params">()</span> {
 }
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestSuite</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;? extends TestCase&gt; theClass)</span> {
  ...
 }
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestSuite</span><span class="hljs-params">(Class&lt;? extends TestCase&gt; theClass, String name)</span> {
  ...
 }
 ... ... ... ... ...
}
</code></pre>
<div dir='rtl'>
<p><strong>توابع وابسته</strong> اگر یک تابع، دیگری را فراخوانی می‌کند ، باید به صورت عمودی نزدیک باشند و در صورت امکان، صدازننده باید بالاتر از صدازده‌شده باشد. این به برنامه جریان طبیعی می‌بخشد. اگر این قرارداد با اطمینان دنبال شود ، خوانندگان می توانند اعتماد کنند که تعاریف تابع کمی بعد از استفاده دنبال می شوند. به عنوان مثال ، قطعه FitNesse را در لیست 5-5 در نظر بگیرید. توجه کنید که بالاترین تابع چگونه توابع زیر خود را فراخوانی می‌کند و چگونه آن‌ها به نوبه خود توابع زیر خود را فراخوانی می‌کنند. این کار، پیدا کردن توابع فراخوانی شده را آسان می‌کند و خوانایی کل ماژول را تا حد زیادی افزایش می‌دهد.</p>
</div>
<p>Listing 5-5</p>
<p>WikiPageResponder.java</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WikiPageResponder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SecureResponder</span> {
 <span class="hljs-keyword">protected</span> WikiPage page;
 <span class="hljs-keyword">protected</span> PageData pageData;
 <span class="hljs-keyword">protected</span> String pageTitle;
 <span class="hljs-keyword">protected</span> Request request;
 <span class="hljs-keyword">protected</span> PageCrawler crawler;
 <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">makeResponse</span><span class="hljs-params">(FitNesseContext context, Request request)</span>
 <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-type">String</span> <span class="hljs-variable">pageName</span> <span class="hljs-operator">=</span> getPageNameOrDefault(request, <span class="hljs-string">&quot;FrontPage&quot;</span>);
  loadPage(pageName, context);
  <span class="hljs-keyword">if</span> (page == <span class="hljs-literal">null</span>)
   <span class="hljs-keyword">return</span> notFoundResponse(context, request);
  <span class="hljs-keyword">else</span>
   <span class="hljs-keyword">return</span> makePageResponse(context);
 }
 <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getPageNameOrDefault</span><span class="hljs-params">(Request request, String defaultPageName)</span> {
  <span class="hljs-type">String</span> <span class="hljs-variable">pageName</span> <span class="hljs-operator">=</span> request.getResource();
  <span class="hljs-keyword">if</span> (StringUtil.isBlank(pageName))
  pageName = defaultPageName;
  <span class="hljs-keyword">return</span> pageName;
 }
 <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadPage</span><span class="hljs-params">(String resource, FitNesseContext context)</span>
 <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-type">WikiPagePath</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> PathParser.parse(resource);
  crawler = context.root.getPageCrawler();
  crawler.setDeadEndStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VirtualEnabledPageCrawler</span>());
  page = crawler.getPage(context.root, path);
  <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">null</span>)
  pageData = page.getData();
 }
 <span class="hljs-keyword">private</span> Response <span class="hljs-title function_">notFoundResponse</span><span class="hljs-params">(FitNesseContext context, Request request)</span>
 <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotFoundResponder</span>().makeResponse(context, request);
 }
 <span class="hljs-keyword">private</span> SimpleResponse <span class="hljs-title function_">makePageResponse</span><span class="hljs-params">(FitNesseContext context)</span>
 <span class="hljs-keyword">throws</span> Exception {
  pageTitle = PathParser.render(crawler.getFullPath(page));
  <span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> makeHtml(context);
  <span class="hljs-type">SimpleResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleResponse</span>();
  response.setMaxAge(<span class="hljs-number">0</span>);
  response.setContent(html);
  <span class="hljs-keyword">return</span> response;
 }
}
...
</code></pre>
<div dir='rtl'>
<p>بعلاوه، این قطعه، نمونه خوبی از نگه داشتن ثابتها در سطح مناسب است [G35]. ثابت &quot;FrontPage&quot; می توانست در تابع getPageNameOrDefault دفن شود ، اما این می تواند یک ثابت شناخته شده و مورد انتظار را در تابع نامناسب سطح پایین پنهان کند. بهتر بود که آن ثابت را از جایی که منطقی است باشد، به محلی انتقال دهیم که واقعاً از آن استفاده می کند.</p>
</div>
<p align="center">
  <img src=../../../assets/image/05/img-5.3.png/>
</p>
<div dir='rtl'>
<p><strong>میل مفهومی</strong> بخش‌های خاصی از کد نیازست نزدیک بخش‌های دیگر باشند. آنها میل مفهومی خاصی دارند. هرچه این میل قوی‌تر باشد ، فاصله عمودی کمتری باید بین آنها وجود داشته باشد.</p>
<p>همانطور که دیدیم، این میل ممکن است بر اساس یک وابستگی مستقیم باشد، مانند اینکه یک تابع، تابع دیگری را صدا می‌کند، یا یک تابع از یک متغیر استفاده می‌کند. اما علل احتمالی دیگری نیز وجود دارد. وابستگی ممکن است ایجاد شود زیرا گروهی از توابع عملیاتی مشابه را انجام می دهند. این قطعه کد را از Junit 4.3.1 در نظر بگیرید:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Assert</span> {
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">assertTrue</span><span class="hljs-params">(String message, <span class="hljs-type">boolean</span> condition)</span> {
  <span class="hljs-keyword">if</span> (!condition)
   fail(message);
 }
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">assertTrue</span><span class="hljs-params">(<span class="hljs-type">boolean</span> condition)</span> {
  assertTrue(<span class="hljs-literal">null</span>, condition);
 }
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">assertFalse</span><span class="hljs-params">(String message, <span class="hljs-type">boolean</span> condition)</span> {
  assertTrue(message, !condition);
 }
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">assertFalse</span><span class="hljs-params">(<span class="hljs-type">boolean</span> condition)</span> {
  assertFalse(<span class="hljs-literal">null</span>, condition);
 }
}
...
</code></pre>
<div dir='rtl'>
<p>این توابع از یک تمایل مفهومی قوی برخوردار هستند زیرا آنها دارای یک طرح مشترک نام‌گذاری هستند و صورت‌های مختلفی از یک کار پایه را انجام می دهند. این واقعیت که آنها یکدیگر را صدا می کنند در درجه دوم است. حتی اگر این کار را نکردند، هنوز هم نیاز است به هم نزدیک باشند.</p>
<h3>ترتیب عمودی</h3>
<p>به طور کلی می خواهیم وابستگی های فراخوانی تابع به سمت پایین باشد. یعنی تابعی که فراخوانی می شود باید زیر تابعی باشد که فراخوانی را انجام می دهد. این یک جریان خوب از ماژول کد منبع از سطح بالا به سطح پایین ایجاد می کند.</p>
<p>همانند مقالات روزنامه‌ها، انتظار داریم مهمترین مفاهیم ابتدا مطرح شوند، همچنین انتظار داریم که با کمترین جزئیات آلوده کننده بیان شوند. ما انتظار داریم که جزئیات سطح پایین آخر باشد. این به ما اجازه می‌دهد بدون اینکه خود را در جزئیات غوطه‌ور کنیم، از فایل‌های منبع خلاص شویم، و از چند تابع اول خلاصه کنیم. لیست 5-5 از این طریق سازمان‌یافته است. شاید حتی مثالهای بهتر این موارد عبارتند از لیست 15-5 در صفحه 263 و لیست 3-7 در صفحه 50.</p>
<h2>قالب‌بندی افقی</h2>
<p>یک خط باید چقدر عرض داشته باشد؟ برای پاسخ دادن به آن ، بیایید بررسی کنیم که خطوط در برنامه های معمول چقدر عرض دارند. باز هم، ما هفت پروژه مختلف را بررسی می کنیم. شکل 5-2 توزیع طول خطوط هر هفت پروژه را نشان می دهد. منظم بودن، خصوصاً در حدود 45 کاراکتر چشمگیر است. در واقع، هر اندازه از 20 تا 60 نشان دهنده حدود 1 درصد از تعداد کل خطوط است. این 40 درصد است! شاید 30 درصد دیگر کمتر از 10 حرف عرض داشته باشند. به یاد داشته باشید این مقیاس ورود به سیستم است، بنابراین شکل خطی افت بیش از 80 کاراکتر واقعاً قابل توجه است. برنامه نویسان به وضوح خطوط کوتاه را ترجیح می دهند.</p>
</div>
<p align="center">
  <img src=../../../assets/image/05/img-5.4.png/>
</p>
<p>Java line width distribution</p>
<div dir='rtl'>
<p>این نشان می دهد که ما باید تلاش کنیم خطوط خود را کوتاه نگه داریم. حد 80 قدیمی هولریت کمی خودسرانه است و من مخالف این نیستم که خطوط به 100 یا حتی 120 برسد. اما فراتر از آن احتمالاً فقط بی احتیاطی است.</p>
<p>من قبلاً از این قانون پیروی می کردم که شما هرگز نباید به سمت راست پیمایش کنید. اما امروزه مانیتورها برای این امر بسیار گسترده هستند و برنامه نویسان جوان می توانند فونت را به اندازه ای کوچک کنند که بتوانند 200 کاراکتر در صفحه نمایش دهند. چنین کاری نکن من، شخصاً حد خودم را 120 گذاشتم.</p>
<h3>گشودگی و چگالی افقی</h3>
<p>ما از فضای سفید افقی برای ارتباط چیزهایی که به شدت مرتبط هستند و جدا کردن مواردی که ارتباط ضعیف‌تری دارند استفاده می‌کنیم. تابع زیر را در نظر بگیرید:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureLine</span><span class="hljs-params">(String line)</span> {
 lineCount++;
 <span class="hljs-type">int</span> <span class="hljs-variable">lineSize</span> <span class="hljs-operator">=</span> line.length();
 totalChars += lineSize;
 lineWidthHistogram.addLine(lineSize, lineCount);
 recordWidestLine(lineSize);
}
</code></pre>
<div dir='rtl'>
<p>من اپراتورهای انتصاب را با فضای سفید احاطه کردم تا آنها را برجسته کنم. عبارات انتساب دارای دو عنصر مشخص و اصلی هستند: سمت چپ و سمت راست. فضاها آن تفکیک را آشکار می سازند.</p>
<p>از طرف دیگر ، من بین نام تابع و پرانتز باز فاصله نگذاشتم. این به این دلیل است که عملکرد و آرگومان های آن ارتباط تنگاتنگی دارند. جدا کردن آنها باعث می شود که به جای متصل بودن ، از هم جدا به نظر برسند. من آرگومان های درون پرانتز فراخوانی تابع را برای برجسته کردن ویرگول، جدا می کنم و نشان می دهم که آرگومان ها جدا هستند.</p>
<p>یکی دیگر از موارد استفاده از فضای خالی ، تأکید بر تقدم عملگرها است.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Quadratic</span> {
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">root1</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> c)</span> {
  <span class="hljs-type">double</span> <span class="hljs-variable">determinant</span> <span class="hljs-operator">=</span> determinant(a, b, c);
  <span class="hljs-keyword">return</span> (-b + Math.sqrt(determinant)) / (<span class="hljs-number">2</span>*a);
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">root2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> {
  <span class="hljs-type">double</span> <span class="hljs-variable">determinant</span> <span class="hljs-operator">=</span> determinant(a, b, c);
  <span class="hljs-keyword">return</span> (-b - Math.sqrt(determinant)) / (<span class="hljs-number">2</span>*a);
 }
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">determinant</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> c)</span> {
  <span class="hljs-keyword">return</span> b*b - <span class="hljs-number">4</span>*a*c;
 }
}
</code></pre>
<div dir='rtl'>
<p>توجه کنید که تساوی‌ها به چه زیبایی خوانده می‌شوند. بین فاکتورها فضای خالی وجود ندارد زیرا از اولویت بالایی برخوردار هستند. ترم‌ها با فضای خالی از هم جدا می‌شوند زیرا جمع و تفریق اولویت‌های کمتری هستند.</p>
<p>متأسفانه ، بیشتر ابزارها برای اصلاح مجدد کد از اولویت عملگرها چشم پوشی می کنند و فاصله یکسانی را در کل اعمال می کنند. بنابراین فاصله های ظریف مانند آنچه در بالا نشان داده شده است پس از اصلاح کد ، از بین می روند.</p>
<h3>ترازبندی افقی</h3>
<p>هنگامی که من یک برنامه نویس زبان اسمبلی بودم ، از تراز افقی برای برجسته سازی برخی ساختارها استفاده می کردم. وقتی شروع به کد نویسی در C ، C ++ و سرانجام جاوا کردم ، سعی کردم همه نام متغیرها را در مجموعه ای از اعلامیه ها یا همه مقادیر را در مجموعه عبارات انتساب ردیف کنم. کد من ممکن است به این شکل باشد:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FitNesseExpediter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResponseSender</span> {
 <span class="hljs-keyword">private</span>     Socket    socket;
 <span class="hljs-keyword">private</span>  InputStream     input;
 <span class="hljs-keyword">private</span>  OutputStream    output;
 <span class="hljs-keyword">private</span>  Request   request;
 <span class="hljs-keyword">private</span>  Response   response;
 <span class="hljs-keyword">private</span>  FitNesseContext context;
 <span class="hljs-keyword">protected</span>  <span class="hljs-type">long</span>    requestParsingTimeLimit;
 <span class="hljs-keyword">private</span>  <span class="hljs-type">long</span>    requestProgress;
 <span class="hljs-keyword">private</span>  <span class="hljs-type">long</span>    requestParsingDeadline;
 <span class="hljs-keyword">private</span>  <span class="hljs-type">boolean</span>   hasError;
 
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">FitNesseExpediter</span><span class="hljs-params">(Socket s,
 FitNesseContext context)</span> <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-built_in">this</span>.context =            context;
  socket =                  s;
  input =                   s.getInputStream();
  output =                  s.getOutputStream();
  requestParsingTimeLimit = <span class="hljs-number">10000</span>;
 }
}
</code></pre>
<div dir='rtl'>
<p>من فهمیدم که این نوع هم ترازی مفید نیست. به نظر می رسد هم ترازی موارد پرت را تأکید می‌کند و چشم من را از قصد واقعی دور می‌کند. به عنوان مثال ، در لیست اعلامیه های بالا وسوسه می شوید لیستی از نام های متغیر را بدون بررسی انواع آنها بخوانید. به همین ترتیب ، در لیست عبارات انتساب ، وسوسه می شوید که لیست مقادیر را بدون دیدن عملگر انتساب به پایین نگاه کنید. بدتر از آن ، ابزارهای قالب بندی مجدد خودکار معمولاً این نوع هم ترازی را از بین می برند.</p>
<p>بنابراین ، در پایان ، من دیگر این نوع کارها را انجام نمی دهم. امروزه من ترجیح می دهم تعاریف و انتساب غیر هم‌تراز ، همانطور که در زیر نشان داده شده است ، زیرا آنها یک نقص مهم را نشان می دهند. اگر من لیست های طولانی دارم که باید تراز شوند ، مشکل طولانی بودن لیست ها است ، نه عدم هم ترازی. طول لیست تعاریف در FitNesseExpediter در زیر نشان می دهد که این کلاس باید تقسیم شود.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FitNesseExpediter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResponseSender</span> {
 <span class="hljs-keyword">private</span> Socket socket;
 <span class="hljs-keyword">private</span> InputStream input;
 <span class="hljs-keyword">private</span> OutputStream output;
 <span class="hljs-keyword">private</span> Request request;
 <span class="hljs-keyword">private</span> Response response;
 <span class="hljs-keyword">private</span> FitNesseContext context;
 <span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> requestParsingTimeLimit;
 <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> requestProgress;
 <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> requestParsingDeadline;
 <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> hasError;
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">FitNesseExpediter</span><span class="hljs-params">(Socket s, FitNesseContext context)</span> <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-built_in">this</span>.context = context;
  socket = s;
  input = s.getInputStream();
  output = s.getOutputStream();
  requestParsingTimeLimit = <span class="hljs-number">10000</span>;
 }
}
</code></pre>
<div dir='rtl'>
<h3>تورفتگی</h3>
<p>فایل منبع یک سلسله مراتب است و بیشتر شبیه یک طرح کلی است. اطلاعاتی وجود دارد که مربوط به فایل به طور کلی ، به کلاسهای جداگانه درون فایل ، به متدهای درون کلاسها ، به بلوک های درون متدها و به طور بازگشتی به بلوک های درون بلوک ها است. هر سطح از این سلسله مراتب محدوده ای است که می توان در آن اسامی را اعلام کرد و در آن تعاریف و دستورات اجرایی را تفسیر می کند.</p>
<p>برای اینکه این سلسله مراتب از محدوده ها قابل مشاهده باشد ، متناسب با موقعیت آنها در سلسله مراتب ، خطوط کد منبع را تورفتگی می دهیم. عبارات موجود در سطح فایل ، مانند اکثر تعاریف کلاس ، به هیچ وجه فرورفته نیستند. متدهای درون یک کلاس در یک سطح سمت راست کلاس قرار دارند. پیاده سازی آن متدها در یک سطح به سمت راست تعریف متد اجرا می شود. پیاده سازی بلوک در یک سطح سمت راست بلوک حاوی آن اجرا می شود و غیره.</p>
<p>برنامه نویسان به شدت به این طرح تورفتگی اعتماد می کنند. آنها به صورت تصویری خطوطی را در سمت چپ قرار می دهند تا ببینند در چه دامنه ای ظاهر می شوند. این به آنها امکان می دهد تا به سرعت در دامنه هایی مانند پیاده سازی دستورات if یا while که مربوط به وضعیت فعلی آنها نیستند ، جست و جو کنند. آنها سمت چپ را برای اعلامیه های متد جدید ، متغیرهای جدید و حتی کلاس های جدید اسکن می کنند. بدون تورفتگی ، برنامه ها برای انسان عملاً قابل خواندن نیستند.</p>
<p>برنامه های زیر را که از نظر نحوی و معنایی یکسان هستند در نظر بگیرید:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FitNesseServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SocketServer</span> { <span class="hljs-keyword">private</span> FitNesseContext
context; <span class="hljs-keyword">public</span> <span class="hljs-title function_">FitNesseServer</span><span class="hljs-params">(FitNesseContext context)</span> { <span class="hljs-built_in">this</span>.context =
context; } <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serve</span><span class="hljs-params">(Socket s)</span> { serve(s, <span class="hljs-number">10000</span>); } <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>
<span class="hljs-title function_">serve</span><span class="hljs-params">(Socket s, <span class="hljs-type">long</span> requestTimeout)</span> { <span class="hljs-keyword">try</span> { <span class="hljs-type">FitNesseExpediter</span> <span class="hljs-variable">sender</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>
<span class="hljs-title class_">FitNesseExpediter</span>(s, context);
sender.setRequestParsingTimeLimit(requestTimeout); sender.start(); }
<span class="hljs-keyword">catch</span>(Exception e) { e.printStackTrace(); } } }
-----

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FitNesseServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SocketServer</span> {
 <span class="hljs-keyword">private</span> FitNesseContext context;
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">FitNesseServer</span><span class="hljs-params">(FitNesseContext context)</span> {
  <span class="hljs-built_in">this</span>.context = context;
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serve</span><span class="hljs-params">(Socket s)</span> {
  serve(s, <span class="hljs-number">10000</span>);
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serve</span><span class="hljs-params">(Socket s, <span class="hljs-type">long</span> requestTimeout)</span> {
  <span class="hljs-keyword">try</span> {
   <span class="hljs-type">FitNesseExpediter</span> <span class="hljs-variable">sender</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FitNesseExpediter</span>(s, context);
   sender.setRequestParsingTimeLimit(requestTimeout);
   sender.start();
  }
  <span class="hljs-keyword">catch</span> (Exception e) {
   e.printStackTrace();
  }
 }
}
</code></pre>
<div dir='rtl'>
<p>چشم شما به سرعت می تواند ساختار پرونده تورفتگی را تشخیص دهد. تقریباً بلافاصله می‌توانید متغیرها ، سازنده ها ، دسترسی ها و متد ها را تشخیص دهید. فقط چند ثانیه طول می‌کشد تا متوجه شوید که این نوعی ازفرانت‌اند ساده یک سوکت است که دارای زمان است. با این وجود، مطالعه نسخه بدون تورفتگی شدیدا غیر قابل نفوذ است.</p>
<p><strong>نادیده گرفتن تورفتگی</strong></p>
<p>شکستن قانون تورفتگی برای دستورات کوتاه if، حلقه های کوتاه یا توابع کوتاه ، وسوسه انگیز است. هر وقت که تسلیم این وسوسه شدم ، تقریباً همیشه برمی‌گردم و تورفتگی را دوباره برمی‌گردانم. بنابراین از فرو ریختن دامنه ها به یک خط مانند این جلوگیری می‌کنم:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TextWidget</span> {
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REGEXP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^#[^\r\n]*(?:(?:\r\n)|\n|\r)?&quot;</span>;
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">CommentWidget</span><span class="hljs-params">(ParentWidget parent, String text)</span>{
  <span class="hljs-built_in">super</span>(parent, text);
 }
 <span class="hljs-keyword">public</span> String <span class="hljs-title function_">render</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>; 
 }
}
</code></pre>
<div dir='rtl'>
<p>من ترجیح می‌دهم به جای این موارد دامنه ها را گسترش و تورفتگی بدهم:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TextWidget</span> {
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REGEXP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;^#[^\r\n]*(?:(?:\r\n)|\n|\r)?&quot;</span>;
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">CommentWidget</span><span class="hljs-params">(ParentWidget parent, String text)</span> {
  <span class="hljs-built_in">super</span>(parent, text);
 }
 <span class="hljs-keyword">public</span> String <span class="hljs-title function_">render</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;
 }
}
</code></pre>
<div dir='rtl'>
<h3>دامنه های ساختگی</h3>
<p>همانطور که در زیر نشان داده می‌شود ، بعضی اوقات بدنه while یا for ساختگی است. من این نوع ساختارها را دوست ندارم و سعی می‌کنم از آنها اجتناب کنم. وقتی نمی توانم از آنها اجتناب کنم ، مطمئن می‌شوم که بدنه ساختگی به درستی فرورفتگی داشته و توسط براکت احاطه شده باشد. نمی‌توانم به شما بگویم که چند بار گول یک نقطه ویرگول را خورده‌ام که در انتهای حلقه while روی همان خط بوده. مگر اینکه آن نقطه ویرگول را با تورفته کردن روی خط خود قابل مشاهده کنید ، دیدن آن خیلی سخت است.</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">while</span> (dis.read(buf, <span class="hljs-number">0</span>, readBufferSize) != -<span class="hljs-number">1</span>);
</code></pre>
<div dir='rtl'>
<h2>قوانین تیم</h2>
</div>
<p align="center">
  <img src=../../../assets/image/05/img-5.5.png/>
</p>
<div dir='rtl'>
<p>عنوان این بخش بازی با کلمات است. هر برنامه نویس قوانین قالب بندی مورد علاقه خود را دارد ، اما اگر در یک تیم کار کند ، قوانین تیم حاکم است.</p>
<p>یک تیم از توسعه‌دهندگان باید بر روی یک سبک قالب بندی واحد توافق کنند و سپس هر یک از اعضای آن تیم باید از آن سبک استفاده کنند. ما می‌خواهیم که این نرم افزار سبک سازگار داشته باشد. ما نمی‌خواهیم که به نظر می رسد توسط گروهی از افراد مخالف نوشته شده است.</p>
<p>هنگامی که پروژه FitNesse را در سال 2002 شروع کردم ، با تیم برای کار در یک سبک کدگذاری نشستم. این کار حدود 10 دقیقه طول کشید. ما تصمیم گرفتیم که براکت‌های خود را کجا قرار دهیم ، اندازه فرورفتگی ما چه اندازه باشد ، چگونه کلاس ها ، متغیرها و روش ها را نام ببریم و موارد دیگر. سپس ما آن قوانین را در قالب ساز کد IDE خود رمزگذاری کردیم و از آن زمان با آنها همراه هستیم. این قوانینی نبود که من ترجیح می‌دهم. آنها قوانینی بودند که توسط تیم تصمیم گرفته‌شد. من به عنوان عضوی از این تیم هنگام نوشتن کد در پروژه FitNesse آنها را دنبال می کردم.</p>
<p>به یاد داشته باشید ، یک سیستم نرم‌افزاری خوب از مجموعه اسنادی تشکیل شده است که به زیبایی خوانده می‌شوند. آنها باید سبک ثابت و روان داشته باشند. خواننده باید بتواند اعتماد کند که حرکات قالب‌بندی که در یک فایل منبع دیده‌است ، در دیگران معنای مشابهی خواهدداشت. آخرین کاری که می‌خواهیم انجام دهیم افزودن پیچیدگی بیشتر به کد منبع با نوشتن آن در مخلوطی از سبک های مختلف فردی است.</p>
<h2>قوانین قالب بندی عمو باب</h2>
<p>قوانینی که من شخصاً استفاده می‌کنم بسیار ساده هستند و توسط کدی در لیست 5-6 نشان داده شده‌اند. این را مثالی از نحوه ایجاد کد بهترین سند استاندارد کدگذاری در نظر بگیرید.</p>
</div>
<p>Listing 5-6</p>
<p>CodeAnalyzer.java</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeAnalyzer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">JavaFileAnalysis</span> {
 <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> lineCount;
 <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxLineWidth;
 <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> widestLineNumber;
 <span class="hljs-keyword">private</span> LineWidthHistogram lineWidthHistogram;
 <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> totalChars;
 <span class="hljs-keyword">public</span> <span class="hljs-title function_">CodeAnalyzer</span><span class="hljs-params">()</span> {
  lineWidthHistogram = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LineWidthHistogram</span>();
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;File&gt; <span class="hljs-title function_">findJavaFiles</span><span class="hljs-params">(File parentDirectory)</span> {
  List&lt;File&gt; files = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;File&gt;();
  findJavaFiles(parentDirectory, files);
  <span class="hljs-keyword">return</span> files;
 }
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findJavaFiles</span><span class="hljs-params">(File parentDirectory, List&lt;File&gt; files)</span> {
  <span class="hljs-keyword">for</span> (File file : parentDirectory.listFiles()) {
   <span class="hljs-keyword">if</span> (file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>))
   files.add(file);
   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isDirectory())
   findJavaFiles(file, files);
  }
 }
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">analyzeFile</span><span class="hljs-params">(File javaFile)</span> <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(javaFile));
  String line;
  <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>)
  measureLine(line);
 }
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureLine</span><span class="hljs-params">(String line)</span> {
  lineCount++;
  <span class="hljs-type">int</span> <span class="hljs-variable">lineSize</span> <span class="hljs-operator">=</span> line.length();
  totalChars += lineSize;
  lineWidthHistogram.addLine(lineSize, lineCount);
  recordWidestLine(lineSize);
 }
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordWidestLine</span><span class="hljs-params">(<span class="hljs-type">int</span> lineSize)</span> {
  <span class="hljs-keyword">if</span> (lineSize &gt; maxLineWidth) {
   maxLineWidth = lineSize;
   widestLineNumber = lineCount;
  }
 }
 <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLineCount</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> lineCount;
 }
 <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxLineWidth</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> maxLineWidth;
 }
 <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getWidestLineNumber</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> widestLineNumber;
 }
 <span class="hljs-keyword">public</span> LineWidthHistogram <span class="hljs-title function_">getLineWidthHistogram</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> lineWidthHistogram;
 }
 <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getMeanLineWidth</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)totalChars/lineCount;
 }
 <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMedianLineWidth</span><span class="hljs-params">()</span> {
  Integer[] sortedWidths = getSortedWidths();
  <span class="hljs-type">int</span> <span class="hljs-variable">cumulativeLineCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> width : sortedWidths) {
   cumulativeLineCount += lineCountForWidth(width);
   <span class="hljs-keyword">if</span> (cumulativeLineCount &gt; lineCount/<span class="hljs-number">2</span>)
   <span class="hljs-keyword">return</span> width;
  }
 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Cannot get here&quot;</span>);
 }
 <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lineCountForWidth</span><span class="hljs-params">(<span class="hljs-type">int</span> width)</span> {
  <span class="hljs-keyword">return</span> lineWidthHistogram.getLinesforWidth(width).size();
 }
 <span class="hljs-keyword">private</span> Integer[] getSortedWidths() {
  Set&lt;Integer&gt; widths = lineWidthHistogram.getWidths();
  Integer[] sortedWidths = (widths.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">0</span>]));
  Arrays.sort(sortedWidths);
  <span class="hljs-keyword">return</span> sortedWidths;
 }
}
</code></pre>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
