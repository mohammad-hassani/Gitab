

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>مدیریت خطا</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/Gitab/" aria-current="page">خانه</a>
        <a href="/Gitab/books/list-books">کتاب‌ها</a>
        <a href="#">مترجمین</a>
        <a href="#">همکاری</a>
        <a href="#">درباره ما</a>
      </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <div dir="rtl">
<h1>مدیریت خطا</h1>
<p><img src="../../../assets/image/07/img-7.1.png" alt=""></p>
<p>ممکن است وجود بخشی درباره مدیریت خطا در کتابی درباره کد تمیز عجیب به نظر برسد. اما مدیریت خطا یکی از جنبه‌هایی است که همه ما هنگام برنامه‌نویسی با آن مواجه می‌شویم. ورودی‌ها ممکن است غیرعادی باشند و دستگاه‌ها ممکن است خراب شوند. به طور خلاصه، ممکن است مشکلاتی پیش بیاید و در این شرایط، ما به عنوان برنامه‌نویس مسئولیت داریم که اطمینان حاصل کنیم کد ما به درستی عمل می‌کند.</p>
<p>اما ارتباط این موضوع با کد تمیز باید واضح باشد. بسیاری از پایگاه‌های کد به شدت تحت تأثیر مدیریت خطا قرار دارند. وقتی می‌گویم تحت تأثیر، منظورم این نیست که مدیریت خطا تنها کاری است که آنها انجام می‌دهند، بلکه به این معنی است که به دلیل پراکندگی مدیریت خطا، تقریباً غیرممکن است که بفهمیم کد چه کاری انجام می‌دهد. مدیریت خطا مهم است، اما اگر باعث اختلال در منطق کد شود، اشتباه است.</p>
<p>در این فصل، تعدادی تکنیک و نکته را معرفی می‌کنم که می‌توانید برای نوشتن کدی که هم تمیز و هم مقاوم باشد، استفاده کنید—کدی که به شیوه‌ای شایسته و با سبک به مدیریت خطا می‌پردازد.</p>
<h2>از Exception ها به جای return کردن کد خطا استفاده کنید</h2>
<p>در گذشته‌های دور، زبان‌های زیادی وجود داشتند که استثنا نداشتند. در این زبان‌ها، تکنیک‌های مدیریت و گزارش خطا محدود بود. شما یا باید یک پرچم خطا تعیین می‌کردید یا یک کد خطا بازمی‌گرداندید که فراخواننده می‌توانست آن را بررسی کند. کد موجود در فهرست ۷-۱ این روش‌ها را نشان می‌دهد.</p>
</div>
Listing 7-1 -- DeviceController.java
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeviceController</span> {
  ...
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendShutDown</span><span class="hljs-params">()</span> {
      <span class="hljs-type">DeviceHandle</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> getHandle(DEV1);
      <span class="hljs-comment">// Check the state of the device</span>
      <span class="hljs-keyword">if</span> (handle != DeviceHandle.INVALID) {
        <span class="hljs-comment">// Save the device status to the record field</span>
        retrieveDeviceRecord(handle);
        <span class="hljs-comment">// If not suspended, shut down</span>
        <span class="hljs-keyword">if</span> (record.getStatus() != DEVICE_SUSPENDED) {
          pauseDevice(handle);
          clearDeviceWorkQueue(handle);
          closeDevice(handle);
        } <span class="hljs-keyword">else</span> {
          logger.log(<span class="hljs-string">&quot;Device suspended. Unable to shut down&quot;</span>);
        }
      } <span class="hljs-keyword">else</span> {
        logger.log(<span class="hljs-string">&quot;Invalid handle for: &quot;</span> + DEV1.toString());
      }
    }
    ...
}
</code></pre>
<div dir="rtl">
مشکل این رویکردها این است که کد فراخواننده را شلوغ می‌کند. فراخواننده باید بلافاصله پس از فراخوانی، خطاها را بررسی کند. متأسفانه، به راحتی ممکن است این مورد فراموش شود. به همین دلیل بهتر است هنگامی که با یک خطا مواجه می‌شوید، یک استثنا پرتاب کنید. این کار باعث می‌شود کد فراخواننده تمیزتر باشد و منطق آن تحت تأثیر مدیریت خطا قرار نگیرد. فهرست ۷-۲ کد را نشان می‌دهد پس از اینکه تصمیم به پرتاب استثنا در متدهایی که می‌توانند خطا را شناسایی کنند، گرفته‌ایم.
</div>
<p>Listing 7-2 -- DeviceController.java (with exceptions)</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeviceController</span> {
  ...
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendShutDown</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">try</span> {
      tryToShutDown();
    } <span class="hljs-keyword">catch</span> (DeviceShutDownError e) {
      logger.log(e);
    }
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryToShutDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> DeviceShutDownError {
    <span class="hljs-type">DeviceHandle</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> getHandle(DEV1);
    <span class="hljs-type">DeviceRecord</span> <span class="hljs-variable">record</span> <span class="hljs-operator">=</span> retrieveDeviceRecord(handle);
    pauseDevice(handle);
    clearDeviceWorkQueue(handle);
    closeDevice(handle);
  }
  <span class="hljs-keyword">private</span> DeviceHandle <span class="hljs-title function_">getHandle</span><span class="hljs-params">(DeviceID id)</span> {
      ...
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeviceShutDownError</span>(<span class="hljs-string">&quot;Invalid handle for: &quot;</span> + id.toString());
      ...
    }
    ...
}
</code></pre>
<div dir="rtl">
توجه کنید به چه میزان تمیزتر شده است. این فقط یک مسئله زیبایی‌شناسی نیست. کد بهتر شده زیرا دو نگرانی که با هم در هم پیچیده بودند، یعنی الگوریتم خاموش کردن دستگاه و مدیریت خطا، اکنون از هم جدا شده‌اند. شما می‌توانید هر یک از این نگرانی‌ها را به‌طور مستقل بررسی و درک کنید.
<h2>اولین وضعیت try-catch-finally خود را بنویسید</h2>
<p>یکی از جالب‌ترین نکات درباره استثناها این است که آن‌ها یک محدوده درون برنامه شما تعریف می‌کنند. زمانی که کد را در بخش try یک جمله try-catch-finally اجرا می‌کنید، در واقع بیان می‌کنید که اجرا در هر نقطه‌ای ممکن است متوقف شود و سپس در بخش catch از سر گرفته شود.</p>
<p>به نوعی، بلوک‌های try مانند تراکنش‌ها هستند. catch شما باید برنامه شما را در یک حالت سازگار ترک کند، فرقی نمی‌کند چه اتفاقی در بخش try بیفتد. به همین دلیل، شروع با یک جمله try-catch-finally هنگامی که کدی می‌نویسید که ممکن است استثنا پرتاب کند، یک رویه خوب است. این به شما کمک می‌کند تا مشخص کنید کاربر آن کد باید چه انتظاری داشته باشد، صرف‌نظر از اینکه چه چیزی در کدی که در بخش try اجرا می‌شود، اشتباه پیش برود.</p>
<p>بیایید یک مثال را بررسی کنیم. ما باید کدی بنویسیم که به یک فایل دسترسی پیدا کند و برخی اشیاء سریال‌شده را بخواند.</p>
<p>ما با یک unit test شروع می‌کنیم که نشان می‌دهد وقتی فایل وجود ندارد، یک استثنا خواهیم گرفت:</p>
</div>
<pre class="hljs"><code> <span class="hljs-meta">@Test(expected = StorageException.class)</span>
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">retrieveSectionShouldThrowOnInvalidFileName</span><span class="hljs-params">()</span> {
   sectionStore.retrieveSection(<span class="hljs-string">&quot;invalid - file&quot;</span>);
 }
</code></pre>
<div dir="rtl">
test ما را مجبور می‌کند که این کد موقتی را بنویسیم.
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> List&lt;RecordedGrip&gt; <span class="hljs-title function_">retrieveSection</span><span class="hljs-params">(String sectionName)</span> {
  <span class="hljs-comment">// dummy return until we have a real implementation</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;RecordedGrip&gt;();
}
</code></pre>
<div dir="rtl">
test ما شکست می‌خورد زیرا استثنایی پرتاب نمی‌کند. سپس، پیاده‌سازی‌مان را تغییر می‌دهیم تا سعی کند به یک فایل نامعتبر دسترسی پیدا کند. این عمل یک استثنا پرتاب می‌کند:
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> List&lt;RecordedGrip&gt; <span class="hljs-title function_">retrieveSection</span><span class="hljs-params">(String sectionName)</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(sectionName)
  } <span class="hljs-keyword">catch</span> (Exception e) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageException</span>(<span class="hljs-string">&quot;retrieval error&quot;</span>, e);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;RecordedGrip&gt;();
}
</code></pre>
<div dir="rtl">
اکنون test ما موفقیت‌آمیز است زیرا استثنا را گرفته‌ایم. در این مرحله، می‌توانیم کد را بهبود دهیم. می‌توانیم نوع استثنایی که می‌گیریم را دقیق‌تر کنیم تا با نوعی که واقعاً از سازنده FileInputStream پرتاب می‌شود، یعنی FileNotFoundException، مطابقت داشته باشد:
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> List&lt;RecordedGrip&gt; <span class="hljs-title function_">retrieveSection</span><span class="hljs-params">(String sectionName)</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(sectionName);
      stream.close();
    } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageException</span>(<span class="hljs-string">&quot;retrieval error&quot;</span>, e);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;RecordedGrip&gt;();
    }
</code></pre>
<div dir="rtl">
حالا که محدوده را با ساختار try-catch تعریف کرده‌ایم، می‌توانیم از TDD برای ساخت بقیه منطق مورد نیاز استفاده کنیم. این منطق بین ایجاد FileInputStream و بستن آن اضافه خواهد شد و می‌تواند طوری رفتار کند که انگار هیچ چیزی اشتباه نمی‌شود.
<p>سعی کنید تست‌هایی بنویسید که باعث ایجاد استثناها شوند، سپس رفتار handler خود را به‌گونه‌ای اضافه کنید که تست‌ها را تأمین کند. این کار باعث می‌شود ابتدا محدوده تراکنش بلوک try را بسازید و به شما کمک می‌کند تا ماهیت تراکنش این محدوده را حفظ کنید.</p>
<h2>از استثناهای بدون چک استفاده کنید</h2>
<p>وقتی که استثناهای چک‌شده در نسخه اول جاوا معرفی شدند، به نظر ایده‌ای عالی می‌آمدند. امضای هر متد شامل تمام استثناهایی بود که می‌توانست به فراخواننده‌اش منتقل کند. علاوه بر این، این استثناها بخشی از نوع متد بودند. اگر امضا با کاری که کد شما انجام می‌دهد مطابقت نداشت، کد شما عملاً کامپایل نمی‌شد.</p>
<p>در آن زمان، فکر می‌کردیم استثناهای چک‌شده ایده خوبی هستند و بله، می‌توانند فوایدی داشته باشند. با این حال، اکنون روشن است که برای تولید نرم‌افزارهای پایدار، وجود آن‌ها ضروری نیست. زبان C# استثناهای چک‌شده ندارد و با وجود تلاش‌های شجاعانه، C++ نیز چنین نیست. نه پایتون و نه روبی هم استثناهای چک‌شده ندارند. اما امکان نوشتن نرم‌افزارهای پایدار در تمام این زبان‌ها وجود دارد. از آنجایی که این‌طور است، باید واقعاً تصمیم بگیریم که آیا استثناهای چک‌شده به نسبت هزینه ای که دارند مفیدند یا خیر.</p>
<p>چه قیمتی؟ قیمت استثناهای چک‌شده نقض اصول Open/Closed است. اگر از یک متد در کد خود یک استثنای چک‌شده را throws کنید و catch در سه سطح بالاتر باشد، باید آن استثنا را در امضای هر متد بین خود و catch اعلام کنید. این به این معنی است که یک تغییر در سطح پایین نرم‌افزار می‌تواند تغییرات امضا را در بسیاری از سطوح بالاتر اجباری کند. ماژول‌های تغییر یافته باید دوباره ساخته و مستقر شوند، حتی اگر چیزی که برایشان مهم است تغییر نکرده باشد.</p>
<p>سلسله مراتب فراخوانی در یک سیستم بزرگ را تصور کنید. توابع در بالای سلسله مراتب توابع زیر خود را فراخوانی می‌کنند، که توابع بیشتری را در زیر خود فراخوانی می‌کنند، و به همین ترتیب. حال بیایید بگوییم یکی از توابع در پایین‌ترین سطح به گونه‌ای اصلاح شده است که باید یک استثنا را throws کند. اگر آن استثنا چک‌شده باشد، باید یک clause throws به امضای تابع اضافه شود. اما این به این معنی است که هر تابعی که تابع اصلاح شده ما را فراخوانی می‌کند نیز باید یا برای catch استثنای جدید تغییر کند یا clause throws مناسب را به امضای خود اضافه کند. به همین ترتیب. نتیجه نهایی یک سلسله تغییرات است که از پایین‌ترین سطوح نرم‌افزار به بالاترین سطوح می‌رسد! کپسوله‌سازی شکسته می‌شود زیرا تمام توابع در مسیر یک throws باید از جزئیات آن استثنای سطح پایین مطلع باشند. با توجه به اینکه هدف از استثناها این است که به شما اجازه دهند خطاها را از فاصله‌ای دور مدیریت کنید، متأسفانه استثناهای چک‌شده به این شکل کپسوله‌سازی را می‌شکنند.</p>
<p>استثناهای چک‌شده گاهی می‌توانند مفید باشند اگر شما در حال نوشتن یک کتابخانه حیاتی هستید: شما باید آن‌ها را catch کنید. اما در توسعه برنامه‌های عمومی، هزینه‌های وابستگی معمولاً بر فواید غلبه می‌کند.</p>
<h2>فراهم کردن context با استفاده از استثناها</h2>
<p>هر استثنایی که شما thrown می‌کنید باید زمینه کافی برای تعیین منبع و محل خطا را فراهم کند. در جاوا، می‌توانید یک stack trace از هر استثنا دریافت کنید؛ اما یک stack trace نمی‌تواند نیت عملیاتی که شکست خورده است را به شما بگوید.</p>
<p>پیام‌های خطای مفهومی ایجاد کنید و آن‌ها را به همراه استثناهای خود ارسال کنید. عملیات ناموفق و نوع شکست را ذکر کنید. اگر در برنامه‌تان لاگ‌گیری می‌کنید، اطلاعات کافی را برای لاگ کردن خطا در catch خود ارسال کنید.</p>
<h2>تعریف کلاس‌های استثنا بر اساس نیازهای فراخواننده</h2>
<p>راه‌های زیادی برای طبقه‌بندی خطاها وجود دارد. می‌توانیم آن‌ها را بر اساس منبع‌شان طبقه‌بندی کنیم: آیا از یک مؤلفه خاص آمده‌اند یا نه؟ یا بر اساس نوع‌شان: آیا این خطاها ناشی از خرابی‌های دستگاه، خرابی‌های شبکه یا خطاهای برنامه‌نویسی هستند؟ با این حال، وقتی که کلاس‌های استثنا را در یک برنامه تعریف می‌کنیم، مهم‌ترین نگرانی ما باید این باشد که چگونه این استثناها catch می‌شوند.</p>
<p>بیایید به یک مثال از طبقه‌بندی ضعیف استثناها نگاه کنیم. در اینجا یک دستور try-catch-finally برای یک فراخوانی از یک کتابخانه شخص ثالث وجود دارد. این دستور تمام استثناهایی را که این فراخوانی‌ها می‌توانند thrown کنند، پوشش می‌دهد.</p>
</div>
<pre class="hljs"><code><span class="hljs-type">ACMEPort</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ACMEPort</span>(<span class="hljs-number">12</span>);
 <span class="hljs-keyword">try</span> {
 port.open();
 } <span class="hljs-keyword">catch</span> (DeviceResponseException e) {
 reportPortError(e);
 logger.log(<span class="hljs-string">&quot;Device response exception&quot;</span>, e);
 } <span class="hljs-keyword">catch</span> (ATM1212UnlockedException e) {
 reportPortError(e);
 logger.log(<span class="hljs-string">&quot;Unlock exception&quot;</span>, e);
 } <span class="hljs-keyword">catch</span> (GMXError e) {
 reportPortError(e);
 logger.log(<span class="hljs-string">&quot;Device response exception&quot;</span>);
 } <span class="hljs-keyword">finally</span> {
 …
 }
</code></pre>
<div dir="rtl">
آن دستور شامل مقدار زیادی تکرار است و نباید تعجب کنیم. در بیشتر مواقع مدیریت استثنا، کاری که انجام می‌دهیم نسبتاً استاندارد است و ارتباطی به علت واقعی ندارد. ما باید یک خطا را ثبت کنیم و اطمینان حاصل کنیم که می‌توانیم به کار ادامه دهیم.
<p>در این مورد، از آنجایی که می‌دانیم کارهایی که انجام می‌دهیم تقریباً مشابه است، بدون توجه به استثنا، می‌توانیم کد خود را به طور قابل توجهی ساده کنیم با wrapping کردن API که فراخوانی می‌کنیم و اطمینان از اینکه نوع استثنای مشترکی را برمی‌گرداند:</p>
</div>
<pre class="hljs"><code><span class="hljs-type">LocalPort</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalPort</span>(<span class="hljs-number">12</span>);
<span class="hljs-keyword">try</span> {
  port.open();
} <span class="hljs-keyword">catch</span> (PortDeviceFailure e) {
  reportError(e);
  logger.log(e.getMessage(), e);
} <span class="hljs-keyword">finally</span> {
  …
}
</code></pre>
<div dir="rtl">
کلاس LocalPort ما فقط یک wrapper ساده است که استثناهای thrown شده توسط کلاس ACMEPort را catch و ترجمه می‌کند:
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalPort</span> {
  <span class="hljs-keyword">private</span> ACMEPort innerPort;
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">LocalPort</span><span class="hljs-params">(<span class="hljs-type">int</span> portNumber)</span> {
    innerPort = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ACMEPort</span>(portNumber);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">try</span> {
      innerPort.open();
    } <span class="hljs-keyword">catch</span> (DeviceResponseException e) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PortDeviceFailure</span>(e);
    } <span class="hljs-keyword">catch</span> (ATM1212UnlockedException e) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PortDeviceFailure</span>(e);
    } <span class="hljs-keyword">catch</span> (GMXError e) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PortDeviceFailure</span>(e);
    }
  }…
}
</code></pre>
<div dir="rtl">
Wrapperها مانند آنچه برای ACMEPort تعریف کردیم می‌توانند بسیار مفید باشند. در واقع، wrapping APIهای شخص ثالث یک شیوه عالی است. زمانی که یک API شخص ثالث را wrap می‌کنید، وابستگی‌های خود به آن را حداقل می‌کنید: می‌توانید در آینده به یک کتابخانه دیگر منتقل شوید بدون اینکه هزینه زیادی بپردازید. Wrapping همچنین کار را برای mock کردن فراخوانی‌های شخص ثالث هنگام تست کد خود آسان‌تر می‌کند.
<p>یک مزیت نهایی wrapping این است که شما به انتخاب‌های طراحی API یک فروشنده خاص وابسته نیستید. می‌توانید یک API تعریف کنید که با آن احساس راحتی کنید. در مثال قبلی، ما یک نوع استثنا برای خرابی دستگاه پورت تعریف کردیم و متوجه شدیم که می‌توانیم کد بسیار تمیزتری بنویسیم.</p>
<p>اغلب یک کلاس استثنا برای یک حوزه خاص از کد کافی است. اطلاعات ارسال شده با استثنا می‌تواند خطاها را متمایز کند. فقط در صورتی از کلاس‌های مختلف استفاده کنید که زمان‌هایی وجود داشته باشد که بخواهید یک استثنا را catch کنید و اجازه دهید دیگری عبور کند.</p>
<h2>تعریف جریان عادی</h2>
<p><img src="../../../assets/image/07/img-7.2.png" alt=""></p>
<p>اگر از نکات مطرح شده در بخش‌های قبلی پیروی کنید، به جدایی خوبی بین منطق کسب‌وکار و مدیریت خطا خواهید رسید. بخش عمده کد شما شروع به شکل‌گیری به‌عنوان یک الگوریتم تمیز و ساده می‌کند. با این حال، این فرآیند تشخیص خطا را به حاشیه‌های برنامه شما می‌برد. شما APIهای خارجی را wrap می‌کنید تا بتوانید استثناهای خود را thrown کنید و یک handler بالاتر از کد خود تعریف می‌کنید تا بتوانید با هر محاسبه‌ای که متوقف می‌شود، برخورد کنید. بیشتر اوقات، این یک رویکرد عالی است، اما گاهی اوقات ممکن است نخواهید محاسبه را متوقف کنید.</p>
<p>بیایید به یک مثال نگاه کنیم. در اینجا کد نامناسبی وجود دارد که هزینه‌ها را در یک برنامه صورتحساب جمع می‌کند:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">try</span> {
 <span class="hljs-type">MealExpenses</span> <span class="hljs-variable">expenses</span> <span class="hljs-operator">=</span> expenseReportDAO.getMeals(employee.getID());
 m_total += expenses.getTotal();
} <span class="hljs-keyword">catch</span>(MealExpensesNotFound e) {
 m_total += getMealPerDiem();
}
</code></pre>
<div dir="rtl">
در این کسب‌وکار، اگر وعده‌های غذایی هزینه شوند، به مجموع اضافه می‌شوند. اگر هزینه نشوند، کارمند مبلغی به عنوان دستمزد وعده غذایی برای آن روز دریافت می‌کند. این استثنا منطق را شلوغ می‌کند. آیا بهتر نیست که نیازی به برخورد با این مورد خاص نداشته باشیم؟ اگر این‌طور بود، کد ما بسیار ساده‌تر به نظر می‌رسید. کد ما به این شکل خواهد بود:
</div>
<pre class="hljs"><code><span class="hljs-type">MealExpenses</span> <span class="hljs-variable">expenses</span> <span class="hljs-operator">=</span> expenseReportDAO.getMeals(employee.getID());
m_total += expenses.getTotal();
</code></pre>
<div dir="rtl">
آیا می‌توانیم کد را تا این حد ساده کنیم؟ به نظر می‌رسد که می‌توانیم. می‌توانیم کلاس ExpenseReportDAO را طوری تغییر دهیم که همیشه یک شیء MealExpense را برگرداند. اگر هزینه‌ای برای وعده‌های غذایی وجود نداشته باشد، یک شیء MealExpense برمی‌گرداند که دستمزد را به عنوان مجموع خود برمی‌گرداند:
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PerDiemMealExpenses</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MealExpenses</span> {
 <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTotal</span><span class="hljs-params">()</span> {
 <span class="hljs-comment">// return the per diem default</span>
 }
}
</code></pre>
<div dir="rtl">
این الگوی خاص [Fowler] نامیده می‌شود . شما یک کلاس ایجاد می‌کنید یا یک شیء را پیکربندی می‌کنید تا مورد خاصی را برای شما مدیریت کند. وقتی این کار را انجام می‌دهید، کد کلاینت نیازی به برخورد با رفتارهای استثنایی ندارد. آن رفتار در شیء مورد خاص کپسوله شده است.
<h2>null برنگردانید</h2>
<p>به نظر من هر بحثی در مورد مدیریت خطا باید شامل اشاره به کارهایی باشد که ما را به سمت خطا سوق می‌دهند. اولین مورد در این لیست، بازگرداندن null است. نمی‌توانم تعداد برنامه‌هایی را که دیده‌ام که تقریباً هر خط دیگر آن‌ها یک بررسی برای null بود، بشمارم. در اینجا یک کد نمونه وجود دارد:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerItem</span><span class="hljs-params">(Item item)</span> {
  <span class="hljs-keyword">if</span> (item != <span class="hljs-literal">null</span>) {
    <span class="hljs-type">ItemRegistry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> peristentStore.getItemRegistry();
    <span class="hljs-keyword">if</span> (registry != <span class="hljs-literal">null</span>) {
      <span class="hljs-type">Item</span> <span class="hljs-variable">existing</span> <span class="hljs-operator">=</span> registry.getItem(item.getID());
      <span class="hljs-keyword">if</span> (existing.getBillingPeriod().hasRetailOwner()) {
        existing.register(item);
      }
    }
  }
}
</code></pre>
<div dir="rtl">
اگر در یک پایگاه کد با کدی مانند این کار کنید، ممکن است به نظر شما چندان بد نباشد، اما واقعاً بد است! وقتی null را باز می‌گردانیم، در واقع داریم برای خودمان کار ایجاد می‌کنیم و مشکلات را به دوش فراخواننده‌ها می‌گذاریم. تنها کافی است یک بررسی null فراموش شود تا یک برنامه از کنترل خارج شود.
<p>آیا متوجه شدید که در خط دوم آن دستور if تو در تو، هیچ بررسی null وجود نداشت؟ اگر persistentStore null بود، در زمان اجرا چه اتفاقی می‌افتاد؟ ما با یک NullPointerException در زمان اجرا مواجه می‌شدیم، و یا کسی در سطح بالا NullPointerException را catch می‌کند یا نمی‌کند. در هر صورت، این بد است. دقیقاً چه باید کرد در پاسخ به یک NullPointerException که از عمق برنامه شما thrown شده است؟</p>
<p>گفتن اینکه مشکل کد بالا این است که یک بررسی null ندارد، آسان است، اما در واقعیت، مشکل این است که بیش از حد بررسی null دارد. اگر وسوسه می‌شوید که از یک متد null را بازگردانید، به جای آن، در نظر داشته باشید که یک استثنا thrown کنید یا یک شیء مورد خاص برگردانید. اگر از یک متد شخص ثالث که null باز می‌گرداند، فراخوانی می‌کنید، در نظر داشته باشید که آن متد را با متدی که یا یک استثنا thrown می‌کند یا یک شیء مورد خاص برمی‌گرداند، wrap کنید.</p>
<p>در بسیاری از موارد، شیء مورد خاص یک درمان آسان است. تصور کنید که کدی مانند این دارید:</p>
</div>
<pre class="hljs"><code>List &lt;Employee&gt; employees = getEmployees();
<span class="hljs-keyword">if</span> (employees != <span class="hljs-literal">null</span>) {
  <span class="hljs-keyword">for</span> (Employee e: employees) {
    totalPay += e.getPay();
  }
}
</code></pre>
<div dir="rtl">
در حال حاضر، متد getEmployees می‌تواند null را برگرداند، اما آیا لازم است؟ اگر ما متد getEmployee را طوری تغییر دهیم که یک لیست خالی را بازگرداند، می‌توانیم کد را تمیزتر کنیم:
</div>
<pre class="hljs"><code>List &lt;Employee&gt; employees = getEmployees();
<span class="hljs-keyword">for</span> (Employee e: employees) {
  totalPay += e.getPay();
}
</code></pre>
<div dir="rtl">
خوشبختانه، جاوا دارای Collections.emptyList() است که یک لیست از پیش‌تعریف‌شده و غیرقابل تغییر را برمی‌گرداند که می‌توانیم برای این منظور از آن استفاده کنیم:
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">getEmployees</span><span class="hljs-params">()</span> {
 <span class="hljs-keyword">if</span>( .. there are no employees .. ) 
  <span class="hljs-keyword">return</span> Collections.emptyList();
}
</code></pre>
<div dir="rtl">
اگر به این روش کدنویسی کنید، احتمال وقوع NullPointerExceptions را به حداقل می‌رسانید و کد شما تمیزتر خواهد بود.
<h2>null پاس ندهید</h2>
<p>بازگرداندن null از متدها بد است، اما پاس دادن null به داخل متدها بدتر است. مگر اینکه با API کار کنید که از شما بخواهد null را پاس دهید، باید تا حد امکان از پاس دادن null در کد خود پرهیز کنید.</p>
<p>بیایید به یک مثال نگاه کنیم تا ببینیم چرا. در اینجا یک متد ساده وجود دارد که یک معیار را برای دو نقطه محاسبه می‌کند:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricsCalculator</span> 
{
 <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">xProjection</span><span class="hljs-params">(Point p1, Point p2)</span> {
 <span class="hljs-keyword">return</span> (p2.x – p1.x) * <span class="hljs-number">1.5</span>;
 }
 …
}
</code></pre>
<div dir="rtl">زمانی که کسی null را به عنوان یک آرگومان عبور می‌دهد، چه اتفاقی می‌افتد؟</div>
<pre class="hljs"><code>calculator.xProjection(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">12</span>, <span class="hljs-number">13</span>));
</code></pre>
<div dir="rtl">
البته، ما یک NullPointerException خواهیم گرفت.
<p>چگونه می‌توانیم این مشکل را برطرف کنیم؟ می‌توانیم یک نوع استثنا جدید ایجاد کنیم و آن را thrown کنیم:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricsCalculator</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">xProjection</span><span class="hljs-params">(Point p1, Point p2)</span> {
    <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span> || p2 == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> InvalidArgumentException(
        <span class="hljs-string">&quot;Invalid argument for MetricsCalculator.xProjection&quot;</span>);
    }
    <span class="hljs-keyword">return</span> (p2.x– p1.x) * <span class="hljs-number">1.5</span>;
  }
}

</code></pre>
<div dir="rtl">
آیا این بهتر است؟ ممکن است کمی بهتر از یک NullPointerException باشد، اما به خاطر داشته باشید که باید یک handler برای InvalidArgumentException تعریف کنیم. این handler باید چه کاری انجام دهد؟ آیا راه حل مناسبی وجود دارد؟
<p>یک گزینه دیگر نیز وجود دارد. می‌توانیم از مجموعه‌ای از assertions استفاده کنیم:</p>
</div>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricsCalculator</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">xProjection</span><span class="hljs-params">(Point p1, Point p2)</span> {
    <span class="hljs-keyword">assert</span> p1 != <span class="hljs-literal">null</span>: <span class="hljs-string">&quot;p1 should not be null&quot;</span>;
    <span class="hljs-keyword">assert</span> p2 != <span class="hljs-literal">null</span>: <span class="hljs-string">&quot;p2 should not be null&quot;</span>;
    <span class="hljs-keyword">return</span> (p2.x– p1.x) * <span class="hljs-number">1.5</span>;
  }
}
</code></pre>
<div dir="rtl">
این مستندات خوبند اما مشکل را حل نمی‌کنند. اگر کسی null را عبور دهد، همچنان با یک خطای زمان اجرا (runtime error) مواجه خواهیم شد.
<p>در بیشتر زبان‌های برنامه‌نویسی، راه خوبی برای مدیریت null که به طور تصادفی توسط یک فراخواننده عبور داده می‌شود وجود ندارد. به همین دلیل، رویکرد منطقی این است که به طور پیش‌فرض از عبور دادن null جلوگیری کنیم. وقتی این کار را انجام می‌دهید، می‌توانید با این دانش کدنویسی کنید که یک null در لیست آرگومان‌ها نشانه‌ای از یک مشکل است و در نهایت با اشتباهات کمتری مواجه خواهید شد.</p>
<h2>نتیجه‌گیری</h2>
<p>کد تمیز قابل خواندن است، اما باید (قوی) robust نیز باشد. این اهداف متضاد نیستند. ما می‌توانیم کد تمیز و robust بنویسیم اگر به مدیریت خطا به عنوان یک نگرانی جداگانه نگاه کنیم، چیزی که به طور مستقل از منطق اصلی ما قابل مشاهده است. به میزانی که قادر به انجام این کار باشیم، می‌توانیم به طور مستقل در مورد آن استدلال کنیم و پیشرفت‌های زیادی در نگهداری کد خود داشته باشیم.</p>
</div>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';
    const media = window.matchMedia('(prefers-color-scheme: dark)');
    const getEffective = s => (s === 'auto' ? (media.matches ? 'dark' : 'light') : s);

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = getEffective(s);
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    let saved = localStorage.getItem(KEY) || 'auto';
    updateTheme(saved);

    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'auto';
      const next = current === 'auto' ? 'dark' : current === 'dark' ? 'light' : 'auto';
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    media.addEventListener('change', () => {
      if ((localStorage.getItem(KEY) || 'auto') === 'auto') updateTheme('auto');
    });

    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'auto');
    });
  })();
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
</body>
</html>
