

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>برنامه‌نویسی موازی (Parallel Programming)</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

       <nav class="nav">
         <a href="/Gitab/" >خانه</a>
         <a href="/Gitab/books/list-books" >کتاب‌ها</a>
        <a href="/Gitab/translator.html" >مترجمین</a>
         <a href="/Gitab/giter.html" >گیتر</a>
       </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل بیست و دوم:  برنامه‌نویسی موازی (Parallel Programming)</h1>
<p>در این فصل، ما به <strong>APIها</strong> و ساختارهای چندنخی (multithreading) می‌پردازیم که با هدف بهره‌برداری از پردازنده‌های چند‌هسته‌ای طراحی شده‌اند:</p>
<ul>
<li><strong>Parallel LINQ (PLINQ)</strong></li>
<li><strong>کلاس Parallel</strong></li>
<li><strong>ساختارهای task parallelism</strong></li>
<li><strong>مجموعه‌های concurrent</strong></li>
</ul>
<p>این ساختارها در مجموع (به‌صورت غیررسمی) با عنوان <strong>Parallel Framework (PFX)</strong> شناخته می‌شوند.<br>
کلاس <strong>Parallel</strong> همراه با ساختارهای <strong>task parallelism</strong> تحت عنوان <strong>Task Parallel Library (TPL)</strong> نامیده می‌شوند.</p>
<p>پیش از مطالعه‌ی این فصل، لازم است با مفاهیم پایه‌ای در فصل ۱۴ آشنا باشید—به‌ویژه <strong>locking</strong>، <strong>ایمنی نخ‌ها (thread safety)</strong> و کلاس <strong>Task</strong>.</p>
<p>🔧 علاوه بر این‌ها، .NET مجموعه‌ای از APIهای تخصصی دیگر را برای کمک به برنامه‌نویسی موازی و ناهمگام ارائه می‌دهد:</p>
<ul>
<li><strong>System.Threading.Channels.Channel</strong> → یک صف تولیدکننده/مصرف‌کننده ناهمگام با کارایی بالا، که در <strong>.NET Core 3</strong> معرفی شد.</li>
<li><strong>Microsoft Dataflow</strong> (در فضای نام System.Threading.Tasks.Dataflow) → یک API پیشرفته برای ایجاد شبکه‌ای از بلوک‌های بافر شده (buffered blocks) که عملیات یا تبدیل داده‌ها را به‌صورت موازی اجرا می‌کنند و شباهت زیادی به برنامه‌نویسی actor/agent دارند.</li>
<li><strong>Reactive Extensions</strong> → پیاده‌سازی LINQ روی <strong>IObservable</strong> (جایگزینی برای <strong>IAsyncEnumerable</strong>) که در ترکیب جریان‌های ناهمگام بسیار قدرتمند است. این قابلیت از طریق بسته‌ی <strong>System.Reactive NuGet</strong> عرضه می‌شود.</li>
</ul>
<hr>
<h2>چرا PFX؟ 🤔</h2>
<p>در ۱۵ سال گذشته، سازندگان CPU از پردازنده‌های تک‌هسته‌ای به چند‌هسته‌ای مهاجرت کرده‌اند. این موضوع برای ما برنامه‌نویسان مشکل‌ساز است، زیرا کدهای تک‌نخی به‌طور خودکار از هسته‌های بیشتر سریع‌تر اجرا نمی‌شوند.</p>
<p>استفاده از چند‌هسته در بسیاری از برنامه‌های سمت سرور ساده است، چون هر نخ می‌تواند یک درخواست مشتری جداگانه را به‌طور مستقل پردازش کند. اما روی دسکتاپ این موضوع دشوارتر است، چون معمولاً نیاز دارید کدی را که محاسبات سنگین دارد به این صورت تغییر دهید:</p>
<ol>
<li>تقسیم آن به قطعه‌های کوچک‌تر.</li>
<li>اجرای این قطعه‌ها به‌صورت موازی با چندنخی.</li>
<li>جمع‌آوری نتایج در زمانی که آماده می‌شوند، به شکلی <strong>ایمن از نظر نخ‌ها</strong> و کارا.</li>
</ol>
<p>البته انجام همه‌ی این مراحل با ساختارهای کلاسیک چندنخی ممکن است، اما دست‌وپاگیر است—به‌خصوص مراحل تقسیم‌بندی و جمع‌آوری نتایج. مشکل دیگر این است که استراتژی رایج <strong>locking برای ایمنی نخ‌ها</strong>، هنگام کار هم‌زمان چند نخ روی داده‌های مشترک، باعث ایجاد رقابت (contention) زیادی می‌شود.</p>
<p>کتابخانه‌های <strong>PFX</strong> دقیقاً برای حل این سناریوها طراحی شده‌اند.</p>
<hr>
<h2>مفاهیم PFX 🧩</h2>
<p>برنامه‌نویسی برای بهره‌برداری از چند‌هسته یا چند پردازنده، <strong>parallel programming</strong> نام دارد. این موضوع یک زیرمجموعه از مفهوم گسترده‌تر <strong>multithreading</strong> است.</p>
<p>دو استراتژی اصلی برای تقسیم کار بین نخ‌ها وجود دارد:</p>
<ul>
<li><strong>Data Parallelism (موازی‌سازی داده‌ها)</strong></li>
<li><strong>Task Parallelism (موازی‌سازی وظایف)</strong></li>
</ul>
<p>🔹 در <strong>data parallelism</strong>، وقتی مجموعه‌ای از وظایف باید روی داده‌های زیادی اجرا شوند، هر نخ همان مجموعه وظایف را روی بخشی از داده‌ها اجرا می‌کند. در واقع داده‌ها بین نخ‌ها تقسیم می‌شوند.</p>
<p>🔹 در <strong>task parallelism</strong>، ما وظایف را تقسیم می‌کنیم؛ به این معنا که هر نخ وظیفه‌ای متفاوت را اجرا می‌کند.</p>
<p>به‌طور کلی، <strong>data parallelism</strong> ساده‌تر است و روی سخت‌افزارهایی با قابلیت موازی‌سازی بالا بهتر مقیاس‌پذیر است، زیرا داده‌های مشترک را کاهش می‌دهد یا حذف می‌کند (در نتیجه مشکلات رقابت و ایمنی نخ‌ها نیز کمتر می‌شود). علاوه‌بر این، معمولاً داده‌ها بیش از وظایف جداگانه هستند، و این امر پتانسیل موازی‌سازی را افزایش می‌دهد.</p>
<p><strong>Data parallelism</strong> همچنین زمینه‌ساز <strong>structured parallelism</strong> است؛ به این معنا که کارهای موازی در یک نقطه از برنامه شروع و در همان‌جا نیز پایان می‌یابند. در مقابل، <strong>task parallelism</strong> معمولاً <strong>unstructured</strong> است، یعنی کارهای موازی ممکن است در بخش‌های پراکنده‌ای از برنامه شروع و پایان یابند.</p>
<p>🔑 <strong>Structured parallelism</strong> ساده‌تر، کم‌خطاتر، و امکان واگذاری کارهای دشوار مانند تقسیم‌بندی، هماهنگی نخ‌ها و حتی جمع‌آوری نتایج را به کتابخانه‌ها فراهم می‌کند.</p>
<hr>
<h2>اجزای PFX 🏗️</h2>
<p>کتابخانه‌ی <strong>PFX</strong> از دو لایه‌ی اصلی تشکیل شده است (مطابق شکل 22-1):</p>
<ul>
<li>
<p><strong>لایه بالاتر</strong> → شامل دو API برای data parallelism ساختاریافته:</p>
<ul>
<li><strong>PLINQ</strong></li>
<li><strong>کلاس Parallel</strong></li>
</ul>
</li>
<li>
<p><strong>لایه پایین‌تر</strong> → شامل کلاس‌های task parallelism به‌علاوه مجموعه‌ای از ساختارهای کمکی برای فعالیت‌های برنامه‌نویسی موازی.</p>
</li>
</ul>
 <div align="center">
<p><img src="../../../assets/image/22/Table-22-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>PLINQ ✨</h3>
<p><strong>PLINQ</strong> غنی‌ترین قابلیت‌ها را ارائه می‌دهد: این ابزار تمام مراحل موازی‌سازی را به‌طور خودکار انجام می‌دهد—از جمله:</p>
<ul>
<li>تقسیم کار به وظایف (tasks)</li>
<li>اجرای این وظایف روی نخ‌ها (threads)</li>
<li>جمع‌آوری نتایج در یک توالی خروجی واحد</li>
</ul>
<p>به همین دلیل آن را <strong>Declarative</strong> می‌نامند—چون شما فقط اعلام می‌کنید که می‌خواهید کارتان موازی‌سازی شود (به‌صورت یک پرس‌و‌جوی LINQ ساختاربندی‌شده) و خودِ <strong>runtime</strong> جزئیات پیاده‌سازی را مدیریت می‌کند.</p>
<p>در مقابل، رویکردهای دیگر <strong>Imperative</strong> هستند؛ یعنی شما باید به‌طور صریح کدی بنویسید تا کار را تقسیم یا نتایج را جمع‌آوری کنید.</p>
<p>همان‌طور که خلاصه‌ی زیر نشان می‌دهد:</p>
<ul>
<li>در مورد <strong>کلاس Parallel</strong> → شما باید نتایج را خودتان جمع‌آوری کنید.</li>
<li>در مورد <strong>ساختارهای task parallelism</strong> → شما باید علاوه بر جمع‌آوری نتایج، تقسیم کار را نیز خودتان انجام دهید.</li>
</ul>
 <div align="center">
<p><img src="../../../assets/image/22/Table-22-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>مجموعه‌های Concurrent و Spinning Primitives ⚙️</h3>
<p><strong>مجموعه‌های concurrent</strong> و <strong>spinning primitives</strong> به شما در فعالیت‌های سطح پایین‌تر برنامه‌نویسی موازی کمک می‌کنند. اهمیت این ابزارها از آنجاست که <strong>PFX</strong> نه‌تنها برای سخت‌افزار امروزی بلکه برای نسل‌های آینده‌ی پردازنده‌ها با تعداد هسته‌های بسیار بیشتر طراحی شده است.</p>
<p>فرض کنید باید یک توده چوب خردشده را جابه‌جا کنید و ۳۲ کارگر در اختیار دارید؛ بزرگ‌ترین چالش این است که کارگران بدون مزاحمت برای یکدیگر بتوانند کار کنند. دقیقا همین موضوع در تقسیم یک الگوریتم بین ۳۲ هسته رخ می‌دهد: اگر از <strong>lockهای معمولی</strong> برای محافظت از منابع مشترک استفاده شود، قفل شدن‌ها (blocking) باعث می‌شوند تنها بخشی از هسته‌ها واقعاً فعال باشند.</p>
<p>🔑 مجموعه‌های concurrent به‌طور خاص برای دسترسی‌های بسیار هم‌زمان تنظیم شده‌اند، با تمرکز بر <strong>حداقل‌سازی یا حذف قفل شدن</strong>.<br>
کلاس <strong>Parallel</strong> و همچنین <strong>PLINQ</strong> خودشان برای مدیریت کار به‌صورت کارآمد، متکی بر همین مجموعه‌ها و <strong>spinning primitives</strong> هستند.</p>
<hr>
<h2>کاربردهای دیگر PFX 🛠️</h2>
<p>ساختارهای برنامه‌نویسی موازی تنها برای استفاده از چند‌هسته نیستند، بلکه در سناریوهای دیگر هم مفید واقع می‌شوند:</p>
<ul>
<li>وقتی به یک <strong>queue</strong>، <strong>stack</strong> یا <strong>dictionary</strong> ایمن از نظر نخ‌ها (thread-safe) نیاز دارید.</li>
<li><strong>BlockingCollection</strong> راهی ساده برای پیاده‌سازی ساختارهای تولیدکننده/مصرف‌کننده فراهم می‌کند و همچنین روشی مناسب برای محدودسازی هم‌زمانی است.</li>
<li><strong>Tasks</strong> پایه‌ی اصلی برنامه‌نویسی ناهمگام هستند (همان‌طور که در فصل ۱۴ دیدیم).</li>
</ul>
<hr>
<h2>چه زمانی باید از PFX استفاده کرد؟ ⏱️</h2>
<p>مورد اصلی استفاده از <strong>PFX</strong>، <strong>برنامه‌نویسی موازی</strong> است: یعنی بهره‌برداری از چند‌هسته برای سرعت‌بخشیدن به کدهای محاسباتی سنگین.</p>
<p>یکی از چالش‌های مهم در برنامه‌نویسی موازی، <strong>قانون Amdahl</strong> است. این قانون می‌گوید بیشترین بهبود کارایی از موازی‌سازی، توسط بخشی از کد که باید به‌صورت ترتیبی (sequential) اجرا شود محدود می‌گردد.</p>
<p>📌 مثال: اگر تنها دوسوم زمان اجرای یک الگوریتم قابل موازی‌سازی باشد، حتی با بی‌نهایت هسته نمی‌توانید بیش از سه برابر افزایش کارایی داشته باشید.</p>
<p>بنابراین، پیش از ادامه باید مطمئن شوید که گلوگاه واقعاً در بخشی از کد است که قابلیت موازی‌سازی دارد. همچنین باید بررسی کنید که آیا اصلاً کد شما نیاز به محاسبات سنگین دارد یا خیر—زیرا <strong>بهینه‌سازی</strong> اغلب ساده‌ترین و مؤثرترین راهکار است.<br>
البته این موضوع یک معامله دارد، چون برخی روش‌های بهینه‌سازی می‌توانند موازی‌سازی کد را سخت‌تر کنند.</p>
<p>بیشترین سود در مواردی به‌دست می‌آید که به آن‌ها <strong>embarrassingly parallel problems</strong> می‌گویند—یعنی زمانی که یک کار به‌راحتی می‌تواند به وظایف جداگانه تقسیم شود و هرکدام به‌طور مستقل و کارآمد اجرا شوند.</p>
<p>📷 نمونه‌ها:</p>
<ul>
<li>بسیاری از وظایف پردازش تصویر</li>
<li>ray tracing</li>
<li>روش‌های brute-force در ریاضیات یا رمزنگاری</li>
</ul>
<p>نمونه‌ی یک <strong>مشکل غیر embarrassingly parallel</strong>، پیاده‌سازی یک نسخه‌ی بهینه از الگوریتم <strong>quicksort</strong> است—که برای رسیدن به نتیجه خوب نیازمند فکر بیشتری است و شاید به <strong>unstructured parallelism</strong> نیاز داشته باشد.</p>
<hr>
<h2>PLINQ ⚡</h2>
<p><strong>PLINQ</strong> پرس‌و‌جوهای LINQ محلی را به‌طور خودکار موازی‌سازی می‌کند.<br>
مزیت بزرگ آن این است که بار تقسیم کار و جمع‌آوری نتایج را به‌طور کامل به <strong>.NET</strong> واگذار می‌کند.</p>
<p>برای استفاده از PLINQ، کافیست روی توالی ورودی، متد <strong>AsParallel()</strong> را فراخوانی کرده و سپس پرس‌وجوی LINQ را مثل همیشه ادامه دهید.</p>
<p>نمونه‌ی زیر عددهای اول بین ۳ تا ۱۰۰,۰۰۰ را با استفاده کامل از تمام هسته‌های ماشین محاسبه می‌کند:</p>
<pre class="hljs"><code><span class="hljs-comment">// محاسبه اعداد اول با یک الگوریتم ساده (غیربهینه).</span>
IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; numbers = Enumerable.Range (<span class="hljs-number">3</span>, <span class="hljs-number">100000</span> - <span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> parallelQuery =
    <span class="hljs-keyword">from</span> n <span class="hljs-keyword">in</span> numbers.AsParallel()
    <span class="hljs-keyword">where</span> Enumerable.Range (<span class="hljs-number">2</span>, (<span class="hljs-built_in">int</span>) Math.Sqrt(n)).All (i =&gt; n % i &gt; <span class="hljs-number">0</span>)
    <span class="hljs-keyword">select</span> n;

<span class="hljs-built_in">int</span>[] primes = parallelQuery.ToArray();
</code></pre>
<p>🔍 متد <strong>AsParallel</strong> یک <strong>extension method</strong> در <strong>System.Linq.ParallelEnumerable</strong> است. این متد ورودی را در یک توالی بر پایه‌ی <strong>ParallelQuery<TSource></strong> می‌پیچد. همین موضوع باعث می‌شود عملگرهای پرس‌وجوی LINQ که در ادامه فراخوانی می‌کنید، به مجموعه‌ای جایگزین از متدهای توسعه‌یافته در <strong>ParallelEnumerable</strong> متصل شوند.</p>
<p>این متدها پیاده‌سازی‌های موازی از هر یک از عملگرهای استاندارد پرس‌وجو را فراهم می‌کنند. اساس کار آن‌ها این است که توالی ورودی را به بخش‌هایی تقسیم می‌کنند تا روی نخ‌های مختلف اجرا شوند و سپس نتایج را دوباره در یک توالی خروجی واحد گردآوری کنند (مطابق شکل 22-2).</p>
 <div align="center">
<p><img src="../../../assets/image/22/Table-22-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>استفاده از AsSequential() 🔄</h3>
<p>فراخوانی <strong>AsSequential()</strong> باعث می‌شود که یک توالی <strong>ParallelQuery</strong> باز (unwrap) شود، به‌طوری‌که عملگرهای پرس‌و‌جو (query operators) بعدی به عملگرهای استاندارد LINQ متصل شده و به‌صورت ترتیبی (sequential) اجرا شوند.</p>
<p>این موضوع زمانی ضروری است که:</p>
<ul>
<li>بخواهید متدی را فراخوانی کنید که دارای <strong>اثر جانبی (side effect)</strong> باشد.</li>
<li>یا متد مورد نظر <strong>thread-safe</strong> نباشد.</li>
</ul>
<p>برای عملگرهای پرس‌و‌جویی که <strong>دو توالی ورودی</strong> دریافت می‌کنند (مثل <strong>Join, GroupJoin, Concat, Union, Intersect, Except و Zip</strong>) باید روی هر دو توالی ورودی، متد <strong>AsParallel()</strong> اعمال شود؛ در غیر این صورت خطا (exception) پرتاب خواهد شد.</p>
<p>نکته: نیازی نیست در طول پیشرفت یک پرس‌و‌جو مدام <strong>AsParallel()</strong> را اعمال کنید، زیرا عملگرهای پرس‌و‌جوی PLINQ خودشان یک <strong>ParallelQuery</strong> دیگر برمی‌گردانند. در واقع، فراخوانی دوباره‌ی AsParallel ناکارآمد است، چون باعث ادغام (merge) و تقسیم‌بندی مجدد پرس‌و‌جو می‌شود:</p>
<pre class="hljs"><code>mySequence.AsParallel()           <span class="hljs-comment">// توالی را به ParallelQuery&lt;int&gt; می‌پیچد</span>
          .Where (n =&gt; n &gt; <span class="hljs-number">100</span>)   <span class="hljs-comment">// یک ParallelQuery&lt;int&gt; دیگر تولید می‌کند</span>
          .AsParallel()           <span class="hljs-comment">// غیرضروری و ناکارآمد!</span>
          .Select (n =&gt; n * n);
</code></pre>
<hr>
<h3>محدودیت‌ها و نکات PLINQ ⚠️</h3>
<ul>
<li>همه‌ی عملگرهای پرس‌و‌جو به‌طور مؤثر قابل موازی‌سازی نیستند. برای این موارد (بخش “PLINQ Limitations” در صفحه ۹۳۸)، <strong>PLINQ</strong> عملگر را به‌صورت ترتیبی اجرا می‌کند.</li>
<li>اگر PLINQ تشخیص دهد سربار موازی‌سازی بیشتر از سود آن است، پرس‌و‌جو را به‌صورت ترتیبی اجرا خواهد کرد.</li>
<li><strong>PLINQ فقط روی مجموعه‌های محلی کار می‌کند</strong>؛ مثلاً با <strong>Entity Framework</strong> سازگار نیست، چون در آن حالت LINQ به SQL ترجمه می‌شود و روی سرور پایگاه داده اجرا خواهد شد. با این حال می‌توانید PLINQ را برای پرس‌و‌جوهای محلی روی نتایج حاصل از دیتابیس به‌کار ببرید.</li>
<li>اگر یک پرس‌و‌جوی PLINQ استثنا پرتاب کند، این خطا به‌شکل <strong>AggregateException</strong> دوباره پرتاب می‌شود، که خاصیت <strong>InnerExceptions</strong> آن خطا یا خطاهای واقعی را در خود نگه می‌دارد (برای جزئیات، به “Working with AggregateException” در صفحه ۹۶۴ مراجعه کنید).</li>
</ul>
<hr>
<h3>چرا AsParallel به‌صورت پیش‌فرض فعال نیست؟ 🤔</h3>
<p>با توجه به اینکه <strong>AsParallel</strong> پرس‌و‌جوهای LINQ را به‌طور شفاف موازی‌سازی می‌کند، این پرسش پیش می‌آید: چرا مایکروسافت عملگرهای استاندارد LINQ را به‌طور پیش‌فرض موازی نکرد و PLINQ را به حالت پیش‌فرض تبدیل نکرد؟</p>
<p>دلایل این رویکرد opt-in عبارتند از:</p>
<ol>
<li>
<p>برای اینکه PLINQ مفید باشد، باید حجم قابل‌توجهی از کار محاسباتی سنگین وجود داشته باشد.<br>
اکثر پرس‌و‌جوهای LINQ-to-Objects خیلی سریع اجرا می‌شوند؛ در این حالت نه‌تنها موازی‌سازی غیرضروری است، بلکه سربار تقسیم‌بندی، جمع‌آوری و هماهنگی نخ‌های اضافی می‌تواند اجرای کد را کندتر کند.</p>
</li>
<li>
<p>تفاوت‌های رفتاری:</p>
<ul>
<li>خروجی یک پرس‌و‌جوی PLINQ (به‌طور پیش‌فرض) می‌تواند از نظر <strong>ترتیب عناصر</strong> با LINQ عادی متفاوت باشد (بخش “PLINQ and Ordering” در صفحه ۹۳۷).</li>
<li>PLINQ استثناها را درون یک <strong>AggregateException</strong> می‌پیچد (چون ممکن است چند استثنا به‌طور هم‌زمان رخ دهند).</li>
<li>اگر پرس‌و‌جو متدهای غیر thread-safe را فراخوانی کند، نتایج PLINQ قابل‌اعتماد نخواهند بود.</li>
</ul>
</li>
<li>
<p>PLINQ قابلیت‌های متعددی برای <strong>تنظیم و بهینه‌سازی</strong> دارد. افزودن این پیچیدگی‌ها به API استاندارد LINQ-to-Objects باعث شلوغی و حواس‌پرتی می‌شد.</p>
</li>
</ol>
<hr>
<h3>رفتار اجرایی موازی (Parallel Execution Ballistics) 🎯</h3>
<p>مانند پرس‌و‌جوهای عادی LINQ، پرس‌و‌جوهای <strong>PLINQ</strong> نیز <strong>lazy evaluation</strong> دارند. یعنی اجرا فقط زمانی آغاز می‌شود که شروع به مصرف نتایج کنید—معمولاً با یک حلقه‌ی <strong>foreach</strong> (یا با یک عملگر تبدیلی مثل <strong>ToArray</strong> یا عملگری که یک عنصر/مقدار منفرد برمی‌گرداند).</p>
<p>اما هنگام شمارش نتایج، نحوه‌ی اجرا با پرس‌و‌جوهای ترتیبی معمولی متفاوت است:</p>
<ul>
<li>در پرس‌و‌جوی ترتیبی، همه‌چیز کاملاً توسط مصرف‌کننده و به‌صورت <strong>pull</strong> انجام می‌شود؛ یعنی هر عنصر دقیقاً زمانی واکشی می‌شود که مصرف‌کننده به آن نیاز دارد.</li>
<li>در پرس‌و‌جوی موازی، نخ‌های مستقل عناصر ورودی را کمی زودتر از زمان نیاز مصرف‌کننده واکشی می‌کنند (مثل تله‌پرومتر برای مجریان اخبار 📺). سپس این عناصر در طول زنجیره‌ی پرس‌و‌جو به‌صورت موازی پردازش می‌شوند. نتایج در یک بافر کوچک نگه‌داری می‌شوند تا در لحظه برای مصرف‌کننده آماده باشند.</li>
<li>اگر مصرف‌کننده مکث کند یا زودتر از شمارش کامل خارج شود، پردازشگر پرس‌و‌جو هم متوقف یا مکث می‌کند تا از هدر رفتن CPU و حافظه جلوگیری شود.</li>
</ul>
<hr>
<h3>تنظیم بافر در PLINQ 📦</h3>
<p>می‌توانید رفتار بافر PLINQ را با فراخوانی <strong>WithMergeOptions</strong> بعد از <strong>AsParallel</strong> تغییر دهید:</p>
<ul>
<li><strong>AutoBuffered (پیش‌فرض)</strong> → معمولاً بهترین کارایی کلی را می‌دهد.</li>
<li><strong>NotBuffered</strong> → بافر را غیرفعال می‌کند و برای مواقعی مناسب است که می‌خواهید نتایج را سریع‌تر و بلافاصله ببینید.</li>
<li><strong>FullyBuffered</strong> → کل مجموعه نتایج را قبل از ارائه به مصرف‌کننده ذخیره می‌کند (عملگرهایی مانند <strong>OrderBy</strong> و <strong>Reverse</strong> و همچنین عملگرهای مربوط به <strong>element</strong>، <strong>aggregation</strong> و <strong>conversion</strong> ذاتاً همین‌گونه عمل می‌کنند).</li>
</ul>
<h3>📌 PLINQ و ترتیب (Ordering)</h3>
<p>یکی از عوارض جانبی موازی‌سازی عملگرهای پرس‌وجو این است که هنگام جمع‌آوری نتایج، <strong>لزومی ندارد ترتیب عناصر مثل حالت اولیه باقی بماند</strong> (به شکل 22-2 مراجعه کنید).<br>
به بیان دیگر، تضمین <strong>حفظ ترتیب</strong> در LINQ برای توالی‌ها در PLINQ برقرار نیست.</p>
<p>اگر به <strong>حفظ ترتیب</strong> نیاز داشته باشید، می‌توانید پس از <code>AsParallel()</code> از <code>AsOrdered()</code> استفاده کنید:</p>
<pre class="hljs"><code>myCollection.AsParallel().AsOrdered()...
</code></pre>
<p>استفاده از <code>AsOrdered</code> هنگام کار با مجموعه‌های بزرگ باعث کاهش کارایی می‌شود، چون PLINQ باید موقعیت اصلی هر عنصر را دنبال کند.</p>
<p>می‌توانید اثر <code>AsOrdered</code> را در ادامه‌ی پرس‌وجو با استفاده از <code>AsUnordered</code> خنثی کنید. این کار یک “نقطه‌ی تصادفی در ترتیب” ایجاد می‌کند که به پرس‌وجو اجازه می‌دهد از آن نقطه به بعد کارایی بهتری داشته باشد.<br>
برای مثال، اگر بخواهید ترتیب ورودی فقط برای دو عملگر اول حفظ شود:</p>
<pre class="hljs"><code>inputSequence.AsParallel().AsOrdered()
  .QueryOperator1()
  .QueryOperator2()
  .AsUnordered()
      <span class="hljs-comment">// از اینجا به بعد ترتیب اهمیتی ندارد</span>
  .QueryOperator3()
  ...
</code></pre>
<p>🔹 دلیل اینکه <code>AsOrdered</code> پیش‌فرض نیست این است که در بیشتر پرس‌وجوها، ترتیب اولیه اهمیتی ندارد. اگر قرار بود <code>AsOrdered</code> پیش‌فرض باشد، برای اکثر پرس‌وجوهای موازی باید <code>AsUnordered</code> اضافه می‌کردید تا بهترین کارایی حاصل شود، و این باعث پیچیدگی و بار اضافی می‌شد.</p>
<hr>
<h3>⚠️ محدودیت‌های PLINQ</h3>
<p>همه‌ی عملگرهای پرس‌وجو را نمی‌توان به‌طور مؤثر موازی‌سازی کرد. موارد زیر محدودیت دارند:</p>
<ul>
<li>
<p>نسخه‌های اندیس‌دار <code>Select</code>، <code>SelectMany</code> و <code>ElementAt</code> فقط زمانی موازی‌سازی می‌شوند که عناصر منبع در موقعیت اندیسی اصلی خود باقی مانده باشند.</p>
<blockquote>
<p>بیشتر عملگرها موقعیت اندیس را تغییر می‌دهند (مثل <code>Where</code> که عناصر را حذف می‌کند). بنابراین اگر می‌خواهید از عملگرهای اندیس‌دار استفاده کنید، معمولاً باید آنها در ابتدای پرس‌وجو باشند.</p>
</blockquote>
</li>
<li>
<p>عملگرهای زیر قابل موازی‌سازی هستند، اما از استراتژی تقسیم‌بندی پرهزینه‌ای استفاده می‌کنند که گاهی حتی از پردازش ترتیبی کندتر است:<br>
<code>Join</code>, <code>GroupBy</code>, <code>GroupJoin</code>, <code>Distinct</code>, <code>Union</code>, <code>Intersect</code>, <code>Except</code></p>
</li>
<li>
<p>نسخه‌های <strong>Seeded</strong> از عملگر <code>Aggregate</code> در حالت عادی قابل موازی‌سازی نیستند. PLINQ برای این مورد نسخه‌های خاصی ارائه می‌دهد (بخش <em>Optimizing PLINQ</em> در صفحه 942).</p>
</li>
<li>
<p>همه‌ی عملگرهای دیگر موازی‌سازی می‌شوند، اما این تضمین نمی‌کند که پرس‌وجوی شما <strong>حتماً</strong> موازی شود. اگر PLINQ تشخیص دهد سربار موازی‌سازی پرس‌وجو را کند می‌کند، ممکن است آن را ترتیبی اجرا کند.<br>
✅ می‌توانید با این کد رفتار را مجبور به موازی‌سازی کنید:</p>
</li>
</ul>
<pre class="hljs"><code>.WithExecutionMode(ParallelExecutionMode.ForceParallelism)
</code></pre>
<hr>
<h3>📝 مثال: بررسی املا (Spellchecker) موازی</h3>
<p>فرض کنید می‌خواهیم یک <strong>بررسی‌کننده‌ی املای سریع</strong> برای اسناد بزرگ بنویسیم که از تمام هسته‌های CPU استفاده کند. با تبدیل الگوریتم به یک پرس‌وجوی LINQ، می‌توانیم به‌راحتی آن را موازی کنیم.</p>
<p>🔹 مرحله‌ی اول: دانلود یک <strong>دیکشنری از کلمات انگلیسی</strong> و ذخیره در <code>HashSet</code> برای جست‌وجوی سریع:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (!File.Exists(<span class="hljs-string">&quot;WordLookup.txt&quot;</span>))    <span class="hljs-comment">// حدود 150,000 کلمه</span>
    File.WriteAllText(<span class="hljs-string">&quot;WordLookup.txt&quot;</span>,
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> HttpClient().GetStringAsync(
            <span class="hljs-string">&quot;http://www.albahari.com/ispell/allwords.txt&quot;</span>));

<span class="hljs-keyword">var</span> wordLookup = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">string</span>&gt;(
    File.ReadAllLines(<span class="hljs-string">&quot;WordLookup.txt&quot;</span>),
    StringComparer.InvariantCultureIgnoreCase);
</code></pre>
<p>🔹 مرحله‌ی دوم: ایجاد یک “سند آزمایشی” شامل یک میلیون کلمه‌ی تصادفی، سپس ایجاد چند غلط املایی عمدی:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> random = <span class="hljs-keyword">new</span> Random();
<span class="hljs-built_in">string</span>[] wordList = wordLookup.ToArray();

<span class="hljs-built_in">string</span>[] wordsToTest = Enumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">1000000</span>)
    .Select(i =&gt; wordList[random.Next(<span class="hljs-number">0</span>, wordList.Length)])
    .ToArray();

wordsToTest[<span class="hljs-number">12345</span>] = <span class="hljs-string">&quot;woozsh&quot;</span>;   <span class="hljs-comment">// چند غلط املایی</span>
wordsToTest[<span class="hljs-number">23456</span>] = <span class="hljs-string">&quot;wubsie&quot;</span>;
</code></pre>
<p>🔹 مرحله‌ی سوم: اجرای بررسی موازی با PLINQ:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> query = wordsToTest
    .AsParallel()
    .Select((word, index) =&gt; (word, index))
    .Where(iword =&gt; !wordLookup.Contains(iword.word))
    .OrderBy(iword =&gt; iword.index);

<span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> mistake <span class="hljs-keyword">in</span> query)
    Console.WriteLine(mistake.word + <span class="hljs-string">&quot; - index = &quot;</span> + mistake.index);

<span class="hljs-comment">// خروجی:</span>
<span class="hljs-comment">// woozsh - index = 12345</span>
<span class="hljs-comment">// wubsie - index = 23456</span>
</code></pre>
<p>متد <code>wordLookup.Contains</code> در predicate به پرس‌وجو <strong>حجم پردازشی مناسبی</strong> می‌دهد و ارزش موازی‌سازی را ایجاد می‌کند.</p>
<hr>
<h3>📦 نکته درباره‌ی کارایی و حافظه</h3>
<p>در پرس‌وجو از <strong>Tuple</strong>‌ها <code>(word, index)</code> به‌جای <strong>نوع ناشناس (anonymous types)</strong> استفاده شده است.<br>
چون Tupleها به‌صورت <strong>Value Type</strong> پیاده‌سازی شده‌اند (نه Reference Type):</p>
<ul>
<li>مصرف حافظه در اوج کاهش می‌یابد ✅</li>
<li>کارایی بهتر می‌شود ✅</li>
<li>تخصیص‌های heap و جمع‌آوری زباله (Garbage Collection) کمتر می‌شود ✅</li>
</ul>
<p>📊 البته بنچمارک‌ها نشان می‌دهند این مزایا در عمل <strong>متوسط</strong> هستند، چون مدیر حافظه بسیار کارآمد است و این تخصیص‌ها معمولاً بیش از <strong>Generation 0</strong> دوام نمی‌آورند.</p>
<h3>🧵 استفاده از <code>ThreadLocal&lt;T&gt;</code></h3>
<p>بیایید مثال خودمان را گسترش دهیم و <strong>ایجاد لیست تصادفی کلمات آزمایشی</strong> را نیز موازی‌سازی کنیم.<br>
ما آن را به‌صورت یک پرس‌وجوی LINQ ساختاربندی کردیم، پس باید ساده باشد.</p>
<p>🔹 نسخه‌ی ترتیبی:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span>[] wordsToTest = Enumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">1000000</span>)
    .Select(i =&gt; wordList[random.Next(<span class="hljs-number">0</span>, wordList.Length)])
    .ToArray();
</code></pre>
<p>اما مشکل اینجاست که فراخوانی <code>random.Next</code> <strong>Thread-Safe</strong> نیست؛ بنابراین به‌سادگی نمی‌توانیم <code>AsParallel()</code> را در پرس‌وجو وارد کنیم.</p>
<p>راه‌حل احتمالی این است که متدی بنویسیم که دور <code>random.Next</code> قفل بگذارد؛ اما این باعث محدود شدن هم‌زمانی (Concurrency) می‌شود.<br>
✅ راه‌حل بهتر این است که از <code>ThreadLocal&lt;Random&gt;</code> (بخش <em>Thread-Local Storage</em> صفحه 923) استفاده کنیم تا برای هر نخ یک شیء <code>Random</code> جداگانه ساخته شود.</p>
<p>🔹 نسخه‌ی موازی:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> localRandom = <span class="hljs-keyword">new</span> ThreadLocal&lt;Random&gt;(
    () =&gt; <span class="hljs-keyword">new</span> Random(Guid.NewGuid().GetHashCode()));

<span class="hljs-built_in">string</span>[] wordsToTest = Enumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">1000000</span>).AsParallel()
    .Select(i =&gt; wordList[localRandom.Value.Next(<span class="hljs-number">0</span>, wordList.Length)])
    .ToArray();
</code></pre>
<p>در تابع کارخانه‌ای که برای ایجاد یک شیء <code>Random</code> نوشتیم، از هش (<code>HashCode</code>) یک <code>Guid</code> استفاده کردیم تا مطمئن شویم اگر دو شیء <code>Random</code> در یک بازه‌ی زمانی کوتاه ساخته شوند، دنباله‌ی اعداد تصادفی‌شان متفاوت خواهد بود. 🎲</p>
<hr>
<h3>🤔 چه زمانی از PLINQ استفاده کنیم؟</h3>
<p>ممکن است وسوسه شوید در برنامه‌های موجود خود به‌دنبال پرس‌وجوهای LINQ بگردید و آنها را موازی‌سازی کنید.<br>
اما این معمولاً بی‌فایده است، چون مسائلی که LINQ بهترین راه‌حل برایشان محسوب می‌شود، خیلی سریع اجرا می‌شوند و موازی‌سازی کمکی نمی‌کند.</p>
<p>✅ رویکرد بهتر:</p>
<ul>
<li>پیدا کردن یک <strong>گلوگاه CPU-محور</strong></li>
<li>سپس بررسی اینکه آیا می‌توان آن را به‌صورت یک پرس‌وجوی LINQ بیان کرد</li>
</ul>
<p>🔹 یک اثر جانبی خوشایند این بازنویسی این است که کد <strong>کوچک‌تر و خواناتر</strong> می‌شود.</p>
<p>📌 PLINQ برای مسائلی که به‌طور واضح <strong>Embarrassingly Parallel</strong> هستند عالی است.<br>
اما برای پردازش تصویر (Imaging) انتخاب خوبی نیست، چون جمع‌آوری میلیون‌ها پیکسل در یک توالی خروجی خودش تبدیل به گلوگاه می‌شود.<br>
راه بهتر این است که پیکسل‌ها را مستقیماً در یک آرایه یا بلوک حافظه‌ی unmanaged بنویسیم و از <strong>کلاس Parallel</strong> یا <strong>task parallelism</strong> برای مدیریت چندریسمانی استفاده کنیم.</p>
<p>(با این حال می‌توان با متد <code>ForAll</code> جمع‌آوری نتایج را حذف کرد—بخش <em>Optimizing PLINQ</em> صفحه 942 توضیح می‌دهد. این کار وقتی منطقی است که الگوریتم پردازش تصویر ذاتاً مناسب LINQ باشد.)</p>
<hr>
<h3>🧼 خلوص تابعی (Functional Purity)</h3>
<p>چون PLINQ پرس‌وجوی شما را روی نخ‌های موازی اجرا می‌کند، باید مراقب باشید عملیاتی انجام ندهید که <strong>Thread-Safe</strong> نیستند.</p>
<p>به‌ویژه، نوشتن در متغیرها اثر جانبی دارد و بنابراین ناامن است:</p>
<pre class="hljs"><code><span class="hljs-comment">// پرس‌وجوی زیر هر عنصر را در موقعیتش ضرب می‌کند.</span>
<span class="hljs-comment">// با ورودی Enumerable.Range(0,999) باید مربع‌ها را بدهد.</span>
<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> n <span class="hljs-keyword">in</span> Enumerable.Range(<span class="hljs-number">0</span>,<span class="hljs-number">999</span>).AsParallel()
            <span class="hljs-keyword">select</span> n * i++;
</code></pre>
<p>حتی اگر افزایش <code>i</code> را با قفل ایمن کنیم، باز هم مشکل باقی می‌ماند چون <code>i</code> لزوماً با موقعیت عنصر ورودی تطابق ندارد.<br>
افزودن <code>AsOrdered</code> هم مشکل را حل نمی‌کند؛ چون فقط تضمین می‌کند خروجی به‌ترتیب عناصر پردازش‌شده باشد، نه اینکه واقعاً پردازش ترتیبی انجام شود.</p>
<p>✅ راه‌حل درست: استفاده از نسخه‌ی اندیس‌دار <code>Select</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> query = Enumerable.Range(<span class="hljs-number">0</span>,<span class="hljs-number">999</span>).AsParallel()
                      .Select((n, i) =&gt; n * i);
</code></pre>
<p>🔹 برای بهترین کارایی، متدهایی که در عملگرهای پرس‌وجو فراخوانی می‌شوند باید <strong>Thread-Safe</strong> باشند؛</p>
<ul>
<li>یا به‌دلیل نداشتن اثر جانبی (خالص بودن تابع)</li>
<li>یا اگر به‌وسیله‌ی قفل ایمن شده‌اند، باید بدانید که پتانسیل موازی‌سازی محدود به اثرات رقابت خواهد بود.</li>
</ul>
<hr>
<h3>⚙️ تنظیم درجه‌ی موازی‌سازی (Degree of Parallelism)</h3>
<p>به‌طور پیش‌فرض، PLINQ درجه‌ی موازی‌سازی بهینه برای پردازنده را انتخاب می‌کند.<br>
می‌توانید آن را با متد <code>WithDegreeOfParallelism</code> تغییر دهید:</p>
<pre class="hljs"><code>...AsParallel().WithDegreeOfParallelism(<span class="hljs-number">4</span>)...
</code></pre>
<p>🔹 نمونه: شاید بخواهید درجه‌ی موازی‌سازی را بالاتر از تعداد هسته‌ها افزایش دهید، وقتی کار <strong>I/O-Bound</strong> دارید (مثلاً دانلود هم‌زمان صفحات وب).<br>
بااین‌حال، <strong>Task combinators</strong> و <strong>توابع Asynchronous</strong> راه‌حل مشابه اما کارآمدتری ارائه می‌دهند.</p>
<p>🚫 برخلاف Tasks، PLINQ نمی‌تواند کارهای I/O-Bound را بدون مسدود کردن نخ‌ها انجام دهد (و این بدتر باعث قفل شدن نخ‌های pool می‌شود).</p>
<p>📍 توجه:<br>
<code>WithDegreeOfParallelism</code> را فقط <strong>یک‌بار</strong> می‌توان در یک پرس‌وجوی PLINQ فراخوانی کرد.<br>
اگر نیاز دارید دوباره صدا بزنید، باید پرس‌وجو را merge و دوباره partition کنید (با صدا زدن دوباره‌ی <code>AsParallel</code>).</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-string">&quot;The Quick Brown Fox&quot;</span>
    .AsParallel().WithDegreeOfParallelism(<span class="hljs-number">2</span>)
    .Where(c =&gt; !<span class="hljs-built_in">char</span>.IsWhiteSpace(c))
    .AsParallel().WithDegreeOfParallelism(<span class="hljs-number">3</span>)   <span class="hljs-comment">// Merge + Partition دوباره</span>
    .Select(c =&gt; <span class="hljs-built_in">char</span>.ToUpper(c));
</code></pre>
<hr>
<h3>⏹ لغو (Cancellation)</h3>
<p>لغو کردن یک پرس‌وجوی PLINQ که در حال مصرف نتایجش در <code>foreach</code> هستید ساده است:<br>
کافی است از حلقه خارج شوید (<code>break</code>) و پرس‌وجو به‌طور خودکار لغو می‌شود، چون enumerator به‌طور ضمنی Dispose می‌شود.</p>
<p>اما اگر پرس‌وجو با یک عملگر تبدیل، تک‌عنصر یا تجمیعی خاتمه یابد، باید آن را از یک نخ دیگر با <strong>CancellationToken</strong> لغو کنید.</p>
<p>برای درج توکن، بعد از <code>AsParallel</code> از <code>WithCancellation</code> استفاده کنید و خاصیت <code>Token</code> از یک <code>CancellationTokenSource</code> را پاس دهید.</p>
<p>مثال:</p>
<pre class="hljs"><code>IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; tenMillion = Enumerable.Range(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>_000_000);

<span class="hljs-keyword">var</span> cancelSource = <span class="hljs-keyword">new</span> CancellationTokenSource();
cancelSource.CancelAfter(<span class="hljs-number">100</span>);   <span class="hljs-comment">// لغو بعد از 100 میلی‌ثانیه</span>

<span class="hljs-keyword">var</span> primeNumberQuery =
    <span class="hljs-keyword">from</span> n <span class="hljs-keyword">in</span> tenMillion.AsParallel().WithCancellation(cancelSource.Token)
    <span class="hljs-keyword">where</span> Enumerable.Range(<span class="hljs-number">2</span>, (<span class="hljs-built_in">int</span>)Math.Sqrt(n)).All(i =&gt; n % i &gt; <span class="hljs-number">0</span>)
    <span class="hljs-keyword">select</span> n;

<span class="hljs-keyword">try</span>
{
    <span class="hljs-built_in">int</span>[] primes = primeNumberQuery.ToArray();
    <span class="hljs-comment">// هرگز به این خط نمی‌رسیم چون نخ دیگر ما را لغو می‌کند</span>
}
<span class="hljs-keyword">catch</span> (OperationCanceledException)
{
    Console.WriteLine(<span class="hljs-string">&quot;Query canceled&quot;</span>);
}
</code></pre>
<p>🔹 هنگام لغو، PLINQ منتظر می‌ماند هر نخ کاری روی عنصر جاری‌اش تمام کند، سپس پرس‌وجو پایان می‌یابد.<br>
این یعنی هر متد خارجی که پرس‌وجو فراخوانی کرده باشد، تا انتها اجرا خواهد شد.</p>
<h3>بهینه‌سازی PLINQ 🚀</h3>
<h4>بهینه‌سازی در سمت خروجی</h4>
<p>یکی از مزیت‌های <strong>PLINQ</strong> این است که نتایج پردازش موازی را به‌طور مرتب در یک دنباله‌ی خروجی واحد جمع‌آوری (collate) می‌کند.<br>
اما گاهی همه‌ی کاری که در نهایت انجام می‌دهید این است که روی هر عنصر فقط یک تابع را اجرا کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> n <span class="hljs-keyword">in</span> parallelQuery)
    DoSomething(n);
</code></pre>
<p>اگر چنین شرایطی داشته باشید—و برایتان مهم نباشد که عناصر به چه ترتیبی پردازش می‌شوند—می‌توانید با استفاده از متد <strong>ForAll</strong> در PLINQ کارایی را بهبود بدهید ✅.</p>
<hr>
<h4>متد ForAll</h4>
<p>متد <strong>ForAll</strong> یک delegate را روی هر عنصر خروجی یک <code>ParallelQuery</code> اجرا می‌کند. این متد مستقیماً به هسته‌ی داخلی PLINQ وصل می‌شود و مراحل جمع‌آوری و پیمایش نتایج (collating و enumerating) را دور می‌زند.</p>
<p>🔹 مثال ساده:</p>
<pre class="hljs"><code><span class="hljs-string">&quot;abcdef&quot;</span>
    .AsParallel()
    .Select(c =&gt; <span class="hljs-built_in">char</span>.ToUpper(c))
    .ForAll(Console.Write);
</code></pre>
<hr>
<p>📊 <strong>شکل 22-3</strong> این فرآیند را نشان می‌دهد.</p>
 <div align="center">
<p><img src="../../../assets/image/22/Table-22-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>بهینه‌سازی PLINQ 🚀</h3>
<h4>جمع‌آوری و پیمایش نتایج (Collating &amp; Enumerating)</h4>
<p>عملیات جمع‌آوری (collating) و پیمایش (enumerating) نتایج، ذاتاً <strong>خیلی پرهزینه نیستند</strong>.<br>
به همین دلیل، بهینه‌سازی با استفاده از متد <strong>ForAll</strong> بیشترین سود را زمانی به همراه دارد که:</p>
<ul>
<li>تعداد عناصر ورودی خیلی زیاد باشد 🔢</li>
<li>و هر عنصر به‌سرعت پردازش شود ⚡</li>
</ul>
<hr>
<h4>بهینه‌سازی در سمت ورودی (Input-side Optimization)</h4>
<p>برای اینکه داده‌ها را بین رشته‌ها (threads) تقسیم کند، <strong>PLINQ</strong> از <strong>سه استراتژی پارتیشن‌بندی (Partitioning Strategies)</strong> استفاده می‌کند:</p>
<ol>
<li>
<p><strong>Range Partitioning (پارتیشن‌بندی بازه‌ای)</strong></p>
<ul>
<li>برای دنباله‌های عددی یا داده‌های ایندکس‌دار مناسب است.</li>
<li>ورودی به بازه‌های پیوسته تقسیم می‌شود و هر بازه به یک thread اختصاص داده می‌شود.</li>
</ul>
</li>
<li>
<p><strong>Chunk Partitioning (پارتیشن‌بندی قطعه‌ای / تکه‌ای)</strong></p>
<ul>
<li>داده‌ها در قطعات (chunks) کوچک تقسیم می‌شوند.</li>
<li>این روش باعث بالانس بهتر بین threadها می‌شود، مخصوصاً وقتی زمان پردازش عناصر <strong>نامتوازن</strong> باشد.</li>
</ul>
</li>
<li>
<p><strong>Hash Partitioning (پارتیشن‌بندی هش)</strong></p>
<ul>
<li>با استفاده از یک <strong>کلید هش</strong>، عناصر به threadهای مختلف اختصاص داده می‌شوند.</li>
<li>برای سناریوهایی که داده‌ها ساختار خاصی دارند مفید است.</li>
</ul>
</li>
</ol>
 <div align="center">
<p><img src="../../../assets/image/22/Table-22-5.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>بهینه‌سازی PLINQ در پارتیشن‌بندی ⚡</h3>
<h4>عملگرهایی که نیاز به مقایسه دارند</h4>
<p>برای عملگرهای LINQ که نیازمند <strong>مقایسه عناصر</strong> هستند (مانند:<br>
<code>GroupBy</code>، <code>Join</code>، <code>GroupJoin</code>، <code>Intersect</code>، <code>Except</code>، <code>Union</code> و <code>Distinct</code>) ✅<br>
هیچ انتخابی وجود ندارد: <strong>PLINQ همیشه از Hash Partitioning استفاده می‌کند</strong>.</p>
<ul>
<li>در این حالت PLINQ باید از قبل <strong>hashcode</strong> همه عناصر را محاسبه کند تا اطمینان یابد عناصر با hashcode مشابه روی همان thread پردازش می‌شوند.</li>
<li>این روش می‌تواند نسبتاً <strong>کند</strong> باشد.</li>
<li>اگر سرعت برایتان مسئله‌ساز شد، تنها گزینه این است که با <strong>AsSequential</strong> موازی‌سازی را غیرفعال کنید.</li>
</ul>
<hr>
<h4>سایر عملگرهای کوئری</h4>
<p>برای دیگر عملگرها، شما می‌توانید انتخاب کنید بین:</p>
<ul>
<li><strong>Range Partitioning</strong> 🟦</li>
<li><strong>Chunk Partitioning</strong> 🟩</li>
</ul>
<p>به‌صورت پیش‌فرض:</p>
<ul>
<li>اگر دنباله ورودی <strong>ایندکس‌پذیر</strong> باشد (مثل آرایه‌ها یا چیزی که <code>IList&lt;T&gt;</code> پیاده‌سازی کرده)،<br>
➝ <strong>PLINQ از Range Partitioning استفاده می‌کند</strong>.</li>
<li>در غیر این صورت،<br>
➝ <strong>Chunk Partitioning انتخاب می‌شود</strong>.</li>
</ul>
<hr>
<h4>مقایسه کلی 🔍</h4>
<ul>
<li><strong>Range Partitioning</strong> → سریع‌تر است برای دنباله‌های طولانی که پردازش هر عنصر تقریباً <strong>یکسان</strong> زمان می‌برد.</li>
<li><strong>Chunk Partitioning</strong> → در سایر مواقع معمولاً سریع‌تر است، به‌ویژه وقتی پردازش عناصر <strong>نامتوازن</strong> باشد.</li>
</ul>
<hr>
<h4>اجبار به Range Partitioning</h4>
<ol>
<li>اگر کوئری با <code>Enumerable.Range</code> شروع می‌شود، آن را با <code>ParallelEnumerable.Range</code> جایگزین کنید.</li>
<li>در غیر این صورت، کافی است روی ورودی <code>ToList</code> یا <code>ToArray</code> صدا بزنید (البته این خودش هزینه‌ی کارایی دارد).</li>
</ol>
<p>📌 نکته مهم:<br>
<code>ParallelEnumerable.Range</code> فقط یک شورتکات برای <code>Enumerable.Range(...).AsParallel()</code> نیست؛ بلکه واقعاً باعث <strong>فعال شدن Range Partitioning</strong> می‌شود و رفتار کوئری را تغییر می‌دهد.</p>
<hr>
<h4>اجبار به Chunk Partitioning</h4>
<p>برای این کار باید دنباله ورودی را با <code>Partitioner.Create</code> (از فضای نام <code>System.Collections.Concurrent</code>) بپیچید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] numbers = { <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> };
<span class="hljs-keyword">var</span> parallelQuery =
    Partitioner.Create(numbers, <span class="hljs-literal">true</span>).AsParallel()
              .Where(...);
</code></pre>
<ul>
<li>آرگومان دوم (<code>true</code>) مشخص می‌کند که می‌خواهید <strong>load balancing</strong> فعال باشد، یعنی Chunk Partitioning استفاده شود.</li>
</ul>
<hr>
<h4>نحوه کار Chunk Partitioning ⚙️</h4>
<ul>
<li>
<p>هر thread به‌طور دوره‌ای چند عنصر (یک &quot;chunk&quot;) را برمی‌دارد.</p>
</li>
<li>
<p>در ابتدا chunkها خیلی کوچک هستند (۱ یا ۲ عنصر).</p>
</li>
<li>
<p>با پیشرفت کوئری، اندازه chunkها بیشتر می‌شود.</p>
</li>
<li>
<p>این روش باعث می‌شود:</p>
<ul>
<li>دنباله‌های کوچک به‌خوبی موازی شوند ✅</li>
<li>و دنباله‌های بزرگ باعث <strong>رفت‌وبرگشت بیش‌ازحد (round-tripping)</strong> نشوند.</li>
</ul>
</li>
<li>
<p>اگر یک thread عناصر &quot;ساده‌تر&quot; بگیرد، سریع‌تر آزاد می‌شود و chunks بیشتری پردازش می‌کند.</p>
</li>
<li>
<p>نتیجه → همه threads مشغول و <strong>متعادل</strong> می‌مانند.</p>
</li>
<li>
<p>تنها مشکل → نیاز به <strong>synchronization</strong> (مثل lock اختصاصی) برای دسترسی به دنباله ورودی است که می‌تواند کمی overhead ایجاد کند.</p>
</li>
</ul>
<hr>
<h4>نحوه کار Range Partitioning 🧮</h4>
<ul>
<li>در Range Partitioning، ورودی از همان ابتدا بین threads تقسیم می‌شود.</li>
<li>هر thread بخش <strong>ثابتی</strong> از داده را می‌گیرد → بدون نیاز به lock.</li>
<li>مشکل: اگر بعضی threads عناصر &quot;ساده‌تر&quot; بگیرند و زودتر تمام کنند، بقیه هنوز در حال کار خواهند بود → و این باعث idle شدن threadها می‌شود.</li>
</ul>
<p>📌 مثال: محاسبه اعداد اول با Range Partitioning ممکن است عملکرد ضعیفی داشته باشد.<br>
📌 اما محاسبه ریشه دوم ۱۰ میلیون عدد اول (که زمان پردازش هر عنصر یکسان است) بسیار خوب عمل می‌کند:</p>
<pre class="hljs"><code>ParallelEnumerable.Range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>_000_000).Sum(i =&gt; Math.Sqrt(i));
</code></pre>
 <div align="center">
<p><img src="../../../assets/image/22/Table-22-6.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>بهینه‌سازی Aggregation در PLINQ ⚙️</h3>
<h4>ParallelEnumerable.Range</h4>
<p>متد <code>ParallelEnumerable.Range</code> یک <code>ParallelQuery&lt;T&gt;</code> برمی‌گرداند، بنابراین نیازی به فراخوانی بعدی <strong>AsParallel</strong> نیست.</p>
<ul>
<li>پارتیشن‌بندی Range لزوماً عناصر را در بلوک‌های متوالی تخصیص نمی‌دهد؛ ممکن است از استراتژی <strong>Striping</strong> استفاده کند.</li>
<li>مثال: اگر دو worker داشته باشیم، یکی عناصر <strong>فرد</strong> و دیگری عناصر <strong>زوج</strong> را پردازش می‌کند.</li>
<li>عملگر <code>TakeWhile</code> تقریباً همیشه از این استراتژی استفاده می‌کند تا از پردازش اضافی عناصر در انتهای دنباله جلوگیری کند.</li>
</ul>
<hr>
<h4>بهینه‌سازی Aggregation سفارشی</h4>
<p>PLINQ عملگرهای استاندارد مانند <code>Sum</code>، <code>Average</code>، <code>Min</code> و <code>Max</code> را به‌صورت موازی و بهینه مدیریت می‌کند.<br>
اما <strong>Aggregate</strong> چالش‌های خاصی دارد.</p>
<p>مثال ساده از Aggregate (جمع کردن یک دنباله اعداد):</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] numbers = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
<span class="hljs-built_in">int</span> sum = numbers.Aggregate(<span class="hljs-number">0</span>, (total, n) =&gt; total + n); <span class="hljs-comment">// 6</span>
</code></pre>
<ul>
<li>برای <strong>aggregation بدون seed</strong>، delegate ارائه‌شده باید <strong>associative</strong> و <strong>commutative</strong> باشد.</li>
<li>اگر این قانون رعایت نشود، PLINQ ممکن است نتایج اشتباه بدهد، زیرا چند seed از دنباله برای جمع‌بندی چند پارتیشن استفاده می‌کند.</li>
</ul>
<hr>
<h4>Aggregate با seed چندگانه</h4>
<ul>
<li>
<p>Aggregate با seed صریح معمولاً به‌صورت <strong>سریالی</strong> اجرا می‌شود زیرا فقط یک seed دارد.</p>
</li>
<li>
<p>PLINQ یک overload خاص ارائه می‌دهد که <strong>seed factory</strong> می‌گیرد.</p>
<ul>
<li>برای هر thread، این تابع یک seed محلی ایجاد می‌کند → <strong>accumulator محلی</strong></li>
<li>سپس مقادیر محلی با accumulator اصلی ترکیب می‌شوند.</li>
</ul>
</li>
<li>
<p>این overload همچنین یک delegate برای <strong>تبدیل نهایی</strong> نتایج می‌گیرد.</p>
</li>
</ul>
<p>چهار delegate به ترتیب:</p>
<ol>
<li><code>seedFactory</code> → ایجاد accumulator محلی</li>
<li><code>updateAccumulatorFunc</code> → اضافه کردن یک عنصر به accumulator محلی</li>
<li><code>combineAccumulatorFunc</code> → ترکیب accumulator محلی با اصلی</li>
<li><code>resultSelector</code> → تبدیل نهایی نتیجه</li>
</ol>
<p>مثال ساده جمع اعداد با PLINQ:</p>
<pre class="hljs"><code>numbers.AsParallel().Aggregate(
    () =&gt; <span class="hljs-number">0</span>,                           <span class="hljs-comment">// seedFactory</span>
    (localTotal, n) =&gt; localTotal + n, <span class="hljs-comment">// updateAccumulatorFunc</span>
    (mainTot, localTot) =&gt; mainTot + localTot, <span class="hljs-comment">// combineAccumulatorFunc</span>
    finalResult =&gt; finalResult          <span class="hljs-comment">// resultSelector</span>
);
</code></pre>
<hr>
<h4>مثال واقعی‌تر: شمارش فرکانس حروف در متن</h4>
<p>متن:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> text = <span class="hljs-string">&quot;Let’s suppose this is a really long string&quot;</span>;
<span class="hljs-keyword">var</span> letterFrequencies = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">26</span>];
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> text)
{
    <span class="hljs-built_in">int</span> index = <span class="hljs-built_in">char</span>.ToUpper(c) - <span class="hljs-string">&#x27;A&#x27;</span>;
    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; <span class="hljs-number">26</span>) letterFrequencies[index]++;
}
</code></pre>
<ul>
<li>برای متن‌های طولانی (مثل <strong>gene sequencing</strong>) این روش می‌تواند زمان‌بر باشد.</li>
<li>موازی‌سازی با <code>Parallel.ForEach</code> نیازمند مدیریت همزمانی روی آرایه مشترک است، و قفل کردن می‌تواند <strong>پتانسیل موازی‌سازی</strong> را از بین ببرد.</li>
</ul>
<p>PLINQ با Aggregate راه‌حل تمیزی ارائه می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] result = text.AsParallel().Aggregate(
    () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">26</span>],               <span class="hljs-comment">// accumulator محلی</span>
    (localFrequencies, c) =&gt;        <span class="hljs-comment">// جمع‌بندی در accumulator محلی</span>
    {
        <span class="hljs-built_in">int</span> index = <span class="hljs-built_in">char</span>.ToUpper(c) - <span class="hljs-string">&#x27;A&#x27;</span>;
        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; <span class="hljs-number">26</span>) localFrequencies[index]++;
        <span class="hljs-keyword">return</span> localFrequencies;
    },
    (mainFreq, localFreq) =&gt;         <span class="hljs-comment">// ترکیب local -&gt; main</span>
        mainFreq.Zip(localFreq, (f1, f2) =&gt; f1 + f2).ToArray(),
    finalResult =&gt; finalResult        <span class="hljs-comment">// تبدیل نهایی</span>
);
</code></pre>
<ul>
<li>توجه: تابع محلی <code>localFrequencies</code> عناصر را تغییر می‌دهد.</li>
<li>این بهینه‌سازی امکان‌پذیر است چون هر accumulator محلی <strong>مختص هر thread</strong> است.</li>
</ul>
<h3>کلاس Parallel 🟢</h3>
<p>کتابخانه PFX یک شکل پایه از <strong>Structured Parallelism</strong> ارائه می‌دهد که از طریق سه متد <strong>static</strong> در کلاس <code>Parallel</code> قابل استفاده است:</p>
<ul>
<li>
<p><code>Parallel.Invoke</code><br>
اجرای یک آرایه از delegateها به‌صورت موازی</p>
</li>
<li>
<p><code>Parallel.For</code><br>
معادل موازی حلقه <code>for</code> در C#</p>
</li>
<li>
<p><code>Parallel.ForEach</code><br>
معادل موازی حلقه <code>foreach</code> در C#</p>
</li>
</ul>
<blockquote>
<p>هر سه متد تا تکمیل همه‌ی کارها، بلاک می‌شوند. مشابه PLINQ، در صورت بروز <strong>exception</strong> که مدیریت نشده باشد، سایر workerها بعد از اتمام iteration فعلی متوقف می‌شوند و exceptionها به caller برمی‌گردند—که در یک <code>AggregateException</code> بسته‌بندی شده‌اند.</p>
</blockquote>
<hr>
<h4>Parallel.Invoke</h4>
<p><code>Parallel.Invoke</code> یک آرایه از delegateهای <strong>Action</strong> را موازی اجرا کرده و منتظر اتمام آن‌ها می‌ماند. ساده‌ترین امضای متد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Invoke</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> Action[] actions</span>)</span>;
</code></pre>
<ul>
<li>مشابه PLINQ، متدهای <code>Parallel.*</code> برای کارهای <strong>compute-bound</strong> بهینه شده‌اند، نه I/O-bound.</li>
<li>مثال ساده با دانلود دو صفحه وب به صورت موازی:</li>
</ul>
<pre class="hljs"><code>Parallel.Invoke(
    () =&gt; <span class="hljs-keyword">new</span> WebClient().DownloadFile(<span class="hljs-string">&quot;http://www.linqpad.net&quot;</span>, <span class="hljs-string">&quot;lp.html&quot;</span>),
    () =&gt; <span class="hljs-keyword">new</span> WebClient().DownloadFile(<span class="hljs-string">&quot;http://microsoft.com&quot;</span>, <span class="hljs-string">&quot;ms.html&quot;</span>)
);
</code></pre>
<p><strong>نکته مهم:</strong><br>
<code>Parallel.Invoke</code> حتی با یک میلیون delegate هم به‌صورت مؤثر کار می‌کند، زیرا عناصر را به <strong>batch</strong> تقسیم می‌کند و به چند Task اصلی اختصاص می‌دهد، به جای ایجاد یک Task برای هر delegate.</p>
<blockquote>
<p>مسئولیت collating نتایج بر عهده شماست؛ بنابراین باید به <strong>Thread Safety</strong> توجه کنید:</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">var</span> data = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();
Parallel.Invoke(
    () =&gt; data.Add(<span class="hljs-keyword">new</span> WebClient().DownloadString(<span class="hljs-string">&quot;http://www.foo.com&quot;</span>)),
    () =&gt; data.Add(<span class="hljs-keyword">new</span> WebClient().DownloadString(<span class="hljs-string">&quot;http://www.far.com&quot;</span>))
);
</code></pre>
<ul>
<li>برای حل مشکل thread-unsafe، می‌توان از <strong>locking</strong> استفاده کرد، اما این کار در آرایه‌های بزرگ delegate باعث <strong>bottleneck</strong> می‌شود.</li>
<li>راه بهتر: استفاده از <strong>Thread-Safe Collections</strong>، مانند <code>ConcurrentBag</code>.</li>
</ul>
<p>همچنین <code>Parallel.Invoke</code> یک overload دارد که <strong>ParallelOptions</strong> می‌گیرد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Invoke</span>(<span class="hljs-params">ParallelOptions options, <span class="hljs-keyword">params</span> Action[] actions</span>)</span>;
</code></pre>
<ul>
<li>با <code>ParallelOptions</code> می‌توان <strong>CancellationToken</strong> وارد کرد، حداکثر concurrency را محدود کرد، یا یک <strong>task scheduler</strong> سفارشی مشخص کرد.</li>
</ul>
<hr>
<h4>Parallel.For و Parallel.ForEach</h4>
<p>این متدها معادل موازی حلقه‌های <code>for</code> و <code>foreach</code> هستند، به این معنا که هر iteration به‌صورت موازی اجرا می‌شود.</p>
<p>ساده‌ترین امضاها:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ParallelLoopResult <span class="hljs-title">For</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> fromInclusive, <span class="hljs-built_in">int</span> toExclusive, Action&lt;<span class="hljs-built_in">int</span>&gt; body</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ParallelLoopResult <span class="hljs-title">ForEach</span>&lt;<span class="hljs-title">TSource</span>&gt;(<span class="hljs-params">IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body</span>)</span>;
</code></pre>
<p>مثال:</p>
<p>حلقه <code>for</code> معمولی:</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
    Foo(i);
</code></pre>
<p>معادل موازی:</p>
<pre class="hljs"><code>Parallel.For(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, i =&gt; Foo(i));
<span class="hljs-comment">// یا ساده‌تر</span>
Parallel.For(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, Foo);
</code></pre>
<p>حلقه <code>foreach</code> معمولی:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Hello, world&quot;</span>)
    Foo(c);
</code></pre>
<p>معادل موازی:</p>
<pre class="hljs"><code>Parallel.ForEach(<span class="hljs-string">&quot;Hello, world&quot;</span>, Foo);
</code></pre>
<p>مثال عملی با رمزنگاری (<code>System.Security.Cryptography</code>):</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> keyPairs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">6</span>];
Parallel.For(<span class="hljs-number">0</span>, keyPairs.Length,
    i =&gt; keyPairs[i] = RSA.Create().ToXmlString(<span class="hljs-literal">true</span>));
</code></pre>
<ul>
<li>مشابه <code>Parallel.Invoke</code>، می‌توان تعداد زیادی work item به <code>Parallel.For</code> و <code>Parallel.ForEach</code> داد و آن‌ها به‌صورت مؤثر روی چند Task تقسیم می‌شوند.</li>
<li>همان کار را می‌توان با PLINQ انجام داد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">string</span>[] keyPairs = ParallelEnumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)
    .Select(i =&gt; RSA.Create().ToXmlString(<span class="hljs-literal">true</span>))
    .ToArray();
</code></pre>
<hr>
<h4>حلقه‌های داخلی و خارجی</h4>
<ul>
<li><code>Parallel.For</code> و <code>Parallel.ForEach</code> معمولاً روی <strong>حلقه‌های خارجی</strong> بهتر عمل می‌کنند، زیرا chunkهای بزرگتری برای موازی‌سازی ارائه می‌دهند و overhead مدیریت کمتر می‌شود.</li>
<li>موازی‌سازی هر دو حلقه داخلی و خارجی معمولاً غیرضروری است.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code>Parallel.For(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, i =&gt;
{
    Parallel.For(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>, j =&gt; Foo(i, j));   <span class="hljs-comment">// حلقه داخلی: معمولاً sequential بهتر است</span>
});
</code></pre>
<h3>Parallel.ForEach با اندیس و مدیریت توقف حلقه 🟢</h3>
<p>گاهی اوقات در <strong>حلقه‌های موازی</strong> لازم است که <strong>اندیس iteration</strong> را بدانیم.</p>
<h4>اندیس در حلقه‌های موازی</h4>
<p>در حلقه sequential معمولی:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Hello, world&quot;</span>)
    Console.WriteLine(c.ToString() + i++);
</code></pre>
<p>اما در محیط موازی، <strong>افزایش یک متغیر مشترک thread-safe نیست</strong>.<br>
راه حل: استفاده از overload ای از <code>Parallel.ForEach</code> که اندیس loop را ارائه می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ParallelLoopResult <span class="hljs-title">ForEach</span>&lt;<span class="hljs-title">TSource</span>&gt;(<span class="hljs-params">
    IEnumerable&lt;TSource&gt; source, Action&lt;TSource, ParallelLoopState, <span class="hljs-built_in">long</span>&gt; body</span>)
</span></code></pre>
<ul>
<li>پارامتر سوم از نوع <code>long</code> اندیس هر عنصر را نشان می‌دهد.</li>
<li>مثال:</li>
</ul>
<pre class="hljs"><code>Parallel.ForEach(<span class="hljs-string">&quot;Hello, world&quot;</span>, (c, state, i) =&gt;
{
    Console.WriteLine(c.ToString() + i);
});
</code></pre>
<hr>
<h4>مثال عملی: Spellchecker موازی</h4>
<pre class="hljs"><code><span class="hljs-keyword">var</span> wordLookup = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">string</span>&gt;(
    File.ReadAllLines(<span class="hljs-string">&quot;WordLookup.txt&quot;</span>),
    StringComparer.InvariantCultureIgnoreCase
);

<span class="hljs-keyword">var</span> random = <span class="hljs-keyword">new</span> Random();
<span class="hljs-built_in">string</span>[] wordList = wordLookup.ToArray();
<span class="hljs-built_in">string</span>[] wordsToTest = Enumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">1000000</span>)
    .Select(i =&gt; wordList[random.Next(<span class="hljs-number">0</span>, wordList.Length)])
    .ToArray();

wordsToTest[<span class="hljs-number">12345</span>] = <span class="hljs-string">&quot;woozsh&quot;</span>;
wordsToTest[<span class="hljs-number">23456</span>] = <span class="hljs-string">&quot;wubsie&quot;</span>;

<span class="hljs-keyword">var</span> misspellings = <span class="hljs-keyword">new</span> ConcurrentBag&lt;Tuple&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">string</span>&gt;&gt;();

Parallel.ForEach(wordsToTest, (word, state, i) =&gt;
{
    <span class="hljs-keyword">if</span> (!wordLookup.Contains(word))
        misspellings.Add(Tuple.Create((<span class="hljs-built_in">int</span>)i, word));
});
</code></pre>
<blockquote>
<p>نکته: باید نتایج را در یک <strong>collection ایمن برای Thread</strong> جمع‌آوری کنید.<br>
مزیت استفاده از indexed <code>ForEach</code> نسبت به PLINQ: اجرای <strong>مستقیم بدون اعمال Select با اندیس</strong> که کارایی بیشتری دارد.</p>
</blockquote>
<hr>
<h4>ParallelLoopState: توقف زودهنگام حلقه</h4>
<p>در حلقه موازی نمی‌توان از <code>break</code> معمولی استفاده کرد.<br>
باید از متدهای <code>Break()</code> یا <code>Stop()</code> در شی <code>ParallelLoopState</code> استفاده کنید.</p>
<pre class="hljs"><code>Parallel.ForEach(<span class="hljs-string">&quot;Hello, world&quot;</span>, (c, loopState) =&gt;
{
    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;,&#x27;</span>)
        loopState.Break();  <span class="hljs-comment">// پایان حلقه بعد از iteration جاری</span>
    <span class="hljs-keyword">else</span>
        Console.Write(c);
});
</code></pre>
<p><strong>تفاوت Break و Stop:</strong></p>
<ul>
<li><code>Break()</code> → حلقه بعد از iteration فعلی پایان می‌یابد، حداقل عناصر قبل از توقف اجرا می‌شوند.</li>
<li><code>Stop()</code> → حلقه بلافاصله برای تمام threadها پایان می‌یابد، ممکن است تنها زیرمجموعه‌ای از عناصر پردازش شوند.</li>
</ul>
<hr>
<h4>ParallelLoopResult</h4>
<p>متدهای <code>Parallel.For</code> و <code>Parallel.ForEach</code> یک <strong>ParallelLoopResult</strong> بازمی‌گردانند:</p>
<ul>
<li><code>IsCompleted</code> → آیا حلقه تا انتها اجرا شده؟</li>
<li><code>LowestBreakIteration</code> → اندیس iteration که حلقه با <code>Break()</code> پایان یافته است (اگر <code>Stop()</code> باشد، null برمی‌گرداند).</li>
</ul>
<hr>
<h4>مدیریت طول حلقه و توقف جزئی</h4>
<ul>
<li>اگر بدنه حلقه طولانی است، می‌توان در نقاط مختلف کد، <strong>poll</strong> روی <code>ShouldExitCurrentIteration</code> انجام داد.</li>
<li>این property بلافاصله بعد از <code>Stop()</code> یا کمی بعد از <code>Break()</code> درست می‌شود.</li>
<li>همچنین بعد از درخواست <strong>cancellation</strong> یا رخداد <strong>exception</strong> در حلقه، <code>ShouldExitCurrentIteration</code> برابر true می‌شود.</li>
<li><code>IsExceptional</code> → اطلاع از بروز exception در سایر threadها.</li>
</ul>
<blockquote>
<p>نکته: هر exception مدیریت نشده باعث توقف حلقه بعد از iteration جاری هر thread می‌شود؛ برای جلوگیری از این کار، باید <strong>exceptionها را مدیریت کنید</strong>.</p>
</blockquote>
<h3>بهینه‌سازی با مقادیر محلی در Parallel.For / Parallel.ForEach 🟢</h3>
<p>گاهی حلقه‌های موازی نیاز به <strong>جمع‌آوری داده‌ها در حین iteration</strong> دارند، مخصوصاً وقتی تعداد تکرارها زیاد است.</p>
<hr>
<h4>مشکل نمونه: جمع زدن ریشه دوم ۱۰ میلیون عدد</h4>
<pre class="hljs"><code><span class="hljs-built_in">object</span> locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();
<span class="hljs-built_in">double</span> total = <span class="hljs-number">0</span>;

Parallel.For(<span class="hljs-number">1</span>, <span class="hljs-number">10000000</span>, i =&gt;
{
    <span class="hljs-keyword">lock</span> (locker)
        total += Math.Sqrt(i);
});
</code></pre>
<ul>
<li>هر iteration نیاز به <strong>lock</strong> دارد.</li>
<li>۱۰ میلیون lock باعث <strong>افت شدید کارایی</strong> می‌شود.</li>
</ul>
<p><strong>تشبیه:</strong><br>
فرض کنید ۱۰ نفر زباله جمع می‌کنند و همه یک سطل مشترک دارند؛ زمان تلف شده برای صف‌بندی و contention بسیار زیاد است.</p>
<hr>
<h4>راه حل: <strong>Local Value</strong> (مقدار محلی)</h4>
<ul>
<li>هر thread یک <strong>مقدار محلی</strong> دارد (مثل سطل زباله خصوصی).</li>
<li>در پایان iteration‌ها، مقادیر محلی به مقدار اصلی اضافه می‌شوند.</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">object</span> locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();
<span class="hljs-built_in">double</span> grandTotal = <span class="hljs-number">0</span>;

Parallel.For(
    <span class="hljs-number">1</span>, <span class="hljs-number">10000000</span>,
    () =&gt; <span class="hljs-number">0.0</span>,  <span class="hljs-comment">// مقدار محلی جدید برای هر thread</span>
    (i, state, localTotal) =&gt; localTotal + Math.Sqrt(i),  <span class="hljs-comment">// بدنه حلقه: جمع به local</span>
    localTotal =&gt; { <span class="hljs-keyword">lock</span> (locker) grandTotal += localTotal; }  <span class="hljs-comment">// جمع local به مقدار اصلی</span>
);
</code></pre>
<ul>
<li>تنها lock با مقدار محلی انجام می‌شود، نه برای هر iteration.</li>
<li><strong>کارایی بسیار بهتر از نسخه قبل</strong>.</li>
</ul>
<hr>
<h4>نکته</h4>
<ul>
<li><strong>PLINQ</strong> اغلب جایگزین مناسبی است:</li>
</ul>
<pre class="hljs"><code>ParallelEnumerable.Range(<span class="hljs-number">1</span>, <span class="hljs-number">10000000</span>)
                  .Sum(i =&gt; Math.Sqrt(i));
</code></pre>
<ul>
<li>استفاده از <code>ParallelEnumerable.Range</code> باعث <strong>range partitioning</strong> می‌شود، که برای توالی‌های با زمان پردازش برابر بسیار بهینه است.</li>
<li>برای الگوریتم‌های پیچیده‌تر، می‌توان از LINQ’s <code>Aggregate</code> با seed factory محلی استفاده کرد که مشابه همین مفهوم Local Value در Parallel.For عمل می‌کند.</li>
</ul>
<hr>
<h4>جمع‌بندی</h4>
<ul>
<li>نسخه‌های <code>TLocal</code> در <code>Parallel.For</code> و <code>Parallel.ForEach</code> برای <strong>بهینه‌سازی جمع‌آوری داده‌ها در حلقه‌های بزرگ و پرتکرار</strong> طراحی شده‌اند.</li>
<li>این روش باعث کاهش contention و overhead مربوط به lockها می‌شود.</li>
</ul>
 <div align="center">
<p><img src="../../../assets/image/22/Table-22-7.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>Task Parallelism پیشرفته در PFX ⚡</h3>
<p>این بخش به <strong>ویژگی‌های پیشرفته Task Parallel Library (TPL)</strong> می‌پردازد که به برنامه‌نویسی موازی کمک می‌کنند:</p>
<ul>
<li><strong>تنظیم برنامه‌ریزی (scheduling)</strong> task</li>
<li><strong>ایجاد رابطه والد/فرزند</strong> بین taskها</li>
<li><strong>استفاده پیشرفته از Continuations</strong></li>
<li><strong>TaskFactory</strong></li>
</ul>
<hr>
<h4>کار با تعداد زیاد taskها</h4>
<ul>
<li>TPL اجازه می‌دهد صدها یا هزاران task با overhead کم ایجاد کنید.</li>
<li>برای میلیون‌ها task، باید آن‌ها را به واحدهای کاری بزرگ‌تر تقسیم کنید.</li>
<li><code>Parallel</code> و <code>PLINQ</code> این کار را به صورت خودکار انجام می‌دهند.</li>
</ul>
<hr>
<h4>ایجاد و شروع task</h4>
<ul>
<li><code>Task.Run</code> یک task یا <code>Task&lt;TResult&gt;</code> ایجاد و اجرا می‌کند.</li>
<li>Shortcut برای <code>Task.Factory.StartNew</code> که <strong>گزینه‌های بیشتری</strong> برای کنترل دارد.</li>
</ul>
<h5>مثال: ارسال state به task</h5>
<pre class="hljs"><code><span class="hljs-keyword">var</span> task = Task.Factory.StartNew(Greet, <span class="hljs-string">&quot;Hello&quot;</span>);
task.Wait();  <span class="hljs-comment">// منتظر تکمیل task</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greet</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> state</span>)</span> { Console.Write(state); }  <span class="hljs-comment">// خروجی: Hello</span>
</code></pre>
<ul>
<li>همچنین می‌توان <strong>نام معنی‌دار</strong> برای task اختصاص داد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> task = Task.Factory.StartNew(state =&gt; Greet(<span class="hljs-string">&quot;Hello&quot;</span>), <span class="hljs-string">&quot;Greeting&quot;</span>);
Console.WriteLine(task.AsyncState);  <span class="hljs-comment">// Greeting</span>
task.Wait();
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Greet</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span> { Console.Write(message); }
</code></pre>
<hr>
<h4>TaskCreationOptions</h4>
<p>با این enum می‌توان <strong>رفتار اجرای task را تنظیم کرد</strong>:</p>
<ul>
<li><strong>LongRunning</strong> → اختصاص یک thread ویژه به task (برای taskهای I/O یا طولانی مفید).</li>
<li><strong>PreferFairness</strong> → تلاش برای اجرای taskها به ترتیب ایجاد.</li>
<li><strong>AttachedToParent</strong> → ایجاد task به عنوان child یک task دیگر.</li>
</ul>
<hr>
<h4>Child Tasks</h4>
<ul>
<li>وقتی یک task دیگری را ایجاد می‌کند، می‌توان رابطه والد/فرزند ایجاد کرد.</li>
<li>مثال:</li>
</ul>
<pre class="hljs"><code>Task parent = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine(<span class="hljs-string">&quot;I am a parent&quot;</span>);
    Task.Factory.StartNew(() =&gt; Console.WriteLine(<span class="hljs-string">&quot;I am detached&quot;</span>));  <span class="hljs-comment">// Detached</span>
    Task.Factory.StartNew(() =&gt; Console.WriteLine(<span class="hljs-string">&quot;I am a child&quot;</span>), TaskCreationOptions.AttachedToParent);
});
</code></pre>
<ul>
<li><strong>ویژگی مهم:</strong> هنگام <code>Wait</code> روی parent، taskهای child هم منتظر می‌مانند و <strong>استثناهای child به parent منتقل می‌شوند</strong>.</li>
</ul>
<pre class="hljs"><code>TaskCreationOptions atp = TaskCreationOptions.AttachedToParent;
<span class="hljs-keyword">var</span> parent = Task.Factory.StartNew(() =&gt;
{
    Task.Factory.StartNew(() =&gt; 
        Task.Factory.StartNew(() =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-literal">null</span>; }, atp), atp);
});

parent.Wait();  <span class="hljs-comment">// NullReferenceException wrapped در AggregateException</span>
</code></pre>
<hr>
<h4>انتظار برای چند task</h4>
<ul>
<li>
<p><strong>Task.WaitAll</strong> → منتظر تمام taskها می‌ماند.</p>
</li>
<li>
<p><strong>Task.WaitAny</strong> → منتظر اولین task تکمیل‌شده می‌ماند.</p>
</li>
<li>
<p><code>WaitAll</code> بهینه‌تر از انتظار یکی‌یکی است و AggregateException را برای همه taskهای خطادار تولید می‌کند.</p>
</li>
<li>
<p>همچنین می‌توان <strong>timeout</strong> و <strong>cancellation token</strong> به <code>Wait</code> داد:</p>
<ul>
<li>این باعث لغو انتظار می‌شود، نه خود task.</li>
</ul>
</li>
</ul>
<h3>لغو و ادامه Taskها در TPL ⏹️➡️➡️</h3>
<h4>لغو Task با CancellationToken</h4>
<ul>
<li>هنگام شروع یک task می‌توانید یک <strong>cancellation token</strong> به آن بدهید.</li>
<li>اگر با <code>Cancel</code> روی token فراخوانی شود، task وارد حالت <strong>Canceled</strong> می‌شود.</li>
</ul>
<h5>مثال</h5>
<pre class="hljs"><code><span class="hljs-keyword">var</span> cts = <span class="hljs-keyword">new</span> CancellationTokenSource();
CancellationToken token = cts.Token;
cts.CancelAfter(<span class="hljs-number">500</span>);  <span class="hljs-comment">// لغو خودکار پس از 500ms</span>

Task task = Task.Factory.StartNew(() =&gt;
{
    Thread.Sleep(<span class="hljs-number">1000</span>);
    token.ThrowIfCancellationRequested(); <span class="hljs-comment">// بررسی لغو</span>
}, token);

<span class="hljs-keyword">try</span> { task.Wait(); }
<span class="hljs-keyword">catch</span> (AggregateException ex)
{
    Console.WriteLine(ex.InnerException <span class="hljs-keyword">is</span> TaskCanceledException); <span class="hljs-comment">// True</span>
    Console.WriteLine(task.IsCanceled);                             <span class="hljs-comment">// True</span>
    Console.WriteLine(task.Status);                                 <span class="hljs-comment">// Canceled</span>
}
</code></pre>
<ul>
<li><code>TaskCanceledException</code> از <code>OperationCanceledException</code> مشتق شده است.</li>
<li>اگر بخواهید خودتان یک <code>OperationCanceledException</code> پرتاب کنید، <strong>حتماً token را به سازنده بدهید</strong> تا وضعیت task به Canceled تغییر کند و continuations با <code>OnlyOnCanceled</code> اجرا شوند.</li>
<li>اگر task قبل از شروع لغو شود، <strong>فوری یک OperationCanceledException</strong> تولید می‌شود و task برنامه‌ریزی نمی‌شود.</li>
</ul>
<hr>
<h4>انتشار لغو به سایر APIها</h4>
<ul>
<li>بسیاری از APIها مانند PLINQ از cancellation token پشتیبانی می‌کنند.</li>
<li>مثال:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> cancelSource = <span class="hljs-keyword">new</span> CancellationTokenSource();
CancellationToken token = cancelSource.Token;

Task task = Task.Factory.StartNew(() =&gt;
{
    <span class="hljs-keyword">var</span> query = someSequence.AsParallel().WithCancellation(token);
    <span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> query) { ... }
});
</code></pre>
<ul>
<li>فراخوانی <code>cancelSource.Cancel()</code> → لغو query و task.</li>
</ul>
<hr>
<h4>Continuations (ادامه taskها) 🔗</h4>
<ul>
<li><code>ContinueWith</code> یک delegate را <strong>بلافاصله بعد از پایان یک task</strong> اجرا می‌کند.</li>
<li>مثال ساده:</li>
</ul>
<pre class="hljs"><code>Task task1 = Task.Factory.StartNew(() =&gt; Console.Write(<span class="hljs-string">&quot;antecedent..&quot;</span>));
Task task2 = task1.ContinueWith(ant =&gt; Console.Write(<span class="hljs-string">&quot;..continuation&quot;</span>));
</code></pre>
<ul>
<li><code>ant</code> → ارجاع به task اصلی.</li>
<li><code>ContinueWith</code> خود task جدیدی برمی‌گرداند و می‌توان <strong>چند continuation زنجیره‌ای</strong> ایجاد کرد.</li>
</ul>
<h5>اجرای Continuation روی همان thread</h5>
<pre class="hljs"><code>task1.ContinueWith(ant =&gt; ..., TaskContinuationOptions.ExecuteSynchronously);
</code></pre>
<hr>
<h4>Continuations با Task<TResult></h4>
<ul>
<li>Continuation می‌تواند <strong>مقدار بازگرداند</strong> و داده‌ها را پردازش کند:</li>
</ul>
<pre class="hljs"><code>Task.Factory.StartNew&lt;<span class="hljs-built_in">int</span>&gt;(() =&gt; <span class="hljs-number">8</span>)
    .ContinueWith(ant =&gt; ant.Result * <span class="hljs-number">2</span>)
    .ContinueWith(ant =&gt; Math.Sqrt(ant.Result))
    .ContinueWith(ant =&gt; Console.WriteLine(ant.Result));  <span class="hljs-comment">// 4</span>
</code></pre>
<hr>
<h4>Continuations و Exception</h4>
<ul>
<li>Continuation می‌تواند بررسی کند آیا antecedent خطا داده (<code>ant.Exception</code>) یا از <code>Result/Wait</code> استفاده کند.</li>
<li>اگر continuation exception را نبیند، <strong>UnobservedTaskException</strong> رخ می‌دهد.</li>
<li>الگوی ایمن:</li>
</ul>
<pre class="hljs"><code>Task continuation = Task.Factory.StartNew(() =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-literal">null</span>; })
    .ContinueWith(ant =&gt; { ant.Wait(); <span class="hljs-comment">/* ادامه پردازش */</span> });
continuation.Wait();  <span class="hljs-comment">// exception پرتاب می‌شود</span>
</code></pre>
<ul>
<li>می‌توان continuations مختلف برای <strong>موارد خطا و غیرخطا</strong> تعریف کرد:</li>
</ul>
<pre class="hljs"><code>Task task1 = Task.Factory.StartNew(() =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-literal">null</span>; });
Task error = task1.ContinueWith(ant =&gt; Console.Write(ant.Exception),
                                TaskContinuationOptions.OnlyOnFaulted);
Task ok = task1.ContinueWith(ant =&gt; Console.Write(<span class="hljs-string">&quot;Success!&quot;</span>),
                             TaskContinuationOptions.NotOnFaulted);
</code></pre>
<ul>
<li>برای صرف نظر از استثناها:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IgnoreExceptions</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Task task</span>)</span>
{
    task.ContinueWith(t =&gt; { <span class="hljs-keyword">var</span> ignore = t.Exception; },
                      TaskContinuationOptions.OnlyOnFaulted);
}

Task.Factory.StartNew(() =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-literal">null</span>; }).IgnoreExceptions();
</code></pre>
<hr>
<h4>Continuations و Child Tasks 👶</h4>
<ul>
<li>Continuation <strong>تنها زمانی اجرا می‌شود که تمام child taskها کامل شوند</strong>.</li>
<li>استثناهای childها به continuation منتقل می‌شوند:</li>
</ul>
<pre class="hljs"><code>TaskCreationOptions atp = TaskCreationOptions.AttachedToParent;

Task.Factory.StartNew(() =&gt;
{
    Task.Factory.StartNew(() =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-literal">null</span>; }, atp);
    Task.Factory.StartNew(() =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-literal">null</span>; }, atp);
    Task.Factory.StartNew(() =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-literal">null</span>; }, atp);
})
.ContinueWith(p =&gt; Console.WriteLine(p.Exception),
              TaskContinuationOptions.OnlyOnFaulted);
</code></pre>
<ul>
<li>این امکان را می‌دهد که <strong>چند خطای همزمان را یکجا مدیریت</strong> کنید.</li>
</ul>
 <div align="center">
<p><img src="../../../assets/image/22/Table-22-8.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>ادامه‌های شرطی در Taskها (Conditional Continuations) ⚡</h3>
<ul>
<li>به طور پیش‌فرض، یک <strong>continuation</strong> بدون شرط برنامه‌ریزی می‌شود، چه task اصلی (antecedent) موفق باشد، چه خطا دهد یا لغو شود.</li>
<li>می‌توان رفتار اجرای continuation را با <strong>TaskContinuationOptions</strong> تغییر داد.</li>
</ul>
<h4>سه فلگ اصلی</h4>
<table>
<thead>
<tr>
<th>فلگ</th>
<th>توضیح</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NotOnRanToCompletion</code></td>
<td>اجرا نشود اگر antecedent با موفقیت کامل شد</td>
</tr>
<tr>
<td><code>NotOnFaulted</code></td>
<td>اجرا نشود اگر antecedent خطا داد</td>
</tr>
<tr>
<td><code>NotOnCanceled</code></td>
<td>اجرا نشود اگر antecedent لغو شد</td>
</tr>
</tbody>
</table>
<ul>
<li>این فلگ‌ها <strong>حذف‌کننده</strong> هستند: هر چه بیشتر اعمال کنید، احتمال اجرای continuation کمتر می‌شود.</li>
</ul>
<h4>مقادیر ترکیبی رایج</h4>
<table>
<thead>
<tr>
<th>مقدار</th>
<th>ترکیب فلگ‌ها</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OnlyOnRanToCompletion</code></td>
<td>`NotOnFaulted</td>
<td>NotOnCanceled`</td>
</tr>
<tr>
<td><code>OnlyOnFaulted</code></td>
<td>`NotOnRanToCompletion</td>
<td>NotOnCanceled`</td>
</tr>
<tr>
<td><code>OnlyOnCanceled</code></td>
<td>`NotOnRanToCompletion</td>
<td>NotOnFaulted`</td>
</tr>
</tbody>
</table>
<ul>
<li>ترکیب همه‌ی Not*‌ها منطقی نیست، زیرا منجر به <strong>لغو دائمی continuation</strong> می‌شود.</li>
</ul>
<hr>
<h4>معانی وضعیت antecedent</h4>
<table>
<thead>
<tr>
<th>وضعیت</th>
<th>توضیح</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RanToCompletion</code></td>
<td>موفقیت بدون لغو یا exception</td>
</tr>
<tr>
<td><code>Faulted</code></td>
<td>یک استثنا رخ داده است</td>
</tr>
<tr>
<td><code>Canceled</code></td>
<td>antecedent با token لغو شده یا ادامه شرطی اجرا نشده است</td>
</tr>
</tbody>
</table>
<blockquote>
<p>مهم: اگر continuation به دلیل این فلگ‌ها اجرا نشود، <strong>لغو می‌شود</strong> ولی فراموش نمی‌شود. بنابراین هر continuation روی آن continuation می‌تواند اجرا شود مگر اینکه شرط <code>NotOnCanceled</code> اعمال شده باشد.</p>
</blockquote>
<hr>
<h4>مثال عملی</h4>
<pre class="hljs"><code>Task t1 = Task.Factory.StartNew(() =&gt; { <span class="hljs-comment">/* کار اصلی */</span> });

<span class="hljs-comment">// ادامه فقط در صورت خطا</span>
Task fault = t1.ContinueWith(
    ant =&gt; Console.WriteLine(<span class="hljs-string">&quot;fault&quot;</span>),
    TaskContinuationOptions.OnlyOnFaulted
);

<span class="hljs-comment">// ادامه روی continuation قبلی</span>
Task t3 = fault.ContinueWith(
    ant =&gt; Console.WriteLine(<span class="hljs-string">&quot;t3&quot;</span>)  <span class="hljs-comment">// این همیشه اجرا می‌شود!</span>
);

<span class="hljs-comment">// اگر بخواهیم t3 تنها وقتی اجرا شود که fault اجرا شده:</span>
Task t3_conditional = fault.ContinueWith(
    ant =&gt; Console.WriteLine(<span class="hljs-string">&quot;t3&quot;</span>),
    TaskContinuationOptions.NotOnCanceled
);
</code></pre>
<ul>
<li>نکته کلیدی: <strong>t3_conditional</strong> تنها وقتی اجرا می‌شود که <code>fault</code> واقعاً اجرا شده باشد.</li>
<li>بدون شرط <code>NotOnCanceled</code>، حتی اگر <code>fault</code> اجرا نشود (لغو شود)، <code>t3</code> اجرا می‌شود.</li>
</ul>
 <div align="center">
<p><img src="../../../assets/image/22/Table-22-9.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>Continuations با چند antecedent و TaskFactory 🏗️</h3>
<h4>1️⃣ Continuations با چند antecedent</h4>
<ul>
<li>می‌توان یک continuation را طوری برنامه‌ریزی کرد که بعد از اتمام <strong>چند task</strong> اجرا شود.</li>
<li>دو روش اصلی در <strong>TaskFactory</strong> وجود دارد:</li>
</ul>
<table>
<thead>
<tr>
<th>روش</th>
<th>توضیح</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ContinueWhenAll</code></td>
<td>continuation پس از اتمام همه antecedentها اجرا می‌شود</td>
</tr>
<tr>
<td><code>ContinueWhenAny</code></td>
<td>continuation پس از اتمام هر یک از antecedentها اجرا می‌شود</td>
</tr>
</tbody>
</table>
<blockquote>
<p>مثال با <code>ContinueWhenAll</code>:</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-keyword">var</span> task1 = Task.Run(() =&gt; Console.Write(<span class="hljs-string">&quot;X&quot;</span>));
<span class="hljs-keyword">var</span> task2 = Task.Run(() =&gt; Console.Write(<span class="hljs-string">&quot;Y&quot;</span>));

<span class="hljs-keyword">var</span> continuation = Task.Factory.ContinueWhenAll(
    <span class="hljs-keyword">new</span>[] { task1, task2 },
    tasks =&gt; Console.WriteLine(<span class="hljs-string">&quot;Done&quot;</span>)
);
</code></pre>
<ul>
<li>همان نتیجه با <strong>task combinator</strong> <code>WhenAll</code>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> continuation = Task.WhenAll(task1, task2)
                       .ContinueWith(ant =&gt; Console.WriteLine(<span class="hljs-string">&quot;Done&quot;</span>));
</code></pre>
<hr>
<h4>2️⃣ چند continuation روی یک antecedent</h4>
<ul>
<li>می‌توان چند <code>ContinueWith</code> روی یک task واحد صدا زد.</li>
<li>همه continuationها پس از پایان antecedent شروع می‌شوند (مگر گزینه <code>ExecuteSynchronously</code> مشخص شود).</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> t = Task.Factory.StartNew(() =&gt; Thread.Sleep(<span class="hljs-number">1000</span>));
t.ContinueWith(ant =&gt; Console.Write(<span class="hljs-string">&quot;X&quot;</span>));
t.ContinueWith(ant =&gt; Console.Write(<span class="hljs-string">&quot;Y&quot;</span>));
<span class="hljs-comment">// خروجی می‌تواند XY یا YX باشد</span>
</code></pre>
<hr>
<h4>3️⃣ Task Schedulers 🗂️</h4>
<ul>
<li>
<p><strong>TaskScheduler</strong> کار تخصیص task به threadها را انجام می‌دهد.</p>
</li>
<li>
<p>دو پیاده‌سازی استاندارد:</p>
<ol>
<li><strong>Default scheduler:</strong> با CLR thread pool کار می‌کند.</li>
<li><strong>Synchronization context scheduler:</strong> برای UI مثل WPF یا Windows Forms، تا فقط thread ایجادکننده کنترل‌ها به آنها دسترسی داشته باشد.</li>
</ol>
</li>
</ul>
<blockquote>
<p>مثال: اجرای یک continuation روی UI thread:</p>
</blockquote>
<pre class="hljs"><code>_uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
Task.Run(() =&gt; Foo())
    .ContinueWith(ant =&gt; lblResult.Content = ant.Result, _uiScheduler);
</code></pre>
<ul>
<li>همچنین امکان نوشتن TaskScheduler سفارشی با subclassing وجود دارد، ولی بیشتر در سناریوهای خاص کاربرد دارد.</li>
</ul>
<hr>
<h4>4️⃣ TaskFactory 🏭</h4>
<ul>
<li>
<p><code>Task.Factory</code> یک <strong>TaskFactory پیش‌فرض</strong> بازمی‌گرداند.</p>
</li>
<li>
<p>کارکرد اصلی: ایجاد سه نوع task:</p>
<ol>
<li>Ordinary tasks (<code>StartNew</code>)</li>
<li>Continuations با چند antecedent (<code>ContinueWhenAll</code>, <code>ContinueWhenAny</code>)</li>
<li>Tasks که متدهای قدیمی APM را wrap می‌کنند (<code>FromAsync</code>)</li>
</ol>
</li>
<li>
<p>می‌توان TaskFactory خود را با مقادیر پیش‌فرض سفارشی ساخت:</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> factory = <span class="hljs-keyword">new</span> TaskFactory(
    TaskCreationOptions.LongRunning | TaskCreationOptions.AttachedToParent,
    TaskContinuationOptions.None
);

<span class="hljs-comment">// استفاده از factory برای ایجاد taskها</span>
Task task1 = factory.StartNew(Method1);
Task task2 = factory.StartNew(Method2);
</code></pre>
<ul>
<li>مزیت: ادامه‌ها و taskها به صورت یکپارچه با همان تنظیمات سفارشی اجرا می‌شوند.</li>
</ul>
<h3>کار با AggregateException ⚠️</h3>
<p>همان‌طور که دیدیم، <strong>PLINQ</strong>، کلاس <strong>Parallel</strong> و <strong>Tasks</strong> به‌صورت خودکار استثناها را به مصرف‌کننده منتقل می‌کنند. برای درک اهمیت این موضوع، فرض کنید کوئری LINQ زیر را داریم که در اولین تکرار، یک <strong>DivideByZeroException</strong> ایجاد می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span>
{
    <span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> i <span class="hljs-keyword">in</span> Enumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">1000000</span>)
                <span class="hljs-keyword">select</span> <span class="hljs-number">100</span> / i;
    ...
}
<span class="hljs-keyword">catch</span> (DivideByZeroException)
{
    ...
}
</code></pre>
<p>اگر از PLINQ بخواهیم این کوئری را موازی‌سازی کند و رسیدگی به استثناها را نادیده بگیرد، احتمالاً <strong>DivideByZeroException</strong> در یک نخ (Thread) جداگانه رخ خواهد داد، بدون آن که بلاک <code>catch</code> ما اجرا شود و باعث کرش کردن برنامه خواهد شد.</p>
<p>بنابراین، استثناها به‌طور خودکار گرفته شده و دوباره به فراخواننده پرتاب می‌شوند. اما متأسفانه موضوع به سادگی گرفتن یک <strong>DivideByZeroException</strong> نیست. چون این کتابخانه‌ها از چندین نخ استفاده می‌کنند، ممکن است دو یا چند استثنا همزمان پرتاب شوند. برای اطمینان از گزارش همه استثناها، آن‌ها داخل یک <strong>AggregateException</strong> قرار می‌گیرند که پراپرتی <strong>InnerExceptions</strong> آن شامل همه استثناهای گرفته شده است:</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span>
{
    <span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> i <span class="hljs-keyword">in</span> ParallelEnumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">1000000</span>)
                <span class="hljs-keyword">select</span> <span class="hljs-number">100</span> / i;
    <span class="hljs-comment">// اجرای کوئری</span>
    ...
}
<span class="hljs-keyword">catch</span> (AggregateException aex)
{
    <span class="hljs-keyword">foreach</span> (Exception ex <span class="hljs-keyword">in</span> aex.InnerExceptions)
        Console.WriteLine(ex.Message);
}
</code></pre>
<p>هر دو <strong>PLINQ</strong> و کلاس <strong>Parallel</strong> اجرای کوئری یا حلقه را با اولین استثنا خاتمه می‌دهند و عناصر یا بدنه حلقه‌های بعدی پردازش نمی‌شوند. ممکن است قبل از پایان چرخه جاری، استثناهای دیگری هم پرتاب شوند. اولین استثنا در <strong>AggregateException</strong> از طریق پراپرتی <strong>InnerException</strong> در دسترس است.</p>
<hr>
<h3>Flatten و Handle 🛠️</h3>
<p>کلاس <strong>AggregateException</strong> دو روش برای ساده‌سازی مدیریت استثنا ارائه می‌دهد: <strong>Flatten</strong> و <strong>Handle</strong>.</p>
<h4>Flatten</h4>
<p>اغلب <strong>AggregateException</strong> شامل <strong>AggregateException</strong>های دیگر نیز می‌شود. این حالت معمولاً زمانی رخ می‌دهد که یک <strong>Child Task</strong> استثنا پرتاب کند. با استفاده از <strong>Flatten</strong> می‌توان هر سطحی از تودرتویی را حذف کرد تا مدیریت ساده‌تر شود. این متد یک <strong>AggregateException</strong> جدید با لیست مسطحی از استثناهای داخلی برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-keyword">catch</span> (AggregateException aex)
{
    <span class="hljs-keyword">foreach</span> (Exception ex <span class="hljs-keyword">in</span> aex.Flatten().InnerExceptions)
        myLogWriter.LogException(ex);
}
</code></pre>
<h4>Handle</h4>
<p>گاهی لازم است فقط نوع خاصی از استثناها گرفته شوند و بقیه دوباره پرتاب شوند. متد <strong>Handle</strong> این کار را ساده می‌کند. این متد یک <strong>predicate</strong> از نوع <code>Func&lt;Exception, bool&gt;</code> می‌گیرد و روی هر استثنای داخلی اجرا می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Func&lt;Exception, <span class="hljs-built_in">bool</span>&gt; predicate</span>)
</span></code></pre>
<p>اگر <strong>predicate</strong> مقدار <code>true</code> برگرداند، آن استثنا &quot;مدیریت شده&quot; محسوب می‌شود. پس از اجرای delegate روی همه استثناها:</p>
<ul>
<li>اگر همه استثناها مدیریت شده باشند، دوباره پرتاب نمی‌شوند.</li>
<li>اگر استثنایی مدیریت نشده باشد (<code>false</code>)، یک <strong>AggregateException</strong> جدید شامل آن استثناها ایجاد شده و پرتاب می‌شود.</li>
</ul>
<p>مثال زیر یک <strong>AggregateException</strong> دیگر شامل یک <strong>NullReferenceException</strong> ایجاد می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> parent = Task.Factory.StartNew(() =&gt; 
{
    <span class="hljs-built_in">int</span>[] numbers = { <span class="hljs-number">0</span> };
    <span class="hljs-keyword">var</span> childFactory = <span class="hljs-keyword">new</span> TaskFactory(TaskCreationOptions.AttachedToParent, TaskContinuationOptions.None);
    childFactory.StartNew(() =&gt; <span class="hljs-number">5</span> / numbers[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// تقسیم بر صفر</span>
    childFactory.StartNew(() =&gt; numbers[<span class="hljs-number">1</span>]);       <span class="hljs-comment">// خارج از محدوده</span>
    childFactory.StartNew(() =&gt; { <span class="hljs-keyword">throw</span> <span class="hljs-literal">null</span>; });  <span class="hljs-comment">// ارجاع null</span>
});

<span class="hljs-keyword">try</span> { parent.Wait(); }
<span class="hljs-keyword">catch</span> (AggregateException aex)
{
    aex.Flatten().Handle(ex =&gt; <span class="hljs-comment">// نیاز به Flatten داریم</span>
    {
        <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">is</span> DivideByZeroException)
        {
            Console.WriteLine(<span class="hljs-string">&quot;Divide by zero&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// مدیریت شد</span>
        }
        <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">is</span> IndexOutOfRangeException)
        {
            Console.WriteLine(<span class="hljs-string">&quot;Index out of range&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// مدیریت شد</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// سایر استثناها دوباره پرتاب می‌شوند</span>
    });
}
</code></pre>
<hr>
<h3>مجموعه‌های همزمان (Concurrent Collections) 🗂️</h3>
<p>.NET مجموعه‌های <strong>Thread-Safe</strong> را در فضای نام <strong>System.Collections.Concurrent</strong> ارائه می‌دهد، که برای مدیریت داده‌ها در محیط‌های چندنخی بسیار مفید هستند.</p>
 <div align="center">
<p><img src="../../../assets/image/22/Table-22-10.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>مجموعه‌های همزمان (Concurrent Collections) 🗃️</h3>
<p>مجموعه‌های <strong>همزمان</strong> برای سناریوهای <strong>با هم‌زمانی بالا</strong> بهینه‌سازی شده‌اند؛ با این حال، هر زمان که به یک <strong>مجموعه Thread-Safe</strong> نیاز داشته باشید (به جای استفاده از قفل روی یک مجموعه عادی) هم می‌توانند مفید باشند. با این حال، چند نکته مهم وجود دارد:</p>
<ul>
<li>مجموعه‌های <strong>سنتی</strong> در همه سناریوها به جز موارد با <strong>هم‌زمانی بسیار بالا</strong> عملکرد بهتری دارند.</li>
<li>یک مجموعه <strong>Thread-Safe</strong> تضمین نمی‌کند که کدی که از آن استفاده می‌کند نیز <strong>Thread-Safe</strong> باشد (به فصل «Locking and Thread Safety» صفحه 898 مراجعه کنید).</li>
<li>اگر روی یک مجموعه همزمان در حالی که نخ دیگری در حال تغییر آن است، <strong>Enumeration</strong> انجام دهید، هیچ استثنایی پرتاب نمی‌شود؛ بلکه ترکیبی از محتوای قدیمی و جدید مشاهده خواهید کرد.</li>
<li>نسخه همزمانی از <strong>List<T></strong> وجود ندارد.</li>
<li>کلاس‌های <strong>ConcurrentStack</strong>، <strong>ConcurrentQueue</strong> و <strong>ConcurrentBag</strong> به‌صورت داخلی با <strong>لیست‌های پیوندی</strong> پیاده‌سازی شده‌اند. این باعث می‌شود که مصرف حافظه آن‌ها نسبت به <strong>Stack</strong> و <strong>Queue</strong> غیرهمزمان بیشتر باشد، اما دسترسی همزمان را بهینه می‌کند، زیرا لیست‌های پیوندی برای پیاده‌سازی‌های بدون قفل یا کم‌قفل مناسب‌اند. (چرا که اضافه کردن یک گره به لیست پیوندی تنها نیازمند به‌روزرسانی چند مرجع است، در حالی که اضافه کردن یک عنصر به ساختار شبیه <strong>List<T></strong> ممکن است نیاز به جابه‌جایی هزاران عنصر داشته باشد.)</li>
</ul>
<p>به عبارت دیگر، این مجموعه‌ها صرفاً جایگزینی برای استفاده از <strong>یک مجموعه عادی با قفل</strong> نیستند. برای مثال، اگر کد زیر را روی یک نخ اجرا کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> ConcurrentDictionary&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;();
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) d[i] = <span class="hljs-number">123</span>;
</code></pre>
<p>این کد <strong>سه برابر کندتر</strong> از حالت زیر اجرا می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;();
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) <span class="hljs-keyword">lock</span> (d) d[i] = <span class="hljs-number">123</span>;
</code></pre>
<p>(با این حال، <strong>خواندن از ConcurrentDictionary</strong> سریع است، زیرا بدون قفل انجام می‌شود.)</p>
<hr>
<p>مجموعه‌های همزمان همچنین با مجموعه‌های معمولی متفاوت‌اند، زیرا <strong>متدهای ویژه‌ای برای انجام عملیات‌های اتمیک Test-and-Act</strong> ارائه می‌کنند، مانند <strong>TryPop</strong>. اکثر این متدها از طریق <strong>رابط IProducerConsumerCollection<T></strong> یکپارچه شده‌اند.</p>
<hr>
<h3>IProducerConsumerCollection<T> ⚙️</h3>
<p>یک <strong>مجموعه Producer/Consumer</strong> مجموعه‌ای است که دو کاربرد اصلی دارد:</p>
<ul>
<li><strong>اضافه کردن یک عنصر (&quot;Producing&quot;)</strong></li>
<li><strong>دریافت و حذف یک عنصر (&quot;Consuming&quot;)</strong></li>
</ul>
<p>مثال‌های کلاسیک این نوع مجموعه‌ها، <strong>Stack</strong> و <strong>Queue</strong> هستند. این مجموعه‌ها در برنامه‌نویسی موازی اهمیت دارند زیرا برای پیاده‌سازی‌های <strong>lock-free</strong> بهینه‌اند.</p>
<p>رابط <strong>IProducerConsumerCollection<T></strong> نمایانگر یک <strong>مجموعه Producer/Consumer امن برای نخ‌ها</strong> است. کلاس‌های زیر این رابط را پیاده‌سازی می‌کنند:</p>
<ul>
<li><strong>ConcurrentStack<T></strong></li>
<li><strong>ConcurrentQueue<T></strong></li>
<li><strong>ConcurrentBag<T></strong></li>
</ul>
<p>این رابط از <strong>ICollection</strong> ارث‌بری می‌کند و متدهای زیر را اضافه می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CopyTo</span>(<span class="hljs-params">T[] array, <span class="hljs-built_in">int</span> index</span>)</span>;
<span class="hljs-function">T[] <span class="hljs-title">ToArray</span>()</span>;
<span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">TryAdd</span>(<span class="hljs-params">T item</span>)</span>;
<span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">TryTake</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> T item</span>)</span>;
</code></pre>
<ul>
<li><strong>TryAdd</strong> و <strong>TryTake</strong> بررسی می‌کنند که آیا می‌توان عملیات افزودن یا حذف را انجام داد؛ اگر ممکن باشد، آن را انجام می‌دهند. تست و عمل به‌صورت <strong>اتمیک</strong> انجام می‌شود، بنابراین نیاز به قفل مانند مجموعه‌های معمولی نیست:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">int</span> result;
<span class="hljs-keyword">lock</span> (myStack) <span class="hljs-keyword">if</span> (myStack.Count &gt; <span class="hljs-number">0</span>) result = myStack.Pop();
</code></pre>
<ul>
<li><strong>TryTake</strong> اگر مجموعه خالی باشد، مقدار <code>false</code> برمی‌گرداند.</li>
<li><strong>TryAdd</strong> در سه پیاده‌سازی ارائه‌شده همیشه موفق است و <code>true</code> برمی‌گرداند.</li>
<li>اگر شما مجموعه همزمان خود را پیاده‌سازی کنید که عناصر تکراری را اجازه ندهد، می‌توانید <strong>TryAdd</strong> را طوری پیاده‌سازی کنید که در صورت وجود عنصر، <code>false</code> برگرداند (مثلاً یک <strong>Concurrent Set</strong>).</li>
</ul>
<p>عنصری که <strong>TryTake</strong> حذف می‌کند، توسط زیرکلاس تعیین می‌شود:</p>
<ul>
<li>در <strong>Stack</strong>، آخرین عنصر اضافه‌شده حذف می‌شود.</li>
<li>در <strong>Queue</strong>، اولین عنصر اضافه‌شده حذف می‌شود.</li>
<li>در <strong>Bag</strong>، هر عنصری که بتواند به‌صورت بهینه حذف شود، حذف می‌شود.</li>
</ul>
<p>سه کلاس اصلی معمولاً <strong>TryTake</strong> و <strong>TryAdd</strong> را به‌صورت صریح پیاده‌سازی می‌کنند و همان عملکرد را از طریق متدهای عمومی با نام‌های خاص‌تر مانند <strong>TryDequeue</strong> و <strong>TryPop</strong> در اختیار قرار می‌دهند.</p>
<h3>ConcurrentBag<T> 🎒</h3>
<p>کلاس <strong>ConcurrentBag<T></strong> یک مجموعه <strong>بدون ترتیب</strong> از اشیاء ذخیره می‌کند و <strong>تکراری بودن عناصر مجاز است</strong>. این کلاس برای مواقعی مناسب است که <strong>برایتان مهم نیست چه عنصری هنگام فراخوانی Take یا TryTake دریافت می‌کنید</strong>.</p>
<p>مزیت <strong>ConcurrentBag<T></strong> نسبت به <strong>ConcurrentQueue</strong> یا <strong>ConcurrentStack</strong> این است که متد <strong>Add</strong> آن تقریباً هیچ <strong>هم‌زمانی (contention)</strong> ایجاد نمی‌کند حتی وقتی توسط چندین نخ به‌طور همزمان فراخوانی شود.</p>
<p>در مقابل، فراخوانی <strong>Add</strong> به‌صورت موازی روی <strong>Queue</strong> یا <strong>Stack</strong> کمی هم‌زمانی ایجاد می‌کند (هرچند بسیار کمتر از قفل‌گذاری روی یک مجموعه غیرهمزمان). فراخوانی <strong>Take</strong> روی یک <strong>ConcurrentBag</strong> نیز بسیار بهینه است، به شرط آن که هر نخ بیشتر از تعداد عناصری که اضافه کرده، عنصر نگیرد.</p>
<p>در داخل <strong>ConcurrentBag</strong>، هر نخ <strong>لیست پیوندی خصوصی خود</strong> را دارد. عناصر به لیست خصوصی همان نخی اضافه می‌شوند که <strong>Add</strong> را فراخوانی کرده است و این باعث حذف <strong>هم‌زمانی</strong> می‌شود. وقتی روی bag <strong>Enumeration</strong> انجام می‌دهید، Enumerator به ترتیب از هر لیست خصوصی نخ‌ها عبور می‌کند و عناصر آن‌ها را برمی‌گرداند.</p>
<p>وقتی <strong>Take</strong> را فراخوانی می‌کنید، ابتدا به <strong>لیست خصوصی نخ جاری</strong> نگاه می‌کند. اگر حداقل یک عنصر وجود داشته باشد، عملیات به‌راحتی و بدون هم‌زمانی انجام می‌شود. اما اگر لیست خالی باشد، باید عنصری را از لیست خصوصی نخ دیگری <strong>&quot;سرقت&quot;</strong> کند و احتمال ایجاد هم‌زمانی وجود دارد.</p>
<p>بنابراین، دقیقاً می‌توان گفت که <strong>Take</strong> عنصری را برمی‌گرداند که اخیراً توسط همان نخ اضافه شده است؛ اگر در آن نخ عنصری نباشد، عنصری از نخ دیگری به‌صورت تصادفی بازگردانده می‌شود.</p>
<p><strong>ConcurrentBag</strong> برای مواقعی ایده‌آل است که عملیات موازی روی مجموعه شما عمدتاً شامل <strong>افزودن عناصر</strong> باشد، یا زمانی که <strong>افزودن و برداشتن عناصر روی هر نخ متعادل</strong> است. مثال قبلی از استفاده از <strong>Parallel.ForEach</strong> برای پیاده‌سازی <strong>SpellChecker موازی</strong> را به یاد بیاورید:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> misspellings = <span class="hljs-keyword">new</span> ConcurrentBag&lt;Tuple&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">string</span>&gt;&gt;();
Parallel.ForEach(wordsToTest, (word, state, i) =&gt;
{
  <span class="hljs-keyword">if</span> (!wordLookup.Contains(word))
    misspellings.Add(Tuple.Create((<span class="hljs-built_in">int</span>)i, word));
});
</code></pre>
<p>اما استفاده از <strong>ConcurrentBag</strong> برای یک <strong>صف Producer/Consumer</strong> مناسب نیست، زیرا عناصر توسط نخ‌های مختلف اضافه و حذف می‌شوند.</p>
<hr>
<h3>BlockingCollection<T> ⛔</h3>
<p>اگر روی هر یک از مجموعه‌های Producer/Consumer مانند <strong>ConcurrentStack<T></strong>، <strong>ConcurrentQueue<T></strong> و <strong>ConcurrentBag<T></strong> متد <strong>TryTake</strong> را فراخوانی کنید و مجموعه خالی باشد، متد مقدار <code>false</code> برمی‌گرداند. گاهی مفید است که <strong>تا زمانی که یک عنصر موجود شود، منتظر بمانیم</strong>.</p>
<p>به جای اضافه کردن این قابلیت به <strong>TryTake</strong> (که باعث پیچیدگی زیاد اعضا می‌شد و برای پشتیبانی از <strong>CancellationToken</strong> و <strong>Timeout</strong> مناسب نبود)، طراحان <strong>PFX</strong> این قابلیت را در کلاس <strong>BlockingCollection<T></strong> قرار دادند.</p>
<p><strong>BlockingCollection<T></strong> هر مجموعه‌ای که <strong>IProducerConsumerCollection<T></strong> را پیاده‌سازی کرده باشد، در خود می‌پیچاند و اجازه می‌دهد از آن <strong>Take</strong> انجام دهید—و اگر عنصری موجود نباشد، عملیات <strong>Block</strong> می‌شود.</p>
<p>همچنین، <strong>BlockingCollection</strong> می‌تواند اندازه کل مجموعه را محدود کند و اگر این اندازه رعایت نشود، تولیدکننده <strong>Block</strong> می‌شود. چنین مجموعه‌ای به نام <strong>Bounded Blocking Collection</strong> شناخته می‌شود.</p>
<hr>
<h4>نحوه استفاده از BlockingCollection<T> 📝</h4>
<ol>
<li>نمونه‌ای از کلاس بسازید و اختیاری <strong>IProducerConsumerCollection<T></strong> برای wrap کردن و حداکثر اندازه (Bound) را مشخص کنید.</li>
<li>با <strong>Add</strong> یا <strong>TryAdd</strong> عناصر را به مجموعه داخلی اضافه کنید.</li>
<li>با <strong>Take</strong> یا <strong>TryTake</strong> عناصر را از مجموعه داخلی حذف یا مصرف کنید.</li>
</ol>
<p>اگر سازنده بدون مجموعه داخلی فراخوانی شود، به‌صورت خودکار یک <strong>ConcurrentQueue<T></strong> ساخته می‌شود. متدهای تولید و مصرف اجازه استفاده از <strong>CancellationToken</strong> و <strong>Timeout</strong> را می‌دهند. <strong>Add</strong> و <strong>TryAdd</strong> ممکن است Block شوند اگر اندازه مجموعه محدود باشد؛ <strong>Take</strong> و <strong>TryTake</strong> هنگام خالی بودن مجموعه Block می‌شوند.</p>
<p>روش دیگر برای مصرف عناصر، فراخوانی <strong>GetConsumingEnumerable</strong> است که یک <strong>دنباله (sequence) بالقوه نامحدود</strong> برمی‌گرداند و عناصر را به محض در دسترس شدن ارائه می‌دهد. می‌توانید با فراخوانی <strong>CompleteAdding</strong> دنباله را خاتمه دهید؛ این متد همچنین اجازه enqueue کردن عناصر جدید را نمی‌دهد.</p>
<p><strong>BlockingCollection</strong> متدهای استاتیک <strong>AddToAny</strong> و <strong>TakeFromAny</strong> نیز ارائه می‌دهد که اجازه می‌دهد یک عنصر را به چند مجموعه همزمان اضافه یا از آن‌ها بردارید و اولین مجموعه‌ای که توانست این درخواست را انجام دهد، عملیات را انجام می‌دهد.</p>
<h3>نوشتن یک صف Producer/Consumer 🏭📥</h3>
<p>یک <strong>صف Producer/Consumer</strong> ساختاری بسیار مفید است، هم در <strong>برنامه‌نویسی موازی</strong> و هم در <strong>سناریوهای عمومی هم‌زمانی</strong>. عملکرد آن به این صورت است:</p>
<ul>
<li>یک <strong>Queue</strong> برای نگهداری آیتم‌های کاری یا داده‌هایی که عملیات روی آن‌ها انجام می‌شود، ایجاد می‌کنیم.</li>
<li>هرگاه یک کار نیاز به اجرا داشته باشد، در صف قرار می‌گیرد (<strong>Enqueue</strong>) و فراخواننده می‌تواند به کارهای دیگر بپردازد.</li>
<li>یک یا چند <strong>نخ Worker</strong> در پس‌زمینه فعالیت می‌کنند و آیتم‌های صف را برداشته و اجرا می‌کنند.</li>
</ul>
<p>یک <strong>صف Producer/Consumer</strong> کنترل دقیقی روی تعداد نخ‌هایی که هم‌زمان اجرا می‌شوند فراهم می‌کند. این قابلیت نه تنها برای محدود کردن مصرف CPU بلکه برای مدیریت منابع دیگر نیز مفید است. برای مثال، اگر کارها عملیات‌های سنگین I/O روی دیسک انجام دهند، می‌توان <strong>Concurrency</strong> را محدود کرد تا سیستم‌عامل و سایر برنامه‌ها دچار مشکل نشوند. همچنین می‌توان در طول عمر صف، <strong>Workers</strong> را به‌صورت دینامیک اضافه یا حذف کرد.</p>
<p>خود <strong>Thread Pool</strong> در CLR نوعی صف <strong>Producer/Consumer</strong> است که برای <strong>کارهای کوتاه مدت و Compute-bound</strong> بهینه شده است.</p>
<p>یک <strong>صف Producer/Consumer</strong> معمولاً شامل آیتم‌هایی است که همان <strong>کار</strong> روی آن‌ها انجام می‌شود. برای مثال، آیتم‌ها ممکن است نام فایل‌ها باشند و کار، رمزگذاری آن‌ها باشد. اما اگر آیتم را به شکل یک <strong>Delegate</strong> در نظر بگیریم، می‌توان یک <strong>صف Producer/Consumer عمومی‌تر</strong> نوشت که هر آیتم قادر به انجام هر عملی باشد.</p>
<p>در <a href="http://albahari.com/threading">albahari.com/threading</a> نشان داده شده که چگونه می‌توان یک <strong>Producer/Consumer Queue</strong> از صفر با استفاده از <strong>AutoResetEvent</strong> (و بعداً با <strong>Monitor.Wait/Pulse</strong>) نوشت.</p>
<p>با این حال، نوشتن یک صف از صفر <strong>ضروری نیست</strong>، زیرا اکثر قابلیت‌ها توسط <strong>BlockingCollection<T></strong> فراهم شده‌اند.</p>
<hr>
<h4>مثال استفاده از BlockingCollection برای صف PCQueue 🛠️</h4>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PCQueue</span> : <span class="hljs-title">IDisposable</span>
{
  BlockingCollection&lt;Action&gt; _taskQ = <span class="hljs-keyword">new</span> BlockingCollection&lt;Action&gt;();

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PCQueue</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> workerCount</span>)</span>
  {
    <span class="hljs-comment">// ایجاد و شروع یک Task جداگانه برای هر مصرف‌کننده:</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; workerCount; i++)
      Task.Factory.StartNew(Consume);
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enqueue</span>(<span class="hljs-params">Action action</span>)</span> { _taskQ.Add(action); }

  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Consume</span>()</span>
  {
    <span class="hljs-comment">// این دنباله هنگام نبود عنصر Block می‌شود</span>
    <span class="hljs-comment">// و با فراخوانی CompleteAdding خاتمه می‌یابد.</span>
    <span class="hljs-keyword">foreach</span> (Action action <span class="hljs-keyword">in</span> _taskQ.GetConsumingEnumerable())
      action();  <span class="hljs-comment">// اجرای کار</span>
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span> { _taskQ.CompleteAdding(); }
}
</code></pre>
<p>چون چیزی به سازنده <strong>BlockingCollection</strong> ارسال نکرده‌ایم، به‌صورت خودکار یک <strong>ConcurrentQueue</strong> ایجاد می‌شود. اگر یک <strong>ConcurrentStack</strong> می‌دادیم، صف به یک <strong>Producer/Consumer Stack</strong> تبدیل می‌شد.</p>
<hr>
<h3>استفاده از Tasks در صف Producer/Consumer 🔄</h3>
<p>صفی که نوشتیم کمی <strong>غیر منعطف</strong> است، زیرا بعد از قرار دادن کارها در صف نمی‌توانیم وضعیت آن‌ها را دنبال کنیم. مثلاً خوب است اگر بتوانیم:</p>
<ul>
<li>بدانیم یک کار <strong>تمام شده است</strong> (و بتوانیم await کنیم)</li>
<li>یک کار را <strong>لغو کنیم</strong></li>
<li>به شکلی زیبا با <strong>استثناهای</strong> پرتاب شده توسط کار برخورد کنیم</li>
</ul>
<p>راه حل ایده‌آل این است که متد <strong>Enqueue</strong> یک <strong>Task</strong> برگرداند تا بتوانیم همه این قابلیت‌ها را داشته باشیم. خوشبختانه کلاس <strong>Task</strong> دقیقاً این کار را انجام می‌دهد و می‌توان آن را با <strong>TaskCompletionSource</strong> یا با <strong>ایجاد مستقیم</strong> یک Task (Cold/Unstarted) تولید کرد.</p>
<hr>
<h4>مثال PCQueue با Task 🎯</h4>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PCQueue</span> : <span class="hljs-title">IDisposable</span>
{
  BlockingCollection&lt;Task&gt; _taskQ = <span class="hljs-keyword">new</span> BlockingCollection&lt;Task&gt;();

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PCQueue</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> workerCount</span>)</span>
  {
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; workerCount; i++)
      Task.Factory.StartNew(Consume);
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">Enqueue</span>(<span class="hljs-params">Action action, CancellationToken cancelToken = <span class="hljs-literal">default</span></span>)</span>
  {
    <span class="hljs-keyword">var</span> task = <span class="hljs-keyword">new</span> Task(action, cancelToken);
    _taskQ.Add(task);
    <span class="hljs-keyword">return</span> task;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span>&lt;<span class="hljs-title">TResult</span>&gt; <span class="hljs-title">Enqueue</span>&lt;<span class="hljs-title">TResult</span>&gt;(<span class="hljs-params">Func&lt;TResult&gt; func, CancellationToken cancelToken = <span class="hljs-literal">default</span></span>)</span>
  {
    <span class="hljs-keyword">var</span> task = <span class="hljs-keyword">new</span> Task&lt;TResult&gt;(func, cancelToken);
    _taskQ.Add(task);
    <span class="hljs-keyword">return</span> task;
  }

  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Consume</span>()</span>
  {
    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> task <span class="hljs-keyword">in</span> _taskQ.GetConsumingEnumerable())
      <span class="hljs-keyword">try</span> 
      {
          <span class="hljs-keyword">if</span> (!task.IsCanceled) task.RunSynchronously();
      } 
      <span class="hljs-keyword">catch</span> (InvalidOperationException) { }  <span class="hljs-comment">// شرایط نادر Race Condition</span>
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span> { _taskQ.CompleteAdding(); }
}
</code></pre>
<p>در متد <strong>Enqueue</strong>، یک <strong>Task</strong> ایجاد می‌کنیم، آن را در صف قرار می‌دهیم و به فراخواننده برمی‌گردانیم بدون اینکه اجرا شود. در متد <strong>Consume</strong>، <strong>Task</strong> روی نخ مصرف‌کننده <strong>به‌صورت هم‌زمان اجرا</strong> می‌شود. با گرفتن <strong>InvalidOperationException</strong>، شرایط نادر لغو هم‌زمان Task مدیریت می‌شود.</p>
<hr>
<h4>نمونه استفاده</h4>
<pre class="hljs"><code><span class="hljs-keyword">var</span> pcQ = <span class="hljs-keyword">new</span> PCQueue(<span class="hljs-number">2</span>);    <span class="hljs-comment">// حداکثر concurrency برابر ۲</span>
<span class="hljs-built_in">string</span> result = <span class="hljs-keyword">await</span> pcQ.Enqueue(() =&gt; <span class="hljs-string">&quot;That was easy!&quot;</span>);
</code></pre>
<p>با این روش، <strong>تمام مزایای Task</strong> از جمله <strong>انتشار استثناها، بازگشت مقادیر و لغو</strong> را داریم، در حالی که <strong>کنترل کامل روی زمان‌بندی اجرای کارها</strong> نیز در اختیارمان است.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
