

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>سی‌شارپ پیشرفته</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

       <nav class="nav">
         <a href="/Gitab/" >خانه</a>
         <a href="/Gitab/books/list-books" >کتاب‌ها</a>
        <a href="/Gitab/translator.html" >مترجمین</a>
         <a href="/Gitab/giter.html" >گیتر</a>
       </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل چهارم: سی شارپ پیشرفته</h1>
<p>در این فصل، به سراغ مباحث پیشرفته زبان C# می‌رویم که بر پایه مفاهیمی بنا شده‌اند که در فصل‌های 2 و 3 بررسی کردیم.<br>
چهار بخش اول را باید به صورت پیوسته و پشت سر هم مطالعه کنید؛ اما بخش‌های باقی‌مانده را می‌توانید به هر ترتیبی بخوانید.</p>
<h3>Delegates (نمایندگان) 📨</h3>
<p>یک delegate یک شیء است که می‌داند چگونه یک متد را فراخوانی کند.</p>
<p>نوع delegate تعیین می‌کند که نمونه‌های delegate می‌توانند چه نوع متدهایی را فراخوانی کنند. به طور مشخص، یک delegate نوع بازگشتی متد و انواع پارامترهای متد را تعریف می‌کند.</p>
<p>مثال: تعریف یک نوع delegate به نام Transformer:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Transformer</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>;
</code></pre>
<p>این delegate با هر متدی که بازگشتی از نوع int داشته باشد و یک پارامتر int بگیرد سازگار است. مثل این:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Square</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> { <span class="hljs-keyword">return</span> x * x; }
</code></pre>
<p>یا به صورت کوتاه‌تر (expression-bodied):</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Square</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x;
</code></pre>
<p><strong>ساختن و استفاده از یک delegate 🛠️</strong></p>
<p>اختصاص یک متد به یک متغیر delegate، باعث ایجاد یک نمونه delegate می‌شود:</p>
<pre class="hljs"><code>Transformer t = Square;
</code></pre>
<p>فراخوانی یک نمونه delegate دقیقاً مثل فراخوانی یک متد است:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> answer = t(<span class="hljs-number">3</span>);   <span class="hljs-comment">// answer برابر با 9</span>
</code></pre>
<p>مثال کامل:</p>
<pre class="hljs"><code>Transformer t = Square;   <span class="hljs-comment">// ایجاد نمونه delegate</span>
<span class="hljs-built_in">int</span> result = t(<span class="hljs-number">3</span>);        <span class="hljs-comment">// فراخوانی delegate</span>
Console.WriteLine(result); <span class="hljs-comment">// خروجی: 9</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Square</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x;

<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Transformer</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>;  <span class="hljs-comment">// تعریف نوع delegate</span>
</code></pre>
<p><strong>مفهوم اصلی delegate 🎯</strong></p>
<p>یک نمونه delegate واقعاً به عنوان نماینده‌ی caller عمل می‌کند:<br>
caller (فراخواننده) delegate را فراخوانی می‌کند و سپس delegate، متد هدف را فراخوانی می‌کند.</p>
<p>این واسطه‌گری (indirection) باعث می‌شود که caller از متد هدف جدا و مستقل باشد.</p>
<p><strong>نکته‌های مهم ✅</strong></p>
<p>دستور:</p>
<pre class="hljs"><code>Transformer t = Square;
</code></pre>
<p>در واقع یک میان‌بُر (shorthand) برای این است:</p>
<pre class="hljs"><code>Transformer t = <span class="hljs-keyword">new</span> Transformer(Square);
</code></pre>
<p>عبارت:</p>
<pre class="hljs"><code>t(3)
</code></pre>
<p>میان‌بُری است برای:</p>
<pre class="hljs"><code>t.Invoke(3)
</code></pre>
<p>از نظر فنی، وقتی به Square بدون پرانتز و آرگومان اشاره می‌کنیم، در حال مشخص کردن یک method group هستیم.<br>
اگر متد overload شده باشد، کامپایلر C# بر اساس امضای delegate انتخاب می‌کند که کدام overload مناسب است.</p>
<p><strong>Delegate شبیه به Callback 📞</strong></p>
<p>یک delegate مشابه چیزی است که در اصطلاح عمومی callback نامیده می‌شود.<br>
این مفهوم سازه‌هایی مثل function pointers در زبان C را نیز در بر می‌گیرد.</p>
<h3>نوشتن متدهای پلاگین با استفاده از Delegateها ✨</h3>
<p>یک متغیر از نوع delegate در زمان اجرا (runtime) به یک متد نسبت داده می‌شود. این ویژگی برای نوشتن متدهای پلاگین (plug-in methods) بسیار کاربردی است.</p>
<p>در مثال زیر، ما یک متد کمکی (utility method) به نام Transform داریم که یک عمل transform را روی هر عضو از یک آرایه‌ی عددی (integer array) اعمال می‌کند. این متد Transform یک پارامتر از نوع delegate دارد که می‌توانید برای مشخص کردن پلاگین transform از آن استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] values = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
Transform (values, Square);      <span class="hljs-comment">// اتصال متد Square به Transform</span>
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span> values)
  Console.Write (i + <span class="hljs-string">&quot;  &quot;</span>);      <span class="hljs-comment">// خروجی: 1   4   9</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Transform</span> (<span class="hljs-params"><span class="hljs-built_in">int</span>[] values, Transformer t</span>)</span>
{
  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; values.Length; i++)
    values[i] = t (values[i]);
}

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Square</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x;
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Cube</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x * x;

<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Transformer</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>;
</code></pre>
<p>🔹 در اینجا اگر در خط دوم به‌جای Square از Cube استفاده کنیم، تبدیل روی اعداد به‌صورت مکعب (توان سوم) انجام می‌شود.</p>
<p>🔹 متد Transform یک higher-order function است، چون یک تابع (delegate) را به‌عنوان آرگومان می‌گیرد. (هر متدی که یک delegate را برگرداند نیز یک higher-order function محسوب می‌شود.)</p>
<h3>اهداف متد در Delegateها: Instance و Static ⚡</h3>
<p>یک متد هدف (target method) برای یک delegate می‌تواند محلی (local)، ایستا (static) یا نمونه‌ای (instance) باشد.</p>
<p>مثال یک متد static به‌عنوان هدف delegate:</p>
<pre class="hljs"><code>Transformer t = Test.Square;
Console.WriteLine (t(<span class="hljs-number">10</span>));      <span class="hljs-comment">// 100</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> 
{ 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Square</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x; 
}

<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Transformer</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>;
</code></pre>
<p>مثال یک متد instance به‌عنوان هدف delegate:</p>
<pre class="hljs"><code>Test test = <span class="hljs-keyword">new</span> Test();
Transformer t = test.Square;
Console.WriteLine (t(<span class="hljs-number">10</span>));      <span class="hljs-comment">// 100</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> 
{ 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Square</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x; 
}

<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Transformer</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>;
</code></pre>
<p>🔑 زمانی که یک متد instance به یک delegate اختصاص داده می‌شود، آن delegate فقط به خود متد اشاره نمی‌کند، بلکه نمونه‌ای از کلاس که متد به آن تعلق دارد را هم نگه‌داری می‌کند.</p>
<p><strong>خاصیت Target در کلاس System.Delegate 🎯</strong></p>
<p>کلاس System.Delegate یک ویژگی به نام Target دارد که این نمونه (instance) را نشان می‌دهد (و اگر delegate به یک متد static اشاره کند، مقدارش null خواهد بود).</p>
<p>مثال:</p>
<pre class="hljs"><code>MyReporter r = <span class="hljs-keyword">new</span> MyReporter();
r.Prefix = <span class="hljs-string">&quot;%Complete: &quot;</span>;

ProgressReporter p = r.ReportProgress;
p(<span class="hljs-number">99</span>);                                 <span class="hljs-comment">// %Complete: 99</span>

Console.WriteLine (p.Target == r);     <span class="hljs-comment">// True</span>
Console.WriteLine (p.Method);          <span class="hljs-comment">// Void ReportProgress(Int32)</span>

r.Prefix = <span class="hljs-string">&quot;&quot;</span>;
p(<span class="hljs-number">99</span>);                                 <span class="hljs-comment">// 99</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ProgressReporter</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> percentComplete</span>)</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title">MyReporter</span>
{
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Prefix = <span class="hljs-string">&quot;&quot;</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReportProgress</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> percentComplete</span>)</span>
    =&gt; Console.WriteLine (Prefix + percentComplete);
}
</code></pre>
<p>✅ چون نمونه (instance) در خاصیت Target ذخیره می‌شود، طول عمر آن حداقل به اندازه طول عمر delegate گسترش می‌یابد.</p>
<p>🔖 جمع‌بندی:</p>
<ul>
<li>
<p>Delegateها به ما اجازه می‌دهند که متدها را مثل متغیرها پاس بدهیم.</p>
</li>
<li>
<p>می‌توانند به متدهای static یا instance متصل شوند.</p>
</li>
<li>
<p>خاصیت Target تضمین می‌کند که نمونه مربوط به متد instance تا وقتی delegate زنده است، باقی بماند.</p>
</li>
</ul>
<p>💡 این مفهوم پایه‌ای در طراحی پلاگین‌ها، کال‌بک‌ها و برنامه‌نویسی شیءگراست.</p>
<h3>نمایندگان چندپخشی (Multicast Delegates) 🎯</h3>
<p>تمام نمونه‌های delegate در سی‌شارپ دارای قابلیت چندپخشی (multicast) هستند. این یعنی یک نمونه‌ی delegate می‌تواند نه فقط به یک متد، بلکه به یک لیست از متدها اشاره کند.</p>
<p>عملگرهای + و += برای ترکیب کردن نمونه‌های delegate استفاده می‌شوند:</p>
<pre class="hljs"><code>SomeDelegate d = SomeMethod1;
d += SomeMethod2;
</code></pre>
<p>خط آخر از نظر عملکرد دقیقاً معادل این است:</p>
<pre class="hljs"><code>d = d + SomeMethod2;
</code></pre>
<p>اکنون وقتی d فراخوانی شود، هم SomeMethod1 و هم SomeMethod2 اجرا می‌شوند.<br>
✅ توجه داشته باشید که متدها به ترتیبی که اضافه شده‌اند فراخوانی می‌شوند.</p>
<p>عملگرهای - و -= هم برای حذف یک متد از لیست متدهای یک delegate استفاده می‌شوند:</p>
<pre class="hljs"><code>d -= SomeMethod1;
</code></pre>
<p>اکنون فراخوانی d باعث می‌شود فقط SomeMethod2 اجرا شود.</p>
<p>📌 نکته مهم:</p>
<ul>
<li>وقتی روی یک متغیر delegate که مقدارش null است، عمل + یا += انجام دهید، باز هم کار می‌کند و معادل این است که به آن مقدار جدید بدهید:</li>
</ul>
<pre class="hljs"><code>SomeDelegate d = <span class="hljs-literal">null</span>;
d += SomeMethod1;   <span class="hljs-comment">// معادل با: d = SomeMethod1 وقتی d برابر null است</span>
</code></pre>
<ul>
<li>به طور مشابه، اگر روی یک delegate که فقط یک متد را نگه داشته باشد عمل -= کنید، نتیجه‌اش معادل اختصاص مقدار null به آن متغیر خواهد بود.</li>
</ul>
<p>⚡ یک نکته مهم دیگر:<br>
Delegates در سی‌شارپ immutable هستند. یعنی وقتی شما += یا -= را استفاده می‌کنید، در واقع یک نمونه‌ی جدید از delegate ساخته می‌شود و به متغیر موجود اختصاص داده می‌شود.</p>
<p>📢 اگر یک delegate چندپخشی (multicast delegate) دارای نوع بازگشتی غیر از void باشد، مقدار بازگشتی که شما دریافت می‌کنید مربوط به آخرین متدی است که اجرا شده است. متدهای قبلی همچنان اجرا می‌شوند، اما مقدار بازگشتی آن‌ها نادیده گرفته می‌شود.<br>
(به همین دلیل، در بیشتر مواردی که از multicast delegate استفاده می‌شود، آن‌ها void برمی‌گردانند.)</p>
<p>🧩 تمام انواع delegate به طور ضمنی از System.MulticastDelegate ارث‌بری می‌کنند که خودش از System.Delegate ارث‌بری می‌کند.<br>
کامپایلر سی‌شارپ تمام عملیات +، -، += و -= روی delegateها را به متدهای استاتیک Combine و Remove از کلاس System.Delegate تبدیل می‌کند.</p>
<h4>مثال Multicast Delegate 🛠️</h4>
<p>فرض کنید یک متدی نوشته‌اید که اجرای آن زمان زیادی می‌برد. این متد می‌تواند به طور منظم میزان پیشرفت کار را به فراخواننده گزارش دهد؛ این کار با فراخوانی یک delegate انجام می‌شود.</p>
<p>در مثال زیر، متد HardWork یک پارامتر از نوع delegate به نام ProgressReporter دریافت می‌کند و از آن برای نشان دادن پیشرفت استفاده می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ProgressReporter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> percentComplete</span>)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Util</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HardWork</span>(<span class="hljs-params">ProgressReporter p</span>)</span>
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
        {
            p(i * <span class="hljs-number">10</span>);                           <span class="hljs-comment">// فراخوانی delegate</span>
            System.Threading.Thread.Sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// شبیه‌سازی کار سنگین</span>
        }
    }
}
</code></pre>
<p>برای مانیتور کردن میزان پیشرفت، می‌توانیم یک نمونه‌ی Multicast Delegate به نام p بسازیم تا پیشرفت هم‌زمان توسط دو متد مستقل بررسی شود:</p>
<pre class="hljs"><code>ProgressReporter p = WriteProgressToConsole;
p += WriteProgressToFile;

Util.HardWork(p);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteProgressToConsole</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> percentComplete</span>)</span>
    =&gt; Console.WriteLine(percentComplete);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteProgressToFile</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> percentComplete</span>)</span>
    =&gt; System.IO.File.WriteAllText(<span class="hljs-string">&quot;progress.txt&quot;</span>,
                                    percentComplete.ToString());
</code></pre>
<p>🔍 در اینجا چه اتفاقی می‌افتد؟</p>
<ol>
<li>
<p>ابتدا یک delegate از نوع ProgressReporter ساخته می‌شود و به متد WriteProgressToConsole اشاره می‌کند.</p>
</li>
<li>
<p>سپس با عملگر +=، متد WriteProgressToFile هم به آن اضافه می‌شود.<br>
یعنی delegate p اکنون یک multicast delegate است.</p>
</li>
<li>
<p>هر بار که متد HardWork پیشرفت را گزارش می‌دهد (p(i * 10))، هر دو متد اجرا می‌شوند:</p>
</li>
</ol>
<ul>
<li>
<p>WriteProgressToConsole مقدار پیشرفت را روی کنسول چاپ می‌کند.</p>
</li>
<li>
<p>WriteProgressToFile مقدار پیشرفت را در یک فایل progress.txt ذخیره می‌کند.</p>
</li>
</ul>
<p>📊 نتیجه نهایی:</p>
<ul>
<li>
<p>شما همزمان در کنسول می‌بینید که پیشرفت کار چند درصد است.</p>
</li>
<li>
<p>یک فایل متنی هم دارید که همان اطلاعات را ذخیره می‌کند.</p>
</li>
</ul>
<h3>انواع Delegate عمومی (Generic Delegate Types) ⚡</h3>
<p>یک delegate می‌تواند شامل پارامترهای عمومی (Generic Type Parameters) باشد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> T <span class="hljs-title">Transformer</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T arg</span>)</span>;
</code></pre>
<p>با چنین تعریفی می‌توانیم یک متد ابزار عمومی (Utility Method) بنویسیم که روی هر نوع داده‌ای کار کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] values = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
Util.Transform(values, Square);      <span class="hljs-comment">// اتصال متد Square</span>

<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span> values)
    Console.Write(i + <span class="hljs-string">&quot;  &quot;</span>);         <span class="hljs-comment">// خروجی: 1   4   9</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Square</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Util</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Transform</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] values, Transformer&lt;T&gt; t</span>)</span>
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; values.Length; i++)
            values[i] = t(values[i]);
    }
}
</code></pre>
<h3>Delegates آماده: Func و Action ✅</h3>
<p>با معرفی generic delegates، این امکان فراهم شد که مجموعه‌ای کوچک از delegateها طراحی شوند که آن‌قدر عمومی و انعطاف‌پذیر باشند که برای متدهایی با هر نوع خروجی و هر تعداد (معقول) آرگومان قابل استفاده باشند.</p>
<p>این delegateها همان Func و Action هستند که در فضای نام System تعریف شده‌اند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;()</span>;                
<span class="hljs-function"><span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;(<span class="hljs-params">T arg</span>)</span>;          
<span class="hljs-function"><span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T1</span>, <span class="hljs-keyword">in</span> <span class="hljs-title">T2</span>, <span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;(<span class="hljs-params">T1 arg1, T2 arg2</span>)</span>;
<span class="hljs-comment">// ... ادامه دارد تا 16 پارامتر</span>

<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>()</span>;
<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">T arg</span>)</span>;
<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T1</span>, <span class="hljs-keyword">in</span> <span class="hljs-title">T2</span>&gt;(<span class="hljs-params">T1 arg1, T2 arg2</span>)</span>;
<span class="hljs-comment">// ... ادامه دارد تا 16 پارامتر</span>
</code></pre>
<p>📌 این‌ها بسیار عمومی و قدرتمند هستند.</p>
<p><strong>جایگزینی Transformer با Func 🔄</strong></p>
<p>در مثال قبلی، به جای تعریف delegate اختصاصی Transformer، می‌توانستیم از Func استفاده کنیم:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Transform</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] values, Func&lt;T, T&gt; transformer</span>)</span>
{
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; values.Length; i++)
        values[i] = transformer(values[i]);
}
</code></pre>
<p>در اینجا:</p>
<ul>
<li>
<p>Func&lt;T, T&gt; یعنی یک delegate که یک ورودی از نوع T می‌گیرد و خروجی هم از همان نوع T برمی‌گرداند.</p>
</li>
<li>
<p>دقیقاً همان چیزی است که قبلاً با Transformer<T> ساخته بودیم.</p>
</li>
</ul>
<p><strong>محدودیت‌ها 🚧</strong></p>
<p>تنها سناریوهای عملی که Func و Action پوشش نمی‌دهند، مواردی هستند که شامل پارامترهای ref/out یا pointer باشند.</p>
<p><strong>نکته تاریخی 🕰️</strong></p>
<p>زمانی که C# برای اولین بار معرفی شد، هنوز generics وجود نداشت. به همین دلیل، Func و Action هم وجود نداشتند.<br>
به همین خاطر، بخش زیادی از کتابخانه‌ی .NET از delegateهای سفارشی استفاده می‌کند، نه از Func و Action.</p>
<h3>مقایسه Delegate‌ها و Interface‌ها ⚔️</h3>
<p>هر مسئله‌ای که با یک delegate حل می‌شود، می‌تواند با یک interface هم حل شود.</p>
<p>به‌عنوان مثال، می‌توانیم نمونه‌ی اولیه‌مان را با استفاده از یک interface به نام ITransformer بازنویسی کنیم، به جای اینکه از delegate استفاده کنیم:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] values = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
Util.TransformAll(values, <span class="hljs-keyword">new</span> Squarer());

<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span> values)
    Console.WriteLine(i);

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ITransformer</span>
{
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Transform</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Util</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TransformAll</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] values, ITransformer t</span>)</span>
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; values.Length; i++)
            values[i] = t.Transform(values[i]);
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Squarer</span> : <span class="hljs-title">ITransformer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Transform</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x;
}
</code></pre>
<p>چه زمانی delegate انتخاب بهتری از interface است؟ ✅</p>
<p>طراحی با delegate ممکن است انتخاب بهتری باشد اگر یک یا چند مورد زیر برقرار باشند:</p>
<ul>
<li>
<p>🔹 interface فقط یک متد تعریف کرده باشد.</p>
</li>
<li>
<p>🔹 نیاز به multicast (اتصال چند متد به یک delegate) داشته باشیم.</p>
</li>
<li>
<p>🔹 یک subscriber مجبور باشد چند بار یک interface را پیاده‌سازی کند.</p>
</li>
</ul>
<p><strong>بررسی مثال 🔍</strong></p>
<p>در مثال ITransformer:</p>
<ul>
<li>
<p>ما نیازی به multicast نداریم.</p>
</li>
<li>
<p>اما interface فقط یک متد (Transform) تعریف کرده است.</p>
</li>
<li>
<p>از طرفی ممکن است بخواهیم چندین تبدیل مختلف (مثلاً مربع یا مکعب) را پیاده‌سازی کنیم.</p>
</li>
</ul>
<p>در چنین حالتی، اگر از interface استفاده کنیم، مجبور می‌شویم برای هر تبدیل یک کلاس جداگانه بسازیم، چون یک کلاس فقط یک بار می‌تواند ITransformer را پیاده‌سازی کند. این کار دست‌وپاگیر و تکراری می‌شود.</p>
<p>مثلاً:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] values = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
Util.TransformAll(values, <span class="hljs-keyword">new</span> Cuber());

<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span> values)
    Console.WriteLine(i);

<span class="hljs-keyword">class</span> <span class="hljs-title">Squarer</span> : <span class="hljs-title">ITransformer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Transform</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x;
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Cuber</span> : <span class="hljs-title">ITransformer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Transform</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x * x;
}
</code></pre>
<p>📌 نتیجه:</p>
<ul>
<li>
<p>با delegateها، پیاده‌سازی ساده‌تر و منعطف‌تر است (می‌توانیم به‌راحتی متدهای مختلفی مثل مربع یا مکعب را پاس بدهیم).</p>
</li>
<li>
<p>با interfaceها، مجبوریم برای هر عملگر یک کلاس جدید بسازیم.</p>
</li>
</ul>
<h3>سازگاری Delegate ها ⚖️</h3>
<h4>سازگاری نوع (Type Compatibility) 🏷️</h4>
<p>تمام نوع‌های delegate با هم ناسازگار هستند، حتی اگر امضا (signature) آن‌ها یکی باشد:</p>
<pre class="hljs"><code>D1 d1 = Method1;
D2 d2 = d1;   <span class="hljs-comment">// ❌ خطای زمان کامپایل</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>()</span> { }

<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D1</span>()</span>;
<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D2</span>()</span>;
</code></pre>
<p>🔹 اما این حالت مجاز است:</p>
<pre class="hljs"><code>D2 d2 = new D2(d1);   // ✅ درست
</code></pre>
<p><strong>مقایسه‌ی برابری (Equality) ✅</strong></p>
<p>دو نمونه‌ی delegate وقتی برابر محسوب می‌شوند که به یک متد یکسان اشاره کنند:</p>
<pre class="hljs"><code>D d1 = Method1;
D d2 = Method1;

Console.WriteLine(d1 == d2);   <span class="hljs-comment">// True</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>()</span> { }

<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D</span>()</span>;
</code></pre>
<p>🔹 در مورد multicast delegate‌ها هم، برابری وقتی برقرار است که به همان متدها و به همان ترتیب اشاره کنند.</p>
<h4>سازگاری پارامتر (Parameter Compatibility) 🔄</h4>
<p>وقتی یک متد را فراخوانی می‌کنید، می‌توانید آرگومانی بدهید که از نوع خاص‌تر از پارامتر متد باشد. این رفتار معمولی polymorphism است.</p>
<p>به همین دلیل، یک delegate هم می‌تواند پارامترهایی خاص‌تر از متد هدف خود داشته باشد. این ویژگی را contravariance می‌نامند.</p>
<p>مثال:</p>
<pre class="hljs"><code>StringAction sa = <span class="hljs-keyword">new</span> StringAction(ActOnObject);
sa(<span class="hljs-string">&quot;hello&quot;</span>);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ActOnObject</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> o</span>)</span> =&gt; Console.WriteLine(o);   <span class="hljs-comment">// خروجی: hello</span>

<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StringAction</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;
</code></pre>
<p>🔹 در اینجا StringAction یک متد را با پارامتر string فراخوانی می‌کند.<br>
🔹 اما متدی که واقعا اجرا می‌شود (ActOnObject) پارامترش از نوع object است.<br>
🔹 در این حالت، آرگومان string به‌طور خودکار تبدیل به object (upcast) می‌شود.</p>
<p><strong>3. ارتباط با الگوی استاندارد Event 🎯</strong></p>
<p>الگوی استاندارد event در C# طوری طراحی شده است که از contravariance استفاده کند.</p>
<ul>
<li>
<p>همه‌ی کلاس‌های رویداد از کلاس پایه‌ی مشترک EventArgs ارث‌بری می‌کنند.</p>
</li>
<li>
<p>بنابراین می‌توانید یک متد داشته باشید که توسط دو delegate مختلف فراخوانی شود:</p>
<ul>
<li>
<p>یکی رویداد MouseEventArgs پاس بدهد 🖱️</p>
</li>
<li>
<p>دیگری KeyEventArgs پاس بدهد ⌨️</p>
</li>
</ul>
</li>
</ul>
<p>این کار انعطاف‌پذیری بالایی در مدیریت رویدادها به شما می‌دهد.</p>
<p>📌 خلاصه:</p>
<ul>
<li>
<p>delegate type ها حتی با امضای یکسان هم ناسازگار هستند.</p>
</li>
<li>
<p>multicast delegateها برابرند اگر دقیقا همان متدها و ترتیب را داشته باشند.</p>
</li>
<li>
<p>contravariance اجازه می‌دهد متد هدف، پارامتر عام‌تر از delegate داشته باشد.</p>
</li>
<li>
<p>event pattern از همین ویژگی برای پشتیبانی از انواع مختلف رویدادها استفاده می‌کند.</p>
</li>
</ul>
<h4>سازگاری نوع بازگشتی در Delegateها (Return Type Compatibility) 🔄</h4>
<p>همان‌طور که وقتی یک متد را فراخوانی می‌کنید ممکن است نوعی خاص‌تر از چیزی که انتظار داشتید برگردد (رفتار معمولی polymorphism)؛ در مورد delegate‌ها هم همین موضوع صادق است.</p>
<p>یعنی متد هدف یک delegate می‌تواند نوع بازگشتی خاص‌تر از چیزی که delegate تعریف کرده داشته باشد.<br>
این ویژگی را covariance می‌نامند.</p>
<p>مثال: Covariance در نوع بازگشتی 📝</p>
<pre class="hljs"><code>ObjectRetriever o = <span class="hljs-keyword">new</span> ObjectRetriever(RetrieveString);
<span class="hljs-built_in">object</span> result = o();
Console.WriteLine(result);   <span class="hljs-comment">// hello</span>

<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">RetrieveString</span>()</span> =&gt; <span class="hljs-string">&quot;hello&quot;</span>;

<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">object</span> <span class="hljs-title">ObjectRetriever</span>()</span>;
</code></pre>
<p>🔹 اینجا ObjectRetriever انتظار دارد متدی که به آن متصل است، یک object برگرداند.<br>
🔹 اما در واقعیت، متد RetrieveString یک string برمی‌گرداند.<br>
🔹 چون string زیرکلاس object است، این مجاز است ✅.</p>
<p>📌 پس: نوع بازگشتی delegate ها covariant است.</p>
<h4>واریانس در Delegateهای جنریک ⚙️</h4>
<p>در فصل ۳ گفتیم که اینترفیس‌های جنریک می‌توانند از covariant و contravariant استفاده کنند.<br>
این قابلیت برای delegate‌های جنریک هم وجود دارد.</p>
<p><strong>قوانین خوب برای تعریف delegate جنریک:</strong></p>
<p>اگر پارامتر نوع (Type Parameter) فقط در خروجی استفاده می‌شود → با out (covariant) علامت‌گذاری شود.</p>
<p>اگر پارامتر نوع فقط در ورودی استفاده می‌شود → با in (contravariant) علامت‌گذاری شود.</p>
<p><strong>مثال ۱: Covariance در جنریک‌ها (با Func) 📤</strong></p>
<p>در فضای نام System داریم:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;()</span>;
</code></pre>
<p>این باعث می‌شود بتوانیم بنویسیم:</p>
<pre class="hljs"><code>Func&lt;<span class="hljs-built_in">string</span>&gt; x = () =&gt; <span class="hljs-string">&quot;Hello!&quot;</span>;
Func&lt;<span class="hljs-built_in">object</span>&gt; y = x;   <span class="hljs-comment">// ✅ مجاز به خاطر covariance</span>
</code></pre>
<p>🔹 یعنی می‌توانیم Func<string> را به Func<object> تبدیل کنیم چون string زیرکلاس object است.</p>
<p><strong>مثال ۲: Contravariance در جنریک‌ها (با Action) 📥</strong></p>
<p>باز هم در فضای نام System:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">T arg</span>)</span>;
</code></pre>
<p>این باعث می‌شود:</p>
<pre class="hljs"><code>Action&lt;<span class="hljs-built_in">object</span>&gt; x = obj =&gt; Console.WriteLine(obj);
Action&lt;<span class="hljs-built_in">string</span>&gt; y = x;   <span class="hljs-comment">// ✅ مجاز به خاطر contravariance</span>
</code></pre>
<p>🔹 یعنی می‌توانیم Action<object> را به Action<string> تبدیل کنیم چون متدی که انتظار دریافت object دارد، می‌تواند string هم بگیرد.</p>
<p>📌 خلاصه:</p>
<ul>
<li>
<p>نوع بازگشتی delegate می‌تواند خاص‌تر از نوع تعریف‌شده باشد → این covariance است.</p>
</li>
<li>
<p>در delegate جنریک:</p>
<ul>
<li>
<p>نوع خروجی (out) → covariant 📤</p>
</li>
<li>
<p>نوع ورودی (in) → contravariant 📥</p>
</li>
</ul>
</li>
</ul>
<p>این باعث می‌شود تبدیل‌ها بین delegateها به‌صورت طبیعی و بر اساس ارث‌بری انجام شوند.</p>
<h3>رویدادها (Events)</h3>
<p>هنگام استفاده از <strong>delegates</strong>، دو نقش معمولاً ظاهر می‌شوند: <strong>broadcaster</strong> و <strong>subscriber</strong>.</p>
<ul>
<li><strong>Broadcaster</strong> نوعی است که دارای یک فیلد delegate می‌باشد. این نوع تصمیم می‌گیرد که چه زمانی پیام را پخش کند، با <strong>invoke</strong> کردن delegate.</li>
<li><strong>Subscribers</strong> دریافت‌کنندگان هدف متد هستند. یک subscriber تصمیم می‌گیرد چه زمانی شروع به گوش دادن کند و چه زمانی آن را متوقف کند، با استفاده از عملگرهای <code>+=</code> و <code>-=</code> روی delegate مربوط به broadcaster. یک subscriber درباره دیگر subscribers اطلاعی ندارد و در عملکرد آن‌ها دخالتی نمی‌کند.</li>
</ul>
<h3>رویدادها در C# پیشرفته ⚡</h3>
<p>رویدادها یک ویژگی زبانی هستند که این الگو را رسمی می‌کنند. یک <strong>event</strong> یک ساختار است که تنها زیرمجموعه‌ای از قابلیت‌های delegate را که برای مدل <strong>broadcaster/subscriber</strong> لازم است، در معرض قرار می‌دهد. هدف اصلی رویدادها جلوگیری از دخالت subscribers در عملکرد یکدیگر است.</p>
<p>ساده‌ترین روش برای تعریف یک رویداد، استفاده از کلیدواژه <strong>event</strong> قبل از یک عضو delegate است:</p>
<pre class="hljs"><code><span class="hljs-comment">// تعریف delegate</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PriceChangedHandler</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> oldPrice, <span class="hljs-built_in">decimal</span> newPrice</span>)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Broadcaster</span>
{
    <span class="hljs-comment">// تعریف رویداد</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PriceChangedHandler PriceChanged;
}
</code></pre>
<p>کدی که داخل نوع <strong>Broadcaster</strong> قرار دارد، دسترسی کامل به <strong>PriceChanged</strong> دارد و می‌تواند آن را مانند یک delegate معمولی مدیریت کند. کدهای خارج از <strong>Broadcaster</strong> تنها می‌توانند عملیات <code>+=</code> و <code>-=</code> را روی رویداد <strong>PriceChanged</strong> انجام دهند.</p>
<p>✅ ادامه‌ی متن را ارسال کنید تا ترجمه بعدی را آماده کنم.</p>
<h3>چگونه رویدادها در درون کار می‌کنند؟ 🔍</h3>
<p>وقتی یک رویداد به شکل زیر تعریف می‌کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Broadcaster</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PriceChangedHandler PriceChanged;
}
</code></pre>
<p>سه اتفاق در پشت صحنه رخ می‌دهد:</p>
<p>1️⃣ ابتدا، <strong>کامپایلر</strong> تعریف رویداد را به چیزی شبیه به کد زیر ترجمه می‌کند:</p>
<pre class="hljs"><code>PriceChangedHandler priceChanged;   <span class="hljs-comment">// delegate خصوصی</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PriceChangedHandler PriceChanged
{
    <span class="hljs-keyword">add</span>    { priceChanged += <span class="hljs-keyword">value</span>; }
    <span class="hljs-keyword">remove</span> { priceChanged -= <span class="hljs-keyword">value</span>; }
}
</code></pre>
<p>کلیدواژه‌های <strong>add</strong> و <strong>remove</strong> نشان‌دهنده <strong>accessorهای رویداد صریح</strong> هستند—که عملکردی شبیه به <strong>accessorهای property</strong> دارند. بعداً درباره نحوه نوشتن این‌ها توضیح خواهیم داد.</p>
<p>2️⃣ دوم، کامپایلر داخل کلاس <strong>Broadcaster</strong> به دنبال ارجاعات به <strong>PriceChanged</strong> می‌گردد که عملیات دیگری غیر از <code>+=</code> یا <code>-=</code> انجام می‌دهند و آن‌ها را به فیلد delegate زیرین یعنی <strong>priceChanged</strong> هدایت می‌کند.</p>
<p>3️⃣ سوم، کامپایلر عملیات <code>+=</code> و <code>-=</code> روی رویداد را به فراخوانی <strong>add</strong> و <strong>remove</strong> accessorهای رویداد ترجمه می‌کند. جالب است بدانید که این کار باعث می‌شود رفتار <code>+=</code> و <code>-=</code> وقتی روی رویدادها اعمال می‌شوند، منحصربه‌فرد باشد: برخلاف سایر سناریوها، این‌ها تنها یک میانبر برای <code>+</code> و <code>-</code> به همراه انتساب نیستند.</p>
<p>مثالی را در نظر بگیرید 📈</p>
<p>کلاس <strong>Stock</strong> رویداد <strong>PriceChanged</strong> خود را هر بار که قیمت سهام تغییر می‌کند، فعال می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PriceChangedHandler</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> oldPrice, <span class="hljs-built_in">decimal</span> newPrice</span>)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span>
{
    <span class="hljs-built_in">string</span> symbol;
    <span class="hljs-built_in">decimal</span> price;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stock</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> symbol</span>)</span> =&gt; <span class="hljs-keyword">this</span>.symbol = symbol;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PriceChangedHandler PriceChanged;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Price
    {
        <span class="hljs-keyword">get</span> =&gt; price;
        <span class="hljs-keyword">set</span>
        {
            <span class="hljs-keyword">if</span> (price == <span class="hljs-keyword">value</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">// خروج اگر چیزی تغییر نکرده</span>
            <span class="hljs-built_in">decimal</span> oldPrice = price;
            price = <span class="hljs-keyword">value</span>;
            <span class="hljs-keyword">if</span> (PriceChanged != <span class="hljs-literal">null</span>)      <span class="hljs-comment">// اگر لیست فراخوانی خالی نیست</span>
                PriceChanged(oldPrice, price); <span class="hljs-comment">// رویداد فعال شود</span>
        }
    }
}
</code></pre>
<p>اگر کلیدواژه <strong>event</strong> را حذف کنیم و <strong>PriceChanged</strong> به یک فیلد معمولی delegate تبدیل شود، باز هم مثال ما همان نتایج را خواهد داد. اما کلاس <strong>Stock</strong> کمتر مقاوم خواهد بود، زیرا subscribers می‌توانند با یکدیگر تداخل ایجاد کنند، مثلاً:</p>
<ul>
<li>جایگزین کردن دیگر subscribers با انتساب مجدد <strong>PriceChanged</strong> به جای استفاده از عملگر <code>+=</code>.</li>
<li>پاک کردن تمام subscribers با انتساب <strong>PriceChanged</strong> به <code>null</code>.</li>
<li>ارسال پیام به subscribers دیگر با invoke کردن delegate.</li>
</ul>
<h3>الگوی استاندارد رویدادها 🛠️</h3>
<p>در تقریباً همه مواردی که رویدادها در کتابخانه‌های .NET تعریف می‌شوند، تعریف آن‌ها مطابق یک الگوی استاندارد است تا یکپارچگی بین کدهای کتابخانه و کاربر حفظ شود. در مرکز این الگو، کلاس <strong>System.EventArgs</strong> قرار دارد؛ یک کلاس از پیش تعریف‌شده در .NET که هیچ عضوی ندارد (به جز فیلد استاتیک <strong>Empty</strong>). <strong>EventArgs</strong> کلاس پایه‌ای برای انتقال اطلاعات مربوط به یک رویداد است.</p>
<p>در مثال Stock ما، برای انتقال قیمت قدیمی و جدید هنگام فعال شدن رویداد <strong>PriceChanged</strong>، کلاس EventArgs را به صورت زیر subclass می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PriceChangedEventArgs</span> : <span class="hljs-title">System.EventArgs</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">decimal</span> LastPrice;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">decimal</span> NewPrice;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriceChangedEventArgs</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> lastPrice, <span class="hljs-built_in">decimal</span> newPrice</span>)</span>
    {
        LastPrice = lastPrice;
        NewPrice = newPrice;
    }
}
</code></pre>
<p>برای استفاده مجدد، subclass EventArgs معمولاً بر اساس اطلاعاتی که شامل می‌شود نامگذاری می‌شود، نه بر اساس رویدادی که برای آن استفاده می‌شود. داده‌ها معمولاً به صورت property یا فیلد فقط‌خواندنی ارائه می‌شوند.</p>
<h3>انتخاب یا تعریف delegate برای رویداد 🎯</h3>
<p>سه قاعده وجود دارد:</p>
<p>1️⃣ نوع بازگشتی باید <strong>void</strong> باشد.<br>
2️⃣ دو آرگومان دریافت کند: آرگومان اول از نوع <strong>object</strong> و آرگومان دوم یک subclass از <strong>EventArgs</strong>. آرگومان اول نشان‌دهنده broadcaster و آرگومان دوم شامل اطلاعات اضافی برای انتقال است.<br>
3️⃣ نام delegate باید با <strong>EventHandler</strong> پایان یابد.</p>
<p>.NET یک delegate عمومی به نام <strong>System.EventHandler&lt;&gt;</strong> برای کمک به این کار تعریف کرده است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EventHandler</span>&lt;<span class="hljs-title">TEventArgs</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">object</span> source, TEventArgs e</span>)</span>;
</code></pre>
<p>قبل از وجود genericها در زبان (قبل از C# 2.0)، باید delegate سفارشی را به صورت زیر می‌نوشتیم:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PriceChangedHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, PriceChangedEventArgs e</span>)</span>;
</code></pre>
<p>به دلایل تاریخی، بیشتر رویدادها در کتابخانه‌های .NET از این روش استفاده می‌کنند.</p>
<h3>تعریف رویداد با delegate انتخاب‌شده 🔧</h3>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span>
{
    ...
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;
}
</code></pre>
<h3>نوشتن متد محافظت‌شده و virtual برای فعال کردن رویداد</h3>
<p>نام این متد باید همان نام رویداد باشد، با پیشوند <strong>On</strong>، و یک آرگومان <strong>EventArgs</strong> دریافت کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span>
{
    ...
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPriceChanged</span>(<span class="hljs-params">PriceChangedEventArgs e</span>)</span>
    {
        <span class="hljs-keyword">if</span> (PriceChanged != <span class="hljs-literal">null</span>) PriceChanged(<span class="hljs-keyword">this</span>, e);
    }
}
</code></pre>
<p>برای عملکرد مقاوم در سناریوهای چندنخی (multithreaded)، بهتر است delegate را قبل از تست و فراخوانی به یک متغیر موقت انتساب دهید:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> temp = PriceChanged;
<span class="hljs-keyword">if</span> (temp != <span class="hljs-literal">null</span>) temp(<span class="hljs-keyword">this</span>, e);
</code></pre>
<p>همچنین می‌توان با استفاده از <strong>null-conditional operator</strong> همان کار را بدون متغیر موقت انجام داد:</p>
<pre class="hljs"><code>PriceChanged?.Invoke(<span class="hljs-keyword">this</span>, e);
</code></pre>
<p>این روش هم <strong>thread-safe</strong> و هم مختصر است و بهترین روش عمومی برای فراخوانی رویدادها محسوب می‌شود.</p>
<h3>مثال کامل 💻</h3>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;

Stock stock = <span class="hljs-keyword">new</span> Stock(<span class="hljs-string">&quot;THPW&quot;</span>);
stock.Price = <span class="hljs-number">27.10</span>M;

<span class="hljs-comment">// ثبت برای رویداد PriceChanged</span>
stock.PriceChanged += stock_PriceChanged;
stock.Price = <span class="hljs-number">31.59</span>M;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stock_PriceChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, PriceChangedEventArgs e</span>)</span>
{
    <span class="hljs-keyword">if</span> ((e.NewPrice - e.LastPrice) / e.LastPrice &gt; <span class="hljs-number">0.1</span>M)
        Console.WriteLine(<span class="hljs-string">&quot;Alert, 10% stock price increase!&quot;</span>);
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PriceChangedEventArgs</span> : <span class="hljs-title">EventArgs</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">decimal</span> LastPrice;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">decimal</span> NewPrice;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriceChangedEventArgs</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> lastPrice, <span class="hljs-built_in">decimal</span> newPrice</span>)</span>
    {
        LastPrice = lastPrice; NewPrice = newPrice;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span>
{
    <span class="hljs-built_in">string</span> symbol;
    <span class="hljs-built_in">decimal</span> price;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stock</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> symbol</span>)</span> =&gt; <span class="hljs-keyword">this</span>.symbol = symbol;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPriceChanged</span>(<span class="hljs-params">PriceChangedEventArgs e</span>)</span>
    {
        PriceChanged?.Invoke(<span class="hljs-keyword">this</span>, e);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Price
    {
        <span class="hljs-keyword">get</span> =&gt; price;
        <span class="hljs-keyword">set</span>
        {
            <span class="hljs-keyword">if</span> (price == <span class="hljs-keyword">value</span>) <span class="hljs-keyword">return</span>;
            <span class="hljs-built_in">decimal</span> oldPrice = price;
            price = <span class="hljs-keyword">value</span>;
            OnPriceChanged(<span class="hljs-keyword">new</span> PriceChangedEventArgs(oldPrice, price));
        }
    }
}
</code></pre>
<h3>استفاده از EventHandler غیر عمومی</h3>
<p>وقتی رویداد نیاز به انتقال اطلاعات اضافی ندارد، می‌توان از <strong>EventHandler</strong> غیر generic استفاده کرد. در این مثال، کلاس <strong>Stock</strong> بازنویسی شده تا رویداد <strong>PriceChanged</strong> پس از تغییر قیمت فعال شود و تنها نیاز است بدانیم رویداد رخ داده است، بدون نیاز به اطلاعات اضافی. همچنین از <strong>EventArgs.Empty</strong> استفاده می‌کنیم تا از ایجاد غیرضروری یک نمونه EventArgs جلوگیری شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span>
{
    <span class="hljs-built_in">string</span> symbol;
    <span class="hljs-built_in">decimal</span> price;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stock</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> symbol</span>)</span> { <span class="hljs-keyword">this</span>.symbol = symbol; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler PriceChanged;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPriceChanged</span>(<span class="hljs-params">EventArgs e</span>)</span>
    {
        PriceChanged?.Invoke(<span class="hljs-keyword">this</span>, e);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Price
    {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> price; }
        <span class="hljs-keyword">set</span>
        {
            <span class="hljs-keyword">if</span> (price == <span class="hljs-keyword">value</span>) <span class="hljs-keyword">return</span>;
            price = <span class="hljs-keyword">value</span>;
            OnPriceChanged(EventArgs.Empty);
        }
    }
}
</code></pre>
<p><strong>Accessorهای رویدادها 🔑</strong></p>
<p>Accessorهای یک رویداد، پیاده‌سازی‌های عملگرهای <code>+=</code> و <code>-=</code> آن هستند. به طور پیش‌فرض، این accessors به صورت ضمنی توسط کامپایلر پیاده‌سازی می‌شوند. به مثال زیر توجه کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler PriceChanged;
</code></pre>
<p>کامپایلر این را به شکل زیر تبدیل می‌کند:</p>
<ul>
<li>یک فیلد delegate خصوصی</li>
<li>یک جفت تابع accessor عمومی برای رویداد (<strong>add_PriceChanged</strong> و <strong>remove_PriceChanged</strong>) که عملیات <code>+=</code> و <code>-=</code> را به فیلد delegate خصوصی هدایت می‌کنند</li>
</ul>
<p>شما می‌توانید این روند را با تعریف <strong>explicit event accessors</strong> به دست بگیرید. در اینجا پیاده‌سازی دستی رویداد <strong>PriceChanged</strong> از مثال قبلی آمده است:</p>
<pre class="hljs"><code><span class="hljs-keyword">private</span> EventHandler priceChanged;   <span class="hljs-comment">// تعریف یک delegate خصوصی</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler PriceChanged
{
    <span class="hljs-keyword">add</span>    { priceChanged += <span class="hljs-keyword">value</span>; }
    <span class="hljs-keyword">remove</span> { priceChanged -= <span class="hljs-keyword">value</span>; }
}
</code></pre>
<p>این مثال از نظر عملکرد با پیاده‌سازی پیش‌فرض C# یکسان است (به جز اینکه C# همچنین ایمنی در برابر چندنخی را با الگوریتم lock-free compare-and-swap تضمین می‌کند). با تعریف دستی accessors، به C# می‌گوییم که منطق پیش‌فرض فیلد و accessor را تولید نکند.</p>
<p>با استفاده از explicit event accessors، می‌توان استراتژی‌های پیچیده‌تری برای ذخیره و دسترسی به delegate زیرین اعمال کرد. سه سناریو که این کاربرد دارد:</p>
<p>1️⃣ وقتی accessors تنها به عنوان واسطه برای کلاس دیگری هستند که رویداد را پخش می‌کند.<br>
2️⃣ وقتی کلاس تعداد زیادی رویداد دارد اما اغلب تنها تعداد کمی subscriber وجود دارد، مثل کنترل‌های ویندوز. در این موارد بهتر است delegateهای subscribers را در یک <strong>dictionary</strong> ذخیره کنیم، زیرا dictionary حافظه کمتری نسبت به ده‌ها فیلد delegate خالی مصرف می‌کند.<br>
3️⃣ هنگام پیاده‌سازی explicit یک interface که رویدادی را تعریف کرده است.</p>
<p>نمونه‌ای برای مورد سوم:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IFoo</span> { <span class="hljs-keyword">event</span> EventHandler Ev; }

<span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> : <span class="hljs-title">IFoo</span>
{
    <span class="hljs-keyword">private</span> EventHandler ev;
    <span class="hljs-keyword">event</span> EventHandler IFoo.Ev
    {
        <span class="hljs-keyword">add</span>    { ev += <span class="hljs-keyword">value</span>; }
        <span class="hljs-keyword">remove</span> { ev -= <span class="hljs-keyword">value</span>; }
    }
}
</code></pre>
<p>بخش‌های <strong>add</strong> و <strong>remove</strong> یک رویداد به متدهای <strong>add_XXX</strong> و <strong>remove_XXX</strong> کامپایل می‌شوند.</p>
<hr>
<p><strong>Modifierهای رویدادها ⚡</strong></p>
<p>مثل متدها، رویدادها می‌توانند <strong>virtual</strong>، <strong>overridden</strong>، <strong>abstract</strong> یا <strong>sealed</strong> باشند. همچنین می‌توانند <strong>static</strong> باشند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> EventHandler&lt;EventArgs&gt; StaticEvent;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">event</span> EventHandler&lt;EventArgs&gt; VirtualEvent;
}
</code></pre>
<hr>
<p><strong>Lambda Expressions λ</strong></p>
<p>یک <strong>lambda expression</strong> متدی بدون نام است که به جای یک instance delegate نوشته می‌شود. کامپایلر بلافاصله آن را به یکی از موارد زیر تبدیل می‌کند:</p>
<ul>
<li>یک instance delegate</li>
<li>یا یک <strong>expression tree</strong> از نوع <code>Expression&lt;TDelegate&gt;</code> که کد داخل lambda را به صورت یک مدل شیء قابل پیمایش نمایش می‌دهد. این اجازه می‌دهد lambda بعداً در زمان اجرا تفسیر شود.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code>Transformer sqr = x =&gt; x * x;
Console.WriteLine(sqr(<span class="hljs-number">3</span>));   <span class="hljs-comment">// خروجی: 9</span>
<span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Transformer</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span>;
</code></pre>
<p>کامپایلر lambdaهای این نوع را با نوشتن یک متد خصوصی و انتقال کد expression به آن متد حل می‌کند.</p>
<p>فرم کلی یک lambda:</p>
<pre class="hljs"><code>(parameters) =&gt; expression-or-statement-block
</code></pre>
<p>اگر فقط یک پارامتر با نوع قابل استنتاج داشته باشیم، می‌توان پرانتزها را حذف کرد.</p>
<p>مثال:</p>
<pre class="hljs"><code>x =&gt; x * x;
</code></pre>
<p>هر پارامتر lambda متناظر با پارامتر delegate است و نوع expression (که ممکن است <strong>void</strong> باشد) متناظر با نوع بازگشتی delegate است.</p>
<p>می‌توان expression را به صورت یک بلوک statement نیز نوشت:</p>
<pre class="hljs"><code>x =&gt; { <span class="hljs-keyword">return</span> x * x; };
</code></pre>
<p>اغلب lambdaها همراه با <strong>Func</strong> و <strong>Action</strong> استفاده می‌شوند:</p>
<pre class="hljs"><code>Func&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt; sqr = x =&gt; x * x;
</code></pre>
<p>مثال با دو پارامتر:</p>
<pre class="hljs"><code>Func&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>,<span class="hljs-built_in">int</span>&gt; totalLength = (s1, s2) =&gt; s1.Length + s2.Length;
<span class="hljs-built_in">int</span> total = totalLength(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);   <span class="hljs-comment">// total = 10</span>
</code></pre>
<p>اگر نیازی به استفاده از پارامترها نیست، می‌توان آن‌ها را با underscore دور انداخت (از C# 9):</p>
<pre class="hljs"><code>Func&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>,<span class="hljs-built_in">int</span>&gt; totalLength = (_,_) =&gt; ...
</code></pre>
<p>مثال بدون آرگومان:</p>
<pre class="hljs"><code>Func&lt;<span class="hljs-built_in">string</span>&gt; greeter = () =&gt; <span class="hljs-string">&quot;Hello, world&quot;</span>;
</code></pre>
<p>از C# 10 به بعد، می‌توان از <strong>implicit typing</strong> برای lambda استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> greeter = () =&gt; <span class="hljs-string">&quot;Hello, world&quot;</span>;
</code></pre>
<h3>مشخص کردن صریح نوع پارامتر و نوع بازگشتی Lambda 🔧</h3>
<p>کامپایلر معمولاً می‌تواند نوع پارامترهای lambda را به صورت زمینه‌ای استنتاج کند. وقتی این امکان وجود نداشته باشد، باید نوع هر پارامتر را به صورت صریح مشخص کنید. به دو متد زیر توجه کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T x</span>)</span> { }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Action&lt;T&gt; a</span>)</span> { }
</code></pre>
<p>کد زیر <strong>کامپایل نمی‌شود</strong>، زیرا کامپایلر نمی‌تواند نوع <code>x</code> را استنتاج کند:</p>
<pre class="hljs"><code>Bar(x =&gt; Foo(x));   <span class="hljs-comment">// نوع x چیست؟</span>
</code></pre>
<p>می‌توان با مشخص کردن صریح نوع <code>x</code> مشکل را حل کرد:</p>
<pre class="hljs"><code>Bar((<span class="hljs-built_in">int</span> x) =&gt; Foo(x));
</code></pre>
<p>این مثال ساده را می‌توان به دو روش دیگر نیز اصلاح کرد:</p>
<pre class="hljs"><code>Bar&lt;<span class="hljs-built_in">int</span>&gt;(x =&gt; Foo(x));  <span class="hljs-comment">// مشخص کردن type parameter برای Bar</span>
Bar&lt;<span class="hljs-built_in">int</span>&gt;(Foo);          <span class="hljs-comment">// همانند بالا، با استفاده از method group</span>
</code></pre>
<p>مثالی دیگر از استفاده explicit برای نوع پارامتر (C# 10):</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> sqr = (<span class="hljs-built_in">int</span> x) =&gt; x * x;
</code></pre>
<p>کامپایلر <code>sqr</code> را به نوع <code>Func&lt;int,int&gt;</code> استنتاج می‌کند. بدون مشخص کردن <code>int</code>، استنتاج نوع شکست می‌خورد: کامپایلر می‌داند که sqr باید از نوع <code>Func&lt;T,T&gt;</code> باشد، اما نمی‌داند T چیست.</p>
<p>از C# 10 به بعد می‌توان نوع بازگشتی lambda را نیز مشخص کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> sqr = <span class="hljs-built_in">int</span> (<span class="hljs-built_in">int</span> x) =&gt; x;
</code></pre>
<p>مشخص کردن نوع بازگشتی می‌تواند عملکرد کامپایلر را در lambdaهای پیچیده و تو در تو بهبود دهد.</p>
<hr>
<h3>پارامترهای پیش‌فرض Lambda (C# 12) 🎯</h3>
<p>مانند متدهای معمولی که می‌توانند پارامتر اختیاری داشته باشند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message = <span class="hljs-string">&quot;&quot;</span></span>)</span> =&gt; Console.WriteLine(message);
</code></pre>
<p>lambdaها نیز می‌توانند پارامتر اختیاری داشته باشند:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> print = (<span class="hljs-built_in">string</span> message = <span class="hljs-string">&quot;&quot;</span>) =&gt; Console.WriteLine(message);
print(<span class="hljs-string">&quot;Hello&quot;</span>);
print();
</code></pre>
<p>این ویژگی برای کتابخانه‌هایی مانند <strong><a href="http://ASP.NET">ASP.NET</a> Minimal API</strong> مفید است.</p>
<hr>
<h3>دسترسی به متغیرهای خارجی (Outer Variables) 🌐</h3>
<p>یک lambda می‌تواند به هر متغیری که در محل تعریفش قابل دسترسی است، ارجاع دهد. این متغیرها <strong>outer variables</strong> نامیده می‌شوند و می‌توانند شامل متغیرهای محلی، پارامترها و فیلدها باشند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> factor = <span class="hljs-number">2</span>;
Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; multiplier = n =&gt; n * factor;
Console.WriteLine(multiplier(<span class="hljs-number">3</span>));   <span class="hljs-comment">// خروجی: 6</span>
</code></pre>
<p>متغیرهایی که توسط lambda ارجاع می‌شوند، <strong>captured variables</strong> نامیده می‌شوند. lambda که متغیرها را capture می‌کند، <strong>closure</strong> نامیده می‌شود.</p>
<p>متغیرهای capture شده هنگام فراخوانی delegate ارزیابی می‌شوند، نه هنگام capture شدن:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> factor = <span class="hljs-number">2</span>;
Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; multiplier = n =&gt; n * factor;
factor = <span class="hljs-number">10</span>;
Console.WriteLine(multiplier(<span class="hljs-number">3</span>));  <span class="hljs-comment">// خروجی: 30</span>
</code></pre>
<p>lambdaها می‌توانند خودشان متغیرهای capture شده را به‌روزرسانی کنند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> seed = <span class="hljs-number">0</span>;
Func&lt;<span class="hljs-built_in">int</span>&gt; natural = () =&gt; seed++;
Console.WriteLine(natural());  <span class="hljs-comment">// 0</span>
Console.WriteLine(natural());  <span class="hljs-comment">// 1</span>
Console.WriteLine(seed);       <span class="hljs-comment">// 2</span>
</code></pre>
<p>متغیرهای capture شده طول عمرشان تا طول عمر delegate ادامه پیدا می‌کند. مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> Func&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">Natural</span>()</span>
{
    <span class="hljs-built_in">int</span> seed = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> () =&gt; seed++;  <span class="hljs-comment">// برمی‌گرداند یک closure</span>
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
{
    Func&lt;<span class="hljs-built_in">int</span>&gt; natural = Natural();
    Console.WriteLine(natural()); <span class="hljs-comment">// 0</span>
    Console.WriteLine(natural()); <span class="hljs-comment">// 1</span>
}
</code></pre>
<p>اگر متغیر محلی را داخل خود lambda بسازیم، هر فراخوانی delegate یک متغیر جدید ایجاد می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> Func&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">Natural</span>()</span>
{
    <span class="hljs-keyword">return</span> () =&gt; { <span class="hljs-built_in">int</span> seed = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> seed++; };
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
{
    Func&lt;<span class="hljs-built_in">int</span>&gt; natural = Natural();
    Console.WriteLine(natural());  <span class="hljs-comment">// 0</span>
    Console.WriteLine(natural());  <span class="hljs-comment">// 0</span>
}
</code></pre>
<p>پیاده‌سازی capture داخلی با <strong>hoisting</strong> انجام می‌شود: متغیرهای capture شده به فیلدهای یک کلاس خصوصی منتقل می‌شوند و هنگام فراخوانی متد، کلاس ایجاد شده و به delegate وابسته می‌شود.</p>
<hr>
<h3>Lambdaهای استاتیک ⚡</h3>
<p>زمانی که lambda متغیرهای محلی، پارامترها، فیلدهای instance یا <strong>this</strong> را capture می‌کند، کامپایلر ممکن است کلاس خصوصی ایجاد کند تا ارجاع به داده‌ها ذخیره شود. این باعث مصرف حافظه می‌شود.</p>
<p>از C# 9 به بعد می‌توان با <strong>static</strong> کردن lambda، local function یا anonymous method، از capture شدن state جلوگیری کرد:</p>
<pre class="hljs"><code>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; multiplier = <span class="hljs-keyword">static</span> n =&gt; n * <span class="hljs-number">2</span>;
</code></pre>
<p>اگر بعداً lambda بخواهد متغیری را capture کند، کامپایلر خطا می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> factor = <span class="hljs-number">2</span>;
Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; multiplier = <span class="hljs-keyword">static</span> n =&gt; n * factor;  <span class="hljs-comment">// کامپایل نمی‌شود</span>
</code></pre>
<p>lambda بدون capture، یک instance delegate کش شده را مجدداً استفاده می‌کند و هزینه‌ای ندارد.</p>
<p>lambdaهای استاتیک هنوز می‌توانند به متغیرها و ثابت‌های static دسترسی داشته باشند. <strong>static</strong> تنها نقش بررسی دارد و تاثیری بر IL تولیدشده ندارد؛ بدون آن، کامپایلر در صورت نیاز closure تولید می‌کند، اما حتی آن زمان ترفندهایی برای کاهش هزینه دارد.</p>
<h3>گرفتن متغیرهای تکرار (Capturing iteration variables) 🔄</h3>
<p>وقتی در یک حلقه‌ی <code>for</code> متغیر تکرار (iteration variable) را <strong>Capture</strong> می‌کنید، زبان C# با آن طوری رفتار می‌کند که انگار <strong>بیرون از حلقه تعریف شده باشد</strong>. یعنی در هر تکرار، همان متغیر گرفته می‌شود. به همین دلیل برنامه‌ی زیر به‌جای نمایش <code>012</code>، مقدار <code>333</code> را چاپ می‌کند:</p>
<pre class="hljs"><code>Action[] actions = <span class="hljs-keyword">new</span> Action[<span class="hljs-number">3</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
    actions[i] = () =&gt; Console.Write(i);

<span class="hljs-keyword">foreach</span> (Action a <span class="hljs-keyword">in</span> actions) a();     <span class="hljs-comment">// 333</span>
</code></pre>
<p>هر <strong>closure</strong> (بخش پررنگ شده) همان متغیر <code>i</code> را می‌گیرد. این منطقی است، چون <code>i</code> متغیری است که مقدارش بین تکرارهای حلقه باقی می‌ماند؛ حتی می‌توانید داخل بدنه‌ی حلقه، مقدار <code>i</code> را تغییر دهید. نتیجه این است که وقتی <strong>delegate</strong>ها بعداً فراخوانی می‌شوند، همگی مقدار <code>i</code> در لحظه‌ی فراخوانی را می‌بینند، یعنی <code>3</code>. برای درک بهتر، حلقه را این‌طور بازنویسی کنید:</p>
<pre class="hljs"><code>Action[] actions = <span class="hljs-keyword">new</span> Action[<span class="hljs-number">3</span>];
<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;
actions[<span class="hljs-number">0</span>] = () =&gt; Console.Write(i);
i = <span class="hljs-number">1</span>;
actions[<span class="hljs-number">1</span>] = () =&gt; Console.Write(i);
i = <span class="hljs-number">2</span>;
actions[<span class="hljs-number">2</span>] = () =&gt; Console.Write(i);
i = <span class="hljs-number">3</span>;
<span class="hljs-keyword">foreach</span> (Action a <span class="hljs-keyword">in</span> actions) a();    <span class="hljs-comment">// 333</span>
</code></pre>
<p>راه‌حل برای نمایش <code>012</code> این است که متغیر تکرار را به یک <strong>متغیر محلی جدید</strong> که در همان محدوده‌ی حلقه قرار دارد، انتساب دهیم:</p>
<pre class="hljs"><code>Action[] actions = <span class="hljs-keyword">new</span> Action[<span class="hljs-number">3</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
{
    <span class="hljs-built_in">int</span> loopScopedi = i;
    actions[i] = () =&gt; Console.Write(loopScopedi);
}
<span class="hljs-keyword">foreach</span> (Action a <span class="hljs-keyword">in</span> actions) a();     <span class="hljs-comment">// 012</span>
</code></pre>
<p>چون در هر تکرار، یک متغیر جدید <code>loopScopedi</code> ساخته می‌شود، هر <strong>closure</strong> یک متغیر متفاوت را می‌گیرد. ✨</p>
<blockquote>
<p><strong>نکته:</strong> قبل از نسخه‌ی C# 5.0، حلقه‌های <code>foreach</code> هم همین رفتار را داشتند و باعث سردرگمی می‌شدند. چون متغیر در <code>foreach</code> تغییرناپذیر است، انتظار می‌رفت محلی باشد، ولی نبود. خوشبختانه این موضوع اصلاح شده و حالا می‌توانید متغیرهای <code>foreach</code> را بدون نگرانی Capture کنید. ✅</p>
</blockquote>
<hr>
<h3>مقایسه‌ی <strong>Lambda Expressions</strong> و <strong>Local Methods</strong> 🆚</h3>
<p>عملکرد <strong>local methods</strong> (بخش «Local methods» در صفحه 106) شباهت زیادی به <strong>lambda expressions</strong> دارد، اما سه مزیت دارند:</p>
<ol>
<li>می‌توانند <strong>بازگشتی (recursive)</strong> باشند (خودشان را صدا بزنند) بدون نیاز به روش‌های پیچیده.</li>
<li>نیاز به مشخص کردن نوع delegate ندارند و کد شلوغ نمی‌شود.</li>
<li><strong>کارایی بیشتری</strong> دارند چون سربار delegate را حذف می‌کنند.</li>
</ol>
<p><strong>Local methods</strong> بهینه‌تر هستند چون از واسطه‌ی delegate استفاده نمی‌کنند (این کار باعث صرف مقداری CPU و حافظه می‌شود). همچنین می‌توانند به متغیرهای محلی متد والد دسترسی داشته باشند بدون اینکه کامپایلر مجبور به <strong>hoist کردن</strong> آن‌ها در یک کلاس مخفی باشد.</p>
<p>اما در بسیاری از موارد شما به delegate نیاز دارید؛ مثل وقتی که می‌خواهید متدی با پارامتر از نوع delegate را صدا بزنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>&gt; predicate</span>)</span> { ... }
</code></pre>
<p>(نمونه‌های بیشتری در فصل 8 خواهید دید.) در این مواقع، استفاده از <strong>lambda</strong> معمولاً کوتاه‌تر و تمیزتر است.</p>
<hr>
<h3>متدهای ناشناس (Anonymous Methods) 🕶️</h3>
<p><strong>Anonymous methods</strong> قابلیتی در C# 2.0 بودند که تا حد زیادی با <strong>lambda expressions</strong> در C# 3.0 جایگزین شدند. متدهای ناشناس مثل lambda هستند، اما امکانات زیر را ندارند:</p>
<ul>
<li><strong>پارامترهای نوع‌دهی ضمنی (implicitly typed)</strong></li>
<li><strong>نوشتار به شکل expression</strong> (همیشه باید به صورت بلوک بیانیه باشند)</li>
<li>توانایی <strong>تبدیل به Expression Tree</strong> با <code>Expression&lt;T&gt;</code></li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Transformer</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span>;
Transformer sqr = <span class="hljs-built_in">delegate</span> (<span class="hljs-built_in">int</span> x) { <span class="hljs-keyword">return</span> x * x; };
Console.WriteLine(sqr(<span class="hljs-number">3</span>));  <span class="hljs-comment">// 9</span>
</code></pre>
<p>این معادل نوشتار زیر با lambda است:</p>
<pre class="hljs"><code>Transformer sqr = (<span class="hljs-built_in">int</span> x) =&gt; { <span class="hljs-keyword">return</span> x * x; };
<span class="hljs-comment">// یا ساده‌تر:</span>
Transformer sqr = x =&gt; x * x;
</code></pre>
<p>متدهای ناشناس هم مثل lambdaها متغیرهای بیرونی را Capture می‌کنند و حتی می‌توانند با کلمه‌ی کلیدی <code>static</code> شبیه lambdaهای استاتیک رفتار کنند.</p>
<p>ویژگی خاص آن‌ها این است که <strong>می‌توان پارامترها را کاملاً حذف کرد</strong>، حتی اگر delegate آن‌ها را انتظار داشته باشد. این برای تعریف event با handler خالی مفید است:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler Clicked = <span class="hljs-built_in">delegate</span> { };
</code></pre>
<p>این کار باعث می‌شود قبل از صدا زدن event نیازی به بررسی null نداشته باشید. همچنین نوشتن زیر هم معتبر است:</p>
<pre class="hljs"><code><span class="hljs-comment">// پارامترها حذف شده‌اند:</span>
Clicked += <span class="hljs-built_in">delegate</span> { Console.WriteLine(<span class="hljs-string">&quot;clicked&quot;</span>); };
</code></pre>
<hr>
<h3>دستورات try و مدیریت استثناها (try Statements and Exceptions) ⚠️</h3>
<p>یک دستور <code>try</code> یک بلوک کد را مشخص می‌کند که ممکن است خطا رخ دهد یا نیاز به پاکسازی داشته باشد. بلوک <code>try</code> باید حداقل با یک <code>catch</code> یا یک <code>finally</code> (یا هر دو) همراه باشد:</p>
<ul>
<li><strong>catch</strong> زمانی اجرا می‌شود که خطا در بلوک try رخ دهد.</li>
<li><strong>finally</strong> همیشه بعد از خروج از try (یا catch) اجرا می‌شود و معمولاً برای کارهای پاکسازی مثل بستن اتصالات شبکه است.</li>
</ul>
<p><code>catch</code> به شیء <code>Exception</code> دسترسی دارد که اطلاعات خطا را نگه می‌دارد. شما می‌توانید خطا را مدیریت کنید یا دوباره پرتاب کنید (برای لاگ کردن یا بالا بردن سطح خطا).</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span>
{
    <span class="hljs-comment">// ممکن است خطا رخ دهد</span>
}
<span class="hljs-keyword">catch</span> (ExceptionA ex)
{
    <span class="hljs-comment">// مدیریت خطای نوع ExceptionA</span>
}
<span class="hljs-keyword">catch</span> (ExceptionB ex)
{
    <span class="hljs-comment">// مدیریت خطای نوع ExceptionB</span>
}
<span class="hljs-keyword">finally</span>
{
    <span class="hljs-comment">// پاکسازی</span>
}
</code></pre>
<p>برنامه‌ی زیر را در نظر بگیرید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> y = Calc(<span class="hljs-number">0</span>);
Console.WriteLine(y);

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Calc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; <span class="hljs-number">10</span> / x;
</code></pre>
<p>چون <code>x</code> صفر است، خطای <code>DivideByZeroException</code> رخ می‌دهد و برنامه متوقف می‌شود. حالا با <code>try/catch</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span>
{
    <span class="hljs-built_in">int</span> y = Calc(<span class="hljs-number">0</span>);
    Console.WriteLine(y);
}
<span class="hljs-keyword">catch</span> (DivideByZeroException ex)
{
    Console.WriteLine(<span class="hljs-string">&quot;x cannot be zero&quot;</span>);
}
Console.WriteLine(<span class="hljs-string">&quot;program completed&quot;</span>);

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Calc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; <span class="hljs-number">10</span> / x;
</code></pre>
<p>خروجی:</p>
<pre class="hljs"><code>x cannot be zero
program completed
</code></pre>
<p>در عمل، بهتر است <strong>خطاهای قابل پیشگیری را قبل از وقوع بررسی کنید</strong>، مثلاً تقسیم بر صفر را چک کنید، چون <strong>exceptionها هزینه‌بر هستند</strong> (صدها سیکل پردازنده یا بیشتر).</p>
<p>وقتی exception رخ می‌دهد، CLR بررسی می‌کند:</p>
<ul>
<li>اگر <code>catch</code> سازگار پیدا شد: همان را اجرا می‌کند، سپس <code>finally</code> و برنامه ادامه می‌یابد.</li>
<li>اگر پیدا نشد: <code>finally</code> اجرا می‌شود (اگر باشد) و CLR به عقب در stack دنبال <code>try</code> می‌گردد.</li>
<li>اگر هیچ تابعی مسئولیت نگرفت: برنامه متوقف می‌شود.</li>
</ul>
<hr>
<h3>بخش catch (بخش گرفتن استثناها) 🛡️</h3>
<p>یک <strong>catch clause</strong> مشخص می‌کند که چه نوع استثنایی (<strong>Exception</strong>) باید گرفته شود. این نوع باید یا <strong>System.Exception</strong> باشد یا یک زیرکلاس از <strong>System.Exception</strong>.</p>
<p>اگر <strong>System.Exception</strong> را بگیرید، تمام خطاهای ممکن را خواهید گرفت. این کار در شرایط زیر مفید است:</p>
<ul>
<li>وقتی برنامه‌تان می‌تواند بدون توجه به نوع خاص استثنا، بهبود یابد.</li>
<li>وقتی قصد دارید استثنا را دوباره پرتاب کنید (مثلاً بعد از ثبت یا <strong>Log</strong> کردن آن).</li>
<li>وقتی هندلر خطای شما آخرین خط دفاعی قبل از پایان برنامه است.</li>
</ul>
<p>اما در حالت معمول، بهتر است نوع‌های خاص استثنا را بگیرید تا مجبور نشوید با شرایطی روبه‌رو شوید که هندلر شما برای آن طراحی نشده است (مثلاً <strong>OutOfMemoryException</strong>).</p>
<p>برای مدیریت چند نوع استثنا، می‌توانید از چندین بخش <strong>catch</strong> استفاده کنید (هرچند در این مثال می‌توان به جای مدیریت استثنا، بررسی ورودی‌ها را انجام داد):</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span>
  {
    <span class="hljs-keyword">try</span>
    {
      <span class="hljs-built_in">byte</span> b = <span class="hljs-built_in">byte</span>.Parse (<span class="hljs-keyword">args</span>[<span class="hljs-number">0</span>]);
      Console.WriteLine (b);
    }
    <span class="hljs-keyword">catch</span> (IndexOutOfRangeException)
    {
      Console.WriteLine (<span class="hljs-string">&quot;Please provide at least one argument&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (FormatException)
    {
      Console.WriteLine (<span class="hljs-string">&quot;That&#x27;s not a number!&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (OverflowException)
    {
      Console.WriteLine (<span class="hljs-string">&quot;You&#x27;ve given me more than a byte!&quot;</span>);
    }
  }
}
</code></pre>
<p>برای هر استثنا فقط یک <strong>catch</strong> اجرا می‌شود. اگر می‌خواهید یک هندلر کلی مثل <strong>System.Exception</strong> داشته باشید، باید هندلرهای خاص‌تر را قبل از آن قرار دهید.</p>
<p>گاهی نیاز ندارید به ویژگی‌های استثنا دسترسی داشته باشید. در این حالت می‌توانید متغیر را حذف کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">catch</span> (OverflowException)   <span class="hljs-comment">// بدون متغیر</span>
{
  ...
}
</code></pre>
<p>حتی می‌توانید هم متغیر و هم نوع را حذف کنید (به این معنی که همه استثناها گرفته می‌شوند):</p>
<pre class="hljs"><code><span class="hljs-keyword">catch</span> { ... }
</code></pre>
<hr>
<h3>Exception filters (فیلترهای استثنا) 🔍</h3>
<p>می‌توانید در بخش <strong>catch</strong> یک فیلتر استثنا با استفاده از کلمه <strong>when</strong> مشخص کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">catch</span> (WebException ex) <span class="hljs-keyword">when</span> (ex.Status == WebExceptionStatus.Timeout)
{
  ...
}
</code></pre>
<p>در این مثال، اگر <strong>WebException</strong> پرتاب شود، عبارت بولی بعد از <strong>when</strong> ارزیابی می‌شود. اگر نتیجه <strong>false</strong> باشد، این <strong>catch</strong> نادیده گرفته شده و به سراغ <strong>catch</strong>های بعدی می‌رود.</p>
<p>با <strong>exception filters</strong> می‌توان یک نوع استثنا را چند بار با شرایط متفاوت گرفت:</p>
<pre class="hljs"><code><span class="hljs-keyword">catch</span> (WebException ex) <span class="hljs-keyword">when</span> (ex.Status == WebExceptionStatus.Timeout)
{ ... }
<span class="hljs-keyword">catch</span> (WebException ex) <span class="hljs-keyword">when</span> (ex.Status == WebExceptionStatus.SendFailure)
{ ... }
</code></pre>
<p>عبارت بولی در <strong>when</strong> حتی می‌تواند شامل متدهایی باشد که عملیات جانبی انجام می‌دهند، مانند ثبت خطا برای اهداف عیب‌یابی.</p>
<hr>
<h3>بخش finally (بخش پایانی) 🧹</h3>
<p>بخش <strong>finally</strong> همیشه اجرا می‌شود—چه استثنا رخ دهد چه نه، و چه <strong>try</strong> به طور کامل اجرا شود یا خیر. معمولاً از <strong>finally</strong> برای کدهای پاک‌سازی استفاده می‌کنیم.</p>
<p>بخش <strong>finally</strong> بعد از هر یک از این حالت‌ها اجرا می‌شود:</p>
<ul>
<li>بعد از اتمام یک <strong>catch</strong> (یا زمانی که یک استثنای جدید پرتاب شود).</li>
<li>بعد از اتمام بلوک <strong>try</strong> (یا زمانی که استثنایی رخ دهد که هندلری برایش وجود ندارد).</li>
<li>زمانی که کنترل با یک دستور پرش (مثل <strong>return</strong> یا <strong>goto</strong>) از بلوک <strong>try</strong> خارج شود.</li>
</ul>
<p>تنها مواردی که می‌توانند مانع اجرای <strong>finally</strong> شوند، یک حلقه بی‌نهایت یا پایان ناگهانی پردازش است.</p>
<p>بخش <strong>finally</strong> به برنامه‌تان نظم و قطعیت اضافه می‌کند. در مثال زیر، فایلی که باز شده همیشه بسته می‌شود، صرف‌نظر از اینکه:</p>
<ul>
<li>بلوک <strong>try</strong> به طور عادی تمام شود.</li>
<li>اجرا به دلیل خالی بودن فایل (<strong>EndOfStream</strong>) زودتر بازگردد.</li>
<li>یک <strong>IOException</strong> هنگام خواندن فایل رخ دهد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReadFile</span>()</span>
{
  StreamReader reader = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// در فضای نام System.IO</span>
  <span class="hljs-keyword">try</span>
  {
    reader = File.OpenText (<span class="hljs-string">&quot;file.txt&quot;</span>);
    <span class="hljs-keyword">if</span> (reader.EndOfStream) <span class="hljs-keyword">return</span>;
    Console.WriteLine (reader.ReadToEnd());
  }
  <span class="hljs-keyword">finally</span>
  {
    <span class="hljs-keyword">if</span> (reader != <span class="hljs-literal">null</span>) reader.Dispose();
  }
}
</code></pre>
<p>در این مثال، فایل را با فراخوانی <strong>Dispose</strong> روی <strong>StreamReader</strong> بستیم. فراخوانی <strong>Dispose</strong> روی یک شیء در داخل <strong>finally</strong> یک روش استاندارد است و در #C با دستور <strong>using</strong> نیز پشتیبانی می‌شود.</p>
<hr>
<h3>دستور <code>using</code> ♻️</h3>
<p>بسیاری از کلاس‌ها منابع مدیریت‌نشده (Unmanaged Resources) مانند <strong>دستگیره‌های فایل (File Handles)</strong>، <strong>دستگیره‌های گرافیکی (Graphics Handles)</strong> یا <strong>اتصالات پایگاه داده (Database Connections)</strong> را در خود جای می‌دهند. این کلاس‌ها اینترفیس <strong><code>System.IDisposable</code></strong> را پیاده‌سازی می‌کنند که تنها یک متد بدون پارامتر به نام <strong><code>Dispose</code></strong> دارد و برای پاک‌سازی این منابع استفاده می‌شود.</p>
<p>دستور <strong><code>using</code></strong> یک نگارش ساده و شکیل برای فراخوانی <strong><code>Dispose</code></strong> روی یک شیء پیاده‌ساز <strong><code>IDisposable</code></strong>، درون یک بلوک <strong><code>finally</code></strong> فراهم می‌کند.</p>
<p>به‌عنوان مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (StreamReader reader = File.OpenText(<span class="hljs-string">&quot;file.txt&quot;</span>))
{
    ...
}
</code></pre>
<p>این قطعه‌کد دقیقاً معادل زیر است:</p>
<pre class="hljs"><code>StreamReader reader = File.OpenText(<span class="hljs-string">&quot;file.txt&quot;</span>);
<span class="hljs-keyword">try</span>
{
    ...
}
<span class="hljs-keyword">finally</span>
{
    <span class="hljs-keyword">if</span> (reader != <span class="hljs-literal">null</span>)
        ((IDisposable)reader).Dispose();
}
</code></pre>
<hr>
<h3>اعلان‌های <code>using</code> (Using Declarations) ✍️</h3>
<p>اگر در <strong>C# 8 و نسخه‌های بالاتر</strong>، براکت‌ها و بلوک کد بعد از دستور <strong><code>using</code></strong> حذف شوند، این دستور تبدیل به <strong>اعلان using</strong> می‌شود. در این حالت، منبع زمانی آزاد می‌شود که اجرای برنامه از بلوک محصورکننده خارج گردد.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (File.Exists(<span class="hljs-string">&quot;file.txt&quot;</span>))
{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> reader = File.OpenText(<span class="hljs-string">&quot;file.txt&quot;</span>);
    Console.WriteLine(reader.ReadLine());
    ...
}
</code></pre>
<p>در این حالت، <strong><code>reader</code></strong> زمانی Dispose می‌شود که اجرای برنامه از بلوک <strong><code>if</code></strong> خارج شود.</p>
<hr>
<h3>پرتاب استثنا (Throwing Exceptions) 🚀</h3>
<p>استثناها (Exceptions) می‌توانند هم توسط <strong>زمان اجرا (Runtime)</strong> و هم در <strong>کدهای کاربر</strong> پرتاب شوند. در مثال زیر، متد <strong><code>Display</code></strong> یک استثنای <strong><code>System.ArgumentNullException</code></strong> را پرتاب می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> { Display(<span class="hljs-literal">null</span>); }
<span class="hljs-keyword">catch</span> (ArgumentNullException ex)
{
    Console.WriteLine(<span class="hljs-string">&quot;Caught the exception&quot;</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>
{
    <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(name));
    Console.WriteLine(name);
}
</code></pre>
<p>از آن‌جایی که بررسی آرگومان برای مقدار <strong>null</strong> و پرتاب <strong><code>ArgumentNullException</code></strong> بسیار رایج است، از <strong>.NET 6</strong> یک میان‌بر ارائه شده است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>
{
    ArgumentNullException.ThrowIfNull(name);
    Console.WriteLine(name);
}
</code></pre>
<p>توجه کنید که در این روش، نیازی به مشخص کردن نام پارامتر نداریم. دلیل این موضوع در بخش <strong>CallerArgumentExpression</strong> (صفحه 247) توضیح داده خواهد شد.</p>
<hr>
<h3>عبارت‌های <code>throw</code> (Throw Expressions) 🎯</h3>
<p>عبارت <strong><code>throw</code></strong> می‌تواند به‌عنوان یک <strong>عبارت (Expression)</strong> در متدهای <strong>Expression-bodied</strong> استفاده شود:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Foo</span>()</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();
</code></pre>
<p>همچنین می‌تواند در یک <strong>عبارت شرطی سه‌تایی (Ternary Conditional Expression)</strong> ظاهر شود:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ProperCase</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span> =&gt;
    <span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span> ? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;value&quot;</span>) :
    <span class="hljs-keyword">value</span> == <span class="hljs-string">&quot;&quot;</span> ? <span class="hljs-string">&quot;&quot;</span> :
    <span class="hljs-built_in">char</span>.ToUpper(<span class="hljs-keyword">value</span>[<span class="hljs-number">0</span>]) + <span class="hljs-keyword">value</span>.Substring(<span class="hljs-number">1</span>);
</code></pre>
<hr>
<h3>پرتاب دوباره استثنا (Rethrowing an Exception) 🔄</h3>
<p>می‌توانید یک استثنا را گرفته و دوباره پرتاب کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span>
{
    ...
}
<span class="hljs-keyword">catch</span> (Exception ex)
{
    <span class="hljs-comment">// Log error</span>
    ...
    <span class="hljs-keyword">throw</span>; <span class="hljs-comment">// پرتاب دوباره همان استثنا</span>
}
</code></pre>
<p>اگر به‌جای <strong><code>throw</code></strong> از <strong><code>throw ex</code></strong> استفاده کنیم، برنامه همچنان کار می‌کند اما خاصیت <strong><code>StackTrace</code></strong> دیگر مسیر خطای اصلی را نشان نمی‌دهد.</p>
<p>پرتاب دوباره به شما اجازه می‌دهد خطا را <strong>ثبت (Log)</strong> کنید بدون اینکه آن را نادیده بگیرید، یا زمانی که شرایط فراتر از انتظار است، از ادامه مدیریت خطا صرف‌نظر کنید.</p>
<p>یکی دیگر از سناریوهای رایج، پرتاب یک استثنای <strong>خاص‌تر</strong> است:</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span>
{
    <span class="hljs-comment">// Parse a DateTime from XML element data</span>
}
<span class="hljs-keyword">catch</span> (FormatException ex)
{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> XmlException(<span class="hljs-string">&quot;Invalid DateTime&quot;</span>, ex);
}
</code></pre>
<p>دقت کنید که هنگام ساخت <strong><code>XmlException</code></strong>، استثنای اصلی <strong><code>ex</code></strong> را به‌عنوان آرگومان دوم پاس دادیم. این آرگومان خاصیت <strong><code>InnerException</code></strong> را مقداردهی می‌کند و در اشکال‌زدایی کمک زیادی می‌کند. تقریباً همه انواع استثنا چنین سازنده‌ای دارند.</p>
<hr>
<h3>پرتاب یک استثنای کلی‌تر (Less-Specific Exception)</h3>
<p>این روش زمانی مفید است که در حال عبور از یک <strong>مرز اعتماد (Trust Boundary)</strong> هستید تا از افشای اطلاعات فنی برای مهاجمان بالقوه جلوگیری کنید.</p>
<hr>
<h3>ویژگی‌های کلیدی <strong>System.Exception</strong> ⚙️</h3>
<p>مهم‌ترین ویژگی‌های <strong>System.Exception</strong> به شرح زیر هستند:</p>
<ul>
<li>
<p><strong>StackTrace</strong><br>
رشته‌ای (<strong>string</strong>) که تمام متدهایی را که از نقطه شروع رخداد استثنا تا بلوک <strong>catch</strong> فراخوانی شده‌اند، نمایش می‌دهد.</p>
</li>
<li>
<p><strong>Message</strong><br>
رشته‌ای که توضیح خطا را در خود نگه می‌دارد.</p>
</li>
<li>
<p><strong>InnerException</strong><br>
استثنای داخلی (در صورت وجود) که باعث ایجاد استثنای بیرونی شده است. این استثنا خود می‌تواند شامل <strong>InnerException</strong> دیگری نیز باشد.</p>
</li>
</ul>
<blockquote>
<p>در زبان C# تمام استثناها در زمان اجرا (<strong>runtime exceptions</strong>) اتفاق می‌افتند و معادلی برای استثناهای بررسی‌شده در زمان کامپایل (<strong>compile-time checked exceptions</strong>) مانند Java وجود ندارد.</p>
</blockquote>
<hr>
<h3>انواع رایج استثناها 🚨</h3>
<p>انواع زیر از استثناها به‌طور گسترده در سراسر <strong>CLR</strong> و کتابخانه‌های <strong>.NET</strong> استفاده می‌شوند. شما می‌توانید آن‌ها را خودتان پرتاب کنید یا از آن‌ها به‌عنوان کلاس پایه برای ساخت انواع سفارشی استثنا استفاده نمایید:</p>
<ul>
<li>
<p><strong>System.ArgumentException</strong><br>
زمانی پرتاب می‌شود که یک تابع با آرگومان نامعتبر فراخوانی شود. معمولاً نشان‌دهنده یک خطای برنامه‌نویسی است.</p>
</li>
<li>
<p><strong>System.ArgumentNullException</strong><br>
زیرکلاس <strong>ArgumentException</strong> که وقتی یک آرگومان تابع به‌طور غیرمنتظره <strong>null</strong> باشد، پرتاب می‌شود.</p>
</li>
<li>
<p><strong>System.ArgumentOutOfRangeException</strong><br>
زیرکلاس <strong>ArgumentException</strong> که وقتی یک آرگومان (معمولاً عددی) خیلی بزرگ یا خیلی کوچک باشد، پرتاب می‌شود. برای مثال، ارسال یک عدد منفی به تابعی که فقط مقادیر مثبت را می‌پذیرد.</p>
</li>
<li>
<p><strong>System.InvalidOperationException</strong><br>
زمانی پرتاب می‌شود که وضعیت یک شیء برای اجرای موفقیت‌آمیز متد مناسب نباشد، بدون توجه به مقدار آرگومان‌ها. مثال‌ها شامل خواندن یک فایل بازنشده یا دریافت عنصر بعدی از یک شمارنده (<strong>Enumerator</strong>) است که لیست زیرین آن در میانه اجرا تغییر کرده است.</p>
</li>
<li>
<p><strong>System.NotSupportedException</strong><br>
زمانی پرتاب می‌شود که یک قابلیت خاص پشتیبانی نمی‌شود. مثالی مناسب: فراخوانی متد <strong>Add</strong> روی مجموعه‌ای که <strong>IsReadOnly</strong> آن <strong>true</strong> است.</p>
</li>
<li>
<p><strong>System.NotImplementedException</strong><br>
زمانی پرتاب می‌شود که یک تابع هنوز پیاده‌سازی نشده است.</p>
</li>
<li>
<p><strong>System.ObjectDisposedException</strong><br>
زمانی پرتاب می‌شود که روی شیئی که قبلاً <strong>Dispose</strong> شده، متدی فراخوانی شود.</p>
</li>
</ul>
<p>یکی دیگر از استثناهای رایج <strong>NullReferenceException</strong> است. این استثنا توسط <strong>CLR</strong> زمانی پرتاب می‌شود که تلاش کنید به عضوی از شیئی که مقدار آن <strong>null</strong> است دسترسی پیدا کنید (که نشان‌دهنده وجود باگ در کد شماست). برای تست، می‌توانید به‌طور مستقیم این استثنا را پرتاب کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">throw</span> <span class="hljs-literal">null</span>;
</code></pre>
<hr>
<h3>الگوی متدهای <strong>TryXXX</strong> 🔄</h3>
<p>هنگام نوشتن یک متد، زمانی که مشکلی پیش می‌آید، دو انتخاب دارید: یا یک کد خطا برگردانید یا یک استثنا پرتاب کنید. به‌طور کلی، زمانی که خطا خارج از روند عادی برنامه باشد یا زمانی که انتظار ندارید فراخواننده بتواند با آن مقابله کند، استثنا پرتاب می‌کنید.</p>
<p>بااین‌حال، گاهی بهتر است هر دو انتخاب را به مصرف‌کننده ارائه دهید. مثالی از این مورد نوع <strong>int</strong> است که دو نسخه از متد <strong>Parse</strong> را ارائه می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Parse</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> input</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryParse</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> input, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> returnValue</span>)</span>;
</code></pre>
<p>اگر <strong>Parse</strong> شکست بخورد، یک استثنا پرتاب می‌کند؛ اما <strong>TryParse</strong> در این حالت مقدار <strong>false</strong> برمی‌گرداند.</p>
<p>می‌توانید این الگو را با این روش پیاده‌سازی کنید که متد <strong>XXX</strong> در نهایت متد <strong>TryXXX</strong> را فراخوانی کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">return</span>-<span class="hljs-function">type <span class="hljs-title">XXX</span>(<span class="hljs-params">input-type input</span>)</span>
{
    <span class="hljs-keyword">return</span>-type returnValue;
    <span class="hljs-keyword">if</span> (!TryXXX(input, <span class="hljs-keyword">out</span> returnValue))
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> YYYException(...);
    <span class="hljs-keyword">return</span> returnValue;
}
</code></pre>
<hr>
<h3>جایگزین‌های استثناها 🛠️</h3>
<p>همانند <strong>int.TryParse</strong>، یک تابع می‌تواند با برگرداندن یک کد خطا از طریق مقدار بازگشتی یا پارامتر به تابع فراخواننده، شکست را اطلاع دهد. اگرچه این روش برای خطاهای ساده و قابل پیش‌بینی کارآمد است، اما هنگام مواجهه با خطاهای غیرمعمول یا غیرقابل پیش‌بینی دست‌وپاگیر می‌شود، امضای متدها را شلوغ می‌کند و پیچیدگی‌های غیرضروری ایجاد می‌نماید.</p>
<p>همچنین این روش برای توابعی که متد نیستند (مانند عملگرها مثل عملگر تقسیم یا ویژگی‌ها <strong>Properties</strong>) قابل استفاده نیست. یک جایگزین دیگر قرار دادن خطا در یک محل مشترک است که تمام توابع در زنجیره فراخوانی بتوانند آن را ببینند (مثلاً یک متد <strong>static</strong> که خطای فعلی را در هر نخ ذخیره کند). با این حال، این روش نیازمند مشارکت هر تابع در الگوی انتشار خطا است که هم دست‌وپاگیر و هم مستعد خطا خواهد بود.</p>
<hr>
<h3>شمارش (Enumeration) و پیمایشگرها (Iterators) 🔄</h3>
<h4>شمارش (Enumeration)</h4>
<p><strong>Enumerator (شمارش‌گر)</strong> یک مکان‌نما (cursor) <strong>فقط خواندنی</strong> و <strong>فقط رو به جلو</strong> روی یک دنباله از مقادیر است. در زبان #C، یک نوع (type) به‌عنوان شمارش‌گر شناخته می‌شود اگر یکی از شرایط زیر را داشته باشد:</p>
<ul>
<li>یک متد عمومی (public) بدون پارامتر به نام <code>MoveNext</code> و یک ویژگی (property) به نام <code>Current</code> داشته باشد.</li>
<li>واسط <code>System.Collections.Generic.IEnumerator&lt;T&gt;</code> را پیاده‌سازی کند.</li>
<li>واسط <code>System.Collections.IEnumerator</code> را پیاده‌سازی کند.</li>
</ul>
<p><strong>عبارت foreach</strong> روی یک <strong>Enumerable object (شیء شمارش‌پذیر)</strong> پیمایش می‌کند.<br>
یک <strong>Enumerable object</strong> نمایش منطقی یک دنباله است. این شیء خودش مکان‌نما نیست، بلکه <strong>مکان‌نما تولید می‌کند</strong>. در #C، یک نوع به‌عنوان شمارش‌پذیر شناخته می‌شود اگر یکی از شرایط زیر را داشته باشد (بررسی‌ها به همین ترتیب انجام می‌شود):</p>
<ul>
<li>یک متد عمومی بدون پارامتر به نام <code>GetEnumerator</code> داشته باشد که یک شمارش‌گر برگرداند.</li>
<li>واسط <code>System.Collections.Generic.IEnumerable&lt;T&gt;</code> را پیاده‌سازی کند.</li>
<li>واسط <code>System.Collections.IEnumerable</code> را پیاده‌سازی کند.</li>
<li>(از #C نسخه 9 به بعد) بتواند به یک متد توسعه‌ای (extension method) به نام <code>GetEnumerator</code> که یک شمارش‌گر برمی‌گرداند، متصل شود (بخش <strong>&quot;Extension Methods&quot;</strong> در صفحه 217 را ببینید).</li>
</ul>
<p><strong>الگوی شمارش</strong> به شکل زیر است:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Enumerator</span>   <span class="hljs-comment">// معمولاً واسط IEnumerator یا IEnumerator&lt;T&gt; را پیاده‌سازی می‌کند</span>
{
  <span class="hljs-keyword">public</span> IteratorVariableType Current { <span class="hljs-keyword">get</span> {...} }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span> {...}
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Enumerable</span>   <span class="hljs-comment">// معمولاً واسط IEnumerable یا IEnumerable&lt;T&gt; را پیاده‌سازی می‌کند</span>
{
  <span class="hljs-function"><span class="hljs-keyword">public</span> Enumerator <span class="hljs-title">GetEnumerator</span>()</span> {...}
}
</code></pre>
<p><strong>نمونه پیمایش سطح بالا</strong> روی کاراکترهای کلمه <code>&quot;beer&quot;</code> با استفاده از <code>foreach</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;beer&quot;</span>)
  Console.WriteLine(c);
</code></pre>
<p><strong>نمونه پیمایش سطح پایین</strong> روی کاراکترهای <code>&quot;beer&quot;</code> بدون استفاده از <code>foreach</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> enumerator = <span class="hljs-string">&quot;beer&quot;</span>.GetEnumerator())
  <span class="hljs-keyword">while</span> (enumerator.MoveNext())
  {
    <span class="hljs-keyword">var</span> element = enumerator.Current;
    Console.WriteLine(element);
  }
</code></pre>
<blockquote>
<p>اگر شمارش‌گر واسط <code>IDisposable</code> را پیاده‌سازی کند، عبارت <code>foreach</code> مانند یک عبارت <code>using</code> عمل کرده و <strong>به‌طور ضمنی</strong> شیء شمارش‌گر را آزاد (dispose) می‌کند.</p>
</blockquote>
<p>جزئیات بیشتر در مورد واسط‌های شمارش در <strong>فصل 7</strong> توضیح داده شده است.</p>
<hr>
<h4>مقداردهی اولیه مجموعه‌ها (Collection Initializers) و عبارات مجموعه‌ای (Collection Expressions) 📝</h4>
<p>شما می‌توانید در یک مرحله، یک شیء شمارش‌پذیر را ایجاد و مقداردهی کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
</code></pre>
<p>از نسخه #C 12 به بعد، می‌توانید این کار را کوتاه‌تر انجام دهید (با استفاده از <strong>براکت‌ها</strong>):</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System.Collections.Generic;
List&lt;<span class="hljs-built_in">int</span>&gt; list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
</code></pre>
<p><strong>عبارات مجموعه‌ای</strong> <strong>هدف‌نوعی (target-typed)</strong> هستند؛ یعنی نوع <code>[1, 2, 3]</code> به نوع متغیری که به آن انتساب داده می‌شود بستگی دارد. مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
Span&lt;<span class="hljs-built_in">int</span>&gt; span = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
</code></pre>
<p>حتی می‌توانید هنگام فراخوانی متدها هم نوع را حذف کنید اگر کامپایلر بتواند آن را استنباط کند:</p>
<pre class="hljs"><code>Foo([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">List&lt;<span class="hljs-built_in">int</span>&gt; numbers</span>)</span> { ... }
</code></pre>
<p>کامپایلر این کد را به این شکل ترجمه می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System.Collections.Generic;
List&lt;<span class="hljs-built_in">int</span>&gt; list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();
list.Add(<span class="hljs-number">1</span>);
list.Add(<span class="hljs-number">2</span>);
list.Add(<span class="hljs-number">3</span>);
</code></pre>
<p>این موضوع نیازمند این است که شیء شمارش‌پذیر واسط <code>System.Collections.IEnumerable</code> را پیاده‌سازی کند و یک متد <code>Add</code> با تعداد پارامتر مناسب داشته باشد. (در عبارات مجموعه‌ای، کامپایلر از الگوهای دیگر هم برای ایجاد مجموعه‌های فقط خواندنی پشتیبانی می‌کند.)</p>
<p>همچنین می‌توانید دیکشنری‌ها را هم به همین شکل مقداردهی کنید (بخش <strong>&quot;Dictionaries&quot;</strong> در صفحه 394 را ببینید):</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;()
{
  { <span class="hljs-number">5</span>, <span class="hljs-string">&quot;five&quot;</span> },
  { <span class="hljs-number">10</span>, <span class="hljs-string">&quot;ten&quot;</span> }
};
</code></pre>
<p>یا به شکل کوتاه‌تر:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>&gt;()
{
  [<span class="hljs-meta">3</span>] = <span class="hljs-string">&quot;three&quot;</span>,
  [<span class="hljs-meta">10</span>] = <span class="hljs-string">&quot;ten&quot;</span>
};
</code></pre>
<p>این روش نه تنها برای دیکشنری‌ها، بلکه برای هر نوعی که <strong>Indexer</strong> داشته باشد، معتبر است.</p>
<hr>
<h4>پیمایشگرها (Iterators) ⚙️</h4>
<p>در حالی که عبارت <code>foreach</code> <strong>مصرف‌کننده</strong> یک شمارش‌گر است، <strong>Iterator (پیمایشگر)</strong> <strong>تولیدکننده</strong> یک شمارش‌گر است.<br>
مثال زیر یک پیمایشگر است که یک دنباله از اعداد فیبوناچی را تولید می‌کند (هر عدد حاصل جمع دو عدد قبلی است):</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-built_in">int</span> fib <span class="hljs-keyword">in</span> <span class="hljs-title">Fibs</span>(<span class="hljs-params"><span class="hljs-number">6</span></span>))
  Console.<span class="hljs-title">Write</span>(<span class="hljs-params">fib + <span class="hljs-string">&quot;  &quot;</span></span>)</span>;

<span class="hljs-function">IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">Fibs</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> fibCount</span>)</span>
{
  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, prevFib = <span class="hljs-number">1</span>, curFib = <span class="hljs-number">1</span>; i &lt; fibCount; i++)
  {
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> prevFib;
    <span class="hljs-built_in">int</span> newFib = prevFib + curFib;
    prevFib = curFib;
    curFib = newFib;
  }
}
</code></pre>
<p><strong>خروجی:</strong></p>
<pre class="hljs"><code>1  1  2  3  5  8
</code></pre>
<p>در حالی که دستور <code>return</code> می‌گوید: <strong>&quot;این مقداری است که از این متد خواسته بودی&quot;</strong>، دستور <code>yield return</code> می‌گوید: <strong>&quot;این عنصر بعدی است که از این شمارش‌گر خواسته بودی&quot;</strong>.<br>
در هر دستور <code>yield</code>، کنترل به فراخواننده برمی‌گردد، اما <strong>وضعیت متد حفظ می‌شود</strong> تا وقتی فراخواننده عنصر بعدی را درخواست کرد، متد از همان‌جا ادامه یابد. این وضعیت به عمر شمارش‌گر وابسته است و بعد از اتمام پیمایش آزاد می‌شود.</p>
<p>کامپایلر متدهای پیمایشگر را به کلاس‌های خصوصی تبدیل می‌کند که واسط‌های <code>IEnumerable&lt;T&gt;</code> و/یا <code>IEnumerator&lt;T&gt;</code> را پیاده‌سازی می‌کنند.<br>
منطق موجود در بلوک پیمایشگر در متد <code>MoveNext</code> و ویژگی <code>Current</code> کلاس تولیدشده توسط کامپایلر قرار داده می‌شود. <strong>این یعنی وقتی متد پیمایشگر را صدا می‌زنید، هیچ کدی اجرا نمی‌شود؛ تنها یک نمونه از کلاس ساخته می‌شود!</strong><br>
کد شما تنها وقتی اجرا می‌شود که پیمایش شروع شود، معمولاً با یک عبارت <code>foreach</code>.</p>
<blockquote>
<p>پیمایشگرها می‌توانند متدهای محلی (local methods) هم باشند (بخش <strong>&quot;Local methods&quot;</strong> در صفحه 106 را ببینید).</p>
</blockquote>
<hr>
<h3>معنای <strong>Iterator</strong> (تکرارکننده) 🔄</h3>
<p>یک <strong>Iterator</strong> یا «تکرارکننده» متدی، ویژگی (Property) یا ایندکسری است که شامل یک یا چند دستور <code>yield</code> است. یک <strong>Iterator</strong> باید یکی از چهار رابط (Interface) زیر را برگرداند، در غیر این صورت کامپایلر خطا تولید می‌کند:</p>
<pre class="hljs"><code><span class="hljs-comment">// رابط‌های Enumerable</span>
System.Collections.IEnumerable
System.Collections.Generic.IEnumerable&lt;T&gt;

<span class="hljs-comment">// رابط‌های Enumerator</span>
System.Collections.IEnumerator
System.Collections.Generic.IEnumerator&lt;T&gt;
</code></pre>
<p><strong>Iterator</strong> بسته به اینکه یک رابط <strong>Enumerable</strong> یا <strong>Enumerator</strong> برمی‌گرداند، رفتار متفاوتی دارد. توضیح کامل این موضوع در فصل ۷ آمده است.</p>
<hr>
<h3>استفاده از چندین دستور <code>yield</code></h3>
<p>در یک <strong>Iterator</strong> می‌توان چندین دستور <code>yield</code> استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-built_in">string</span> s <span class="hljs-keyword">in</span> <span class="hljs-title">Foo</span>())
    Console.<span class="hljs-title">WriteLine</span>(<span class="hljs-params">s</span>)</span>; <span class="hljs-comment">// چاپ می‌کند: &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;</span>

<span class="hljs-function">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">Foo</span>()</span>
{
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;One&quot;</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Two&quot;</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Three&quot;</span>;
}
</code></pre>
<hr>
<h3>استفاده از <code>yield break</code></h3>
<p>در یک بلوک <strong>Iterator</strong> استفاده از دستور <code>return</code> مجاز نیست. برای خروج زودهنگام از <strong>Iterator</strong> (بدون برگرداندن عناصر بیشتر) باید از <code>yield break</code> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-function">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> breakEarly</span>)</span>
{
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;One&quot;</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Two&quot;</span>;
    <span class="hljs-keyword">if</span> (breakEarly)
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Three&quot;</span>;
}
</code></pre>
<hr>
<h3><strong>Iteratorها</strong> و بلوک‌های <strong>try/catch/finally</strong> ⚠️</h3>
<ul>
<li>استفاده از <code>yield return</code> در یک بلوک <code>try</code> که شامل بخش <code>catch</code> باشد، <strong>مجاز نیست</strong>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">Foo</span>()</span>
{
    <span class="hljs-keyword">try</span> { <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;One&quot;</span>; } <span class="hljs-comment">// غیرمجاز</span>
    <span class="hljs-keyword">catch</span> { ... }
}
</code></pre>
<ul>
<li>
<p>همچنین استفاده از <code>yield return</code> در بخش‌های <code>catch</code> یا <code>finally</code> نیز مجاز نیست.<br>
دلیل این محدودیت‌ها این است که کامپایلر باید <strong>Iteratorها</strong> را به کلاس‌های معمولی با متدهای <code>MoveNext</code>، <code>Current</code> و <code>Dispose</code> تبدیل کند و مدیریت بلاک‌های خطا پیچیدگی زیادی ایجاد می‌کند.</p>
</li>
<li>
<p>اما می‌توانید در بلوک <code>try</code> که <strong>فقط</strong> شامل یک بخش <code>finally</code> است از <code>yield return</code> استفاده کنید:</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-function">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">Foo</span>()</span>
{
    <span class="hljs-keyword">try</span> { <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;One&quot;</span>; } <span class="hljs-comment">// مجاز</span>
    <span class="hljs-keyword">finally</span> { ... }
}
</code></pre>
<p>کد موجود در بلوک <code>finally</code> زمانی اجرا می‌شود که شمارنده (<strong>Enumerator</strong>) مصرف‌کننده به انتهای توالی برسد یا از بین برود. دستور <code>foreach</code> به‌صورت ضمنی شمارنده را Dispose می‌کند اگر زودتر از حلقه خارج شوید، بنابراین این روش امنی برای استفاده از شمارنده‌هاست.</p>
<hr>
<h3>احتیاط هنگام استفاده از <strong>Enumeratorها</strong> به‌صورت دستی 🔍</h3>
<p>اگر شمارنده را به‌صورت دستی استفاده می‌کنید و قبل از پایان کار آن را رها کنید بدون اینکه Dispose کنید، بلوک <code>finally</code> اجرا نمی‌شود. برای جلوگیری از این مشکل، شمارنده‌ها را درون یک دستور <code>using</code> قرار دهید:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> firstElement = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">var</span> sequence = Foo();
<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> enumerator = sequence.GetEnumerator())
    <span class="hljs-keyword">if</span> (enumerator.MoveNext())
        firstElement = enumerator.Current;
</code></pre>
<hr>
<h3>ترکیب توالی‌ها (Composing Sequences) 🧩</h3>
<p><strong>Iteratorها</strong> قابلیت ترکیب بالایی دارند. مثال زیر تنها اعداد <strong>فیبوناچی زوج</strong> را تولید می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Collections.Generic;

<span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-built_in">int</span> fib <span class="hljs-keyword">in</span> <span class="hljs-title">EvenNumbersOnly</span>(<span class="hljs-params">Fibs(<span class="hljs-number">6</span></span>)))
    Console.<span class="hljs-title">WriteLine</span>(<span class="hljs-params">fib</span>)</span>;

<span class="hljs-function">IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">Fibs</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> fibCount</span>)</span>
{
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, prevFib = <span class="hljs-number">1</span>, curFib = <span class="hljs-number">1</span>; i &lt; fibCount; i++)
    {
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> prevFib;
        <span class="hljs-built_in">int</span> newFib = prevFib + curFib;
        prevFib = curFib;
        curFib = newFib;
    }
}

<span class="hljs-function">IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">EvenNumbersOnly</span>(<span class="hljs-params">IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; sequence</span>)</span>
{
    <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> x <span class="hljs-keyword">in</span> sequence)
        <span class="hljs-keyword">if</span> ((x % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> x;
}
</code></pre>
<p>نکته مهم این است که <strong>هر عنصر دقیقاً زمانی محاسبه می‌شود که درخواست شود</strong>، یعنی فقط هنگام فراخوانی متد <code>MoveNext()</code> مقدار جدید تولید می‌شود. (شکل ۴-۱ فرآیند درخواست و خروجی داده‌ها را در طول زمان نشان می‌دهد.)</p>
<div align="center">
<p><img src="../../../assets/image/04/Table-4-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>ترکیب‌پذیری الگوی Iterator در LINQ و انواع مقدار تهی (Nullable Value Types) ✨</h3>
<p>ترکیب‌پذیری یا <strong>Composability</strong> در الگوی <strong>Iterator</strong> (تکرارکننده) بسیار مفید و کاربردی است، مخصوصاً در <strong>LINQ</strong>. ما این موضوع را دوباره در فصل ۸ به‌طور کامل بررسی خواهیم کرد.</p>
<hr>
<h2>انواع مقدار تهی (Nullable Value Types) 📝</h2>
<p>در زبان C#، <strong>Reference Types</strong> (انواع مرجع) می‌توانند نشان‌دهنده یک مقدار موجود نباشند، یعنی مقدار آن‌ها می‌تواند <code>null</code> باشد:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-literal">null</span>;   <span class="hljs-comment">// مشکلی ندارد، نوع مرجع</span>
</code></pre>
<p>اما <strong>Value Types</strong> (انواع مقداری) به‌صورت عادی نمی‌توانند <code>null</code> باشند و اگر تلاش کنید، خطای کامپایل دریافت می‌کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i = <span class="hljs-literal">null</span>;   <span class="hljs-comment">// خطای کامپایل، نوع مقداری نمی‌تواند null باشد</span>
</code></pre>
<p>برای این‌که یک <strong>Value Type</strong> قابلیت داشتن مقدار تهی را داشته باشد، باید از یک ساختار خاص به نام <strong>Nullable Type</strong> استفاده کنید. برای تعریف یک نوع Nullable کافی است بعد از نوع داده از علامت <code>?</code> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>? i = <span class="hljs-literal">null</span>;                  <span class="hljs-comment">// صحیح، نوع Nullable</span>
Console.WriteLine(i == <span class="hljs-literal">null</span>);   <span class="hljs-comment">// خروجی True</span>
</code></pre>
<hr>
<h2>ساختار Nullable<T> 🛠</h2>
<p>در واقع <code>T?</code> معادل <code>System.Nullable&lt;T&gt;</code> است. این یک <strong>Struct</strong> سبک و تغییرناپذیر (<strong>Immutable</strong>) است که فقط شامل دو فیلد است:</p>
<ul>
<li><strong>Value</strong>: مقدار ذخیره شده</li>
<li><strong>HasValue</strong>: نشان می‌دهد که آیا مقداری موجود است یا خیر</li>
</ul>
<p>تعریف ساده آن به شکل زیر است:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Nullable&lt;T&gt; <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">struct</span>
{
    <span class="hljs-keyword">public</span> T Value { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> HasValue { <span class="hljs-keyword">get</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetValueOrDefault</span>()</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetValueOrDefault</span>(<span class="hljs-params">T defaultValue</span>)</span>;
    ...
}
</code></pre>
<p>نمونه کد:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>? i = <span class="hljs-literal">null</span>;
Console.WriteLine(i == <span class="hljs-literal">null</span>);  <span class="hljs-comment">// True</span>
</code></pre>
<p>این کد در پشت صحنه به شکل زیر ترجمه می‌شود:</p>
<pre class="hljs"><code>Nullable&lt;<span class="hljs-built_in">int</span>&gt; i = <span class="hljs-keyword">new</span> Nullable&lt;<span class="hljs-built_in">int</span>&gt;();
Console.WriteLine(!i.HasValue);   <span class="hljs-comment">// True</span>
</code></pre>
<blockquote>
<p>توجه: اگر مقدار <strong>HasValue</strong> برابر <strong>false</strong> باشد و شما بخواهید <strong>Value</strong> را بخوانید، یک <strong>InvalidOperationException</strong> رخ می‌دهد.<br>
متد <strong>GetValueOrDefault()</strong> در صورتی که <strong>HasValue = true</strong> باشد مقدار <strong>Value</strong> را برمی‌گرداند، وگرنه مقدار پیش‌فرض یا مقداری که شما مشخص کرده‌اید را برمی‌گرداند.</p>
</blockquote>
<p><strong>نکته مهم</strong>: مقدار پیش‌فرض برای هر <strong>T?</strong> برابر <code>null</code> است.</p>
<hr>
<h2>تبدیل‌های ضمنی و صریح (Implicit و Explicit Conversions) 🔄</h2>
<p>تبدیل یک مقدار <code>T</code> به <code>T?</code> <strong>ضمنی</strong> است (احتیاجی به عمل خاصی ندارد).<br>
اما تبدیل از <code>T?</code> به <code>T</code> <strong>صریح</strong> است و نیاز به <strong>Cast</strong> دارد:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>? x = <span class="hljs-number">5</span>;         <span class="hljs-comment">// تبدیل ضمنی</span>
<span class="hljs-built_in">int</span> y = (<span class="hljs-built_in">int</span>)x;     <span class="hljs-comment">// تبدیل صریح</span>
</code></pre>
<p>در واقع، تبدیل صریح دقیقاً معادل دسترسی به ویژگی <strong>Value</strong> است.<br>
بنابراین، اگر <strong>HasValue = false</strong> باشد و شما بخواهید Cast کنید، استثنای <strong>InvalidOperationException</strong> ایجاد می‌شود.</p>
<hr>
<h2>Boxing و Unboxing در Nullable Types 🎁</h2>
<p>هنگامی که یک <strong>T?</strong> جعبه‌بندی (<strong>Box</strong>) می‌شود، مقدار ذخیره‌شده در <strong>Heap</strong> فقط <strong>T</strong> است، نه <strong>T?</strong>. این بهینه‌سازی ممکن است زیرا <strong>Reference Types</strong> می‌توانند به‌طور طبیعی <code>null</code> را نمایش دهند.</p>
<p>همچنین می‌توانید <strong>Unboxing</strong> یا خارج کردن از جعبه را با عملگر <code>as</code> انجام دهید. اگر عملیات ناموفق باشد، نتیجه <code>null</code> خواهد بود:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span> o = <span class="hljs-string">&quot;string&quot;</span>;
<span class="hljs-built_in">int</span>? x = o <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>?;
Console.WriteLine(x.HasValue);   <span class="hljs-comment">// False</span>
</code></pre>
<h3>عملگرهای ارتقا (Operator Lifting) 🛠️</h3>
<p>ساختار <strong>Nullable<T></strong> عملگرهایی مثل <code>&lt;</code>، <code>&gt;</code> یا حتی <code>==</code> را تعریف نمی‌کند. با این حال، کد زیر بدون هیچ مشکلی کامپایل و اجرا می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>? x = <span class="hljs-number">5</span>;
<span class="hljs-built_in">int</span>? y = <span class="hljs-number">10</span>;
<span class="hljs-built_in">bool</span> b = x &lt; y;      <span class="hljs-comment">// true</span>
</code></pre>
<p>این موضوع به این دلیل است که کامپایلر عملگر <strong>کمتر از</strong> را از نوع پایه (در اینجا <code>int</code>) قرض گرفته یا به اصطلاح <strong>ارتقا داده</strong> است. از نظر مفهومی، عبارت مقایسه بالا به شکل زیر ترجمه می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">bool</span> b = (x.HasValue &amp;&amp; y.HasValue) ? (x.Value &lt; y.Value) : <span class="hljs-literal">false</span>;
</code></pre>
<p>به عبارت دیگر، اگر هر دو متغیر <code>x</code> و <code>y</code> مقدار داشته باشند، مقایسه با استفاده از عملگر کمتر از نوع <code>int</code> انجام می‌شود؛ در غیر این صورت، نتیجه <code>false</code> خواهد بود.</p>
<p>ارتقای عملگر به این معناست که شما می‌توانید به طور ضمنی از عملگرهای نوع <code>T</code> روی نوع <code>T?</code> استفاده کنید. همچنین می‌توانید عملگرهای مخصوص به <code>T?</code> تعریف کنید تا رفتار خاصی در برابر مقادیر <code>null</code> داشته باشند، اما در بیشتر مواقع بهتر است به کامپایلر اعتماد کنید تا به طور خودکار منطق مربوط به <code>nullable</code> را پیاده‌سازی کند. چند مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>? x = <span class="hljs-number">5</span>;
<span class="hljs-built_in">int</span>? y = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// مثال‌های عملگر برابری</span>
Console.WriteLine (x == y);    <span class="hljs-comment">// False</span>
Console.WriteLine (x == <span class="hljs-literal">null</span>); <span class="hljs-comment">// False</span>
Console.WriteLine (x == <span class="hljs-number">5</span>);    <span class="hljs-comment">// True</span>
Console.WriteLine (y == <span class="hljs-literal">null</span>); <span class="hljs-comment">// True</span>
Console.WriteLine (y == <span class="hljs-number">5</span>);    <span class="hljs-comment">// False</span>
Console.WriteLine (y != <span class="hljs-number">5</span>);    <span class="hljs-comment">// True</span>

<span class="hljs-comment">// مثال‌های عملگر مقایسه‌ای</span>
Console.WriteLine (x &lt; <span class="hljs-number">6</span>);     <span class="hljs-comment">// True</span>
Console.WriteLine (y &lt; <span class="hljs-number">6</span>);     <span class="hljs-comment">// False</span>
Console.WriteLine (y &gt; <span class="hljs-number">6</span>);     <span class="hljs-comment">// False</span>

<span class="hljs-comment">// مثال‌های سایر عملگرها</span>
Console.WriteLine (x + <span class="hljs-number">5</span>);     <span class="hljs-comment">// 10</span>
Console.WriteLine (x + y);     <span class="hljs-comment">// null (خط خالی چاپ می‌شود)</span>
</code></pre>
<hr>
<h3>رفتار عملگرها با مقادیر <code>null</code> در Nullable 🧩</h3>
<p>کامپایلر بسته به نوع عملگر، منطق متفاوتی برای برخورد با مقادیر <code>null</code> در نظر می‌گیرد. در ادامه، قوانین مربوط به هر دسته از عملگرها توضیح داده شده است.</p>
<h4>1. عملگرهای برابری (<code>==</code> و <code>!=</code>)</h4>
<p>این عملگرها دقیقاً مشابه نوع‌های <strong>Reference</strong> با مقادیر <code>null</code> رفتار می‌کنند:</p>
<ul>
<li>دو مقدار <code>null</code> برابر هستند:</li>
</ul>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span>);                       <span class="hljs-comment">// True</span>
Console.WriteLine ((<span class="hljs-built_in">bool</span>?)<span class="hljs-literal">null</span> == (<span class="hljs-built_in">bool</span>?)<span class="hljs-literal">null</span>);         <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>اگر فقط یکی از عملوندها <code>null</code> باشد، برابر نیستند.</li>
<li>اگر هر دو مقدار داشته باشند، مقادیر آن‌ها مقایسه می‌شود.</li>
</ul>
<hr>
<h4>2. عملگرهای مقایسه‌ای (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>)</h4>
<p>مقایسه مقادیر <code>null</code> بی‌معنا است؛ بنابراین مقایسه هر مقدار <code>null</code> با <code>null</code> یا مقدار غیر <code>null</code> نتیجه <strong>false</strong> خواهد بود:</p>
<pre class="hljs"><code><span class="hljs-built_in">bool</span> b = x &lt; y;    <span class="hljs-comment">// ترجمه شده:</span>
<span class="hljs-built_in">bool</span> b = (x.HasValue &amp;&amp; y.HasValue) 
         ? (x.Value &lt; y.Value)
         : <span class="hljs-literal">false</span>;
<span class="hljs-comment">// b برابر false است (با فرض x=5 و y=null)</span>
</code></pre>
<hr>
<h4>3. سایر عملگرها (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>+</code>, <code>++</code>, <code>--</code>, <code>!</code>, <code>~</code>)</h4>
<p>هرگاه یکی از عملوندها <code>null</code> باشد، نتیجه نیز <code>null</code> خواهد بود. این الگو برای کاربران SQL آشناست:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>? c = x + y;   <span class="hljs-comment">// ترجمه شده:</span>
<span class="hljs-built_in">int</span>? c = (x.HasValue &amp;&amp; y.HasValue)
         ? (<span class="hljs-built_in">int</span>?) (x.Value + y.Value) 
         : <span class="hljs-literal">null</span>;
<span class="hljs-comment">// c برابر null است (با فرض x=5 و y=null)</span>
</code></pre>
<p>تنها استثنا زمانی است که عملگرهای <code>&amp;</code> و <code>|</code> روی نوع <code>bool?</code> اعمال شوند که به‌زودی توضیح داده می‌شود.</p>
<hr>
<h3>ترکیب انواع Nullable و Non-Nullable 🧮</h3>
<p>شما می‌توانید انواع <code>nullable</code> و <code>non-nullable</code> را با هم ترکیب کنید، چون تبدیل ضمنی از <code>T</code> به <code>T?</code> وجود دارد:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>? a = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">int</span> b = <span class="hljs-number">2</span>;
<span class="hljs-built_in">int</span>? c = a + b;   <span class="hljs-comment">// c برابر null است - معادل a + (int?)b</span>
</code></pre>
<hr>
<h3>نوع‌های Nullable و عملگرهای <code>&amp;</code> و <code>|</code> برای <code>bool?</code> 🔹</h3>
<p>هنگامی که عملگرهای <code>&amp;</code> و <code>|</code> برای عملوندهایی از نوع <strong>bool?</strong> استفاده می‌شوند، مقدار <code>null</code> به‌عنوان یک <strong>مقدار ناشناخته</strong> در نظر گرفته می‌شود. بنابراین:</p>
<ul>
<li>
<p><code>null | true</code> برابر <strong>true</strong> است، زیرا:</p>
<ul>
<li>اگر مقدار ناشناخته false باشد، نتیجه true است.</li>
<li>اگر مقدار ناشناخته true باشد، نتیجه true است.</li>
</ul>
</li>
<li>
<p>به‌طور مشابه، <code>null &amp; false</code> برابر <strong>false</strong> است. این رفتار برای کاربران SQL آشناست.</p>
</li>
</ul>
<p>مثال دیگر:</p>
<pre class="hljs"><code><span class="hljs-built_in">bool</span>? n = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">bool</span>? f = <span class="hljs-literal">false</span>;
<span class="hljs-built_in">bool</span>? t = <span class="hljs-literal">true</span>;

Console.WriteLine (n | n);    <span class="hljs-comment">// (null)</span>
Console.WriteLine (n | f);    <span class="hljs-comment">// (null)</span>
Console.WriteLine (n | t);    <span class="hljs-comment">// True</span>
Console.WriteLine (n &amp; n);    <span class="hljs-comment">// (null)</span>
Console.WriteLine (n &amp; f);    <span class="hljs-comment">// False</span>
Console.WriteLine (n &amp; t);    <span class="hljs-comment">// (null)</span>
</code></pre>
<hr>
<h3>Nullable Value Types و عملگرهای کمکی (<code>??</code> و Null-Conditional) ⚡</h3>
<p>نوع‌های <strong>nullable</strong> به‌خوبی با عملگر <strong>Null Coalescing (<code>??</code>)</strong> کار می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>? x = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">int</span> y = x ?? <span class="hljs-number">5</span>;        <span class="hljs-comment">// y برابر 5</span>

<span class="hljs-built_in">int</span>? a = <span class="hljs-literal">null</span>, b = <span class="hljs-number">1</span>, c = <span class="hljs-number">2</span>;
Console.WriteLine (a ?? b ?? c);  <span class="hljs-comment">// 1 (اولین مقدار غیر-null)</span>
</code></pre>
<p>استفاده از <code>??</code> روی یک مقدار nullable معادل فراخوانی متد <code>GetValueOrDefault</code> با یک مقدار پیش‌فرض است، با این تفاوت که اگر متغیر null نباشد، عبارت پیش‌فرض هرگز ارزیابی نمی‌شود.</p>
<p>همچنین <strong>Null-Conditional Operator (<code>?.</code>)</strong> با نوع‌های nullable به خوبی کار می‌کند:</p>
<pre class="hljs"><code>System.Text.StringBuilder sb = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">int</span>? length = sb?.ToString().Length;  <span class="hljs-comment">// length برابر null می‌شود</span>
</code></pre>
<p>می‌توانیم این را با <code>??</code> ترکیب کنیم تا به جای null مقدار صفر برگردانیم:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> length = sb?.ToString().Length ?? <span class="hljs-number">0</span>;  <span class="hljs-comment">// اگر sb null باشد، نتیجه 0 است</span>
</code></pre>
<hr>
<h3>سناریوهای استفاده از نوع‌های Nullable 💡</h3>
<p>یکی از رایج‌ترین کاربردها برای <strong>nullable value types</strong> نمایش مقادیر ناشناخته است. این حالت به‌ویژه در برنامه‌نویسی پایگاه داده رایج است، جایی که یک کلاس به جدول با ستون‌های nullable نگاشت می‌شود.</p>
<p>اگر ستون‌ها از نوع <strong>string</strong> باشند، مشکلی وجود ندارد زیرا string نوع مرجع است و می‌تواند null باشد. اما اکثر ستون‌های SQL به نوع struct در CLR نگاشت می‌شوند، بنابراین استفاده از نوع‌های nullable بسیار مفید است:</p>
<pre class="hljs"><code><span class="hljs-comment">// نگاشت به جدول Customer در پایگاه داده</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span>
{
  ...
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span>? AccountBalance;
}
</code></pre>
<p>همچنین، نوع nullable می‌تواند برای نمایش <strong>فیلد پشتیبان (backing field)</strong> یک property محیطی (ambient property) استفاده شود. یک <strong>ambient property</strong> اگر null باشد، مقدار parent خود را بازمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Row</span>
{
  ...
  Grid parent;
  Color? color;

  <span class="hljs-keyword">public</span> Color Color
  {
    <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> color ?? parent.Color; }
    <span class="hljs-keyword">set</span> { color = <span class="hljs-keyword">value</span> == parent.Color ? (Color?)<span class="hljs-literal">null</span> : <span class="hljs-keyword">value</span>; }
  }
}
</code></pre>
<hr>
<h3>جایگزین‌ها برای Nullable Value Types ⚖️</h3>
<p>قبل از اینکه nullable value types بخشی از زبان C# باشند (قبل از C# 2.0)، استراتژی‌های مختلفی برای مدیریت آن‌ها وجود داشت. یکی از این استراتژی‌ها این بود که یک مقدار خاص غیر-null را به‌عنوان <strong>magic value</strong> یا مقدار null فرض کنیم.</p>
<p>مثال‌ها:</p>
<pre class="hljs"><code><span class="hljs-comment">// String.IndexOf وقتی کاراکتر پیدا نشود، -1 برمی‌گرداند</span>
<span class="hljs-built_in">int</span> i = <span class="hljs-string">&quot;Pink&quot;</span>.IndexOf(<span class="hljs-string">&#x27;b&#x27;</span>);
Console.WriteLine(i);  <span class="hljs-comment">// -1</span>

<span class="hljs-comment">// Array.IndexOf وقتی عنصر پیدا نشود (و آرایه از اندیس 1 شروع شود):</span>
Array a = Array.CreateInstance(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] {<span class="hljs-number">2</span>}, <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] {<span class="hljs-number">1</span>});
a.SetValue(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);
a.SetValue(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>);
Console.WriteLine(Array.IndexOf(a, <span class="hljs-string">&quot;c&quot;</span>));  <span class="hljs-comment">// 0</span>
</code></pre>
<p>مشکل انتخاب <strong>magic value</strong>:</p>
<ul>
<li>هر نوع مقداری می‌تواند null را به شیوه متفاوت نمایش دهد. در مقابل، nullable value types یک الگوی یکنواخت برای همه نوع‌ها ارائه می‌کند.</li>
<li>ممکن است مقدار مشخصی برای null وجود نداشته باشد.</li>
<li>فراموش کردن تست مقدار (مثل HasValue) باعث بروز خطا می‌شود، اما با nullable value types این خطا به‌صورت <strong>InvalidOperationException</strong> روی همان خط رخ می‌دهد.</li>
<li>قابلیت null بودن یک مقدار در نوع آن لحاظ نمی‌شود. نوع‌ها هدف برنامه را مشخص می‌کنند و به کامپایلر امکان بررسی صحت و رعایت قواعد یکنواخت را می‌دهند.</li>
</ul>
<h3>نوع‌های Nullable Reference Types 🟢</h3>
<p>در حالی که <strong>nullable value types</strong> امکان null بودن را به نوع‌های مقدار (value types) اضافه می‌کنند، <strong>nullable reference types</strong> (از C# 8 به بعد) برعکس عمل می‌کنند: آن‌ها مقداری از <strong>non-nullability</strong> را به نوع‌های مرجع (reference types) اضافه می‌کنند تا از بروز <strong>NullReferenceException</strong> جلوگیری کنند.</p>
<p>این قابلیت یک <strong>سطح ایمنی</strong> اضافه می‌کند که صرفاً توسط <strong>کامپایلر</strong> اعمال می‌شود و به صورت <strong>هشدارها (warnings)</strong> زمانی ظاهر می‌شود که کامپایلر تشخیص دهد کدی ممکن است باعث NullReferenceException شود.</p>
<hr>
<h3>فعال‌سازی Nullable Reference Types ⚙️</h3>
<p>برای فعال کردن nullable reference types، می‌توانید یکی از این روش‌ها را استفاده کنید:</p>
<ol>
<li>اضافه کردن عنصر <code>&lt;Nullable&gt;</code> به فایل <code>.csproj</code> پروژه (برای کل پروژه):</li>
</ol>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Nullable</span>&gt;</span>enable<span class="hljs-tag">&lt;/<span class="hljs-name">Nullable</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<ol start="2">
<li>یا/و استفاده از دستورالعمل‌های زیر در کد، در مکان‌هایی که می‌خواهید اعمال شود:</li>
</ol>
<pre class="hljs"><code><span class="hljs-meta">#nullable enable    // فعال‌سازی nullable reference types از این نقطه به بعد</span>
<span class="hljs-meta">#nullable disable   // غیرفعال‌سازی nullable reference types از این نقطه به بعد</span>
<span class="hljs-meta">#nullable restore   // بازگرداندن تنظیمات به حالت پروژه</span>
</code></pre>
<hr>
<h3>تعریف نوع‌های Nullable Reference</h3>
<p>پس از فعال شدن، <strong>non-nullability</strong> به صورت پیش‌فرض اعمال می‌شود. برای اینکه یک <strong>reference type</strong> بتواند مقدار null بگیرد، باید از علامت <code>?</code> استفاده کنید. مثال:</p>
<pre class="hljs"><code><span class="hljs-meta">#nullable enable</span>

<span class="hljs-built_in">string</span> s1 = <span class="hljs-literal">null</span>;   <span class="hljs-comment">// هشدار کامپایلر! ❌</span>
<span class="hljs-built_in">string</span>? s2 = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// صحیح ✅: s2 یک nullable reference type است</span>
</code></pre>
<p>توجه کنید که <strong>string و string?</strong> در زمان اجرا تفاوتی ندارند، بر خلاف <strong>nullable value types</strong> که چیزی واقعی به سیستم نوع اضافه می‌کنند (<code>Nullable&lt;T&gt;</code>).</p>
<hr>
<h3>هشدارها و مقداردهی اولیه</h3>
<p>اگر یک فیلد non-nullable بدون مقداردهی اولیه تعریف شود، کامپایلر هشدار می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> { <span class="hljs-built_in">string</span> x; }   <span class="hljs-comment">// هشدار: x مقداردهی نشده</span>
</code></pre>
<p>هشدار با مقداردهی اولیه فیلد یا مقداردهی در سازنده حذف می‌شود.</p>
<hr>
<h3>عملگر Null-Forgiving (<code>!</code>) ⚠️</h3>
<p>کامپایلر هنگام دسترسی به یک <strong>nullable reference type</strong> که احتمال NullReferenceException دارد، هشدار می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>? s</span>)</span> =&gt; Console.Write(s.Length);  <span class="hljs-comment">// هشدار</span>
</code></pre>
<p>برای حذف هشدار، می‌توان از <strong>null-forgiving operator</strong> استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>? s</span>)</span> =&gt; Console.Write(s!.Length);
</code></pre>
<p>⚠️ این روش خطرناک است و ممکن است همان <strong>NullReferenceException</strong> که می‌خواستیم جلوگیری کنیم را ایجاد کند. روش ایمن‌تر:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>? s</span>)</span>
{
    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>) 
        Console.Write(s.Length);
}
</code></pre>
<p>کامپایلر با تحلیل جریان برنامه (static flow analysis) می‌تواند تشخیص دهد که دسترسی ایمن است و هشدارها را ندهد.</p>
<hr>
<h3>محدودیت‌ها و تحلیل کامپایلر</h3>
<p>کامپایلر توانایی کامل برای تشخیص خطر NullReferenceException ندارد. مثلاً نمی‌تواند تشخیص دهد که عناصر یک آرایه مقداردهی شده‌اند یا نه:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> strings = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">10</span>];
Console.WriteLine(strings[<span class="hljs-number">0</span>].Length);  <span class="hljs-comment">// هیچ هشداری تولید نمی‌شود</span>
</code></pre>
<hr>
<h3>تفکیک Annotation و Warning Contexts 🛠️</h3>
<p>فعال کردن nullable reference types با دستور <code>#nullable enable</code> یا <code>&lt;Nullable&gt;enable&lt;/Nullable&gt;</code> دو کار انجام می‌دهد:</p>
<ol>
<li><strong>nullable annotation context</strong>: همه متغیرهای reference-type را non-nullable فرض می‌کند مگر آنکه با <code>?</code> مشخص شوند.</li>
<li><strong>nullable warning context</strong>: کامپایلر هنگام مواجهه با کدی که احتمال NullReferenceException دارد، هشدار می‌دهد.</li>
</ol>
<p>می‌توان این دو مورد را جداگانه فعال کرد:</p>
<pre class="hljs"><code><span class="hljs-meta">#nullable enable annotations  // فقط annotation context فعال است</span>
<span class="hljs-meta">#nullable enable warnings     // فقط <span class="hljs-keyword">warning</span> context فعال است</span>
</code></pre>
<p>یا در فایل پروژه:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">Nullable</span>&gt;</span>annotations<span class="hljs-tag">&lt;/<span class="hljs-name">Nullable</span>&gt;</span>
<span class="hljs-comment">&lt;!-- OR --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Nullable</span>&gt;</span>warnings<span class="hljs-tag">&lt;/<span class="hljs-name">Nullable</span>&gt;</span>
</code></pre>
<p>فعال کردن فقط <strong>annotation context</strong> برای کلاس یا اسمبلی قدیمی می‌تواند اولین گام مناسب برای افزودن nullable reference types بدون مواجهه با هشدارها باشد.</p>
<hr>
<h3>تبدیل هشدارها به خطا ⚡</h3>
<p>در پروژه‌های جدید، می‌توان nullable context را از ابتدا فعال کرد و حتی هشدارها را به خطا تبدیل نمود تا پروژه تا زمانی که تمام هشدارهای null رفع نشده‌اند، <strong>قابل کامپایل نباشد</strong>:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Nullable</span>&gt;</span>enable<span class="hljs-tag">&lt;/<span class="hljs-name">Nullable</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">WarningsAsErrors</span>&gt;</span>CS8600;CS8602;CS8603<span class="hljs-tag">&lt;/<span class="hljs-name">WarningsAsErrors</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<h3>متدهای توسعه‌یافته (Extension Methods) ✨</h3>
<p><strong>متدهای توسعه‌یافته</strong> امکان افزودن متدهای جدید به یک نوع موجود را بدون تغییر در تعریف اصلی آن نوع فراهم می‌کنند.</p>
<hr>
<h3>تعریف Extension Method</h3>
<p>یک <strong>extension method</strong> در واقع یک <strong>متد static</strong> در یک کلاس <strong>static</strong> است که <strong>پارامتر اول آن با کلیدواژه <code>this</code> مشخص شده</strong> و نوع این پارامتر، همان نوعی است که می‌خواهیم گسترش دهیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringHelper</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsCapitalized</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> s</span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.IsNullOrEmpty(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">char</span>.IsUpper(s[<span class="hljs-number">0</span>]);
    }
}
</code></pre>
<p>این متد را می‌توان به صورت <strong>متد نمونه (instance method)</strong> روی رشته‌ها فراخوانی کرد:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-string">&quot;Perth&quot;</span>.IsCapitalized());  <span class="hljs-comment">// True</span>
</code></pre>
<p>کامپایلر این کد را به فراخوانی معمولی <strong>static</strong> تبدیل می‌کند:</p>
<pre class="hljs"><code>Console.WriteLine(StringHelper.IsCapitalized(<span class="hljs-string">&quot;Perth&quot;</span>));
</code></pre>
<hr>
<h3>گسترش اینترفیس‌ها</h3>
<p>می‌توان این متدها را روی <strong>interface</strong>ها نیز اعمال کرد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">First</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;T&gt; sequence</span>)</span>
{
    <span class="hljs-keyword">foreach</span> (T element <span class="hljs-keyword">in</span> sequence)
        <span class="hljs-keyword">return</span> element;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">&quot;No elements!&quot;</span>);
}

Console.WriteLine(<span class="hljs-string">&quot;Seattle&quot;</span>.First());  <span class="hljs-comment">// S</span>
</code></pre>
<hr>
<h3>زنجیره‌سازی متدهای توسعه‌یافته (Extension Method Chaining)</h3>
<p>مثل متدهای نمونه، می‌توان extension methodها را <strong>زنجیره‌ای</strong> فراخوانی کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringHelper</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Pluralize</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> s</span>)</span> { ... }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Capitalize</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> s</span>)</span> { ... }
}

<span class="hljs-built_in">string</span> x = <span class="hljs-string">&quot;sausage&quot;</span>.Pluralize().Capitalize();   <span class="hljs-comment">// &quot;Sausages&quot;</span>
<span class="hljs-built_in">string</span> y = StringHelper.Capitalize(StringHelper.Pluralize(<span class="hljs-string">&quot;sausage&quot;</span>)); <span class="hljs-comment">// معادل x</span>
</code></pre>
<hr>
<h3>حل ابهام و قواعد دسترسی</h3>
<ol>
<li><strong>Namespace</strong>:<br>
برای دسترسی به extension method، کلاس آن باید در <strong>scope</strong> باشد (معمولاً با import namespace):</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">using</span> Utils;  <span class="hljs-comment">// کلاس StringHelper در namespace Utils قرار دارد</span>
</code></pre>
<ol start="2">
<li><strong>Extension method vs Instance method</strong>:<br>
هر متد نمونه‌ی سازگار، <strong>اولویت بیشتری نسبت به extension method دارد</strong>. برای فراخوانی extension method در این شرایط، باید از <strong>فراخوانی static</strong> استفاده کرد:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> x</span>)</span> { }   <span class="hljs-comment">// همیشه برنده است</span>
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Extensions</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Test t, <span class="hljs-built_in">int</span> x</span>)</span> { }
}

<span class="hljs-comment">// فراخوانی:</span>
Extensions.Foo(<span class="hljs-keyword">new</span> Test(), <span class="hljs-number">42</span>);   <span class="hljs-comment">// باید از روش static استفاده شود</span>
</code></pre>
<ol start="3">
<li><strong>Extension method vs Extension method</strong>:<br>
اگر دو متد extension با امضای یکسان وجود داشته باشد، برای رفع ابهام باید به صورت <strong>static</strong> فراخوانی شود.<br>
اگر یکی از متدها آرگومان‌های خاص‌تری داشته باشد، متد خاص‌تر برنده است.</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringHelper</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsCapitalized</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> s</span>)</span> { ... }
}
<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObjectHelper</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsCapitalized</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">object</span> s</span>)</span> { ... }
}

<span class="hljs-built_in">bool</span> test1 = <span class="hljs-string">&quot;Perth&quot;</span>.IsCapitalized();  <span class="hljs-comment">// فراخوانی StringHelper</span>
</code></pre>
<hr>
<h3>کاهش سطح یک متد توسعه‌یافته (Demoting an Extension Method)</h3>
<p>فرض کنید یک متد توسعه‌یافته در کتابخانه شخص ثالث با یک متد جدید در کتابخانه .NET تداخل دارد. می‌توان بدون حذف آن، آن را <strong>به یک متد static معمولی تبدیل کرد</strong>:</p>
<ul>
<li>کافی است <code>this</code> را از پارامتر اول حذف کنیم.</li>
<li>همه‌ی فراخوانی‌هایی که قبلاً با extension method بوده‌اند، هنگام کامپایل دوباره به <strong>فراخوانی static</strong> تبدیل می‌شوند.</li>
<li>مصرف‌کنندگان کتابخانه فقط زمانی تحت تأثیر قرار می‌گیرند که دوباره پروژه را کامپایل کنند.</li>
</ul>
<hr>
<h3>نوع‌های ناشناس (Anonymous Types) و تاپل‌ها (Tuples) در C# 🟢</h3>
<hr>
<h2>۱. نوع‌های ناشناس (Anonymous Types) ✨</h2>
<p>یک <strong>نوع ناشناس</strong>، کلاس ساده‌ای است که <strong>کامپایلر به صورت خودکار ایجاد می‌کند</strong> تا مجموعه‌ای از مقادیر را ذخیره کند.</p>
<h3>نحوه تعریف</h3>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dude = <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">&quot;Bob&quot;</span>, Age = <span class="hljs-number">23</span> };
</code></pre>
<p>کامپایلر تقریباً این را به صورت زیر ترجمه می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnonymousGeneratedTypeName</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnonymousGeneratedTypeName</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span>
    {
        <span class="hljs-keyword">this</span>.name = name; <span class="hljs-keyword">this</span>.age = age;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name =&gt; name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age =&gt; age;
    <span class="hljs-comment">// متدهای Equals، GetHashCode و ToString بازنویسی شده‌اند</span>
}
</code></pre>
<blockquote>
<p>⚠️ باید همیشه از <code>var</code> برای ارجاع به نوع ناشناس استفاده کرد، چون <strong>نام ندارد</strong>.</p>
</blockquote>
<hr>
<h3>قواعد و نکات مهم</h3>
<ol>
<li><strong>استنتاج نام ویژگی‌ها:</strong><br>
اگر یک عبارت شامل <strong>شناسه‌ای موجود</strong> باشد، نام ویژگی می‌تواند از آن استخراج شود:</li>
</ol>
<pre class="hljs"><code><span class="hljs-built_in">int</span> Age = <span class="hljs-number">23</span>;
<span class="hljs-keyword">var</span> dude = <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">&quot;Bob&quot;</span>, Age, Age.ToString().Length };
<span class="hljs-comment">// معادل:</span>
<span class="hljs-keyword">var</span> dude = <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">&quot;Bob&quot;</span>, Age = Age, Length = Age.ToString().Length };
</code></pre>
<ol start="2">
<li><strong>برابر بودن نوع ناشناس:</strong><br>
دو نمونه ناشناس با <strong>ویژگی‌های یکسان در همان اسمبلی</strong>، نوع یکسان دارند:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> { X = <span class="hljs-number">2</span>, Y = <span class="hljs-number">4</span> };
<span class="hljs-keyword">var</span> a2 = <span class="hljs-keyword">new</span> { X = <span class="hljs-number">2</span>, Y = <span class="hljs-number">4</span> };
Console.WriteLine(a1.GetType() == a2.GetType());  <span class="hljs-comment">// True</span>
</code></pre>
<ol start="3">
<li>
<p><strong>مقایسه مقادیر:</strong></p>
<ul>
<li><code>Equals</code> → مقایسه داده‌ها (ساختاری)</li>
<li><code>==</code> → مقایسه مرجع (referential)</li>
</ul>
</li>
</ol>
<pre class="hljs"><code>Console.WriteLine(a1.Equals(a2));  <span class="hljs-comment">// True</span>
Console.WriteLine(a1 == a2);       <span class="hljs-comment">// False</span>
</code></pre>
<ol start="4">
<li><strong>آرایه‌ای از نوع ناشناس:</strong></li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dudes = <span class="hljs-keyword">new</span>[]
{
    <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">&quot;Bob&quot;</span>, Age = <span class="hljs-number">30</span> },
    <span class="hljs-keyword">new</span> { Name = <span class="hljs-string">&quot;Tom&quot;</span>, Age = <span class="hljs-number">40</span> }
};
</code></pre>
<ol start="5">
<li><strong>غیر قابل تغییر بودن (Immutable)</strong><br>
از C# 10 به بعد می‌توان با <code>with</code> یک نسخه جدید با تغییرات ساخت بدون تخریب نسخه اصلی:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> { A = <span class="hljs-number">1</span>, B = <span class="hljs-number">2</span>, C = <span class="hljs-number">3</span>, D = <span class="hljs-number">4</span>, E = <span class="hljs-number">5</span> };
<span class="hljs-keyword">var</span> a2 = a1 <span class="hljs-keyword">with</span> { E = <span class="hljs-number">10</span> };
Console.WriteLine(a2);  <span class="hljs-comment">// { A = 1, B = 2, C = 3, D = 4, E = 10 }</span>
</code></pre>
<blockquote>
<p>نوع‌های ناشناس بسیار کاربردی در <strong>LINQ</strong> هستند.</p>
</blockquote>
<hr>
<h2>۲. تاپل‌ها (Tuples) 🔹</h2>
<p><strong>تاپل‌ها</strong> مشابه نوع‌های ناشناس هستند، اما امکان بازگرداندن چند مقدار از یک متد را بدون پارامتر <code>out</code> می‌دهند.</p>
<h3>تعریف ساده</h3>
<pre class="hljs"><code><span class="hljs-keyword">var</span> bob = (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);  <span class="hljs-comment">// المان‌ها نام‌گذاری نشده‌اند</span>
Console.WriteLine(bob.Item1);  <span class="hljs-comment">// Bob</span>
Console.WriteLine(bob.Item2);  <span class="hljs-comment">// 23</span>
</code></pre>
<ul>
<li>تاپل‌ها <strong>Value Type</strong> هستند و المان‌هایشان قابل تغییر است:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> joe = bob;    <span class="hljs-comment">// کپی از bob</span>
joe.Item1 = <span class="hljs-string">&quot;Joe&quot;</span>;
Console.WriteLine(bob);  <span class="hljs-comment">// (Bob, 23)</span>
Console.WriteLine(joe);  <span class="hljs-comment">// (Joe, 23)</span>
</code></pre>
<h3>تعریف با نوع مشخص</h3>
<pre class="hljs"><code>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) bob = (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);
</code></pre>
<ul>
<li>می‌توان تاپل را از متد بازگرداند:</li>
</ul>
<pre class="hljs"><code>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) GetPerson() =&gt; (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);
(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) person = GetPerson();
Console.WriteLine(person.Item1);  <span class="hljs-comment">// Bob</span>
Console.WriteLine(person.Item2);  <span class="hljs-comment">// 23</span>
</code></pre>
<h3>سازگاری با جنریک‌ها</h3>
<pre class="hljs"><code>Task&lt;(<span class="hljs-built_in">string</span>,<span class="hljs-built_in">int</span>)&gt;
Dictionary&lt;(<span class="hljs-built_in">string</span>,<span class="hljs-built_in">int</span>), Uri&gt;
IEnumerable&lt;(<span class="hljs-built_in">int</span> id, <span class="hljs-built_in">string</span> name)&gt;   <span class="hljs-comment">// امکان نام‌گذاری المان‌ها</span>
</code></pre>
<hr>
<h3>نام‌گذاری المان‌های تاپل و نکات پیشرفته 🟢</h3>
<hr>
<h2>۱. نام‌گذاری المان‌ها هنگام ایجاد تاپل</h2>
<p>می‌توان المان‌ها را با نام‌های معنی‌دار مشخص کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> tuple = (name: <span class="hljs-string">&quot;Bob&quot;</span>, age: <span class="hljs-number">23</span>);
Console.WriteLine(tuple.name);  <span class="hljs-comment">// Bob</span>
Console.WriteLine(tuple.age);   <span class="hljs-comment">// 23</span>
</code></pre>
<p>همین کار هنگام <strong>مشخص کردن نوع تاپل</strong> نیز ممکن است:</p>
<pre class="hljs"><code>(<span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age) GetPerson() =&gt; (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);
<span class="hljs-keyword">var</span> person = GetPerson();
Console.WriteLine(person.name);  <span class="hljs-comment">// Bob</span>
Console.WriteLine(person.age);   <span class="hljs-comment">// 23</span>
</code></pre>
<hr>
<h2>۲. استفاده از رکوردها (Records) برای نوع بازگشتی قوی‌تر</h2>
<p>به جای تاپل می‌توان از <strong>رکوردها</strong> استفاده کرد تا نوع بازگشتی <strong>قوی و قابل تغییر</strong> داشته باشیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Person</span>(<span class="hljs-title">string</span> <span class="hljs-title">Name</span>, <span class="hljs-title">int</span> <span class="hljs-title">Age</span>);

<span class="hljs-function">Person <span class="hljs-title">GetPerson</span>()</span> =&gt; <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);
<span class="hljs-keyword">var</span> person = GetPerson();
Console.WriteLine(person.Name);  <span class="hljs-comment">// Bob</span>
Console.WriteLine(person.Age);   <span class="hljs-comment">// 23</span>
</code></pre>
<p>مزایا:</p>
<ul>
<li>نوع بازگشتی نام‌گذاری شده و قابل بازسازی/refactor است.</li>
<li>کاهش تکرار کد.</li>
<li>تشویق به طراحی خوب و اصول OOP.</li>
</ul>
<hr>
<h2>۳. استنتاج خودکار نام المان‌ها</h2>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> now = DateTime.Now;
<span class="hljs-keyword">var</span> tuple = (now.Day, now.Month, now.Year);
Console.WriteLine(tuple.Day);  <span class="hljs-comment">// OK</span>
</code></pre>
<blockquote>
<p>کامپایلر از نام فیلد یا پراپرتی برای المان‌ها استفاده می‌کند.</p>
</blockquote>
<hr>
<h2>۴. سازگاری نوعی (Type Compatibility) و اشتباهات محتمل</h2>
<p>تاپل‌ها فقط از نظر <strong>نوع المان‌ها</strong> با هم سازگارند؛ <strong>نام المان‌ها اهمیتی ندارد</strong>:</p>
<pre class="hljs"><code>(<span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age, <span class="hljs-built_in">char</span> sex) bob1 = (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;M&#x27;</span>);
(<span class="hljs-built_in">string</span> age, <span class="hljs-built_in">int</span> sex, <span class="hljs-built_in">char</span> name) bob2 = bob1;  <span class="hljs-comment">// بدون خطا!</span>
Console.WriteLine(bob2.name);  <span class="hljs-comment">// M</span>
Console.WriteLine(bob2.age);   <span class="hljs-comment">// Bob</span>
Console.WriteLine(bob2.sex);   <span class="hljs-comment">// 23</span>
</code></pre>
<blockquote>
<p>⚠️ این می‌تواند منجر به نتایج گیج‌کننده شود.</p>
</blockquote>
<hr>
<h2>۵. حذف نام المان‌ها در زمان اجرا (Type Erasure)</h2>
<ul>
<li>تاپل‌ها از <code>ValueTuple&lt;&gt;</code> استفاده می‌کنند و در runtime <strong>نام المان‌ها را ندارند</strong>.</li>
<li>فقط در سورس کد و کامپایلر وجود دارند.</li>
<li>در بیشتر ابزارها مثل <strong>Debugging</strong> یا <strong>Reflection</strong> نام‌ها قابل مشاهده نیستند.</li>
</ul>
<hr>
<h2>۶. ایجاد alias برای تاپل‌ها (C# 12)</h2>
<p>می‌توان با <code>using</code> برای تاپل‌ها نام مستعار تعریف کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> Point = (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>);
Point p = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);

<span class="hljs-comment">// با نام المان:</span>
<span class="hljs-keyword">using</span> Point = (<span class="hljs-built_in">int</span> X, <span class="hljs-built_in">int</span> Y);  <span class="hljs-comment">// Legal</span>
Point p2 = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
</code></pre>
<hr>
<h2>۷. استفاده از ValueTuple.Create</h2>
<p>می‌توان تاپل را با متد کارخانه‌ای نیز ساخت:</p>
<pre class="hljs"><code>ValueTuple&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">int</span>&gt; bob1 = ValueTuple.Create(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);
(<span class="hljs-built_in">string</span>,<span class="hljs-built_in">int</span>) bob2           = ValueTuple.Create(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);
(<span class="hljs-built_in">string</span> name,<span class="hljs-built_in">int</span> age) bob3  = ValueTuple.Create(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);
</code></pre>
<hr>
<h3>تجزیه (Deconstructing) تاپل‌ها 🧩</h3>
<p>تاپل‌ها به‌صورت ضمنی از <strong>الگوی تجزیه (deconstruction pattern)</strong> پشتیبانی می‌کنند (رجوع کنید به بخش «Deconstructors» در صفحه ۱۱۰)، بنابراین می‌توانید به راحتی یک تاپل را به متغیرهای جداگانه تقسیم کنید. به مثال زیر توجه کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> bob = (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);
<span class="hljs-built_in">string</span> name = bob.Item1;
<span class="hljs-built_in">int</span> age = bob.Item2;
</code></pre>
<p>با استفاده از <strong>deconstructor تاپل</strong>، می‌توان کد را ساده‌تر نوشت:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> bob = (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);
(<span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age) = bob;   <span class="hljs-comment">// تجزیه تاپل bob به</span>
                                <span class="hljs-comment">// متغیرهای جداگانه (name و age)</span>
Console.WriteLine(name);
Console.WriteLine(age);
</code></pre>
<p>نحو (syntax) تجزیه شبیه به نحو اعلام تاپل با <strong>عناصر نام‌گذاری‌شده</strong> است، اما تفاوت دارد:</p>
<pre class="hljs"><code>(<span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age)      = bob;   <span class="hljs-comment">// تجزیه یک تاپل</span>
(<span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age) bob2 = bob;   <span class="hljs-comment">// اعلام یک تاپل جدید</span>
</code></pre>
<p>مثال دیگری هنگام فراخوانی یک متد با <strong>استفاده از استنتاج نوع (var)</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> (name, age, sex) = GetBob();
Console.WriteLine(name);  <span class="hljs-comment">// Bob</span>
Console.WriteLine(age);   <span class="hljs-comment">// 23</span>
Console.WriteLine(sex);   <span class="hljs-comment">// M</span>

(<span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age, <span class="hljs-built_in">char</span> sex) GetBob() =&gt; (<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;M&#x27;</span>);
</code></pre>
<p>همچنین می‌توانید مستقیماً <strong>مقداردهی به فیلدها و خصوصیات</strong> (fields and properties) انجام دهید، که یک روش کوتاه برای مقداردهی چندین فیلد یا property در سازنده (constructor) فراهم می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> X, Y;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span> =&gt; (X, Y) = (x, y);
}
</code></pre>
<hr>
<h3>مقایسه برابری (Equality Comparison) ⚖️</h3>
<p>مانند <strong>anonymous types</strong>، متد <strong>Equals</strong> در تاپل‌ها یک مقایسه ساختاری (structural equality) انجام می‌دهد؛ یعنی داده‌های داخلی مقایسه می‌شوند نه مراجع (references):</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> t1 = (<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> t2 = (<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-number">1</span>);
Console.WriteLine(t1.Equals(t2));  <span class="hljs-comment">// True</span>
</code></pre>
<p>علاوه بر این، <strong>ValueTuple&lt;&gt;</strong> عملگرهای <code>==</code> و <code>!=</code> را بازتعریف کرده است:</p>
<pre class="hljs"><code>Console.WriteLine(t1 == t2);  <span class="hljs-comment">// True (از C# 7.3 به بعد)</span>
</code></pre>
<p>تاپل‌ها همچنین <strong>متد GetHashCode</strong> را بازتعریف می‌کنند، بنابراین می‌توان از آن‌ها به‌عنوان <strong>کلید در دیکشنری‌ها</strong> استفاده کرد. مقایسه برابری را در بخش «Equality Comparison» صفحه ۳۴۴ و دیکشنری‌ها را در فصل ۷ به‌طور مفصل بررسی کرده‌ایم.</p>
<p>نوع‌های <strong>ValueTuple&lt;&gt;</strong> همچنین رابط <strong>IComparable</strong> را پیاده‌سازی می‌کنند (رجوع کنید به «Order Comparison» صفحه ۳۵۵)، بنابراین می‌توان از آن‌ها به‌عنوان کلید مرتب‌سازی استفاده کرد.</p>
<hr>
<h3>کلاس‌های System.Tuple 🗂️</h3>
<p>در فضای نام <strong>System</strong>، خانواده‌ای از نوع‌های generic به نام <strong>Tuple</strong> وجود دارد (نه ValueTuple). این‌ها از سال ۲۰۱۰ معرفی شدند و به‌صورت کلاس تعریف شده‌اند، در حالی که <strong>ValueTuple</strong> به‌صورت struct هستند.</p>
<p>در عمل، تعریف تاپل‌ها به‌صورت کلاس، اشتباه محسوب شد؛ چرا که در سناریوهای رایج استفاده از تاپل، <strong>struct</strong> کمی بهتر عمل می‌کند و از تخصیص حافظه اضافی جلوگیری می‌کند. به همین دلیل، وقتی مایکروسافت پشتیبانی زبانی برای تاپل‌ها در C# 7 اضافه کرد، <strong>Tuple</strong> قدیمی را کنار گذاشت و به <strong>ValueTuple</strong> جدید روی آورد.</p>
<p>با این حال، هنوز ممکن است در کدهای قبل از C# 7 با کلاس‌های Tuple برخورد کنید. این‌ها پشتیبانی زبانی خاصی ندارند و به شکل زیر استفاده می‌شوند:</p>
<pre class="hljs"><code>Tuple&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; t = Tuple.Create(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">23</span>);  <span class="hljs-comment">// متد کارخانه‌ای (Factory method)</span>
Console.WriteLine(t.Item1);  <span class="hljs-comment">// Bob</span>
Console.WriteLine(t.Item2);  <span class="hljs-comment">// 23</span>
</code></pre>
<hr>
<h3>رکوردها (Records) 📄</h3>
<p>رکورد یک نوع خاص از <strong>کلاس یا struct</strong> است که برای کار با داده‌های <strong>غیرقابل تغییر (immutable/read-only)</strong> طراحی شده است.</p>
<p>ویژگی مفید آن، <strong>تغییر غیرمخرب (nondestructive mutation)</strong> است؛ با این حال، رکوردها برای ایجاد انواعی که صرفاً داده‌ها را نگه می‌دارند یا ترکیب می‌کنند نیز مفید هستند. در موارد ساده، رکوردها <strong>کدهای اضافی را حذف می‌کنند</strong> و در عین حال، <strong>مقایسه برابری مناسب برای انواع غیرقابل تغییر</strong> را رعایت می‌کنند.</p>
<p>رکوردها صرفاً یک <strong>مفهوم زمان کامپایل در C#</strong> هستند و در زمان اجرا، CLR آن‌ها را به‌صورت کلاس یا struct معمولی می‌بیند (با چند عضو اضافی «ترکیب‌شده» توسط کامپایلر).</p>
<hr>
<h3>مقدمه 📝</h3>
<p>نوشتن <strong>انواع غیرقابل تغییر (immutable types)</strong> که در آن‌ها فیلدها پس از مقداردهی اولیه قابل تغییر نباشند، یک استراتژی رایج برای ساده‌تر کردن نرم‌افزار و کاهش باگ‌ها است. این موضوع همچنین بخش اصلی <strong>برنامه‌نویسی تابعی (functional programming)</strong> است، جایی که از حالت قابل تغییر اجتناب می‌شود و توابع به‌عنوان داده در نظر گرفته می‌شوند. LINQ نیز از این اصل الهام گرفته است.</p>
<p>برای «تغییر» یک شیء غیرقابل تغییر، باید یک نمونه جدید بسازید و داده‌ها را با تغییرات مورد نظر خود منتقل کنید (<strong>تغییر غیرمخرب – nondestructive mutation</strong>). از نظر کارایی، این کار به اندازه‌ای که فکر می‌کنید ناکارآمد نیست، زیرا <strong>کپی سطحی (shallow copy)</strong> همیشه کافی است و نیازی به <strong>کپی عمیق (deep copy)</strong> که شامل زیرشی‌ها و مجموعه‌ها نیز باشد، نیست؛ چرا که داده‌ها غیرقابل تغییر هستند. اما از نظر حجم کدنویسی، پیاده‌سازی تغییر غیرمخرب می‌تواند بسیار پرزحمت باشد، به‌ویژه وقتی تعداد زیادی property وجود داشته باشد. <strong>رکوردها (records)</strong> این مشکل را با یک <strong>الگوی پشتیبانی‌شده توسط زبان</strong> حل می‌کنند.</p>
<p>مسئله دوم این است که برنامه‌نویسان—به‌ویژه برنامه‌نویسان تابعی—گاهی از انواع غیرقابل تغییر صرفاً برای <strong>ترکیب داده‌ها</strong> استفاده می‌کنند (بدون افزودن رفتار). تعریف چنین انواعی کاری بیشتر از آنچه باید باشد می‌برد، زیرا لازم است <strong>یک سازنده (constructor)</strong> داشته باشید تا هر پارامتر را به هر property عمومی اختصاص دهد (یک <strong>deconstructor</strong> نیز ممکن است مفید باشد). با رکوردها، کامپایلر این کار را برای شما انجام می‌دهد.</p>
<p>در نهایت، یکی از نتایج غیرقابل تغییر بودن یک شیء این است که <strong>هویت آن تغییر نمی‌کند</strong>؛ بنابراین برای این نوع‌ها، پیاده‌سازی <strong>برابری ساختاری (structural equality)</strong> بیشتر مفید است تا <strong>برابری مرجع (referential equality)</strong>. برابری ساختاری یعنی دو نمونه زمانی برابرند که <strong>داده‌های آن‌ها یکسان باشد</strong> (مانند تاپل‌ها). رکوردها به‌صورت پیش‌فرض برابری ساختاری را فراهم می‌کنند—صرف‌نظر از این‌که نوع زیرین کلاس باشد یا struct—بدون هیچ کد اضافی.</p>
<hr>
<h3>تعریف رکورد 🏷️</h3>
<p>تعریف یک رکورد شبیه تعریف <strong>کلاس یا struct</strong> است و می‌تواند شامل همان نوع اعضا باشد، از جمله فیلدها، propertyها، متدها و غیره. رکوردها می‌توانند <strong>interfaceها</strong> را پیاده‌سازی کنند و رکوردهای مبتنی بر کلاس می‌توانند از رکوردهای دیگر ارث‌بری کنند.</p>
<p>به‌صورت پیش‌فرض، <strong>نوع زیرین رکورد کلاس است</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span> { }   <span class="hljs-comment">// Point یک کلاس است</span>
</code></pre>
<p>از C# 10 به بعد، نوع زیرین رکورد می‌تواند struct نیز باشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">struct</span> <span class="hljs-title">Point</span> { }   <span class="hljs-comment">// Point یک struct است</span>
</code></pre>
<p>(استفاده از <code>record class</code> نیز قانونی است و همان معنی <code>record</code> را دارد.)</p>
<p>یک رکورد ساده ممکن است فقط تعدادی <strong>property با init-only</strong> داشته باشد و احتمالاً یک <strong>سازنده</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">double</span> y</span>)</span> =&gt; (X, Y) = (x, y);
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> X { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Y { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }    
}
</code></pre>
<p>سازنده ما از یک <strong>میانبر (shortcut)</strong> استفاده می‌کند که در بخش قبل توضیح داده شد:</p>
<pre class="hljs"><code>(X, Y) = (x, y);
</code></pre>
<p>این در واقع معادل است با:</p>
<pre class="hljs"><code>{ <span class="hljs-keyword">this</span>.X = x; <span class="hljs-keyword">this</span>.Y = y; }
</code></pre>
<hr>
<h3>کارهای کامپایلر هنگام تعریف رکورد ⚙️</h3>
<p>پس از کامپایل، C# تعریف رکورد را به کلاس (یا struct) تبدیل می‌کند و مراحل اضافی زیر را انجام می‌دهد:</p>
<ul>
<li>نوشتن <strong>سازنده کپی (copy constructor)</strong> محافظت‌شده و یک <strong>متد Clone پنهان</strong> برای تسهیل تغییر غیرمخرب</li>
<li>بازتعریف/بارگذاری مجدد متدهای مرتبط با برابری برای پیاده‌سازی <strong>برابری ساختاری</strong></li>
<li>بازتعریف متد <strong>ToString()</strong> (برای نمایش propertyهای عمومی، مشابه anonymous types)</li>
</ul>
<p>مثال تقریباً برابر با آنچه بالا تعریف شد:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>
{  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">double</span> y</span>)</span> =&gt; (X, Y) = (x, y);
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> X { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Y { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }    

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Point</span>(<span class="hljs-params">Point original</span>)  <span class="hljs-comment">// سازنده کپی</span></span>
    {
        <span class="hljs-keyword">this</span>.X = original.X; <span class="hljs-keyword">this</span>.Y = original.Y;
    }

    <span class="hljs-comment">// نام عجیب تولید شده توسط کامپایلر</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Point &lt;Clone&gt;$() =&gt; <span class="hljs-keyword">new</span> Point(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// متد Clone</span>

    <span class="hljs-comment">// کد اضافی برای بازتعریف Equals, ==, !=, GetHashCode, ToString()</span>
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<hr>
<h3>لیست پارامترها 📝</h3>
<p>هیچ چیزی مانع قرار دادن <strong>پارامترهای اختیاری (optional)</strong> در سازنده نمی‌شود، اما یک الگوی خوب (به‌ویژه در کتابخانه‌های عمومی) این است که آن‌ها را <strong>از سازنده حذف کرده و صرفاً به‌صورت propertyهای init-only</strong> ارائه دهید:</p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> Foo(<span class="hljs-number">123</span>, <span class="hljs-number">234</span>) { Optional2 = <span class="hljs-number">345</span> };

<span class="hljs-keyword">record</span> <span class="hljs-title">Foo</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> required1, <span class="hljs-built_in">int</span> required2</span>)</span> { ... }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Required1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Required2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Optional1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Optional2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
}
</code></pre>
<p>مزیت این الگو این است که می‌توان <strong>propertyهای init-only جدید</strong> اضافه کرد بدون اینکه <strong>سازگاری باینری با نسخه‌های قدیمی</strong> را مختل کنید.</p>
<hr>
<h3>کوتاه‌سازی تعریف رکورد با لیست پارامترها ⚡</h3>
<p>تعریف رکورد را می‌توان با <strong>لیست پارامترها</strong> کوتاه کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>)
{
    <span class="hljs-comment">// می‌توانید اعضای کلاس اضافی نیز تعریف کنید...</span>
}
</code></pre>
<p>پارامترها می‌توانند شامل <strong>modifiers</strong> مانند <code>in</code> و <code>params</code> باشند، اما نه <code>out</code> یا <code>ref</code>. اگر لیست پارامتر مشخص شود، کامپایلر کارهای اضافی زیر را انجام می‌دهد:</p>
<ul>
<li>نوشتن یک property <strong>init-only</strong> برای هر پارامتر</li>
<li>نوشتن <strong>سازنده اصلی (primary constructor)</strong> برای مقداردهی propertyها</li>
<li>نوشتن یک <strong>deconstructor</strong></li>
</ul>
<p>بنابراین اگر رکورد خود را ساده تعریف کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>);
</code></pre>
<p>کامپایلر تقریباً همان کدی را تولید می‌کند که در بخش قبل دیدیم. تنها تفاوت جزئی این است که نام پارامترها در سازنده اصلی <code>X</code> و <code>Y</code> خواهد بود، نه <code>x</code> و <code>y</code>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> X, <span class="hljs-built_in">double</span> Y</span>)  <span class="hljs-comment">// سازنده اصلی</span></span>
{
    <span class="hljs-keyword">this</span>.X = X; <span class="hljs-keyword">this</span>.Y = Y;
}
</code></pre>
<hr>
<h3>قابلیت‌های اضافی لیست پارامترها</h3>
<ul>
<li>پارامترهای <code>X</code> و <code>Y</code> به‌صورت جادویی در هر <strong>initializer</strong> فیلد یا property در رکورد در دسترس هستند</li>
<li>کامپایلر <strong>یک deconstructor</strong> نیز تولید می‌کند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deconstruct</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">double</span> X, <span class="hljs-keyword">out</span> <span class="hljs-built_in">double</span> Y</span>)</span>
{
    X = <span class="hljs-keyword">this</span>.X; Y = <span class="hljs-keyword">this</span>.Y;
}
</code></pre>
<ul>
<li>رکوردهایی با لیست پارامتر را می‌توان <strong>به‌عنوان subclass</strong> تعریف کرد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point3D</span>(<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>, <span class="hljs-title">double</span> <span class="hljs-title">Z</span>) : <span class="hljs-title">Point</span>(<span class="hljs-title">X</span>, <span class="hljs-title">Y</span>);
</code></pre>
<p>که کامپایلر تولید می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Point3D</span> : <span class="hljs-title">Point</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Z { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point3D</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> X, <span class="hljs-built_in">double</span> Y, <span class="hljs-built_in">double</span> Z</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">X, Y</span>)</span>
        =&gt; <span class="hljs-keyword">this</span>.Z = Z;
}
</code></pre>
<p>لیست پارامترها یک <strong>میانبر عالی</strong> برای کلاس‌هایی هستند که صرفاً <strong>چند مقدار را گروه‌بندی می‌کنند (product type در برنامه‌نویسی تابعی)</strong> و برای <strong>نمونه‌سازی سریع (prototyping)</strong> مفید هستند. البته هنگام نیاز به <strong>اضافه کردن منطق به accessors init</strong> (مثلاً اعتبارسنجی پارامتر) چندان مناسب نیستند.</p>
<h3>قابلیت تغییرپذیری در رکوردهای Struct 🔄</h3>
<p>وقتی که <strong>لیست پارامتر</strong> در یک <strong>record struct</strong> تعریف می‌کنید، کامپایلر به‌صورت پیش‌فرض <strong>propertyهای قابل نوشتن (writable)</strong> ایجاد می‌کند، نه propertyهای <strong>init-only</strong>، مگر اینکه تعریف رکورد را با کلمه کلیدی <code>readonly</code> پیش‌فرض کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">readonly</span> <span class="hljs-keyword">record</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> X, <span class="hljs-built_in">double</span> Y</span>)</span>;
</code></pre>
<p>دلیل این رفتار این است که در <strong>سناریوهای معمولی</strong>، مزایای ایمنی <strong>غیرقابل تغییر بودن (immutability)</strong> از این ناشی می‌شود که <strong>خانه یا محیط نگهدارنده struct غیرقابل تغییر است</strong>، نه خود struct.</p>
<p>در مثال زیر، حتی اگر فیلد <code>X</code> قابل نوشتن باشد، قادر به تغییر آن نیستیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> test = <span class="hljs-keyword">new</span> Immutable();
test.Field.X++;  <span class="hljs-comment">// غیرمجاز، زیرا Field readonly است</span>
test.Prop.X++;   <span class="hljs-comment">// غیرمجاز، زیرا Prop فقط { get; } دارد</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">Immutable</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> Mutable Field;
    <span class="hljs-keyword">public</span> Mutable Prop { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">struct</span> Mutable { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X, Y; }
</code></pre>
<p>و اگر بخواهیم کاری مانند زیر انجام دهیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> test = <span class="hljs-keyword">new</span> Immutable();
Mutable m = test.Prop;
m.X++;
</code></pre>
<p>تمام کاری که انجام می‌دهیم این است که یک <strong>متغیر محلی (local variable)</strong> را تغییر می‌دهیم، که نسخه‌ای کپی از <code>test.Prop</code> است. تغییر یک متغیر محلی می‌تواند یک <strong>بهینه‌سازی مفید</strong> باشد و مزایای <strong>سیستم نوع غیرقابل تغییر</strong> را نقض نمی‌کند.</p>
<p>از طرف دیگر، اگر <code>Field</code> یک فیلد قابل نوشتن و <code>Prop</code> یک property قابل نوشتن باشد، می‌توانیم به راحتی <strong>محتویات آن‌ها را جایگزین کنیم</strong>—صرف‌نظر از اینکه struct <code>Mutable</code> چگونه تعریف شده است.</p>
<h3>تغییرات غیرمخرب (Nondestructive Mutation) 🔄✨</h3>
<p>مهم‌ترین کاری که کامپایلر با <strong>تمام رکوردها</strong> انجام می‌دهد، ایجاد یک <strong>کپی‌کننده (copy constructor)</strong> و یک <strong>متد پنهان Clone</strong> است. این امکان را فراهم می‌کند که بتوانید با استفاده از <strong>کلمه کلیدی <code>with</code></strong>، یک تغییر غیرمخرب روی رکورد انجام دهید:</p>
<pre class="hljs"><code>Point p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);
Point p2 = p1 <span class="hljs-keyword">with</span> { Y = <span class="hljs-number">4</span> };
Console.WriteLine(p2);       <span class="hljs-comment">// Point { X = 3, Y = 4 }</span>

<span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>);
</code></pre>
<p>در این مثال، <code>p2</code> نسخه‌ای <strong>کپی از <code>p1</code></strong> است، ولی با مقدار <strong>Y = 4</strong>. مزیت این روش وقتی واضح‌تر می‌شود که رکورد تعداد زیادی property داشته باشد:</p>
<pre class="hljs"><code>Test t1 = <span class="hljs-keyword">new</span> Test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);
Test t2 = t1 <span class="hljs-keyword">with</span> { A = <span class="hljs-number">10</span>, C = <span class="hljs-number">30</span> };
Console.WriteLine(t2);

<span class="hljs-keyword">record</span> <span class="hljs-title">Test</span>(<span class="hljs-title">int</span> <span class="hljs-title">A</span>, <span class="hljs-title">int</span> <span class="hljs-title">B</span>, <span class="hljs-title">int</span> <span class="hljs-title">C</span>, <span class="hljs-title">int</span> <span class="hljs-title">D</span>, <span class="hljs-title">int</span> <span class="hljs-title">E</span>, <span class="hljs-title">int</span> <span class="hljs-title">F</span>, <span class="hljs-title">int</span> <span class="hljs-title">G</span>, <span class="hljs-title">int</span> <span class="hljs-title">H</span>);
</code></pre>
<p>خروجی به شکل زیر خواهد بود:</p>
<pre class="hljs"><code>Test { A = 10, B = 2, C = 30, D = 4, E = 5, F = 6, G = 7, H = 8 }
</code></pre>
<h3>مراحل تغییر غیرمخرب 🛠️</h3>
<p>1️⃣ ابتدا، <strong>کپی‌کننده</strong> رکورد را clone می‌کند. به‌طور پیش‌فرض، هر یک از فیلدهای داخلی رکورد کپی می‌شوند، که یک <strong>نسخه دقیق</strong> ایجاد می‌کند و از اجرای منطق در accessorهای init جلوگیری می‌کند. تمام فیلدها شامل <strong>عمومی، خصوصی و فیلدهای پنهان پشت propertyهای اتوماتیک</strong> در کپی گنجانده می‌شوند.</p>
<p>2️⃣ سپس، هر property در <strong>لیست مقداردهی اعضا (member initializer)</strong> به‌روزرسانی می‌شود، این بار با استفاده از <strong>init accessor</strong>.</p>
<p>کامپایلر کد زیر را:</p>
<pre class="hljs"><code>Test t2 = t1 <span class="hljs-keyword">with</span> { A = <span class="hljs-number">10</span>, C = <span class="hljs-number">30</span> };
</code></pre>
<p>به چیزی شبیه به این تبدیل می‌کند:</p>
<pre class="hljs"><code>Test t2 = <span class="hljs-keyword">new</span> Test(t1);  <span class="hljs-comment">// استفاده از copy constructor برای clone کردن t1 فیلد به فیلد</span>
t2.A = <span class="hljs-number">10</span>;               <span class="hljs-comment">// به‌روزرسانی property A</span>
t2.C = <span class="hljs-number">30</span>;               <span class="hljs-comment">// به‌روزرسانی property C</span>
</code></pre>
<blockquote>
<p>⚠️ همان‌طور که می‌بینید، نوشتن مستقیم این کد در حالت عادی <strong>کامپایل نمی‌شود</strong> چون A و C propertyهای <strong>init-only</strong> هستند. علاوه بر این، copy constructor <strong>protected</strong> است و C# برای دور زدن این محدودیت، آن را از طریق متد پنهان <code>&lt;Clone&gt;$</code> فراخوانی می‌کند.</p>
</blockquote>
<h3>تعریف کپی‌کننده سفارشی ✍️</h3>
<p>اگر لازم باشد، می‌توانید <strong>copy constructor خودتان</strong> را تعریف کنید. کامپایلر از تعریف شما استفاده خواهد کرد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Point</span>(<span class="hljs-params">Point original</span>)</span>
{
    <span class="hljs-keyword">this</span>.X = original.X; 
    <span class="hljs-keyword">this</span>.Y = original.Y;
}
</code></pre>
<p>نوشتن کپی‌کننده سفارشی مفید است اگر رکورد شما حاوی <strong>زیر-اشیاء یا مجموعه‌های قابل تغییر</strong> باشد که باید clone شوند، یا فیلدهای محاسبه‌شده‌ای داشته باشید که می‌خواهید پاک شوند. ⚠️ توجه کنید که تنها می‌توانید <strong>جایگزین</strong> کنید، نه <strong>بهبود دهید</strong>.</p>
<p>در <strong>Subclass کردن رکورد دیگر</strong>، copy constructor مسئول <strong>کپی فقط فیلدهای خودش</strong> است. برای کپی فیلدهای رکورد پایه، از <strong>delegate به base</strong> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Point</span>(<span class="hljs-params">Point original</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">original</span>)</span>
{
    ...
}
</code></pre>
<h3>اعتبارسنجی propertyها ✅</h3>
<p>با propertyهای <strong>صریح</strong>، می‌توانید منطق اعتبارسنجی را در <strong>init accessor</strong> بنویسید. به عنوان مثال، مطمئن می‌شویم X هیچ‌گاه <strong>NaN</strong> نباشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">double</span> y</span>)</span> =&gt; (X, Y) = (x, y);
    <span class="hljs-built_in">double</span> _x;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> X
    { 
        <span class="hljs-keyword">get</span> =&gt; _x;
        <span class="hljs-keyword">init</span>
        {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">double</span>.IsNaN(<span class="hljs-keyword">value</span>))
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;X Cannot be NaN&quot;</span>);
            _x = <span class="hljs-keyword">value</span>;
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Y { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }    
}
</code></pre>
<p>با این طراحی، اعتبارسنجی هم <strong>در زمان ساخت رکورد</strong> و هم <strong>در زمان تغییر غیرمخرب</strong> انجام می‌شود:</p>
<pre class="hljs"><code>Point p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);
Point p2 = p1 <span class="hljs-keyword">with</span> { X = <span class="hljs-built_in">double</span>.NaN };   <span class="hljs-comment">// پرتاب Exception</span>
</code></pre>
<p>کپی‌کننده خودکار، <strong>تمام فیلدها و propertyهای اتوماتیک</strong> را کپی می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Point</span>(<span class="hljs-params">Point original</span>)</span>
{
    _x = original._x; 
    Y = original.Y;
}
</code></pre>
<p>کپی کردن <code>_x</code> از طریق <strong>accessor</strong> انجام نمی‌شود، ولی مشکلی ایجاد نمی‌کند چون مقدار قبلاً با <strong>init accessor</strong> به‌صورت امن مقداردهی شده است.</p>
<h3>فیلدهای محاسبه‌شده و ارزیابی Lazy ⚡</h3>
<p>یکی از الگوهای رایج در <strong>برنامه‌نویسی تابعی (Functional)</strong> که با رکوردهای غیرقابل تغییر خوب کار می‌کند، <strong>lazy evaluation</strong> است: مقدار تنها وقتی محاسبه می‌شود که لازم باشد و سپس برای استفاده بعدی <strong>کش</strong> می‌شود.</p>
<p>مثلاً می‌خواهیم propertyی در رکورد Point تعریف کنیم که فاصله از مبدأ (0,0) را برگرداند:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>)
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> DistanceFromOrigin =&gt; Math.Sqrt(X*X + Y*Y);
}
</code></pre>
<p>برای بهینه‌سازی و جلوگیری از محاسبه مکرر، می‌توانیم مقدار آن را <strong>lazy</strong> در یک فیلد ذخیره کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>
{
    <span class="hljs-built_in">double</span>? _distance;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> X { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Y { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> DistanceFromOrigin =&gt; _distance ??= Math.Sqrt(X*X + Y*Y);
}
</code></pre>
<p>✅ در این حالت، <code>_distance</code> تنها <strong>یک بار محاسبه</strong> می‌شود و تغییر <code>X</code> یا <code>Y</code> باعث پاک شدن مقدار کش شده می‌شود.</p>
<pre class="hljs"><code>Point p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);
Console.WriteLine(p1.DistanceFromOrigin);   <span class="hljs-comment">// 3.605551275463989</span>
Point p2 = p1 <span class="hljs-keyword">with</span> { Y = <span class="hljs-number">4</span> };
Console.WriteLine(p2.DistanceFromOrigin);   <span class="hljs-comment">// 4.47213595499958</span>
</code></pre>
<p>مزیت دیگر این است که <strong>copy constructor خودکار</strong> نیز فیلد کش شده <code>_distance</code> را کپی می‌کند، بنابراین اگر propertyهای دیگری که در محاسبات دخیل نیستند، تغییر کنند، <strong>مقدار کش شده از بین نمی‌رود</strong>.</p>
<p>اگر نخواهید این رفتار را داشته باشید، می‌توانید در <strong>init accessor</strong> مقدار کش را پاک کنید یا یک <strong>copy constructor سفارشی</strong> بنویسید که فیلد کش را نادیده بگیرد.</p>
<hr>
<h3>سازنده‌های اولیه (Primary Constructors) 🏗️✨</h3>
<p>وقتی یک <strong>رکورد</strong> با <strong>لیست پارامترها</strong> تعریف می‌کنید، کامپایلر به‌طور خودکار <strong>propertyها</strong> را تعریف می‌کند و یک <strong>سازنده اولیه (primary constructor)</strong> و یک <strong>deconstructor</strong> ایجاد می‌کند. همان‌طور که دیدیم، این روش در موارد ساده خوب کار می‌کند و در موارد پیچیده‌تر می‌توانید لیست پارامترها را حذف کرده و propertyها و سازنده را به‌صورت دستی بنویسید.</p>
<p>C# همچنین یک گزینه <strong>میان‌راه مفید</strong> ارائه می‌دهد؛ اگر بخواهید با <strong>معنای عجیب سازنده‌های اولیه</strong> کنار بیایید، می‌توانید یک <strong>لیست پارامتر تعریف کنید</strong> و در عین حال برخی یا همه propertyها را خودتان تعریف کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Student</span>(<span class="hljs-title">string</span> <span class="hljs-title">ID</span>, <span class="hljs-title">string</span> <span class="hljs-title">LastName</span>, <span class="hljs-title">string</span> <span class="hljs-title">GivenName</span>)
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> ID { <span class="hljs-keyword">get</span>; } = ID;
}
</code></pre>
<p>در این حالت، ما property <strong>ID</strong> را <strong>به‌طور دستی مدیریت کردیم</strong> و آن را به صورت <strong>read-only</strong> تعریف کردیم (به جای init-only)، بنابراین این property دیگر در <strong>تغییر غیرمخرب (nondestructive mutation)</strong> شرکت نمی‌کند.</p>
<p>اگر هیچ‌وقت نیازی به تغییر غیرمخرب یک property ندارید، تعریف آن به صورت <strong>read-only</strong> اجازه می‌دهد داده‌های محاسبه‌شده را بدون نیاز به نوشتن مکانیسم تازه‌سازی ذخیره کنید.</p>
<p>⚠️ دقت کنید که لازم بود <strong>یک مقداردهی اولیه برای property</strong> ارائه دهیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> ID { <span class="hljs-keyword">get</span>; } = ID;
</code></pre>
<p>زمانی که <strong>تعریف property را به عهده می‌گیرید</strong>، مسئول مقداردهی آن هستید و <strong>سازنده اولیه دیگر به‌صورت خودکار آن را مقداردهی نمی‌کند</strong>. (این دقیقاً مشابه رفتار کلاس‌ها و structها با سازنده‌های اولیه است.) همچنین توجه کنید که <strong>ID در اینجا به پارامتر سازنده اولیه اشاره دارد، نه به property.</strong></p>
<hr>
<h3>رکوردهای struct و بازتعریف property به عنوان field 🧱</h3>
<p>با <strong>record struct</strong>، قانونی است که property را به عنوان <strong>field</strong> بازتعریف کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">struct</span> <span class="hljs-title">Student</span>(<span class="hljs-title">string</span> <span class="hljs-title">ID</span>)
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> ID = ID;
}
</code></pre>
<p>طبق <strong>معنای سازنده‌های اولیه در کلاس‌ها و structها</strong>، پارامترهای سازنده اولیه (مثل ID، LastName و GivenName) <strong>به‌طور جادویی در تمام initializerهای field و property قابل دسترس هستند</strong>. مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Student</span>(<span class="hljs-title">string</span> <span class="hljs-title">ID</span>, <span class="hljs-title">string</span> <span class="hljs-title">LastName</span>, <span class="hljs-title">string</span> <span class="hljs-title">FirstName</span>)
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> ID { <span class="hljs-keyword">get</span>; } = ID;
    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _enrollmentYear = <span class="hljs-built_in">int</span>.Parse(ID.Substring(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>));
}
</code></pre>
<p>در این مثال، <code>_enrollmentYear</code> از چهار رقم اول <strong>ID</strong> محاسبه شده است. چون property <strong>ID read-only</strong> است، می‌توان آن را امن در یک <strong>field read-only</strong> ذخیره کرد، بدون اینکه تغییر غیرمخرب مشکلی ایجاد کند.</p>
<p>⚠️ اما در دنیای واقعی، بدون <strong>سازنده صریح</strong>، هیچ مکان مرکزی برای اعتبارسنجی ID و پرتاب <strong>exception معنی‌دار</strong> وجود ندارد.</p>
<hr>
<h3>اعتبارسنجی با init-only accessors ✅</h3>
<p>برای انجام <strong>اعتبارسنجی</strong> روی propertyها، باید از <strong>init-only accessor صریح</strong> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Person</span>(<span class="hljs-title">string</span> <span class="hljs-title">Name</span>)
{
    <span class="hljs-built_in">string</span> _name = Name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name
    {
        <span class="hljs-keyword">get</span> =&gt; _name;
        <span class="hljs-keyword">init</span> =&gt; _name = <span class="hljs-keyword">value</span> ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-string">&quot;Name&quot;</span>);
    }
}
</code></pre>
<p>⚠️ چون <strong>Name یک property اتوماتیک نیست</strong>، نمی‌توان initializer تعریف کرد. بهترین کار این است که initializer را روی <strong>field پشت property</strong> قرار دهید، اما این باعث می‌شود که <strong>check null نادیده گرفته شود</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-literal">null</span>);    <span class="hljs-comment">// موفقیت‌آمیز! (check نادیده گرفته شد)</span>
</code></pre>
<p>مشکل اصلی این است که <strong>نمی‌توان بدون نوشتن سازنده، پارامتر سازنده اولیه را به property اختصاص داد</strong>. راه‌حل ساده این است که <strong>لیست پارامتر را حذف کرده و یک سازنده معمولی بنویسید</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> =&gt; Name = name;  <span class="hljs-comment">// اختصاص به PROPERTY</span>
    <span class="hljs-built_in">string</span> _name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span> =&gt; _name; <span class="hljs-keyword">init</span> =&gt; ... }
}
</code></pre>
<hr>
<h3>رکوردها و مقایسه برابری (Equality) ⚖️</h3>
<p>مانند <strong>structها، anonymous types و tuples</strong>، رکوردها <strong>structural equality</strong> را به صورت پیش‌فرض ارائه می‌کنند؛ یعنی دو رکورد <strong>برابرند اگر فیلدها و propertyهای اتوماتیک آنها برابر باشند</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
Console.WriteLine(p1.Equals(p2));   <span class="hljs-comment">// True</span>

<span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>);
</code></pre>
<p>عملگر <strong>==</strong> نیز با رکوردها کار می‌کند (مانند tuples):</p>
<pre class="hljs"><code>Console.WriteLine(p1 == p2);         <span class="hljs-comment">// True</span>
</code></pre>
<p>⚠️ اجرای پیش‌فرض برابری برای رکوردها ممکن است آسیب‌پذیر باشد، به‌خصوص اگر رکورد حاوی <strong>مقادیر lazy، transient، آرایه‌ها یا collectionها</strong> باشد که نیاز به مدیریت ویژه برای مقایسه دارند. خوشبختانه، اصلاح آن نسبتاً ساده است و نیاز به کار زیادی ندارد.</p>
<hr>
<h3>نوشتن Equals سفارشی 🖋️</h3>
<p>بر خلاف کلاس‌ها و structها، <strong>نمی‌توانید object.Equals را override کنید</strong>؛ در عوض باید یک متد <strong>public Equals</strong> با این <strong>امضا</strong> تعریف کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>)
{
    <span class="hljs-built_in">double</span> _someOtherField;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Point other</span>)</span> =&gt;
        other != <span class="hljs-literal">null</span> &amp;&amp; X == other.X &amp;&amp; Y == other.Y;
}
</code></pre>
<ul>
<li>متد <strong>Equals</strong> باید <strong>virtual</strong> باشد، نه override.</li>
<li>نوع پارامتر باید <strong>نوع رکورد واقعی</strong> باشد (در این مثال Point، نه object).</li>
<li>وقتی امضا درست باشد، کامپایلر به صورت خودکار متد شما را patch می‌کند.</li>
</ul>
<p>در مثال بالا، منطق برابری را تغییر دادیم تا فقط <strong>X و Y</strong> مقایسه شوند و <code>_someOtherField</code> نادیده گرفته شود.</p>
<p>اگر رکورد دیگری را <strong>subclass</strong> کنید، می‌توانید <strong>base.Equals</strong> را فراخوانی کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Point other</span>)</span> =&gt; <span class="hljs-keyword">base</span>.Equals(other) &amp;&amp; ...
</code></pre>
<p>✅ نکته مهم: اگر منطق برابری را خودتان پیاده کنید، باید <strong>GetHashCode</strong> را نیز override کنید. خوشبختانه در رکوردها نیازی به overload کردن <strong>!= یا ==</strong> و پیاده‌سازی <strong>IEquatable<T></strong> نیست؛ همه این‌ها به‌صورت خودکار انجام می‌شود.</p>
<p>موضوع <strong>مقایسه برابری رکوردها</strong> به صورت کامل در بخش «Equality Comparison» صفحه 344 پوشش داده شده است.</p>
<h3>الگوها (Patterns) 🧩✨</h3>
<p>در فصل ۳، نشان دادیم که چگونه می‌توان از عملگر <strong>is</strong> برای بررسی موفقیت <strong>تبدیل مرجع (reference conversion)</strong> استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>)
    Console.WriteLine(((<span class="hljs-built_in">string</span>)obj).Length);
</code></pre>
<p>یا به شکل کوتاه‌تر:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> s)
    Console.WriteLine(s.Length);
</code></pre>
<p>این روش کوتاه، یکی از <strong>الگوها (type pattern)</strong> را به کار می‌گیرد. عملگر <strong>is</strong> همچنین از الگوهای دیگری پشتیبانی می‌کند که در نسخه‌های اخیر C# معرفی شده‌اند، مانند <strong>property pattern</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> { Length: <span class="hljs-number">4</span> })
    Console.WriteLine(<span class="hljs-string">&quot;A string with 4 characters&quot;</span>);
</code></pre>
<p>الگوها در زمینه‌های زیر پشتیبانی می‌شوند:</p>
<ul>
<li>بعد از عملگر <strong>is</strong> <code>(variable is pattern)</code></li>
<li>در <strong>switch statements</strong></li>
<li>در <strong>switch expressions</strong></li>
</ul>
<p>ما قبلاً <strong>type pattern</strong> (و به طور خلاصه، <strong>tuple pattern</strong>) را در بخش‌های «Switching on types» صفحه 89 و «The is operator» صفحه 130 پوشش داده‌ایم. در این بخش، الگوهای پیشرفته‌تر معرفی شده در نسخه‌های جدید C# را بررسی می‌کنیم.</p>
<p>برخی از الگوهای تخصصی‌تر عمدتاً برای استفاده در <strong>switch statements/expressions</strong> طراحی شده‌اند و نیاز به <strong>when clauses</strong> را کاهش می‌دهند و امکان استفاده از <strong>switch</strong> را در مواقعی فراهم می‌کنند که قبلاً امکان آن نبود.</p>
<p>⚠️ به یاد داشته باشید که همیشه می‌توانید <strong>switch expressionهای پیچیده</strong> را با <strong>if ساده</strong> جایگزین کنید، یا در برخی موارد از <strong>عملگر شرطی سه‌تایی (ternary operator)</strong> استفاده کنید، معمولاً بدون نیاز به کد اضافی زیاد.</p>
<hr>
<h3>الگوی ثابت (Constant Pattern) 🔢</h3>
<p>الگوی ثابت به شما امکان می‌دهد مستقیماً با یک <strong>ثابت (constant)</strong> مطابقت دهید و هنگام کار با نوع <strong>object</strong> مفید است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span>
{
    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-number">3</span>) ...
}
</code></pre>
<p>این عبارت با کد زیر معادل است:</p>
<pre class="hljs"><code>obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span> &amp;&amp; (<span class="hljs-built_in">int</span>)obj == <span class="hljs-number">3</span>
</code></pre>
<p>⚠️ چون این یک عملگر <strong>static</strong> است، C# اجازه نمی‌دهد که مستقیماً با <strong>==</strong> یک object را با یک constant مقایسه کنید، زیرا کامپایلر باید نوع‌ها را از قبل بداند.</p>
<p>به تنهایی، این الگو کاربرد محدودی دارد، زیرا جایگزین منطقی آن این است:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-number">3.</span>Equals(obj)) ...
</code></pre>
<p>به زودی خواهیم دید که <strong>الگوی ثابت</strong> با <strong>pattern combinators</strong> بسیار کاربردی‌تر می‌شود.</p>
<hr>
<h3>الگوهای رابطه‌ای (Relational Patterns) 📏</h3>
<p>از C# 9 به بعد، می‌توانید از عملگرهای <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> در الگوها استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">is</span> &gt; <span class="hljs-number">100</span>) Console.WriteLine(<span class="hljs-string">&quot;x is greater than 100&quot;</span>);
</code></pre>
<p>این الگو در <strong>switch</strong> بسیار مفید می‌شود:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetWeightCategory</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> bmi</span>)</span> =&gt; bmi <span class="hljs-keyword">switch</span>
{
    &lt; <span class="hljs-number">18.5</span>m =&gt; <span class="hljs-string">&quot;underweight&quot;</span>,
    &lt; <span class="hljs-number">25</span>m =&gt; <span class="hljs-string">&quot;normal&quot;</span>,
    &lt; <span class="hljs-number">30</span>m =&gt; <span class="hljs-string">&quot;overweight&quot;</span>,
    _ =&gt; <span class="hljs-string">&quot;obese&quot;</span>
};
</code></pre>
<p>⚠️ الگوهای رابطه‌ای حتی زمانی که متغیر از نوع <strong>object</strong> باشد کار می‌کنند، اما باید در استفاده از <strong>ثابت‌های عددی</strong> بسیار دقت کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span> obj = <span class="hljs-number">2</span>m;                  <span class="hljs-comment">// obj از نوع decimal است</span>
Console.WriteLine(obj <span class="hljs-keyword">is</span> &lt; <span class="hljs-number">3</span>m);   <span class="hljs-comment">// True</span>
Console.WriteLine(obj <span class="hljs-keyword">is</span> &lt; <span class="hljs-number">3</span>);    <span class="hljs-comment">// False</span>
</code></pre>
<hr>
<h3>ترکیب‌کننده‌های الگو (Pattern Combinators) 🔗</h3>
<p>از C# 9 به بعد، می‌توانید از کلیدواژه‌های <strong>and, or, not</strong> برای ترکیب الگوها استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsJanetOrJohn</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> =&gt; name.ToUpper() <span class="hljs-keyword">is</span> <span class="hljs-string">&quot;JANET&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;JOHN&quot;</span>;
<span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsVowel</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> c</span>)</span> =&gt; c <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;e&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;i&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;o&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;u&#x27;</span>;
<span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Between1And9</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> =&gt; n <span class="hljs-keyword">is</span> &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> &lt;= <span class="hljs-number">9</span>;
<span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsLetter</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> c</span>)</span> =&gt; c <span class="hljs-keyword">is</span> &gt;= <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">and</span> &lt;= <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-keyword">or</span> &gt;= <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">and</span> &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>;
</code></pre>
<ul>
<li>مانند عملگرهای <code>&amp;&amp;</code> و <code>||</code>، <strong>and</strong> اولویت بالاتری نسبت به <strong>or</strong> دارد و می‌توان با پرانتز این ترتیب را تغییر داد.</li>
</ul>
<p>یک ترفند مفید این است که <strong>not combinator</strong> را با <strong>type pattern</strong> ترکیب کنید تا بررسی کنید آیا یک object <strong>از نوع خاصی نیست</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">string</span>) ...
</code></pre>
<p>این حالت زیباتر از نوشتن زیر است:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (!(obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>)) ...
</code></pre>
<h3>الگوی <code>var</code> 🟢</h3>
<p>الگوی <strong>var</strong> نوعی <strong>type pattern</strong> است که در آن به جای نام نوع، از کلمه کلیدی <strong>var</strong> استفاده می‌کنید. این تبدیل همیشه موفق است و هدف آن فقط <strong>امکان استفاده مجدد از متغیری است که پس از آن می‌آید</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsJanetOrJohn</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> =&gt; 
    name.ToUpper() <span class="hljs-keyword">is</span> <span class="hljs-keyword">var</span> upper &amp;&amp; (upper == <span class="hljs-string">&quot;JANET&quot;</span> || upper == <span class="hljs-string">&quot;JOHN&quot;</span>);
</code></pre>
<p>این معادل کد زیر است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsJanetOrJohn</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>
{
    <span class="hljs-built_in">string</span> upper = name.ToUpper();
    <span class="hljs-keyword">return</span> upper == <span class="hljs-string">&quot;JANET&quot;</span> || upper == <span class="hljs-string">&quot;JOHN&quot;</span>;
}
</code></pre>
<p>💡 توانایی <strong>معرفی و استفاده مجدد یک متغیر میانی</strong> (مثل <code>upper</code>) در یک متد با <strong>expression-bodied</strong> بسیار کاربردی است، به ویژه در <strong>lambda expressions</strong>.<br>
⚠️ متأسفانه، این الگو عمدتاً زمانی مفید است که متد مورد نظر <strong>نوع بازگشتی bool</strong> داشته باشد.</p>
<hr>
<h3>الگوهای Tuple و Positional 🟦</h3>
<p><strong>Tuple pattern</strong> (معرفی‌شده در C# 8) برای مطابقت با <strong>tuples</strong> استفاده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> p = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
Console.WriteLine(<span class="hljs-function">p <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-number">3</span></span>))</span>;  <span class="hljs-comment">// True</span>
</code></pre>
<p>می‌توانید از آن برای <strong>switch</strong> روی چند مقدار استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">AverageCelsiusTemperature</span>(<span class="hljs-params">Season season, <span class="hljs-built_in">bool</span> daytime</span>)</span> =&gt;
    (season, daytime) <span class="hljs-keyword">switch</span>
    {
        (Season.Spring, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-number">20</span>,
        (Season.Spring, <span class="hljs-literal">false</span>) =&gt; <span class="hljs-number">16</span>,
        (Season.Summer, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-number">27</span>,
        (Season.Summer, <span class="hljs-literal">false</span>) =&gt; <span class="hljs-number">22</span>,
        (Season.Fall, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-number">18</span>,
        (Season.Fall, <span class="hljs-literal">false</span>) =&gt; <span class="hljs-number">12</span>,
        (Season.Winter, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-number">10</span>,
        (Season.Winter, <span class="hljs-literal">false</span>) =&gt; <span class="hljs-number">-2</span>,
        _ =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Unexpected combination&quot;</span>)
    };

<span class="hljs-built_in">enum</span> Season { Spring, Summer, Fall, Winter };
</code></pre>
<p>⚡ <strong>Tuple pattern</strong> در واقع یک <strong>حالت ویژه از positional pattern</strong> است (C# 8+) که با هر نوعی که متد <strong>Deconstruct</strong> ارائه دهد، کار می‌کند.</p>
<p>مثال با <strong>record Point</strong> و <strong>deconstructor تولید شده توسط کامپایلر</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
Console.WriteLine(<span class="hljs-function">p <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-number">2</span></span>))</span>;  <span class="hljs-comment">// True</span>
<span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-title">int</span> <span class="hljs-title">X</span>, <span class="hljs-title">int</span> <span class="hljs-title">Y</span>);      <span class="hljs-comment">// دارای deconstructor تولید شده توسط کامپایلر</span>
</code></pre>
<p>می‌توانید هنگام <strong>match</strong>، متغیرها را <strong>deconstruct</strong> کنید:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-function">p <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-keyword">var</span> x, <span class="hljs-keyword">var</span> y</span>) &amp;&amp; x</span> == y);  <span class="hljs-comment">// True</span>
</code></pre>
<p>مثال <strong>switch expression</strong> که <strong>type pattern</strong> را با <strong>positional pattern</strong> ترکیب می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Print</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span> =&gt; obj <span class="hljs-keyword">switch</span> 
{
    Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) =&gt; <span class="hljs-string">&quot;Empty point&quot;</span>,
    Point(<span class="hljs-keyword">var</span> x, <span class="hljs-keyword">var</span> y) <span class="hljs-keyword">when</span> x == y =&gt; <span class="hljs-string">&quot;Diagonal&quot;</span>,
    ...
};
</code></pre>
<hr>
<h3>الگوهای Property 🏷️</h3>
<p><strong>Property pattern</strong> (C# 8+) بر اساس یک یا چند <strong>مقدار property</strong> یک object مطابقت می‌دهد.<br>
مثال ساده قبلاً با <strong>is operator</strong> داشتیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> { Length:<span class="hljs-number">4</span> }) ...
</code></pre>
<p>⚠️ این تنها کمی از نوشتن کد زیر صرفه‌جویی می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> s &amp;&amp; s.Length == <span class="hljs-number">4</span>) ...
</code></pre>
<p>با <strong>switch statements</strong> و <strong>expressions</strong>، property patterns کاربرد بیشتری پیدا می‌کنند.</p>
<p>مثال با کلاس <strong>System.Uri</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">ShouldAllow</span>(<span class="hljs-params">Uri uri</span>)</span> =&gt; uri <span class="hljs-keyword">switch</span>
{
    { Scheme: <span class="hljs-string">&quot;http&quot;</span>,  Port: <span class="hljs-number">80</span>  } =&gt; <span class="hljs-literal">true</span>,
    { Scheme: <span class="hljs-string">&quot;https&quot;</span>, Port: <span class="hljs-number">443</span> } =&gt; <span class="hljs-literal">true</span>,
    { Scheme: <span class="hljs-string">&quot;ftp&quot;</span>,   Port: <span class="hljs-number">21</span>  } =&gt; <span class="hljs-literal">true</span>,
    { IsLoopback: <span class="hljs-literal">true</span> } =&gt; <span class="hljs-literal">true</span>,
    _ =&gt; <span class="hljs-literal">false</span>
};
</code></pre>
<p>می‌توانید <strong>propertyها را تو در تو (nested)</strong> کنید، که از C# 10 به بعد می‌توان ساده‌سازی کرد:</p>
<pre class="hljs"><code>{ Scheme.Length: <span class="hljs-number">4</span>, Port: <span class="hljs-number">80</span> } =&gt; <span class="hljs-literal">true</span>,
</code></pre>
<p>همچنین می‌توان از <strong>الگوهای دیگر داخل property patterns</strong> استفاده کرد، مثل <strong>relational patterns</strong>:</p>
<pre class="hljs"><code>{ Host: { Length: &lt; <span class="hljs-number">1000</span> }, Port: &gt; <span class="hljs-number">0</span> } =&gt; <span class="hljs-literal">true</span>,
</code></pre>
<p>شرایط پیچیده‌تر را می‌توان با <strong>when clause</strong> بیان کرد:</p>
<pre class="hljs"><code>{ Scheme: <span class="hljs-string">&quot;http&quot;</span> } <span class="hljs-keyword">when</span> <span class="hljs-built_in">string</span>.IsNullOrWhiteSpace(uri.Query) =&gt; <span class="hljs-literal">true</span>,
</code></pre>
<p>می‌توانید <strong>property pattern را با type pattern ترکیب کنید</strong> و متغیر معرفی کنید:</p>
<pre class="hljs"><code>Uri { Scheme: <span class="hljs-string">&quot;http&quot;</span>, Port: <span class="hljs-number">80</span> } httpUri =&gt; httpUri.Host.Length &lt; <span class="hljs-number">1000</span>,
</code></pre>
<p>و همین متغیر را می‌توان در <strong>when clause</strong> استفاده کرد:</p>
<pre class="hljs"><code>Uri { Scheme: <span class="hljs-string">&quot;http&quot;</span>, Port: <span class="hljs-number">80</span> } httpUri 
    <span class="hljs-keyword">when</span> httpUri.Host.Length &lt; <span class="hljs-number">1000</span> =&gt; <span class="hljs-literal">true</span>,
</code></pre>
<p>نکته جالب: می‌توان متغیرها را در سطح property نیز معرفی کرد:</p>
<pre class="hljs"><code>{ Scheme: <span class="hljs-string">&quot;http&quot;</span>, Port: <span class="hljs-number">80</span>, Host: <span class="hljs-built_in">string</span> host } =&gt; host.Length &lt; <span class="hljs-number">1000</span>,
</code></pre>
<p>تایپ ضمنی نیز مجاز است، یعنی می‌توانید <strong>string</strong> را با <strong>var</strong> جایگزین کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">ShouldAllow</span>(<span class="hljs-params">Uri uri</span>)</span> =&gt; uri <span class="hljs-keyword">switch</span>
{
    { Scheme: <span class="hljs-string">&quot;http&quot;</span>,  Port: <span class="hljs-number">80</span>, Host: <span class="hljs-keyword">var</span> host } =&gt; host.Length &lt; <span class="hljs-number">1000</span>,
    { Scheme: <span class="hljs-string">&quot;https&quot;</span>, Port: <span class="hljs-number">443</span> } =&gt; <span class="hljs-literal">true</span>,
    { Scheme: <span class="hljs-string">&quot;ftp&quot;</span>,   Port: <span class="hljs-number">21</span>  } =&gt; <span class="hljs-literal">true</span>,
    { IsLoopback: <span class="hljs-literal">true</span> } =&gt; <span class="hljs-literal">true</span>,
    _ =&gt; <span class="hljs-literal">false</span>
};
</code></pre>
<p>⚠️ در بسیاری از موارد، صرفه‌جویی در تعداد کاراکترها زیاد نیست. جایگزین ساده‌تر می‌تواند این باشد:</p>
<pre class="hljs"><code>{ Scheme: <span class="hljs-string">&quot;http&quot;</span>, Port: <span class="hljs-number">80</span> } =&gt; uri.Host.Length &lt; <span class="hljs-number">1000</span>,
</code></pre>
<p>یا:</p>
<pre class="hljs"><code>{ Scheme: <span class="hljs-string">&quot;http&quot;</span>, Port: <span class="hljs-number">80</span>, Host: { Length: &lt; <span class="hljs-number">1000</span> } } =&gt; ...
</code></pre>
<h3>الگوهای List 📋</h3>
<p><strong>List patterns</strong> (معرفی‌شده در C# 11) روی هر نوع collection قابل شمارش (<strong>Count</strong> یا <strong>Length</strong>) و با <strong>indexer عددی</strong> کار می‌کنند.</p>
<p>یک <strong>list pattern</strong> با استفاده از براکت‌ها <code>[ ]</code> تعریف می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] numbers = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> };
Console.Write(numbers <span class="hljs-keyword">is</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);   <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>علامت <strong>underscore <code>_</code></strong> برای مطابقت با یک عنصر با هر مقداری استفاده می‌شود:</li>
</ul>
<pre class="hljs"><code>Console.Write(numbers <span class="hljs-keyword">is</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, _, _, <span class="hljs-number">4</span>]);   <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>می‌توانید از <strong>var pattern</strong> برای گرفتن یک عنصر استفاده کنید:</li>
</ul>
<pre class="hljs"><code>Console.Write(numbers <span class="hljs-keyword">is</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">var</span> x, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] &amp;&amp; x &gt; <span class="hljs-number">1</span>);   <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li><strong>دو نقطه <code>..</code></strong> برای مشخص کردن یک <strong>slice</strong> استفاده می‌شود که صفر یا چند عنصر را مطابقت می‌دهد:</li>
</ul>
<pre class="hljs"><code>Console.Write(numbers <span class="hljs-keyword">is</span> [<span class="hljs-number">0</span>, .., <span class="hljs-number">4</span>]);    <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>با آرایه‌ها یا سایر انواعی که از <strong>indices و ranges</strong> پشتیبانی می‌کنند، می‌توان slice را با var pattern ترکیب کرد:</li>
</ul>
<pre class="hljs"><code>Console.Write(numbers <span class="hljs-keyword">is</span> [<span class="hljs-number">0</span>, .. <span class="hljs-keyword">var</span> mid, <span class="hljs-number">4</span>] &amp;&amp; mid.Contains(<span class="hljs-number">2</span>)); <span class="hljs-comment">// True</span>
</code></pre>
<p>⚠️ یک <strong>list pattern</strong> می‌تواند حداکثر یک slice داشته باشد.</p>
<hr>
<h3>Attributes 🏷️</h3>
<p><strong>Attributes</strong> مکانیزمی <strong>extensible</strong> برای اضافه کردن اطلاعات <strong>سفارشی</strong> به عناصر کد هستند (assembly، نوع، member، return value، parameter و generic type parameters).</p>
<ul>
<li>برای تعریف یک attribute، از یک کلاس که از <code>System.Attribute</code> ارث‌بری می‌کند استفاده می‌کنیم.</li>
<li>برای اعمال attribute، نام نوع آن را در <strong>براکت‌های <code>[ ]</code></strong> قبل از عنصر کد قرار می‌دهیم:</li>
</ul>
<pre class="hljs"><code>[<span class="hljs-meta">ObsoleteAttribute</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> {...}
</code></pre>
<p>⚡ به دلیل اینکه convention تمام attributeها با <code>Attribute</code> ختم می‌شوند، می‌توان suffix را حذف کرد:</p>
<pre class="hljs"><code>[<span class="hljs-meta">Obsolete</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> {...}
</code></pre>
<ul>
<li>
<p>پارامترهای attribute به دو دسته تقسیم می‌شوند:</p>
<ol>
<li><strong>Positional</strong>: مربوط به پارامترهای public constructor attribute</li>
<li><strong>Named</strong>: مربوط به فیلدها یا propertyهای عمومی attribute</li>
</ol>
</li>
</ul>
<p>مثال با XmlTypeAttribute:</p>
<pre class="hljs"><code>[<span class="hljs-meta">XmlType(<span class="hljs-string">&quot;Customer&quot;</span>, Namespace=<span class="hljs-string">&quot;http://oreilly.com&quot;</span>)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomerEntity</span> { ... }
</code></pre>
<ul>
<li><strong>Positional</strong>: <code>&quot;Customer&quot;</code></li>
<li><strong>Named</strong>: <code>Namespace=&quot;http://oreilly.com&quot;</code></li>
</ul>
<hr>
<h3>اعمال Attributes به Assembly و Fieldها 🏗️</h3>
<ul>
<li>می‌توان یک attribute را به <strong>assembly</strong> متصل کرد:</li>
</ul>
<pre class="hljs"><code>[<span class="hljs-meta">assembly: AssemblyFileVersion(<span class="hljs-string">&quot;1.2.3.4&quot;</span>)</span>]
</code></pre>
<ul>
<li>برای اعمال attribute به <strong>backing field</strong> یک property خودکار:</li>
</ul>
<pre class="hljs"><code>[<span class="hljs-meta">field:NonSerialized</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
</code></pre>
<hr>
<h3>Attributes روی Lambda Expressions ⚡</h3>
<p>از C# 10 به بعد، می‌توان attributeها را به <strong>method، پارامترها و return value</strong> lambda اضافه کرد:</p>
<pre class="hljs"><code>Action&lt;<span class="hljs-built_in">int</span>&gt; a = [Description(<span class="hljs-string">&quot;Method&quot;</span>)]
               [<span class="hljs-meta">return: Description(<span class="hljs-string">&quot;Return value&quot;</span>)</span>]
               ([Description(<span class="hljs-string">&quot;Parameter&quot;</span>)] <span class="hljs-built_in">int</span> x) =&gt; Console.Write(x);
</code></pre>
<ul>
<li>این ویژگی برای فریمورک‌هایی مثل <strong><a href="http://ASP.NET">ASP.NET</a></strong> مفید است و نیاز به تعریف method جداگانه را از بین می‌برد.</li>
<li>برای دسترسی به این attributeها:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> methodAtt = a.GetMethodInfo().GetCustomAttributes();
<span class="hljs-keyword">var</span> paramAtt  = a.GetMethodInfo().GetParameters()[<span class="hljs-number">0</span>].GetCustomAttributes();
<span class="hljs-keyword">var</span> returnAtt = a.GetMethodInfo().ReturnParameter.GetCustomAttributes();
</code></pre>
<p>⚠️ برای جلوگیری از ابهام سینتکسی، <strong>پارامتر lambda همیشه باید داخل پرانتز باشد</strong>.<br>
❌ اعمال attribute روی <strong>expression-tree lambdas</strong> مجاز نیست.</p>
<h3>مشخص کردن چند Attribute همزمان 🏷️</h3>
<p>می‌توان چند <strong>attribute</strong> را به یک عنصر کد نسبت داد. این کار را می‌توان به سه روش انجام داد:</p>
<ol>
<li>تمام attributeها در یک جفت براکت <code>[ ]</code>، با کاما جدا شده:</li>
</ol>
<pre class="hljs"><code>[<span class="hljs-meta">Serializable, Obsolete, CLSCompliant(false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> { ... }
</code></pre>
<ol start="2">
<li>هر attribute در یک جفت براکت جداگانه:</li>
</ol>
<pre class="hljs"><code>[<span class="hljs-meta">Serializable</span>]
[<span class="hljs-meta">Obsolete</span>]
[<span class="hljs-meta">CLSCompliant(false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> { ... }
</code></pre>
<ol start="3">
<li>ترکیبی از دو روش بالا:</li>
</ol>
<pre class="hljs"><code>[<span class="hljs-meta">Serializable, Obsolete</span>]
[<span class="hljs-meta">CLSCompliant(false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> { ... }
</code></pre>
<p>همه مثال‌های بالا از نظر معنایی <strong>یکسان</strong> هستند. ✅</p>
<hr>
<h3>Caller Info Attributes 📞</h3>
<p>سه <strong>attribute ویژه</strong> وجود دارد که می‌توان پارامترهای اختیاری را با آن‌ها علامت زد تا کامپایلر اطلاعات <strong>caller</strong> را در مقدار پیش‌فرض پارامتر قرار دهد:</p>
<ul>
<li><code>[CallerMemberName]</code>: نام عضو فراخواننده</li>
<li><code>[CallerFilePath]</code>: مسیر فایل منبع فراخواننده</li>
<li><code>[CallerLineNumber]</code>: شماره خط فراخواننده</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Runtime.CompilerServices;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span> =&gt; Foo();

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">
        [CallerMemberName] <span class="hljs-built_in">string</span> memberName = <span class="hljs-literal">null</span>,
        [CallerFilePath] <span class="hljs-built_in">string</span> filePath = <span class="hljs-literal">null</span>,
        [CallerLineNumber] <span class="hljs-built_in">int</span> lineNumber = <span class="hljs-number">0</span></span>)</span>
    {
        Console.WriteLine(memberName);
        Console.WriteLine(filePath);
        Console.WriteLine(lineNumber);
    }
}
</code></pre>
<p>فرض کنید فایل در <code>c:\source\test\Program.cs</code> است، خروجی:</p>
<pre class="hljs"><code>Main
c:\source\test\Program.cs
6
</code></pre>
<ul>
<li>این ویژگی برای <strong>logging</strong> و <strong>INotifyPropertyChanged</strong> بسیار مفید است.</li>
<li>مثال استفاده در کلاس با PropertyChanged:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> : <span class="hljs-title">INotifyPropertyChanged</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PropertyChangedEventHandler PropertyChanged = <span class="hljs-built_in">delegate</span> { };

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RaisePropertyChanged</span>(<span class="hljs-params">[CallerMemberName] <span class="hljs-built_in">string</span> propertyName = <span class="hljs-literal">null</span></span>)</span>
        =&gt; PropertyChanged(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> PropertyChangedEventArgs(propertyName));

    <span class="hljs-built_in">string</span> customerName;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> CustomerName
    {
        <span class="hljs-keyword">get</span> =&gt; customerName;
        <span class="hljs-keyword">set</span>
        {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == customerName) <span class="hljs-keyword">return</span>;
            customerName = <span class="hljs-keyword">value</span>;
            RaisePropertyChanged();  <span class="hljs-comment">// تبدیل می‌شود به: RaisePropertyChanged(&quot;CustomerName&quot;);</span>
        }
    }
}
</code></pre>
<hr>
<h3>CallerArgumentExpression (C# 10) ✍️</h3>
<ul>
<li><code>[CallerArgumentExpression]</code> ثبت <strong>عبارت پارامتر</strong> در محل فراخوانی را ممکن می‌کند.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code>Print(Math.PI * <span class="hljs-number">2</span>);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> number,
           [CallerArgumentExpression(<span class="hljs-string">&quot;number&quot;</span></span>)] <span class="hljs-built_in">string</span> expr</span> = <span class="hljs-literal">null</span>)
    =&gt; Console.WriteLine(expr);
<span class="hljs-comment">// خروجی: Math.PI * 2</span>
</code></pre>
<ul>
<li>حتی کامنت‌ها هم در رشته قرار می‌گیرند:</li>
</ul>
<pre class="hljs"><code>Print(Math.PI <span class="hljs-comment">/*(π)*/</span> * <span class="hljs-number">2</span>);
<span class="hljs-comment">// خروجی: Math.PI /*(π)*/ * 2</span>
</code></pre>
<p>کاربرد اصلی: <strong>کتابخانه‌های validation و assertion</strong>:</p>
<pre class="hljs"><code>Assert(<span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">5</span>);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Assert</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> condition,
            [CallerArgumentExpression(<span class="hljs-string">&quot;condition&quot;</span></span>)] <span class="hljs-built_in">string</span> message</span> = <span class="hljs-literal">null</span>)
{
    <span class="hljs-keyword">if</span> (!condition) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Assertion failed: &quot;</span> + message);
}
</code></pre>
<ul>
<li>نمونه دیگر: <code>ArgumentNullException.ThrowIfNull</code> در .NET 6:</li>
</ul>
<pre class="hljs"><code>ArgumentNullException.ThrowIfNull(message);
</code></pre>
<p>⚠️ می‌توان <code>[CallerArgumentExpression]</code> را چند بار استفاده کرد تا چند عبارت پارامتر ثبت شود.</p>
<hr>
<h3>Dynamic Binding 🔄</h3>
<ul>
<li><strong>Dynamic binding</strong> زمان <strong>resolve کردن type، member و operator</strong> را به <strong>runtime</strong> موکول می‌کند.</li>
<li>مفید در interoperating با <strong>dynamic languages</strong> یا <strong>COM</strong> و همچنین زمانی که می‌خواهید از <strong>reflection</strong> استفاده کنید.</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">dynamic</span> d = GetSomeObject();
d.Quack();  <span class="hljs-comment">// کامپایلر بررسی نمی‌کند، اجرا در زمان runtime</span>
</code></pre>
<ul>
<li>در dynamic binding، کامپایلر <strong>binding</strong> را به runtime واگذار می‌کند، برخلاف <strong>static binding</strong> که در زمان کامپایل رخ می‌دهد.</li>
</ul>
<h3><strong>Static Binding در مقابل Dynamic Binding ⚡</strong></h3>
<p>در C#، <strong>binding</strong> یعنی اتصال نام یک عضو (مانند متد) به پیاده‌سازی آن.</p>
<hr>
<h4><strong>Static Binding (Binding ایستا) 🏗️</strong></h4>
<ul>
<li>اتصال در <strong>زمان کامپایل</strong> انجام می‌شود.</li>
<li>کامپایلر باید <strong>نوع متغیرها را بداند</strong> تا بتواند متدها یا عملگرها را پیدا کند.</li>
<li>مثال:</li>
</ul>
<pre class="hljs"><code>Duck d = <span class="hljs-keyword">new</span> Duck();
d.Quack();  <span class="hljs-comment">// کامپایلر بررسی می‌کند که کلاس Duck متد Quack دارد یا خیر</span>
</code></pre>
<ul>
<li>اگر نوع متغیر <code>object</code> باشد، دسترسی به متد ناموفق خواهد بود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">object</span> d = <span class="hljs-keyword">new</span> Duck();
d.Quack();  <span class="hljs-comment">// خطای کامپایل</span>
</code></pre>
<hr>
<h4><strong>Dynamic Binding (Binding پویا) 🌀</strong></h4>
<ul>
<li>اتصال در <strong>زمان اجرا (runtime)</strong> انجام می‌شود.</li>
<li>نوع متغیر <code>dynamic</code> است و کامپایلر فرض می‌کند <strong>ممکن است متد وجود داشته باشد</strong>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">dynamic</span> d = <span class="hljs-keyword">new</span> Duck();
d.Quack();  <span class="hljs-comment">// بررسی و اتصال در زمان اجرا انجام می‌شود</span>
</code></pre>
<ul>
<li>اگر نوع واقعی متغیر متدی نداشته باشد، <strong>RuntimeBinderException</strong> پرتاب می‌شود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">dynamic</span> d = <span class="hljs-number">5</span>;
d.Hello();  <span class="hljs-comment">// RuntimeBinderException</span>
</code></pre>
<hr>
<h4><strong>انواع Dynamic Binding</strong></h4>
<ol>
<li>
<p><strong>Custom Binding</strong> 🔧</p>
<ul>
<li>زمانی که شیء dynamic، اینترفیس <code>IDynamicMetaObjectProvider</code> را پیاده‌سازی کند.</li>
<li>برای کنترل رفتار متدها در زبان‌های داینامیک مثل IronPython یا IronRuby استفاده می‌شود.</li>
<li>مثال:</li>
</ul>
</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Dynamic;

<span class="hljs-built_in">dynamic</span> d = <span class="hljs-keyword">new</span> Duck();
d.Quack();  <span class="hljs-comment">// &quot;Quack method was called&quot;</span>
d.Waddle(); <span class="hljs-comment">// &quot;Waddle method was called&quot;</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> : <span class="hljs-title">DynamicObject</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryInvokeMember</span>(<span class="hljs-params">InvokeMemberBinder binder, <span class="hljs-built_in">object</span>[] <span class="hljs-keyword">args</span>, <span class="hljs-keyword">out</span> <span class="hljs-built_in">object</span> result</span>)</span>
    {
        Console.WriteLine(binder.Name + <span class="hljs-string">&quot; method was called&quot;</span>);
        result = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<ol start="2">
<li>
<p><strong>Language Binding</strong> 📚</p>
<ul>
<li>زمانی که شیء dynamic، <code>IDynamicMetaObjectProvider</code> را پیاده‌سازی نکند.</li>
<li>مفید برای دور زدن محدودیت‌های سیستم نوع .NET و اجتناب از کپی کد برای هر نوع داده.</li>
<li>مثال محاسبه میانگین:</li>
</ul>
</li>
</ol>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">3</span>, y = <span class="hljs-number">4</span>;
Console.WriteLine(Mean(x, y));
<span class="hljs-function"><span class="hljs-built_in">dynamic</span> <span class="hljs-title">Mean</span>(<span class="hljs-params"><span class="hljs-built_in">dynamic</span> a, <span class="hljs-built_in">dynamic</span> b</span>)</span> =&gt; (a + b) / <span class="hljs-number">2</span>;
</code></pre>
<p>⚠️ <strong>نکته:</strong> در dynamic binding، امنیت نوع <strong>compile-time</strong> از بین می‌رود، ولی امنیت نوع <strong>runtime</strong> حفظ می‌شود.</p>
<hr>
<h4><strong>نمایش Runtime شیء dynamic</strong></h4>
<pre class="hljs"><code><span class="hljs-built_in">dynamic</span> x = <span class="hljs-string">&quot;hello&quot;</span>;
Console.WriteLine(x.GetType().Name);  <span class="hljs-comment">// String</span>
x = <span class="hljs-number">123</span>;
Console.WriteLine(x.GetType().Name);  <span class="hljs-comment">// Int32</span>
</code></pre>
<ul>
<li><code>dynamic</code> از نظر ساختاری با <code>object</code> یکسان است، فقط اجازه عملیات داینامیک می‌دهد.</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">object</span> o = <span class="hljs-keyword">new</span> System.Text.StringBuilder();
<span class="hljs-built_in">dynamic</span> d = o;
d.Append(<span class="hljs-string">&quot;hello&quot;</span>);
Console.WriteLine(o);  <span class="hljs-comment">// hello</span>
</code></pre>
<ul>
<li>در runtime، اعضای dynamic با Attribute مشخص می‌شوند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">dynamic</span> Foo;
}
<span class="hljs-comment">// معادل با:</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    [<span class="hljs-meta">System.Runtime.CompilerServices.DynamicAttribute</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Foo;
}
</code></pre>
<hr>
<h4><strong>تبدیل‌های Dynamic 🔄</strong></h4>
<ul>
<li>dynamic قابلیت تبدیل ضمنی با همه نوع‌ها را دارد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i = <span class="hljs-number">7</span>;
<span class="hljs-built_in">dynamic</span> d = i;
<span class="hljs-built_in">long</span> j = d;   <span class="hljs-comment">// بدون نیاز به cast</span>
</code></pre>
<ul>
<li>اگر تبدیل ضمنی ممکن نباشد، <strong>RuntimeBinderException</strong> پرتاب می‌شود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">short</span> k = d;  <span class="hljs-comment">// RuntimeBinderException</span>
</code></pre>
<hr>
<h4><strong>مقایسه var و dynamic</strong></h4>
<table>
<thead>
<tr>
<th>ویژگی</th>
<th><code>var</code></th>
<th><code>dynamic</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>زمان تعیین نوع</td>
<td>Compile-time</td>
<td>Runtime</td>
</tr>
<tr>
<td>مثال</td>
<td><code>var y = &quot;hello&quot;;</code></td>
<td><code>dynamic x = &quot;hello&quot;;</code></td>
</tr>
<tr>
<td>رفتار انتساب</td>
<td>خطای کامپایل در نوع نادرست</td>
<td>خطای زمان اجرا در نوع نادرست</td>
</tr>
</tbody>
</table>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">dynamic</span> x = <span class="hljs-string">&quot;hello&quot;</span>;
<span class="hljs-keyword">var</span> y = x;        <span class="hljs-comment">// y نیز dynamic است</span>
<span class="hljs-built_in">int</span> z = y;        <span class="hljs-comment">// Runtime error</span>
</code></pre>
<ul>
<li><code>var</code> می‌گوید: &quot;بگذار نوع توسط کامپایلر مشخص شود&quot;</li>
<li><code>dynamic</code> می‌گوید: &quot;بگذار نوع توسط runtime مشخص شود&quot;</li>
</ul>
<h3><strong>Dynamic Expressions در C# 🌀</strong></h3>
<p>در C#، تقریبا همه اعضای یک شیء (fields, properties, methods, events, constructors, indexers, operators و conversions) را می‌توان <strong>به صورت داینامیک</strong> فراخوانی کرد.</p>
<hr>
<h4><strong>نتیجه متدهای void</strong></h4>
<ul>
<li>نمی‌توانید نتیجه یک <strong>عبارت dynamic با نوع بازگشتی void</strong> را مصرف کنید.</li>
<li>تفاوت با static typing: خطا <strong>در زمان اجرا</strong> رخ می‌دهد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">dynamic</span> list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();
<span class="hljs-keyword">var</span> result = list.Add(<span class="hljs-number">5</span>);  <span class="hljs-comment">// RuntimeBinderException</span>
</code></pre>
<hr>
<h4><strong>تأثیر cascading dynamic</strong></h4>
<ul>
<li>هر عبارتی که شامل <strong>عملوند dynamic</strong> باشد، معمولا خودش dynamic خواهد بود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">dynamic</span> x = <span class="hljs-number">2</span>;
<span class="hljs-keyword">var</span> y = x * <span class="hljs-number">3</span>;  <span class="hljs-comment">// نوع static y: dynamic</span>
</code></pre>
<ul>
<li>
<p>استثناها:</p>
<ol>
<li><strong>کست به نوع static</strong>:</li>
</ol>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">dynamic</span> x = <span class="hljs-number">2</span>;
<span class="hljs-keyword">var</span> y = (<span class="hljs-built_in">int</span>)x;  <span class="hljs-comment">// y از نوع int</span>
</code></pre>
<ol start="2">
<li><strong>صدا زدن constructor</strong> همیشه static است:</li>
</ol>
<pre class="hljs"><code><span class="hljs-built_in">dynamic</span> capacity = <span class="hljs-number">10</span>;
<span class="hljs-keyword">var</span> sb = <span class="hljs-keyword">new</span> System.Text.StringBuilder(capacity);  <span class="hljs-comment">// sb از نوع StringBuilder</span>
</code></pre>
<hr>
<h3><strong>Dynamic Calls بدون Dynamic Receiver</strong></h3>
<ul>
<li>معمول‌ترین حالت، <strong>receiver داینامیک</strong> است:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">dynamic</span> x = ...;
x.Foo();  <span class="hljs-comment">// x receiver است</span>
</code></pre>
<ul>
<li>اما می‌توان <strong>متدهای statically known</strong> را با آرگومان‌های dynamic فراخوانی کرد.</li>
<li>مثال با overload resolution:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; Console.WriteLine(<span class="hljs-string">&quot;int&quot;</span>);
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> x</span>)</span> =&gt; Console.WriteLine(<span class="hljs-string">&quot;string&quot;</span>);

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        <span class="hljs-built_in">dynamic</span> x = <span class="hljs-number">5</span>;
        <span class="hljs-built_in">dynamic</span> y = <span class="hljs-string">&quot;watermelon&quot;</span>;
        Foo(x);  <span class="hljs-comment">// int</span>
        Foo(y);  <span class="hljs-comment">// string</span>
    }
}
</code></pre>
<ul>
<li>اگر نام متد یا تعداد پارامترها درست نباشد، <strong>خطای کامپایل</strong> دریافت می‌کنیم.</li>
</ul>
<hr>
<h3><strong>استفاده از Static Types در Dynamic Binding</strong></h3>
<ul>
<li>حتی در binding داینامیک، اگر برخی آرگومان‌ها <strong>static type مشخص</strong> داشته باشند، استفاده می‌شود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> x, <span class="hljs-built_in">object</span> y</span>)</span> { Console.WriteLine(<span class="hljs-string">&quot;oo&quot;</span>); }
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> x, <span class="hljs-built_in">string</span> y</span>)</span> { Console.WriteLine(<span class="hljs-string">&quot;os&quot;</span>); }
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> x, <span class="hljs-built_in">object</span> y</span>)</span> { Console.WriteLine(<span class="hljs-string">&quot;so&quot;</span>); }
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> x, <span class="hljs-built_in">string</span> y</span>)</span> { Console.WriteLine(<span class="hljs-string">&quot;ss&quot;</span>); }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        <span class="hljs-built_in">object</span> o = <span class="hljs-string">&quot;hello&quot;</span>;
        <span class="hljs-built_in">dynamic</span> d = <span class="hljs-string">&quot;goodbye&quot;</span>;
        Foo(o, d);  <span class="hljs-comment">// os</span>
    }
}
</code></pre>
<hr>
<h3><strong>توابع غیرقابل فراخوانی Dynamically ❌</strong></h3>
<ul>
<li>
<p>برخی توابع نمی‌توانند با dynamic فراخوانی شوند:</p>
<ol>
<li><strong>Extension methods</strong> (با syntax extension)</li>
<li><strong>اعضای interface</strong> در صورتی که نیاز به cast به آن interface باشد</li>
<li><strong>Base members که توسط subclass پنهان شده‌اند</strong></li>
</ol>
</li>
<li>
<p>دلیل: dynamic binding فقط به <strong>نام متد و receiver</strong> نیاز دارد، اما در این سه مورد، <strong>نوع اضافی compile-time-only</strong> نیز دخیل است و در runtime موجود نیست.</p>
</li>
</ul>
<hr>
<h4><strong>مثال: فراخوانی عضو Interface با dynamic</strong></h4>
<pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title">IFoo</span> { <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span>; }
<span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> : <span class="hljs-title">IFoo</span> { <span class="hljs-keyword">void</span> IFoo.Test() {} }

IFoo f = <span class="hljs-keyword">new</span> Foo();
<span class="hljs-built_in">dynamic</span> d = f;
d.Test();  <span class="hljs-comment">// Runtime exception</span>
</code></pre>
<ul>
<li>cast به interface در زمان کامپایل مشخص می‌کند که binding باید روی IFoo انجام شود، اما در runtime این اطلاعات از دست می‌رود.</li>
</ul>
<hr>
<h4><strong>راهکار: کتابخانه Uncapsulator ⚡</strong></h4>
<ul>
<li>کتابخانه open-source برای <strong>dynamic بهتر</strong>، حل مشکل فراخوانی اعضای interface، base types و static members به صورت داینامیک.</li>
<li>مثال:</li>
</ul>
<pre class="hljs"><code>IFoo f = <span class="hljs-keyword">new</span> Foo();
<span class="hljs-built_in">dynamic</span> uf = f.Uncapsulate();
uf.Test();  <span class="hljs-comment">// حالا کار می‌کند</span>
</code></pre>
<ul>
<li>
<p>قابلیت‌های Uncapsulator:</p>
<ul>
<li>Cast به base types و interfaces</li>
<li>فراخوانی static members به صورت داینامیک</li>
<li>دسترسی به اعضای غیر عمومی (nonpublic members)</li>
</ul>
</li>
</ul>
<h3>بارگذاری مجدد عملگرها (Operator Overloading) ⚙️</h3>
<p>شما می‌توانید عملگرها را بارگذاری مجدد کنید تا نحو (syntax) طبیعی‌تری برای نوع‌های سفارشی فراهم شود. بارگذاری مجدد عملگرها بیشتر برای پیاده‌سازی <code>struct</code>های سفارشی که نمایانگر نوع‌های داده‌ای نسبتاً ابتدایی هستند، مناسب است. به‌عنوان مثال، یک نوع عددی سفارشی گزینه‌ی بسیار مناسبی برای بارگذاری مجدد عملگرها است.</p>
<p>عملگرهای نمادین زیر قابل بارگذاری مجدد هستند:</p>
<pre class="hljs"><code>+ (unary) - (unary) ! ˜ ++ --
+ % &gt;&gt;
&gt;= &amp; == &lt;= * / | ^ &lt;&lt; != &gt; &lt; 
</code></pre>
<p>عملگرهای زیر نیز قابل بارگذاری مجدد هستند:</p>
<ul>
<li>تبدیل‌های ضمنی و صریح (با کلمات کلیدی <code>implicit</code> و <code>explicit</code>)</li>
<li>عملگرهای <code>true</code> و <code>false</code> (نه مقادیر ثابت)</li>
</ul>
<p>عملگرهای زیر به‌صورت غیرمستقیم بارگذاری می‌شوند:</p>
<ul>
<li>عملگرهای ترکیبی (<code>+=, /=</code> و غیره) به‌طور ضمنی با بازنویسی عملگرهای غیرترکیبی (<code>+, /</code>) بازنویسی می‌شوند.</li>
<li>عملگرهای شرطی <code>&amp;&amp;</code> و <code>||</code> به‌طور ضمنی با بازنویسی عملگرهای بیتی <code>&amp;</code> و <code>|</code> بازنویسی می‌شوند.</li>
</ul>
<hr>
<h3>توابع عملگر (Operator Functions) 🛠️</h3>
<p>برای بارگذاری یک عملگر، باید یک <strong>تابع عملگر</strong> تعریف کنید. قوانین توابع عملگر به شرح زیر است:</p>
<ul>
<li>نام تابع با کلمه کلیدی <code>operator</code> و سپس نماد عملگر مشخص می‌شود.</li>
<li>تابع عملگر باید <code>static</code> و <code>public</code> باشد.</li>
<li>پارامترهای تابع عملگر نشان‌دهنده‌ی عملوندها هستند.</li>
<li>نوع بازگشتی تابع عملگر نشان‌دهنده‌ی نتیجه‌ی یک عبارت است.</li>
<li>حداقل یکی از عملوندها باید از نوعی باشد که تابع عملگر در آن تعریف شده است.</li>
</ul>
<p>مثال زیر یک <code>struct</code> به نام <code>Note</code> تعریف می‌کند که نمایانگر یک نت موسیقی است و سپس عملگر <code>+</code> را بارگذاری می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Note
{
    <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Note</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> semitonesFromA</span>)</span> { <span class="hljs-keyword">value</span> = semitonesFromA; }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Note <span class="hljs-keyword">operator</span> + (Note x, <span class="hljs-built_in">int</span> semitones)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Note (x.<span class="hljs-keyword">value</span> + semitones);
    }
}
</code></pre>
<p>این بارگذاری به ما اجازه می‌دهد یک <code>int</code> را به یک <code>Note</code> اضافه کنیم:</p>
<pre class="hljs"><code>Note B = <span class="hljs-keyword">new</span> Note (<span class="hljs-number">2</span>);
Note CSharp = B + <span class="hljs-number">2</span>;
</code></pre>
<p>بارگذاری یک عملگر، به‌طور خودکار عملگر ترکیبی متناظر را نیز بارگذاری می‌کند. در مثال ما، چون <code>+</code> را بازنویسی کردیم، می‌توانیم از <code>+=</code> هم استفاده کنیم:</p>
<pre class="hljs"><code>CSharp += <span class="hljs-number">2</span>;
</code></pre>
<p>همانند متدها و پراپرتی‌ها، C# اجازه می‌دهد توابع عملگر که شامل یک عبارت هستند با <strong>نحو بدنه-عبارتی (expression-bodied syntax)</strong> کوتاه‌تر نوشته شوند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Note <span class="hljs-keyword">operator</span> + (Note x, <span class="hljs-built_in">int</span> semitones)
    =&gt; <span class="hljs-keyword">new</span> Note (x.<span class="hljs-keyword">value</span> + semitones);
</code></pre>
<hr>
<h3>عملگرهای Checked ✔️</h3>
<p>از C# 11 به بعد، هنگام تعریف تابع عملگر، می‌توان نسخه‌ی <code>checked</code> آن را نیز تعریف کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Note <span class="hljs-keyword">operator</span> + (Note x, <span class="hljs-built_in">int</span> semitones)
    =&gt; <span class="hljs-keyword">new</span> Note (x.<span class="hljs-keyword">value</span> + semitones);

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Note <span class="hljs-keyword">operator</span> checked + (Note x, <span class="hljs-built_in">int</span> semitones)
    =&gt; checked (<span class="hljs-keyword">new</span> Note (x.<span class="hljs-keyword">value</span> + semitones));
</code></pre>
<p>نسخه‌ی <code>checked</code> داخل عبارت‌ها یا بلوک‌های <code>checked</code> فراخوانی می‌شود:</p>
<pre class="hljs"><code>Note B = <span class="hljs-keyword">new</span> Note (<span class="hljs-number">2</span>);
Note other = checked (B + <span class="hljs-built_in">int</span>.MaxValue);  <span class="hljs-comment">// پرتاب OverflowException</span>
</code></pre>
<hr>
<h3>بارگذاری عملگرهای برابری و مقایسه ⚖️</h3>
<p>عملگرهای برابری و مقایسه گاهی هنگام نوشتن <code>struct</code>ها و در موارد نادر هنگام نوشتن کلاس‌ها بازنویسی می‌شوند. قوانین و الزامات خاصی برای بارگذاری این عملگرها وجود دارد که در فصل ۶ توضیح داده شده است. خلاصه این قوانین:</p>
<p><strong>جفت‌بندی (Pairing)</strong><br>
کامپایلر C# اطمینان می‌دهد که عملگرهای منطقی جفت شده، هر دو تعریف شده باشند: <code>(== !=), (&lt; &gt;), (&lt;= &gt;=)</code></p>
<p><strong>Equals و GetHashCode</strong><br>
در بیشتر موارد، اگر <code>==</code> و <code>!=</code> را بارگذاری می‌کنید، باید متدهای <code>Equals</code> و <code>GetHashCode</code> تعریف شده در <code>object</code> را بازنویسی کنید تا رفتار معناداری داشته باشید. اگر این کار را نکنید، کامپایلر هشدار می‌دهد.</p>
<p><strong>IComparable و IComparable<T></strong><br>
اگر <code>&lt; &gt;</code> و <code>&lt;= &gt;=</code> را بارگذاری می‌کنید، بهتر است <code>IComparable</code> و <code>IComparable&lt;T&gt;</code> را پیاده‌سازی کنید.</p>
<hr>
<h3>تبدیل‌های ضمنی و صریح سفارشی 🔄</h3>
<p>تبدیل‌های ضمنی و صریح نیز عملگرهای قابل بارگذاری هستند. این تبدیل‌ها معمولاً برای ساده و طبیعی کردن تبدیل بین نوع‌های مرتبط (مثلاً نوع‌های عددی) استفاده می‌شوند.</p>
<p>برای تبدیل بین نوع‌های کمتر مرتبط، روش‌های زیر مناسب‌تر هستند:</p>
<ul>
<li>نوشتن یک سازنده که پارامتر آن از نوع مبدأ باشد.</li>
<li>نوشتن متدهای <code>ToXXX</code> و (static) <code>FromXXX</code> برای تبدیل بین نوع‌ها.</li>
</ul>
<p>همان‌طور که در بحث نوع‌ها توضیح داده شد، دلیل اصلی تبدیل‌های ضمنی این است که تضمین می‌کنند عملیات موفقیت‌آمیز باشد و اطلاعات از دست نرود. در مقابل، تبدیل صریح زمانی لازم است که شرایط زمان اجرا مشخص کند آیا تبدیل موفق است یا اطلاعات ممکن است از دست برود.</p>
<p>مثال زیر تبدیل بین نوع موسیقی <code>Note</code> و <code>double</code> (نمایش فرکانس بر حسب هرتز) را نشان می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-comment">// تبدیل به هرتز</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">double</span> (<span class="hljs-params">Note x</span>)</span>
    =&gt; <span class="hljs-number">440</span> * Math.Pow(<span class="hljs-number">2</span>, (<span class="hljs-built_in">double</span>)x.<span class="hljs-keyword">value</span> / <span class="hljs-number">12</span>);

<span class="hljs-comment">// تبدیل از هرتز (دقیق تا نزدیک‌ترین نیم‌پرده)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">Note</span> (<span class="hljs-params"><span class="hljs-built_in">double</span> x</span>)</span>
    =&gt; <span class="hljs-keyword">new</span> Note((<span class="hljs-built_in">int</span>)(<span class="hljs-number">0.5</span> + <span class="hljs-number">12</span> * (Math.Log(x/<span class="hljs-number">440</span>) / Math.Log(<span class="hljs-number">2</span>))));
</code></pre>
<pre class="hljs"><code>Note n = (Note)<span class="hljs-number">554.37</span>;  <span class="hljs-comment">// تبدیل صریح</span>
<span class="hljs-built_in">double</span> x = n;           <span class="hljs-comment">// تبدیل ضمنی</span>
</code></pre>
<p>با توجه به راهنمایی‌های خود، این مثال ممکن است بهتر باشد با متد <code>ToFrequency</code> و متد استاتیک <code>FromFrequency</code> پیاده‌سازی شود، به جای استفاده از عملگرهای ضمنی و صریح.</p>
<p>تبدیل‌های سفارشی توسط عملگرهای <code>as</code> و <code>is</code> نادیده گرفته می‌شوند:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-number">554.37</span> <span class="hljs-keyword">is</span> Note);   <span class="hljs-comment">// False</span>
Note n = <span class="hljs-number">554.37</span> <span class="hljs-keyword">as</span> Note;             <span class="hljs-comment">// خطا</span>
</code></pre>
<h3>بارگذاری مجدد عملگرهای true و false ✅</h3>
<p>عملگرهای <code>true</code> و <code>false</code> به ندرت در نوع‌هایی بارگذاری می‌شوند که به لحاظ «روحی» بولی هستند ولی تبدیل به <code>bool</code> ندارند. نمونه‌ی آن نوعی است که منطق سه‌حالته (three-state logic) را پیاده‌سازی می‌کند. با بارگذاری این عملگرها، این نوع می‌تواند به‌طور یکپارچه با دستورات شرطی و عملگرها کار کند؛ مانند: <code>if</code>, <code>do</code>, <code>while</code>, <code>for</code>, <code>&amp;&amp;</code>, <code>||</code> و <code>?:</code>.</p>
<p>ساختار <code>System.Data.SqlTypes.SqlBoolean</code> این قابلیت را ارائه می‌دهد:</p>
<pre class="hljs"><code>SqlBoolean a = SqlBoolean.Null;
<span class="hljs-keyword">if</span> (a)
    Console.WriteLine(<span class="hljs-string">&quot;True&quot;</span>);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!a)
    Console.WriteLine(<span class="hljs-string">&quot;False&quot;</span>);
<span class="hljs-keyword">else</span>
    Console.WriteLine(<span class="hljs-string">&quot;Null&quot;</span>);
</code></pre>
<p>خروجی:</p>
<pre class="hljs"><code>Null
</code></pre>
<p>کد زیر بازپیاده‌سازی بخش‌های مورد نیاز <code>SqlBoolean</code> برای نشان دادن عملگرهای <code>true</code> و <code>false</code> است:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> SqlBoolean
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">true</span>(<span class="hljs-params">SqlBoolean x</span>)</span>
        =&gt; x.m_value == True.m_value;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">false</span>(<span class="hljs-params">SqlBoolean x</span>)</span>
        =&gt; x.m_value == False.m_value;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlBoolean <span class="hljs-keyword">operator</span> !(SqlBoolean x)
    {
        <span class="hljs-keyword">if</span> (x.m_value == Null.m_value) <span class="hljs-keyword">return</span> Null;
        <span class="hljs-keyword">if</span> (x.m_value == False.m_value) <span class="hljs-keyword">return</span> True;
        <span class="hljs-keyword">return</span> False;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> SqlBoolean Null = <span class="hljs-keyword">new</span> SqlBoolean(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> SqlBoolean False = <span class="hljs-keyword">new</span> SqlBoolean(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> SqlBoolean True = <span class="hljs-keyword">new</span> SqlBoolean(<span class="hljs-number">2</span>);

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SqlBoolean</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span> <span class="hljs-keyword">value</span></span>)</span> { m_value = <span class="hljs-keyword">value</span>; }
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">byte</span> m_value;
}
</code></pre>
<hr>
<h3>چندریختی ایستا (Static Polymorphism) 🌀</h3>
<p>در بخش «Calling Static Virtual/Abstract Interface Members» صفحه ۸۲۶، ویژگی پیشرفته‌ای معرفی شد که در آن یک رابط (interface) می‌تواند اعضای <code>static virtual</code> یا <code>static abstract</code> تعریف کند که توسط کلاس‌ها و <code>struct</code>ها به‌صورت اعضای ایستا پیاده‌سازی می‌شوند.</p>
<p>سپس در بخش «Generic Constraints» صفحه ۱۶۳ نشان داده شد که اعمال محدودیت رابط روی پارامتر نوع، امکان دسترسی متد به اعضای آن رابط را فراهم می‌کند. در این بخش، نشان خواهیم داد که چگونه این قابلیت چندریختی ایستا را ممکن می‌سازد و ویژگی‌هایی مانند ریاضیات عمومی (generic math) را فعال می‌کند.</p>
<p>برای نمونه، رابط زیر یک متد ایستا تعریف می‌کند که یک نمونه تصادفی از نوع <code>T</code> ایجاد می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title">ICreateRandom</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title">CreateRandom</span>()</span>;  <span class="hljs-comment">// ایجاد یک نمونه تصادفی از T</span>
}
</code></pre>
<p>فرض کنید می‌خواهیم این رابط را در رکورد زیر پیاده‌سازی کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-title">int</span> <span class="hljs-title">X</span>, <span class="hljs-title">int</span> <span class="hljs-title">Y</span>);
</code></pre>
<p>با کمک کلاس <code>System.Random</code> (که متد <code>Next</code> آن یک عدد صحیح تصادفی تولید می‌کند)، می‌توانیم متد ایستا <code>CreateRandom</code> را به این صورت پیاده‌سازی کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-title">int</span> <span class="hljs-title">X</span>, <span class="hljs-title">int</span> <span class="hljs-title">Y</span>) : <span class="hljs-title">ICreateRandom</span>&lt;<span class="hljs-title">Point</span>&gt;
{
    <span class="hljs-keyword">static</span> Random rnd = <span class="hljs-keyword">new</span>();
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-title">CreateRandom</span>()</span> =&gt; <span class="hljs-keyword">new</span> Point(rnd.Next(), rnd.Next());
}
</code></pre>
<p>برای فراخوانی این متد از طریق رابط، از پارامتر نوع محدود شده استفاده می‌کنیم. متد زیر یک آرایه داده‌ی تست با این روش ایجاد می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function">T[] <span class="hljs-title">CreateTestData</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">int</span> count</span>) <span class="hljs-keyword">where</span> T : ICreateRandom&lt;T&gt;</span>
{
    T[] result = <span class="hljs-keyword">new</span> T[count];
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)
        result[i] = T.CreateRandom();
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>مثال استفاده:</p>
<pre class="hljs"><code>Point[] testData = CreateTestData&lt;Point&gt;(<span class="hljs-number">50</span>);  <span class="hljs-comment">// ایجاد ۵۰ نقطه تصادفی</span>
</code></pre>
<p>فراخوانی متد ایستا <code>CreateRandom</code> در <code>CreateTestData</code> چندریختی است، زیرا نه‌تنها با <code>Point</code> بلکه با هر نوعی که <code>ICreateRandom&lt;T&gt;</code> را پیاده‌سازی کرده باشد، کار می‌کند. این با چندریختی نمونه‌ای متفاوت است، زیرا برای فراخوانی <code>CreateRandom</code> نیاز به نمونه‌ای از <code>ICreateRandom&lt;T&gt;</code> نداریم؛ بلکه آن را روی نوع خود فراخوانی می‌کنیم.</p>
<hr>
<h3>عملگرهای چندریختی (Polymorphic Operators) ⚡</h3>
<p>از آنجا که عملگرها اساساً توابع ایستا هستند (صفحه ۲۵۶)، می‌توان آن‌ها را نیز به‌عنوان اعضای ایستا، مجازی یا رابط تعریف کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title">IAddable</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">IAddable</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> T <span class="hljs-keyword">operator</span> + (T left, T right);
}
</code></pre>
<p>محدودیت نوع خودارجاعی (self-referencing type constraint) در این تعریف رابط برای رعایت قوانین کامپایلر در بارگذاری عملگر ضروری است. به خاطر بیاورید که هنگام تعریف تابع عملگر، حداقل یکی از عملوندها باید از نوعی باشد که تابع در آن تعریف شده است. در این مثال، عملوندها از نوع <code>T</code> هستند، در حالی که نوع شامل <code>IAddable&lt;T&gt;</code> است، بنابراین نیاز به محدودیت نوع خودارجاع داریم تا <code>T</code> بتواند به‌عنوان <code>IAddable&lt;T&gt;</code> در نظر گرفته شود.</p>
<p>پیاده‌سازی رابط به این صورت است:</p>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span>(<span class="hljs-title">int</span> <span class="hljs-title">X</span>, <span class="hljs-title">int</span> <span class="hljs-title">Y</span>) : <span class="hljs-title">IAddable</span>&lt;<span class="hljs-title">Point</span>&gt;
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-keyword">operator</span> + (Point left, Point right) =&gt;
        <span class="hljs-keyword">new</span> Point(left.X + right.X, left.Y + right.Y);
}
</code></pre>
<p>با پارامتر نوع محدود شده، می‌توانیم متدی بنویسیم که عملگر جمع را به‌صورت چندریختی فراخوانی کند:</p>
<pre class="hljs"><code><span class="hljs-function">T <span class="hljs-title">Sum</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">params</span> T[] values</span>) <span class="hljs-keyword">where</span> T : IAddable&lt;T&gt;</span>
{
    T total = values[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; values.Length; i++)
        total += values[i];
    <span class="hljs-keyword">return</span> total;
}
</code></pre>
<p>فراخوانی عملگر <code>+</code> (از طریق <code>+=</code>) چندریختی است، زیرا به <code>IAddable&lt;T&gt;</code> متصل می‌شود، نه <code>Point</code>. بنابراین متد <code>Sum</code> با تمام نوع‌هایی که <code>IAddable&lt;T&gt;</code> را پیاده‌سازی کرده‌اند کار می‌کند.</p>
<p>البته، رابطی مانند <code>IAddable&lt;T&gt;</code> زمانی مفیدتر است که در runtime دات‌نت تعریف شود و همه نوع‌های عددی .NET آن را پیاده‌سازی کنند. خوشبختانه از .NET 7، فضای نام <code>System.Numerics</code> نسخه‌ای پیشرفته‌تر از <code>IAddable</code> را همراه با سایر رابط‌های ریاضی ارائه می‌دهد—که بیشتر آن‌ها تحت پوشش <code>INumber&lt;TSelf&gt;</code> هستند.</p>
<h3>ریاضیات عمومی (Generic Math) ➕</h3>
<p>قبل از .NET 7، کدی که عملیات حسابی انجام می‌داد، باید برای یک نوع عددی مشخص نوشته می‌شد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Sum</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] numbers</span>)   <span class="hljs-comment">// فقط با int کار می‌کند</span></span>
{
    <span class="hljs-comment">// با double، decimal و غیره کار نمی‌کند</span>
    <span class="hljs-built_in">int</span> total = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> n <span class="hljs-keyword">in</span> numbers)
        total += n;
    <span class="hljs-keyword">return</span> total;
}
</code></pre>
<p>در .NET 7، رابط <code>INumber&lt;TSelf&gt;</code> معرفی شد تا عملیات حسابی را در تمامی نوع‌های عددی یکپارچه کند. این یعنی حالا می‌توان نسخه‌ی عمومی (generic) متد بالا را نوشت:</p>
<pre class="hljs"><code><span class="hljs-function">T <span class="hljs-title">Sum</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">params</span> T[] numbers</span>) <span class="hljs-keyword">where</span> T : INumber&lt;T&gt;</span>
{
    T total = T.Zero;
    <span class="hljs-keyword">foreach</span> (T n <span class="hljs-keyword">in</span> numbers)
        total += n;  <span class="hljs-comment">// عملگر جمع برای هر نوع عددی فراخوانی می‌شود</span>
    <span class="hljs-keyword">return</span> total;
}

<span class="hljs-built_in">int</span> intSum = Sum(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>);
<span class="hljs-built_in">double</span> doubleSum = Sum(<span class="hljs-number">3.2</span>, <span class="hljs-number">5.3</span>, <span class="hljs-number">7.1</span>);
<span class="hljs-built_in">decimal</span> decimalSum = Sum(<span class="hljs-number">3.2</span>m, <span class="hljs-number">5.3</span>m, <span class="hljs-number">7.1</span>m);
</code></pre>
<p>تمام نوع‌های عددی صحیح و اعشاری در .NET (و همچنین <code>char</code>) رابط <code>INumber&lt;TSelf&gt;</code> را پیاده‌سازی می‌کنند. این رابط را می‌توان به‌عنوان یک رابط کلی (umbrella interface) تصور کرد که شامل رابط‌های جزئی‌تر برای هر نوع عملیات حسابی (جمع، تفریق، ضرب، تقسیم، باقی‌مانده، مقایسه و غیره) و همچنین رابط‌هایی برای پارسینگ و قالب‌بندی است.</p>
<p>مثالی از چنین رابطی:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IAdditionOperators</span>&lt;<span class="hljs-title">TSelf</span>, <span class="hljs-title">TOther</span>, <span class="hljs-title">TResult</span>&gt;
    <span class="hljs-keyword">where</span> <span class="hljs-title">TSelf</span> : <span class="hljs-title">IAdditionOperators</span>&lt;<span class="hljs-title">TSelf</span>, <span class="hljs-title">TOther</span>, <span class="hljs-title">TResult</span>&gt;?
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> TResult <span class="hljs-keyword">operator</span> + (TSelf left, TOther right);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">virtual</span> TResult <span class="hljs-keyword">operator</span> checked + 
        (TSelf left, TOther right) =&gt; left + right;  <span class="hljs-comment">// فراخوانی عملگر بالا</span>
}
</code></pre>
<p>عملگر ایستا و انتزاعی <code>+</code> همان چیزی است که باعث می‌شود عملگر <code>+=</code> داخل متد <code>Sum</code> کار کند. همچنین توجه کنید که استفاده از <code>static virtual</code> روی عملگر <code>checked</code>، رفتار پیش‌فرض برای پیاده‌سازانی که نسخه‌ی <code>checked</code> عملگر جمع را ارائه نمی‌کنند، فراهم می‌کند.</p>
<p>فضای نام <code>System.Numerics</code> همچنین شامل رابط‌هایی است که بخشی از <code>INumber</code> نیستند و مخصوص عملیات نوع‌های خاصی از اعداد (مثل اعداد اعشاری) هستند.</p>
<p>به‌عنوان مثال، برای محاسبه‌ی <strong>میانگین مربعات (Root Mean Square)</strong> می‌توانیم رابط <code>IRootFunctions&lt;T&gt;</code> را به فهرست محدودیت‌ها اضافه کنیم تا متد ایستا <code>RootN</code> آن برای <code>T</code> در دسترس باشد:</p>
<pre class="hljs"><code><span class="hljs-function">T <span class="hljs-title">RMS</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">params</span> T[] values</span>) <span class="hljs-keyword">where</span> T : INumber&lt;T&gt;, IRootFunctions&lt;T&gt;</span>
{
    T total = T.Zero;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; values.Length; i++)
        total += values[i] * values[i];

    <span class="hljs-comment">// استفاده از T.CreateChecked برای تبدیل values.Length (نوع int) به T</span>
    T count = T.CreateChecked(values.Length);
    <span class="hljs-keyword">return</span> T.RootN(total / count, <span class="hljs-number">2</span>);  <span class="hljs-comment">// محاسبه ریشه دوم (مربع)</span>
}
</code></pre>
<hr>
<h3>کد ناایمن و اشاره‌گرها (Unsafe Code and Pointers) ⚠️</h3>
<p>C# امکان دسترسی مستقیم به حافظه را از طریق اشاره‌گرها در بلوک‌های کد <code>unsafe</code> فراهم می‌کند. نوع‌های اشاره‌گر برای تعامل با APIهای بومی (native)، دسترسی به حافظه خارج از heap مدیریت‌شده، و پیاده‌سازی بهینه‌سازی‌های کوچک در نقاط حساس عملکرد مفید هستند.</p>
<p>پروژه‌هایی که شامل کد ناایمن هستند، باید در فایل پروژه <code>&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;</code> را مشخص کنند.</p>
<h4>اصول اولیه اشاره‌گرها (Pointer Basics)</h4>
<p>برای هر نوع مقدار یا مرجع <code>V</code>، نوع اشاره‌گر متناظر <code>V*</code> وجود دارد. یک نمونه از اشاره‌گر آدرس یک متغیر را نگه می‌دارد. نوع‌های اشاره‌گر می‌توانند به صورت ناایمن به هر نوع اشاره‌گر دیگری تبدیل (cast) شوند.</p>
<p>عملگرهای اصلی اشاره‌گر عبارت‌اند از:</p>
<div align="center">
<p><img src="../../../assets/image/04/Table-4-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>کد ناایمن و اشاره‌گرها (ادامه) ⚡</h3>
<p>همانند زبان C، اضافه کردن (یا کم کردن) یک آفست عدد صحیح به یک اشاره‌گر، یک اشاره‌گر دیگر تولید می‌کند. کم کردن یک اشاره‌گر از دیگری یک عدد صحیح ۶۴ بیتی تولید می‌کند (در هر دو پلتفرم ۳۲ و ۶۴ بیتی).</p>
<hr>
<h3>کد ناایمن (Unsafe Code) 🛡️</h3>
<p>با علامت‌گذاری یک نوع، عضو نوع، یا بلوک دستوری با کلیدواژه <code>unsafe</code>، اجازه دارید از نوع‌های اشاره‌گر استفاده کنید و عملیات اشاره‌گر به سبک C روی حافظه انجام دهید. مثال زیر استفاده از اشاره‌گرها برای پردازش سریع یک بیت‌مپ را نشان می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BlueFilter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[,] bitmap</span>)</span>
{
    <span class="hljs-built_in">int</span> length = bitmap.Length;
    <span class="hljs-keyword">fixed</span> (<span class="hljs-built_in">int</span>* b = bitmap)
    {
        <span class="hljs-built_in">int</span>* p = b;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)
            *p++ &amp;= <span class="hljs-number">0xFF</span>;
    }
}
</code></pre>
<p>کد ناایمن می‌تواند سریع‌تر از پیاده‌سازی امن مشابه اجرا شود. در این مثال، نسخه امن نیاز به حلقه‌ی تو در تو با اندیس‌دهی آرایه و بررسی حدود داشت. همچنین، متد ناایمن C# می‌تواند سریع‌تر از فراخوانی یک تابع C خارجی باشد، چون سربار ترک محیط اجرای مدیریت‌شده وجود ندارد.</p>
<hr>
<h3>دستور fixed 📌</h3>
<p>دستور <code>fixed</code> برای <strong>سنجاق کردن (pin)</strong> یک شی مدیریت‌شده مانند بیت‌مپ استفاده می‌شود. در طول اجرای برنامه، بسیاری از اشیا از heap تخصیص و آزاد می‌شوند. برای جلوگیری از هدررفت یا تکه‌تکه شدن حافظه، جمع‌آورنده زباله (GC) اشیا را جابه‌جا می‌کند. اگر آدرس یک شی تغییر کند، اشاره به آن بی‌فایده است، بنابراین <code>fixed</code> به GC می‌گوید شی را جابه‌جا نکند. استفاده بیش از حد از بلوک‌های <code>fixed</code> می‌تواند روی کارایی زمان اجرا تاثیر بگذارد، بنابراین بهتر است از آن‌ها کوتاه استفاده کنید و از تخصیص حافظه درون بلوک <code>fixed</code> خودداری کنید.</p>
<p>درون دستور <code>fixed</code>، می‌توانید یک اشاره‌گر به هر نوع مقدار، آرایه‌ای از نوع‌های مقدار، یا رشته دریافت کنید. در مورد آرایه‌ها و رشته‌ها، اشاره‌گر در واقع به اولین عنصر اشاره می‌کند که از نوع مقدار است.</p>
<p>نمونه‌ای از سنجاق کردن نوع مقدار داخل نوع مرجع:</p>
<pre class="hljs"><code>Test test = <span class="hljs-keyword">new</span> Test();
<span class="hljs-keyword">unsafe</span>
{
    <span class="hljs-keyword">fixed</span> (<span class="hljs-built_in">int</span>* p = &amp;test.X)   <span class="hljs-comment">// سنجاق کردن test</span>
    {
        *p = <span class="hljs-number">9</span>;
    }
}
Console.WriteLine(test.X);

<span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X; }
</code></pre>
<p>توضیحات بیشتر درباره‌ی <code>fixed</code> در بخش «Mapping a Struct to Unmanaged Memory» صفحه ۹۹۷ آمده است.</p>
<hr>
<h3>عملگر اشاره‌گر به عضو (Pointer-to-Member Operator) 🔗</h3>
<p>علاوه بر عملگرهای <code>&amp;</code> و <code>*</code>، C# عملگر سبک C++ یعنی <code>-&gt;</code> را نیز ارائه می‌دهد که می‌توان از آن روی <code>struct</code>ها استفاده کرد:</p>
<pre class="hljs"><code>Test test = <span class="hljs-keyword">new</span> Test();
<span class="hljs-keyword">unsafe</span>
{
    Test* p = &amp;test;
    p-&gt;X = <span class="hljs-number">9</span>;
    System.Console.WriteLine(test.X);
}
<span class="hljs-keyword">struct</span> Test { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X; }
</code></pre>
<hr>
<h3>کلیدواژه stackalloc 📚</h3>
<p>با استفاده از <code>stackalloc</code> می‌توانید حافظه‌ای را به‌طور مستقیم در <strong>استک</strong> اختصاص دهید. چون روی استک تخصیص می‌یابد، طول عمر آن محدود به اجرای متد است، همانند متغیرهای محلی دیگر که توسط lambda، iterator یا متد async افزایش طول عمر نیافته‌اند. بلوک می‌تواند از عملگر <code>[]</code> برای دسترسی به حافظه استفاده کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>* a = <span class="hljs-keyword">stackalloc</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)
    Console.WriteLine(a[i]);
</code></pre>
<p>در فصل ۲۳، نشان داده می‌شود چگونه می‌توان با <code>Span&lt;T&gt;</code> حافظه اختصاص‌یافته روی استک را بدون استفاده از <code>unsafe</code> مدیریت کرد:</p>
<pre class="hljs"><code>Span&lt;<span class="hljs-built_in">int</span>&gt; a = <span class="hljs-keyword">stackalloc</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)
    Console.WriteLine(a[i]);
</code></pre>
<hr>
<h3>بافرهای با اندازه ثابت (Fixed-Size Buffers) 🧱</h3>
<p>کلیدواژه <code>fixed</code> کاربرد دیگری نیز دارد: ایجاد بافرهای با اندازه ثابت درون <code>struct</code>ها (مفید برای فراخوانی توابع unmanaged؛ فصل ۲۴).</p>
<pre class="hljs"><code><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">struct</span> UnsafeUnicodeString
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> Length;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">fixed</span> <span class="hljs-built_in">byte</span> Buffer[<span class="hljs-number">30</span>];   <span class="hljs-comment">// تخصیص ۳۰ بایت</span>
}

<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeClass</span>
{
    UnsafeUnicodeString uus;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnsafeClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>
    {
        uus.Length = (<span class="hljs-built_in">short</span>)s.Length;
        <span class="hljs-keyword">fixed</span> (<span class="hljs-built_in">byte</span>* p = uus.Buffer)
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; s.Length; i++)
                p[i] = (<span class="hljs-built_in">byte</span>)s[i];
    }
}

<span class="hljs-keyword">new</span> UnsafeClass(<span class="hljs-string">&quot;Christian Troy&quot;</span>);
</code></pre>
<p>نکات مهم:</p>
<ul>
<li>بافرهای با اندازه ثابت آرایه نیستند؛ اگر <code>Buffer</code> آرایه بود، شامل مرجعی به شیء روی heap مدیریت‌شده می‌شد، نه ۳۰ بایت داخل خود <code>struct</code>.</li>
<li>کلیدواژه <code>fixed</code> در این مثال همچنین شیء روی heap (نمونه <code>UnsafeClass</code>) را سنجاق می‌کند. بنابراین <code>fixed</code> دو معنا دارد: <strong>ثابت در اندازه</strong> و <strong>ثابت در مکان</strong>. اغلب با هم استفاده می‌شوند، زیرا یک بافر با اندازه ثابت باید در مکان ثابت باشد تا قابل استفاده باشد.</li>
</ul>
<h3>اشاره‌گر void (<code>void*</code>) 🔹</h3>
<p>یک <strong>اشاره‌گر void</strong> (<code>void*</code>) هیچ فرضی درباره نوع داده پایه ندارد و برای توابعی که با حافظه خام کار می‌کنند مفید است. تبدیل ضمنی از هر نوع اشاره‌گر به <code>void*</code> وجود دارد.</p>
<p>نکات مهم:</p>
<ul>
<li>یک <code>void*</code> قابل <strong>دسترسی مستقیم (dereference)</strong> نیست.</li>
<li>عملیات حسابی روی اشاره‌گرهای void امکان‌پذیر نیست.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">short</span>[] a = { <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">21</span>, <span class="hljs-number">34</span>, <span class="hljs-number">55</span> };
<span class="hljs-keyword">unsafe</span>
{
    <span class="hljs-keyword">fixed</span> (<span class="hljs-built_in">short</span>* p = a)
    {
        <span class="hljs-comment">// sizeof اندازه نوع مقدار را برحسب بایت برمی‌گرداند</span>
        Zap(p, a.Length * <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">short</span>));
    }
}

<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">short</span> x <span class="hljs-keyword">in</span> a)
    Console.WriteLine(x);   <span class="hljs-comment">// همه مقادیر صفر چاپ می‌شوند</span>

<span class="hljs-function"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Zap</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>* memory, <span class="hljs-built_in">int</span> byteCount</span>)</span>
{
    <span class="hljs-built_in">byte</span>* b = (<span class="hljs-built_in">byte</span>*)memory;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; byteCount; i++)
        *b++ = <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<h3>اعداد با اندازه بومی (Native-Sized Integers) 🧮</h3>
<p>نوع‌های <code>nint</code> و <code>nuint</code> (معرفی شده در C# 9) اندازه‌ای مطابق فضای آدرس پردازش در زمان اجرا دارند (در عمل، ۳۲ یا ۶۴ بیت). این نوع‌ها مانند اعداد استاندارد رفتار می‌کنند و از عملیات حسابی و بررسی سرریز (overflow) پشتیبانی کامل دارند:</p>
<pre class="hljs"><code><span class="hljs-built_in">nint</span> x = <span class="hljs-number">123</span>, y = <span class="hljs-number">234</span>;
checked
{
    <span class="hljs-built_in">nint</span> sum = x + y, product = x * y;
    Console.WriteLine(product);
}
</code></pre>
<p>ویژگی‌ها:</p>
<ul>
<li>می‌توان به آن‌ها مقادیر صحیح ۳۲ بیتی داد، اما نه ۶۴ بیتی (ممکن است در زمان اجرا سرریز رخ دهد).</li>
<li>تبدیل به یا از دیگر نوع‌های عدد صحیح با cast صریح امکان‌پذیر است.</li>
<li>می‌توان از آن‌ها برای نمایش آدرس حافظه یا آفست بدون استفاده از اشاره‌گر استفاده کرد.</li>
<li><code>nuint</code> برای نمایش طول یک بلاک حافظه مناسب است.</li>
</ul>
<p>مثال برای بهبود کارایی هنگام کار با اشاره‌گرها:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">unsafe</span> <span class="hljs-built_in">nint</span> <span class="hljs-title">AddressDif</span>(<span class="hljs-params"><span class="hljs-built_in">char</span>* x, <span class="hljs-built_in">char</span>* y</span>)</span> =&gt; (<span class="hljs-built_in">nint</span>)x - (<span class="hljs-built_in">nint</span>)y;
</code></pre>
<p>یک مثال واقعی از کاربرد <code>nint</code> و <code>nuint</code> در کنار اشاره‌گرها، پیاده‌سازی <code>Buffer.MemoryCopy</code> است.</p>
<hr>
<h3>رفتار زمان اجرا در .NET 7+ ⚙️</h3>
<p>در پروژه‌هایی که هدف آن‌ها .NET 7 یا بالاتر است، <code>nint</code> و <code>nuint</code> معادل <code>System.IntPtr</code> و <code>System.UIntPtr</code> عمل می‌کنند، مشابه اینکه <code>int</code> معادل <code>System.Int32</code> است.</p>
<ul>
<li><code>IntPtr</code> و <code>UIntPtr</code> از .NET 7 به بعد قابلیت انجام عملیات حسابی و بررسی سرریز با کامپایلر C# را دارند.</li>
<li>اضافه شدن قابلیت حسابی checked به IntPtr/UIntPtr یک تغییر فنی شکستن سازگاری محسوب می‌شود، اما اثر آن محدود است و فقط در صورتی که پروژه دوباره با هدف .NET 7+ کامپایل شود، ممکن است رخ دهد.</li>
</ul>
<hr>
<h3>رفتار زمان اجرا در .NET 6 یا پایین‌تر ⚡</h3>
<p>در پروژه‌هایی که هدف آن‌ها .NET 6 یا پایین‌تر است، <code>nint</code> و <code>nuint</code> هنوز از <code>IntPtr</code> و <code>UIntPtr</code> استفاده می‌کنند.</p>
<ul>
<li>چون نوع‌های قدیمی <code>IntPtr</code> و <code>UIntPtr</code> اکثر عملیات حسابی را پشتیبانی نمی‌کنند، کامپایلر خلاها را پر می‌کند تا رفتار <code>nint</code>/<code>nuint</code> مشابه .NET 7+ شود.</li>
<li>می‌توان تصور کرد که یک متغیر <code>nint</code>/<code>nuint</code> مانند <code>IntPtr</code>/<code>UIntPtr</code> با یک «کلاه ویژه» است که کامپایلر آن را به‌عنوان یک IntPtr/UIntPtr مدرن می‌شناسد.</li>
<li>این کلاه در صورت تبدیل به IntPtr/UIntPtr از بین می‌رود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">nint</span> x = <span class="hljs-number">123</span>;
Console.WriteLine(x * x);   <span class="hljs-comment">// درست: ضرب پشتیبانی می‌شود</span>
IntPtr y = x;
Console.WriteLine(y * y);   <span class="hljs-comment">// خطای کامپایل: عملگر * پشتیبانی نمی‌شود</span>
</code></pre>
<hr>
<h3>اشاره‌گرهای تابع (Function Pointers) 🔗</h3>
<p>یک <strong>اشاره‌گر تابع</strong> (معرفی در C# 9) مانند delegate است اما بدون واسطه نمونه delegate؛ مستقیماً به آدرس یک متد اشاره می‌کند.</p>
<p>ویژگی‌ها:</p>
<ul>
<li>فقط به متدهای ایستا (static) اشاره می‌کند.</li>
<li>قابلیت multicast ندارد.</li>
<li>نیازمند زمینه <code>unsafe</code> است (زیرا از بررسی نوع زمان اجرا عبور می‌کند).</li>
<li>هدف اصلی: ساده‌سازی و بهینه‌سازی تعامل با APIهای unmanaged.</li>
</ul>
<p>تعریف نوع اشاره‌گر تابع:</p>
<pre class="hljs"><code><span class="hljs-built_in">delegate</span>*&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">char</span>, <span class="hljs-built_in">string</span>, <span class="hljs-keyword">void</span>&gt;   <span class="hljs-comment">// void نوع بازگشتی است</span>
</code></pre>
<p>مطابق تابع زیر:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SomeFunction</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">char</span> y, <span class="hljs-built_in">string</span> z</span>)
</span></code></pre>
<p>عملگر <code>&amp;</code> یک اشاره‌گر تابع از گروه متد ایجاد می‌کند. مثال کامل:</p>
<pre class="hljs"><code><span class="hljs-keyword">unsafe</span>
{
    <span class="hljs-built_in">delegate</span>*&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; functionPointer = &amp;GetLength;
    <span class="hljs-built_in">int</span> length = functionPointer(<span class="hljs-string">&quot;Hello, world&quot;</span>);
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> =&gt; s.Length;
}
</code></pre>
<p>نکات مهم:</p>
<ul>
<li><code>functionPointer</code> یک شیء نیست که بتوان روی آن <code>Invoke</code> فراخوانی کرد.</li>
<li>مستقیماً به آدرس حافظه متد هدف اشاره می‌کند:</li>
</ul>
<pre class="hljs"><code>Console.WriteLine((IntPtr)functionPointer);
</code></pre>
<ul>
<li>مانند هر اشاره‌گر دیگری، بررسی نوع زمان اجرا ندارد.</li>
<li>نمونه زیر نتیجه تابع را به <code>decimal</code> تبدیل می‌کند و ممکن است حافظه تصادفی در خروجی دخیل شود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> pointer2 = (<span class="hljs-built_in">delegate</span>*&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">decimal</span>&gt;)(IntPtr)functionPointer;
Console.WriteLine(pointer2(<span class="hljs-string">&quot;Hello, unsafe world&quot;</span>));
</code></pre>
<h3><code>[SkipLocalsInit]</code> ⚡</h3>
<p>وقتی C# یک متد را کامپایل می‌کند، یک flag تولید می‌کند که به runtime می‌گوید متغیرهای محلی متد را به مقادیر پیش‌فرضشان مقداردهی کند (با صفر کردن حافظه).</p>
<p>از C# 9 به بعد، می‌توانید از کامپایلر بخواهید این flag را تولید نکند با اعمال <strong>attribute</strong> <code>[SkipLocalsInit]</code> روی یک متد (در namespace <code>System.Runtime.CompilerServices</code>):</p>
<pre class="hljs"><code>[<span class="hljs-meta">SkipLocalsInit</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>() ...
</span></code></pre>
<p>می‌توانید این attribute را روی یک نوع (type) اعمال کنید—که معادل اعمال آن روی همه متدهای آن نوع است—یا حتی روی کل یک ماژول (module) که محتوای یک assembly است:</p>
<pre class="hljs"><code>[<span class="hljs-meta">module: System.Runtime.CompilerServices.SkipLocalsInit</span>]
</code></pre>
<p>در سناریوهای امن معمولی، <code>[SkipLocalsInit]</code> تأثیر زیادی روی عملکرد یا کارکرد ندارد، چون <strong>قانون تخصیص قطعی (definite assignment)</strong> در C# نیاز دارد که متغیرهای محلی قبل از خوانده شدن مقداردهی شوند. این بدان معناست که JIT optimizer احتمالاً همان کد ماشین را تولید می‌کند، چه attribute اعمال شده باشد یا نه.</p>
<p>اما در زمینه unsafe، استفاده از <code>[SkipLocalsInit]</code> می‌تواند بار CLR برای مقداردهی اولیه متغیرهای محلی از نوع value را کاهش دهد و باعث <strong>افزایش جزئی عملکرد</strong> شود، مخصوصاً در متدهایی که استفاده زیادی از استک دارند (مثلاً با stackalloc بزرگ). مثال زیر حافظه مقداردهی‌نشده را چاپ می‌کند وقتی <code>[SkipLocalsInit]</code> اعمال شده باشد (به جای صفر):</p>
<pre class="hljs"><code>[<span class="hljs-meta">SkipLocalsInit</span>]
<span class="hljs-function"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span>
{
    <span class="hljs-built_in">int</span> local;
    <span class="hljs-built_in">int</span>* ptr = &amp;local;
    Console.WriteLine(*ptr);

    <span class="hljs-built_in">int</span>* a = <span class="hljs-keyword">stackalloc</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">100</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) Console.WriteLine(a[i]);
}
</code></pre>
<p>جالب این که می‌توان به همان نتیجه در محیط “ایمن” با استفاده از <code>Span&lt;T&gt;</code> رسید:</p>
<pre class="hljs"><code>[<span class="hljs-meta">SkipLocalsInit</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span>
{
    Span&lt;<span class="hljs-built_in">int</span>&gt; a = <span class="hljs-keyword">stackalloc</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">100</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) Console.WriteLine(a[i]);
}
</code></pre>
<p>بنابراین، استفاده از <code>[SkipLocalsInit]</code> نیاز دارد که پروژه شما با <code>&lt;AllowUnsafeBlocks&gt;</code> برابر <code>true</code> کامپایل شود—حتی اگر هیچ متدی unsafe علامت‌گذاری نشده باشد.</p>
<hr>
<h3>دستورات پیش‌پردازنده (Preprocessor Directives) 🛠️</h3>
<p>دستورات پیش‌پردازنده به کامپایلر اطلاعات اضافی درباره بخش‌های کد می‌دهند. رایج‌ترین آن‌ها <strong>دستورات شرطی</strong> هستند که راهی برای شامل یا حذف بخش‌هایی از کد در زمان کامپایل فراهم می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>
{
    <span class="hljs-built_in">int</span> x;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span>
    {
        <span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span>
            Console.WriteLine(<span class="hljs-string">&quot;Testing: x = {0}&quot;</span>, x);
        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
    }
    ...
}
</code></pre>
<p>در این مثال، دستور داخل <code>Foo</code> مشروط به وجود سمبل <code>DEBUG</code> کامپایل می‌شود. اگر سمبل <code>DEBUG</code> حذف شود، دستور کامپایل نمی‌شود.</p>
<p>می‌توان سمبل‌های پیش‌پردازنده را در فایل سورس تعریف کرد یا در سطح پروژه در فایل <code>.csproj</code>:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">DefineConstants</span>&gt;</span>DEBUG;ANOTHERSYMBOL<span class="hljs-tag">&lt;/<span class="hljs-name">DefineConstants</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>با دستورات <code>#if</code> و <code>#elif</code> می‌توان از عملگرهای <code>||</code>، <code>&amp;&amp;</code> و <code>!</code> برای انجام عملیات <strong>or، and و not</strong> روی چند سمبل استفاده کرد. مثال:</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> TESTMODE &amp;&amp; !DEBUG</span>
    ...
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>توجه کنید که این یک عبارت معمولی C# نیست و سمبل‌ها هیچ ارتباطی با متغیرها—چه static و چه غیر—ندارند.</p>
<hr>
<h3><code>#error</code> و <code>#warning</code> ⚠️</h3>
<p>این دستورات از سوءاستفاده تصادفی از دستورات شرطی جلوگیری می‌کنند، با ایجاد <strong>هشدار یا خطا توسط کامپایلر</strong> در صورت مجموعه نامطلوبی از سمبل‌ها.</p>
<p>جدول ۴-۱ فهرست دستورات پیش‌پردازنده را ارائه می‌دهد.</p>
<div align="center">
<p><img src="../../../assets/image/04/Table-4-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>Conditional Attributes 🎯</h3>
<p>یک <strong>attribute</strong> که با <code>Conditional</code> تزئین شده باشد، تنها در صورتی کامپایل می‌شود که <strong>سمبل پیش‌پردازنده مشخص شده</strong> موجود باشد:</p>
<pre class="hljs"><code><span class="hljs-comment">// file1.cs</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span>
<span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Diagnostics;

[<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;DEBUG&quot;</span>)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestAttribute</span> : <span class="hljs-title">Attribute</span> {}

<span class="hljs-comment">// file2.cs</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span>
[<span class="hljs-meta">Test</span>]
<span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{
    [<span class="hljs-meta">Test</span>]
    <span class="hljs-built_in">string</span> s;
}
</code></pre>
<p>کامپایلر تنها زمانی attributeهای <code>[Test]</code> را در فایل <code>file2.cs</code> وارد می‌کند که سمبل <code>DEBUG</code> در محدوده آن فایل تعریف شده باشد.</p>
<hr>
<h3>Pragma Warning ⚠️</h3>
<p>کامپایلر وقتی چیزی در کد شما را غیرعمدی تشخیص دهد، یک <strong>هشدار (warning)</strong> ایجاد می‌کند. بر خلاف خطاها، هشدارها معمولاً مانع کامپایل شدن برنامه نمی‌شوند.</p>
<p>هشدارهای کامپایلر بسیار مفیدند برای شناسایی باگ‌ها، اما وقتی هشدارهای کاذب زیاد شوند، مفید بودنشان کاهش می‌یابد. در برنامه‌های بزرگ، حفظ <strong>نسبت سیگنال به نویز</strong> برای مشاهده هشدارهای واقعی ضروری است.</p>
<p>برای این منظور، می‌توانید هشدارها را به‌صورت انتخابی با دستور <code>#pragma warning</code> غیرفعال کنید. مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span> { }

    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span> disable 414</span>
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> Message = <span class="hljs-string">&quot;Hello&quot;</span>;   <span class="hljs-comment">// این هشدار غیرفعال شد</span>
    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span> restore 414</span>
}
</code></pre>
<p>اگر شماره هشدار در دستور <code>#pragma warning</code> حذف شود، همه هشدارها غیرفعال یا فعال می‌شوند.<br>
با دقت در استفاده از این دستور، می‌توان پروژه را با سوئیچ <code>/warnaserror</code> کامپایل کرد—که باعث می‌شود هر هشدار باقیمانده به یک <strong>خطا</strong> تبدیل شود.</p>
<hr>
<h3>مستندسازی XML 📄</h3>
<p>یک <strong>کامنت مستندسازی (documentation comment)</strong>، تکه‌ای از XML است که یک نوع یا عضو را مستند می‌کند. این کامنت درست قبل از تعریف نوع یا عضو قرار می‌گیرد و با سه اسلش <code>///</code> شروع می‌شود:</p>
<pre class="hljs"><code><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>Cancels a running query.<span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Cancel</span>()</span> { ... }
</code></pre>
<p>کامنت‌های چندخطی به این صورت هستند:</p>
<pre class="hljs"><code><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Cancels a running query</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Cancel</span>()</span> { ... }
</code></pre>
<p>یا به این شکل (با ستاره اضافی):</p>
<pre class="hljs"><code><span class="hljs-comment">/** 
    &lt;summary&gt; Cancels a running query. &lt;/summary&gt;
*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Cancel</span>()</span> { ... }
</code></pre>
<p>اگر گزینه زیر به فایل <code>.csproj</code> اضافه شود:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">DocumentationFile</span>&gt;</span>SomeFile.xml<span class="hljs-tag">&lt;/<span class="hljs-name">DocumentationFile</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>کامپایلر <strong>کامنت‌های مستندسازی</strong> را استخراج و در فایل XML مشخص شده جمع‌آوری می‌کند. کاربردها:</p>
<ul>
<li>اگر در همان فولدر اسمبلی کامپایل‌شده قرار گیرد، ابزارهایی مثل <strong>Visual Studio</strong> و <strong>LINQPad</strong> به‌طور خودکار فایل XML را می‌خوانند و از آن برای ارائه IntelliSense استفاده می‌کنند.</li>
<li>ابزارهای جانبی (مثل Sandcastle و NDoc) می‌توانند فایل XML را به HTML تبدیل کنند.</li>
</ul>
<hr>
<h3>تگ‌های استاندارد XML برای مستندسازی 📑</h3>
<p>تگ‌های استاندارد XML که Visual Studio و ابزارهای تولید مستندات می‌شناسند:</p>
<ul>
<li>
<p><code>&lt;summary&gt;</code><br>
توضیح کوتاهی که IntelliSense نمایش می‌دهد؛ معمولاً یک جمله یا عبارت کوتاه است.</p>
</li>
<li>
<p><code>&lt;remarks&gt;</code><br>
متن اضافی که نوع یا عضو را شرح می‌دهد. ابزارهای مستندسازی این متن را در توضیح کلی ادغام می‌کنند.</p>
</li>
<li>
<p><code>&lt;param&gt;</code><br>
توضیح پارامتر یک متد:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">param</span>&gt;</span>
</code></pre>
</li>
</ul>
<ul>
<li><code>&lt;returns&gt;</code><br>
توضیح مقدار برگشتی یک متد.</li>
</ul>
<ul>
<li>
<p><code>&lt;exception&gt;</code><br>
لیست استثناهایی که متد می‌تواند پرتاب کند:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">exception</span> <span class="hljs-attr">cref</span>=<span class="hljs-string">&quot;type&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">exception</span>&gt;</span>
</code></pre>
</li>
</ul>
<ul>
<li>
<p><code>&lt;example&gt;</code><br>
مثال عملی (شامل توضیح و کد نمونه):</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">example</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">example</span>&gt;</span>
</code></pre>
</li>
<li>
<p><code>&lt;c&gt;</code> و <code>&lt;code&gt;</code></p>
<ul>
<li><code>&lt;c&gt;</code>: قطعه کد خطی داخل مثال.</li>
<li><code>&lt;code&gt;</code>: نمونه کد چندخطی داخل مثال.</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>&lt;see&gt;</code><br>
ارجاع داخلی به یک نوع یا عضو دیگر:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">see</span> <span class="hljs-attr">cref</span>=<span class="hljs-string">&quot;member&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">see</span>&gt;</span>
</code></pre>
</li>
</ul>
<ul>
<li><code>&lt;seealso&gt;</code><br>
ارجاع متقابل به نوع یا عضو دیگر، معمولاً در بخش “See Also”.</li>
</ul>
<ul>
<li>
<p><code>&lt;paramref&gt;</code><br>
ارجاع به پارامتر در <code>&lt;summary&gt;</code> یا <code>&lt;remarks&gt;</code>:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">paramref</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>
</code></pre>
</li>
</ul>
<ul>
<li>
<p><code>&lt;list&gt;</code><br>
ایجاد لیست بولت‌دار، شماره‌دار یا جدولی:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">list</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;bullet|number|table&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">listheader</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">term</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">term</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">listheader</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">term</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">term</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
</code></pre>
</li>
<li>
<p><code>&lt;para&gt;</code><br>
ایجاد یک پاراگراف جدا:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">para</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">para</span>&gt;</span>
</code></pre>
</li>
<li>
<p><code>&lt;include&gt;</code><br>
ادغام یک فایل XML خارجی که مستندات را دارد:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&#x27;filename&#x27;</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;tagpath[@name=&quot;id&quot;]&#x27;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
</code></pre>
</li>
</ul>
<h3>User-Defined Tags 🏷️</h3>
<p>چیزی به‌خصوص در مورد تگ‌های پیش‌فرض XML که توسط کامپایلر C# شناخته می‌شوند وجود ندارد و شما آزاد هستید <strong>تگ‌های خودتان</strong> را تعریف کنید.</p>
<p>تنها پردازش ویژه‌ای که کامپایلر انجام می‌دهد مربوط به:</p>
<ul>
<li><code>&lt;param&gt;</code>: که نام پارامتر را بررسی می‌کند و مطمئن می‌شود تمام پارامترهای متد مستندسازی شده باشند.</li>
<li>صفت <code>cref</code>: که بررسی می‌کند این صفت به یک نوع یا عضو واقعی ارجاع می‌دهد و آن را به یک <strong>ID کاملاً واجد شرایط</strong> از نوع یا عضو گسترش می‌دهد.</li>
</ul>
<p>همچنین می‌توانید از صفت <code>cref</code> در تگ‌های خودتان استفاده کنید؛ کامپایلر همان بررسی و گسترش را انجام می‌دهد، درست مانند تگ‌های پیش‌فرض <code>&lt;exception&gt;</code>, <code>&lt;permission&gt;</code>, <code>&lt;see&gt;</code>, و <code>&lt;seealso&gt;</code>.</p>
<hr>
<h3>Type or Member Cross-References 🔗</h3>
<p>نام‌های نوع و ارجاعات متقابل به نوع یا عضو به <strong>IDهایی یکتا</strong> تبدیل می‌شوند که نوع یا عضو را مشخص می‌کنند.</p>
<p>این نام‌ها شامل دو بخش هستند:</p>
<ol>
<li><strong>پیش‌وند (prefix)</strong> که مشخص می‌کند ID چه چیزی را نمایندگی می‌کند.</li>
<li><strong>امضا (signature)</strong> نوع یا عضو.</li>
</ol>
<p>در ادامه، پیش‌وندهای اعضا (member prefixes) معرفی می‌شوند:</p>
<div align="center">
<p><img src="../../../assets/image/04/Table-4-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>نمونه‌ای از Type و Member IDs 📝</h3>
<p>قواعدی که مشخص می‌کنند <strong>امضاها (signatures)</strong> چگونه تولید می‌شوند، مستند شده‌اند، اگرچه نسبتاً پیچیده هستند.</p>
<p>در اینجا یک مثال از یک نوع و IDهای تولیدشده آن آورده شده است:</p>
<pre class="hljs"><code><span class="hljs-comment">// فضاهای نام (Namespaces) امضای مستقل ندارند</span>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">NS</span>
{
    <span class="hljs-comment"><span class="hljs-doctag">///</span> T:NS.MyClass</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>
    {
        <span class="hljs-comment"><span class="hljs-doctag">///</span> F:NS.MyClass.aField</span>
        <span class="hljs-built_in">string</span> aField;

        <span class="hljs-comment"><span class="hljs-doctag">///</span> P:NS.MyClass.aProperty</span>
        <span class="hljs-built_in">short</span> aProperty { <span class="hljs-keyword">get</span> { ... } <span class="hljs-keyword">set</span> { ... } }

        <span class="hljs-comment"><span class="hljs-doctag">///</span> T:NS.MyClass.NestedType</span>
        <span class="hljs-keyword">class</span> <span class="hljs-title">NestedType</span> { ... }

        <span class="hljs-comment"><span class="hljs-doctag">///</span> M:NS.MyClass.X()</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">X</span>()</span> { ... }

        <span class="hljs-comment"><span class="hljs-doctag">///</span> M:NS.MyClass.Y(System.Int32,System.Double@,System.Decimal@)</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Y</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p1, <span class="hljs-keyword">ref</span> <span class="hljs-built_in">double</span> p2, <span class="hljs-keyword">out</span> <span class="hljs-built_in">decimal</span> p3</span>)</span> { ... }

        <span class="hljs-comment"><span class="hljs-doctag">///</span> M:NS.MyClass.Z(System.Char[],System.Single[0:,0:])</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Z</span>(<span class="hljs-params"><span class="hljs-built_in">char</span>[] p1, <span class="hljs-built_in">float</span>[,] p2</span>)</span> { ... }

        <span class="hljs-comment"><span class="hljs-doctag">///</span> M:NS.MyClass.op_Addition(NS.MyClass,NS.MyClass)</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyClass <span class="hljs-keyword">operator</span> + (MyClass c1, MyClass c2) { ... }

        <span class="hljs-comment"><span class="hljs-doctag">///</span> M:NS.MyClass.op_Implicit(NS.MyClass)~System.Int32</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">MyClass c</span>)</span> { ... }

        <span class="hljs-comment"><span class="hljs-doctag">///</span> M:NS.MyClass.#ctor</span>
        MyClass() { ... }

        <span class="hljs-comment"><span class="hljs-doctag">///</span> M:NS.MyClass.Finalize</span>
        ~MyClass() { ... }

        <span class="hljs-comment"><span class="hljs-doctag">///</span> M:NS.MyClass.#cctor</span>
        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">MyClass</span>()</span> { ... }
    }
}
</code></pre>
<ul>
<li><code>T:</code> پیش‌وند برای <strong>Type</strong></li>
<li><code>F:</code> پیش‌وند برای <strong>Field</strong></li>
<li><code>P:</code> پیش‌وند برای <strong>Property</strong></li>
<li><code>M:</code> پیش‌وند برای <strong>Method</strong></li>
</ul>
<p>IDها شامل <strong>فضای نام، نام کلاس، و نام عضو</strong> هستند و برای متدها، پارامترها و نوع بازگشتی نیز دقیقاً مشخص می‌شوند.</p>
<p>این سیستم به <strong>کامپایلر و ابزارهای مستندسازی</strong> اجازه می‌دهد تا ارجاعات داخلی و خارجی را به‌درستی پیگیری کنند و خطاهای احتمالی را تشخیص دهند.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
