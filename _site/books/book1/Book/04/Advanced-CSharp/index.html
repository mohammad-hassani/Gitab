<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gitab | کتابخانهٔ ترجمه‌های دات‌نت و سی شارپ</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a class="brand" href="/">
        <img src="/icone/logo.svg" alt="Gitab" width="28" height="28">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/">خانه</a>
        <a href="/books/list-books">کتاب‌ها</a>
        <a href="#">همکاری</a>
        <a href="#">درباره‌ما</a>
      </nav>

     <div class="nav-actions">
  <button id="themeToggle" class="icon-btn theme-btn" aria-label="تغییر حالت">
    <img class="icon-sun" src="/icone/sun.svg" alt="روشن">
    <img class="icon-moon" src="/icone/moon.svg" alt="تاریک">
  </button>

  <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
    <img src="/icone/github.svg" alt="GitHub">
  </a>
</div>

  </header>

  <!-- محتوای صفحه -->
  <main class="site-main">
    <h1>فصل چهارم: سی شارپ پیشرفته</h1>
<p>در این فصل، مباحث پیشرفته <code>C#</code> را پوشش می‌دهیم که بر مفاهیم بررسی‌شده در فصل‌های ۲ و ۳ استوار هستند. شما باید چهار بخش اول را به ترتیب بخوانید؛ می‌توانید بقیه بخش‌ها را به هر ترتیبی بخوانید.</p>
<h2>دلیگیت‌ها (Delegates)</h2>
<p>دلیگیت یک شیء است که می‌داند چگونه یک متد را فراخوانی کند.</p>
<p>یک نوع دلیگیت (<code>delegate type</code>) نوع متدی را تعریف می‌کند که نمونه‌های دلیگیت می‌توانند فراخوانی کنند. به طور خاص، آن نوع بازگشتی و انواع پارامترهای متد را تعریف می‌کند. کد زیر یک نوع دلیگیت به نام <code>Transformer</code> تعریف می‌کند:</p>
<pre><code class="language-C#">
delegate int Transformer (int x);
</code></pre>
<p><code>Transformer</code> با هر متدی که دارای نوع بازگشتی <code>int</code> و یک پارامتر <code>int</code> باشد، سازگار است، مانند این:</p>
<pre><code class="language-C#">
int Square (int x) { return x * x; }
</code></pre>
<p>یا، به صورت کوتاه‌تر:</p>
<pre><code class="language-C#">
int Square (int x) =&gt; x * x;
</code></pre>
<p>اختصاص یک متد به یک متغیر دلیگیت، یک نمونه دلیگیت (<strong>delegate instance</strong>) ایجاد می‌کند:</p>
<pre><code class="language-C#">
Transformer t = Square;
</code></pre>
<p>می‌توانید یک نمونه دلیگیت را به همان روشی که یک متد را فراخوانی می‌کنید، فراخوانی کنید:</p>
<pre><code class="language-C#">
int answer = t(3);    // answer برابر 9 است
</code></pre>
<p>در اینجا یک مثال کامل آورده شده است:</p>
<pre><code class="language-C#">
delegate int Transformer (int x);   // اعلان نوع دلیگیت
Transformer t = Square;             // ایجاد نمونه دلیگیت
int result = t(3);                  // فراخوانی دلیگیت
Console.WriteLine (result);         // 9
int Square (int x) =&gt; x * x;
</code></pre>
<p>یک نمونه دلیگیت به معنای واقعی کلمه به عنوان نماینده (<code>delegate</code>) برای فراخواننده عمل می‌کند: فراخواننده دلیگیت را فراخوانی می‌کند، و سپس دلیگیت متد هدف را فراخوانی می‌کند. این غیرمستقیم بودن، فراخواننده را از متد هدف جدا می‌کند.</p>
<p>دستور:</p>
<pre><code class="language-C#">
Transformer t = Square;
</code></pre>
<p>شکل کوتاه‌شده‌ای از:</p>
<pre><code class="language-C#">
Transformer t = new Transformer (Square);
</code></pre>
<p>است.</p>
<p>عبارت t(3) شکل کوتاه‌شده‌ای از t.Invoke(3) است.</p>
<p>از نظر فنی، وقتی به <code>Square</code> بدون پرانتز یا آرگومان ارجاع می‌دهیم، یک گروه متد (<strong>method group</strong>) را مشخص می‌کنیم. اگر متد <code>overload</code> شده باشد، C# بر اساس امضای (<code>signature</code>) دلیگیتی که به آن اختصاص داده می‌شود، <code>overload</code> صحیح را انتخاب خواهد کرد.
دلیگیت شبیه یک <code>callback</code> است، که یک اصطلاح عمومی برای ساختارهایی مانند اشاره‌گرهای تابع C است.</p>
<h3>نوشتن متدهای Plug-in با دلیگیت‌ها</h3>
<p>به یک متغیر دلیگیت در زمان اجرا یک متد اختصاص داده می‌شود. این برای نوشتن متدهای plug-in مفید است. در این مثال، ما یک متد کاربردی به نام <code>Transform</code> داریم که یک تبدیل (transform) را به هر عنصر در یک آرایه اعداد صحیح اعمال می‌کند. متد <code>Transform</code> دارای یک پارامتر دلیگیت است که می‌توانید از آن برای مشخص کردن یک <code>transform</code> plug-in استفاده کنید:</p>
<pre><code class="language-C#">int[] values = { 1, 2, 3 };
Transform (values, Square);      // متد Square را به آن متصل می‌کند
foreach (int i in values)
 Console.Write (i + &quot;  &quot;);      // 1   4   9

void Transform (int[] values, Transformer t)
{
  for (int i = 0; i &lt; values.Length; i++)
    values[i] = t (values[i]);
}
int Square (int x) =&gt; x * x;
int Cube (int x) =&gt; x * x * x;
delegate int Transformer (int x);
</code></pre>
<p>می‌توانیم تبدیل را فقط با تغییر <code>Square</code> به <code>Cube</code> در خط دوم کد تغییر دهیم.
متد <code>Transform</code> ما یک تابع مرتبه بالاتر (<strong>higher-order function</strong>) است زیرا تابعی است که یک تابع را به عنوان آرگومان می‌گیرد. (متدی که یک دلیگیت را برمی‌گرداند نیز یک تابع مرتبه بالاتر خواهد بود.)</p>
<h3>هدف‌های متد نمونه و ثابت (Instance and Static Method Targets)</h3>
<p>متد هدف یک دلیگیت می‌تواند یک متد محلی (<strong>local</strong>)، ثابت (<strong>static</strong>)، یا نمونه (<strong>instance</strong>) باشد. کد زیر یک متد هدف ثابت را نشان می‌دهد:</p>
<pre><code class="language-C#">Transformer t = Test.Square;
Console.WriteLine (t(10));      // 100
class Test { public static int Square (int x) =&gt; x * x; }
delegate int Transformer (int x);
</code></pre>
<p>کد زیر یک متد هدف نمونه را نشان می‌دهد:</p>
<pre><code class="language-C#">Test test = new Test();
Transformer t = test.Square;
Console.WriteLine (t(10));      // 100
class Test { public int Square (int x) =&gt; x * x; }
delegate int Transformer (int x);

</code></pre>
<p>هنگامی که یک متد نمونه به یک شیء دلیگیت اختصاص داده می‌شود، دلیگیت علاوه بر متد، یک ارجاع به نمونه‌ای که متد به آن تعلق دارد نیز حفظ می‌کند. ویژگی <code>Target</code> از کلاس <code>System</code>.<code>Delegate</code> این نمونه را نمایش می‌دهد (و برای دلیگیتی که به یک متد ثابت ارجاع می‌دهد، <code>null</code> خواهد بود). در اینجا یک مثال آورده شده است:</p>
<pre><code class="language-C#">MyReporter r = new MyReporter();
r.Prefix = &quot;%Complete: &quot;;
ProgressReporter p = r.ReportProgress;
p(99);                                 // %Complete: 99
Console.WriteLine (p.Target == r);     // True
Console.WriteLine (p.Method);          // Void ReportProgress(Int32)
r.Prefix = &quot;&quot;;
p(99);                                 // 99
public delegate void ProgressReporter (int percentComplete);
class MyReporter
{
  public string Prefix = &quot;&quot;;
  public void ReportProgress (int percentComplete)
    =&gt; Console.WriteLine (Prefix + percentComplete);
}


</code></pre>
<p>از آنجا که نمونه در ویژگی <code>Target</code> دلیگیت ذخیره می‌شود، طول عمر آن (حداقل تا زمانی که دلیگیت عمر دارد) افزایش می‌یابد.</p>
<h3>دلیگیت‌های چندپخشی (Multicast Delegates)</h3>
<p>تمام نمونه‌های دلیگیت قابلیت چندپخشی (<code>multicast</code>) دارند. این به این معنی است که یک نمونه دلیگیت می‌تواند نه تنها به یک متد هدف، بلکه به لیستی از متدهای هدف نیز ارجاع دهد. عملگرهای <code>+</code> و <code>+=</code> نمونه‌های دلیگیت را با هم ترکیب می‌کنند:</p>
<pre><code class="language-C#">SomeDelegate d = SomeMethod1;
d += SomeMethod2;
</code></pre>
<p>خط آخر از نظر عملکردی همانند کد زیر است:</p>
<pre><code class="language-C#">d = d + SomeMethod2;
</code></pre>
<p>فراخوانی d اکنون هر دو <code>SomeMethod1</code> و <code>SomeMethod2</code> را فراخوانی خواهد کرد. دلیگیت‌ها به ترتیبی که اضافه می‌شوند، فراخوانی می‌گردند.
عملگرهای - و -= عملوند دلیگیت سمت راست را از عملوند دلیگیت سمت چپ حذف می‌کنند:</p>
<pre><code class="language-C#">
d -= SomeMethod1;
</code></pre>
<p>فراخوانی d اکنون تنها باعث فراخوانی <code>SomeMethod2</code> خواهد شد.</p>
<p>فراخوانی <code>+</code> یا <code>+=</code> روی یک متغیر دلیگیت با مقدار <code>null</code> نیز کار می‌کند و معادل اختصاص متغیر به یک مقدار جدید است:</p>
<pre><code class="language-C#">
SomeDelegate d = null;
d += SomeMethod1;       // معادل (وقتی d برابر null است) d = SomeMethod1;
</code></pre>
<p>به طور مشابه، فراخوانی -= روی یک متغیر دلیگیت با یک هدف تطابق‌یافته، معادل اختصاص <code>null</code> به آن متغیر است.</p>
<p>دلیگیت‌ها غیرقابل تغییر (<code>immutable</code>) هستند، بنابراین وقتی <code>+=</code> یا <code>-=</code> را فراخوانی می‌کنید، در واقع یک نمونه دلیگیت جدید ایجاد کرده و آن را به متغیر موجود اختصاص می‌دهید.</p>
<p>اگر یک دلیگیت چندپخشی دارای نوع بازگشتی nonvoid باشد، فراخواننده مقدار بازگشتی را از آخرین متدی که فراخوانی می‌شود دریافت می‌کند. متدهای قبلی همچنان فراخوانی می‌شوند، اما مقادیر بازگشتی آن‌ها دور ریخته می‌شود. در بیشتر سناریوهایی که از دلیگیت‌های چندپخشی استفاده می‌شود، آن‌ها دارای انواع بازگشتی void هستند، بنابراین این ظرافت مطرح نمی‌شود.</p>
<p>تمام انواع دلیگیت به صورت ضمنی از <strong>System.MulticastDelegate</strong> که از <strong>System.Delegate</strong> به ارث می‌برد، مشتق می‌شوند. C# عملیات <code>+</code>, <code>-</code>, <code>+=</code>, و <code>-=</code> روی یک دلیگیت را به متدهای static Combine و Remove از کلاس <strong>System.Delegate</strong> کامپایل می‌کند.</p>
<h4>مثال دلیگیت چندپخشی</h4>
<p>فرض کنید یک متد نوشته‌اید که اجرای آن زمان زیادی می‌برد. این متد می‌تواند به طور منظم با فراخوانی یک دلیگیت، پیشرفت کار را به فراخواننده گزارش دهد. در این مثال، متد <code>HardWork</code> یک پارامتر دلیگیت <code>ProgressReporter</code> دارد که آن را برای نشان دادن پیشرفت فراخوانی می‌کند:</p>
<pre><code class="language-C#">
public delegate void ProgressReporter (int percentComplete);
public class Util
{
  public static void HardWork (ProgressReporter p)
  {
    for (int i = 0; i &lt; 10; i++)
    {
      p (i * 10);                           // فراخوانی دلیگیت
      System.Threading.Thread.Sleep (100);  // شبیه‌سازی کار سخت
    }
  }
}
</code></pre>
<p>برای نظارت بر پیشرفت، می‌توانیم یک نمونه دلیگیت چندپخشی <code>p</code> ایجاد کنیم، به طوری که پیشرفت توسط دو متد مستقل نظارت شود:</p>
<pre><code class="language-C#">
ProgressReporter p = WriteProgressToConsole;
p += WriteProgressToFile;
Util.HardWork (p);

void WriteProgressToConsole (int percentComplete)
  =&gt; Console.WriteLine (percentComplete);
void WriteProgressToFile (int percentComplete)
  =&gt; System.IO.File.WriteAllText (&quot;progress.txt&quot;,
                                   percentComplete.ToString());
</code></pre>
<h3>انواع دلیگیت جنریک (Generic Delegate Types)</h3>
<p>یک نوع دلیگیت می‌تواند شامل پارامترهای نوع جنریک باشد:</p>
<pre><code class="language-C#">public delegate T Transformer (T arg);
</code></pre>
<p>با این تعریف، می‌توانیم یک متد کاربردی <code>Transform</code> عمومی بنویسیم که بر روی هر نوعی کار می‌کند:</p>
<pre><code class="language-C#">int[] values = { 1, 2, 3 };
Util.Transform (values, Square);      // متصل کردن Square
foreach (int i in values)
  Console.Write (i + &quot;  &quot;);           // 1   4   9

int Square (int x) =&gt; x * x;
public class Util
{
  public static void Transform (T[] values, Transformer t)
  {
    for (int i = 0; i &lt; values.Length; i++)
      values[i] = t (values[i]);
  }
}

</code></pre>
<h3>دلیگیت‌های Func و Action</h3>
<p>با دلیگیت‌های جنریک، امکان نوشتن مجموعه‌ای کوچک از انواع دلیگیت‌ها فراهم می‌شود که به قدری عمومی هستند که می‌توانند برای متدهایی با هر نوع بازگشتی و هر تعداد آرگومان (منطقی) کار کنند. این دلیگیت‌ها، دلیگیت‌های <strong>Func</strong> و <strong>Action</strong> هستند که در فضای نام <code>System</code> تعریف شده‌اند (حاشیه‌نویسی‌های <code>in</code> و <code>out</code> نشان‌دهنده <code>variance</code> هستند، که به زودی در زمینه دلیگیت‌ها پوشش می‌دهیم):</p>
<pre><code class="language-C#">
delegate TResult Func                 ();
delegate TResult Func           (T arg);
delegate TResult Func   (T1 arg1, T2 arg2);
... و همین‌طور تا T16

delegate void Action                 ();
delegate void Action           (T arg);
delegate void Action   (T1 arg1, T2 arg2);

... و همین‌طور تا T16
</code></pre>
<p>این دلیگیت‌ها بسیار عمومی هستند. دلیگیت <code>Transformer</code> در مثال قبلی ما می‌تواند با یک دلیگیت <code>Func</code> جایگزین شود که یک آرگومان از نوع <code>T</code> می‌گیرد و یک مقدار از همان نوع را برمی‌گرداند:</p>
<pre><code class="language-C#">
public static void Transform (T[] values, Func transformer)
{
  for (int i = 0; i &lt; values.Length; i++)
    values[i] = transformer (values[i]);
}
</code></pre>
<p>تنها سناریوهای عملی که توسط این دلیگیت‌ها پوشش داده نمی‌شوند، پارامترهای <code>ref/out</code> و اشاره‌گر هستند.</p>
<p>هنگامی که C# برای اولین بار معرفی شد، دلیگیت‌های <code>Func</code> و <code>Action</code> وجود نداشتند (زیرا جنریک‌ها وجود نداشتند). به همین دلیل تاریخی است که بسیاری از بخش‌های <strong>.NET</strong> به جای <code>Func</code> و <code>Action</code> از انواع دلیگیت‌های سفارشی استفاده می‌کنند.</p>
<h3>دلیگیت‌ها در برابر اینترفیس‌ها (Delegates Versus Interfaces)</h3>
<p>مشکلی که می‌توانید با یک دلیگیت حل کنید، با یک اینترفیس نیز قابل حل است. برای مثال، می‌توانیم مثال قبلی خود را با یک اینترفیس به نام <code>ITransformer</code> به جای دلیگیت بازنویسی کنیم:</p>
<pre><code class="language-C#">
int[] values = { 1, 2, 3 };
Util.TransformAll (values, new Squarer());
foreach (int i in values)
  Console.WriteLine (i);

public interface ITransformer
{
  int Transform (int x);
}

public class Util
{
  public static void TransformAll (int[] values, ITransformer t)
  {
    for (int i = 0; i &lt; values.Length; i++)
      values[i] = t.Transform (values[i]);
  }
}

class Squarer : ITransformer
{
  public int Transform (int x) =&gt; x * x;
}
</code></pre>
<p>طراحی با دلیگیت ممکن است انتخاب بهتری نسبت به طراحی با اینترفیس باشد اگر یک یا چند مورد از شرایط زیر درست باشد:</p>
<ul>
<li>
<p>اینترفیس فقط یک متد را تعریف می‌کند.</p>
</li>
<li>
<p>قابلیت چندپخشی (<strong>multicast</strong>) مورد نیاز باشد.</p>
</li>
<li>
<p><strong>subscriber</strong> نیاز داشته باشد اینترفیس را چندین بار پیاده‌سازی کند.</p>
</li>
</ul>
<p>در مثال <code>ITransformer،</code> ما نیازی به چندپخشی نداریم، اما اینترفیس فقط یک متد را تعریف می‌کند. علاوه بر این، ممکن است <code>subscriber</code> ما نیاز داشته باشد <code>ITransformer</code> را چندین بار پیاده‌سازی کند تا تبدیل‌های مختلفی مانند مربع یا مکعب را پشتیبانی کند. با اینترفیس‌ها، مجبوریم برای هر تبدیل یک نوع (<code>type</code>) جداگانه بنویسیم، زیرا یک کلاس فقط می‌تواند یک بار <code>ITransformer</code> را پیاده‌سازی کند. این کار نسبتاً دست و پا گیر است:</p>
<pre><code class="language-C#">
int[] values = { 1, 2, 3 };
Util.TransformAll (values, new Cuber());
foreach (int i in values)
  Console.WriteLine (i);

class Squarer : ITransformer
{
  public int Transform (int x) =&gt; x * x;
}
class Cuber : ITransformer
{
  public int Transform (int x) =&gt; x * x * x;
}
</code></pre>
<h3>سازگاری دلیگیت (Delegate Compatibility)</h3>
<h4>سازگاری نوع (Type compatibility)</h4>
<p>انواع دلیگیت‌ها حتی اگر امضای آن‌ها یکسان باشد، با یکدیگر ناسازگار هستند:</p>
<pre><code class="language-C#">
D1 d1 = Method1;
D2 d2 = d1;                           // خطای زمان کامپایل

void Method1() { }
delegate void D1();
delegate void D2();
</code></pre>
<p>با این حال، کد زیر مجاز است:</p>
<pre><code class="language-D2"></code></pre>
<p>نمونه‌های دلیگیت زمانی برابر در نظر گرفته می‌شوند که متدهای هدف یکسانی داشته باشند:</p>
<pre><code class="language-C#">
D d1 = Method1;
D d2 = Method1;
Console.WriteLine (d1 == d2);         // True

void Method1() { }
delegate void D();
</code></pre>
<p>دلیگیت‌های چندپخشی نیز اگر به متدهای یکسان و به همان ترتیب ارجاع دهند، برابر در نظر گرفته می‌شوند.</p>
<h4>سازگاری پارامتر (Parameter compatibility)</h4>
<p>وقتی یک متد را فراخوانی می‌کنید، می‌توانید آرگومان‌هایی با انواع خاص‌تر از پارامترهای آن متد ارائه دهید. این رفتار عادی چندریختی (<strong>polymorphic</strong>) است. به همین دلیل، یک دلیگیت می‌تواند انواع پارامتر خاص‌تری نسبت به متد هدف خود داشته باشد. به این ویژگی Contravariance گفته می‌شود. در اینجا یک مثال آورده شده است:</p>
<pre><code class="language-C#">
StringAction sa = new StringAction (ActOnObject);
sa (&quot;hello&quot;); // خروجی: hello

void ActOnObject (object o) =&gt; Console.WriteLine (o);
delegate void StringAction (string s);
</code></pre>
<p>یک دلیگیت به سادگی متدی را به نیابت از شخص دیگری فراخوانی می‌کند. در این حالت، <code>StringAction</code> با یک آرگومان از نوع <strong>string</strong> فراخوانی می‌شود. وقتی آرگومان به متد هدف ارسال می‌شود، به صورت ضمنی به <code>object</code> تبدیل می‌شود.</p>
<p>الگوی استاندارد رویداد به شما کمک می‌کند از طریق استفاده از کلاس پایه مشترک <code>EventArgs</code> از <code>contravariance</code> بهره ببرید. برای مثال، می‌توانید یک متد واحد داشته باشید که توسط دو دلیگیت مختلف فراخوانی می‌شود، یکی MouseEventArgs و دیگری KeyEventArgs را ارسال می‌کند.</p>
<h4>سازگاری نوع بازگشتی (Return type compatibility)</h4>
<p>اگر یک متد را فراخوانی کنید، ممکن است نوعی را دریافت کنید که خاص‌تر از آن چیزی باشد که درخواست کرده‌اید. این نیز رفتار عادی چندریختی است. به همین دلیل، متد هدف یک دلیگیت ممکن است نوعی خاص‌تر از آنچه دلیگیت توضیح می‌دهد، برگرداند. به این ویژگی Covariance گفته می‌شود:</p>
<pre><code class="language-C#">
ObjectRetriever o = new ObjectRetriever (RetrieveString);
object result = o();
Console.WriteLine (result);      // خروجی: hello

string RetrieveString() =&gt; &quot;hello&quot;;
delegate object ObjectRetriever();
</code></pre>
<p><code>ObjectRetriever</code> انتظار دارد یک <code>object</code> برگردانده شود، اما یک زیرکلاس از <code>object</code> نیز کارساز است: انواع بازگشتی دلیگیت <code>covariant</code> هستند.</p>
<h4>واریانس پارامتر نوع دلیگیت جنریک (Generic delegate type parameter variance)</h4>
<p>در فصل ۳، دیدیم که چگونه اینترفیس‌های جنریک از پارامترهای نوع <code>covariant</code> و <code>contravariant</code> پشتیبانی می‌کنند. همین قابلیت برای دلیگیت‌ها نیز وجود دارد.</p>
<p>اگر یک نوع دلیگیت جنریک تعریف می‌کنید، بهتر است:</p>
<ul>
<li>
<p>یک پارامتر نوعی را که فقط در مقدار بازگشتی استفاده می‌شود، به عنوان covariant (<code>out</code>) علامت‌گذاری کنید.</p>
</li>
<li>
<p>هر پارامتر نوعی را که فقط در پارامترها استفاده می‌شود، به عنوان contravariant (<code>in</code>) علامت‌گذاری کنید.</p>
</li>
</ul>
<p>انجام این کار به تبدیل‌ها اجازه می‌دهد تا به طور طبیعی با رعایت روابط وراثت بین انواع کار کنند.</p>
<p>دلیگیت زیر (تعریف‌شده در فضای نام <strong>System</strong>) دارای <code>TResult</code> از نوع <code>covariant</code> است:</p>
<pre><code class="language-C#">
delegate TResult Func();
</code></pre>
<p>این امر امکان‌پذیر است:</p>
<pre><code>Func x = ...;
Func y = x;
</code></pre>
<p>دلیگیت زیر (تعریف‌شده در فضای نام <strong>System</strong>) دارای <code>T</code> از نوع <code>contravariant</code> است:</p>
<pre><code class="language-C#">
delegate void Action (T arg);
</code></pre>
<p>این امر امکان‌پذیر است:</p>
<pre><code>Action x = ...;
Action y = x;
</code></pre>
<h3>رویدادها (Events)</h3>
<p>وقتی از دلیگیت‌ها استفاده می‌کنید، معمولاً دو نقش جدید پدیدار می‌شود: پخش‌کننده (<strong>broadcaster</strong>) و مشترک (<strong>subscriber</strong>).</p>
<p>پخش‌کننده نوعی است که یک فیلد دلیگیت دارد. پخش‌کننده با فراخوانی دلیگیت، زمان پخش (broadcast) را تعیین می‌کند.</p>
<p>مشترکین گیرندگان متد هدف هستند. یک مشترک با فراخوانی += و -= روی دلیگیت پخش‌کننده، تصمیم می‌گیرد چه زمانی به گوش دادن (<strong>listening</strong>) شروع یا پایان دهد. یک مشترک از وجود سایر مشترکین خبر ندارد و در کار آن‌ها دخالتی نمی‌کند.</p>
<p>رویدادها (<strong>Events</strong>) یک ویژگی زبانی هستند که این الگو را رسمی می‌کنند. یک رویداد ساختاری است که فقط زیرمجموعه‌ای از ویژگی‌های دلیگیت را که برای مدل پخش‌کننده/مشترک لازم است، آشکار می‌کند. هدف اصلی رویدادها این است که از تداخل مشترکین با یکدیگر جلوگیری کنند.</p>
<p>ساده‌ترین راه برای اعلان یک رویداد، قرار دادن کلمه کلیدی <code>event</code> قبل از یک عضو دلیگیت است:</p>
<pre><code class="language-C#">
// Delegate definition
public delegate void PriceChangedHandler (decimal oldPrice,
                                         decimal newPrice);

public class Broadcaster
{
  // Event declaration
  public event PriceChangedHandler PriceChanged;
}
</code></pre>
<p>کد درون نوع <code>Broadcaster</code> دسترسی کامل به <code>PriceChanged</code> دارد و می‌تواند با آن به عنوان یک دلیگیت رفتار کند. اما کدی که در خارج از <code>Broadcaster</code> قرار دارد، تنها می‌تواند عملیات += و -= را روی رویداد <code>PriceChanged</code> انجام دهد.</p>
<div align="center">
<p><img src="../../../assets/image/04/Table-2-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال + اسکریپت تم -->
  <script>
    document.getElementById('y').textContent = new Date().getFullYear();

    (() => {
      const root = document.documentElement;
      const btn = document.getElementById('themeToggle');
      const KEY = 'gitab-theme';
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      const getEffective = s => s === 'auto' ? (media.matches ? 'dark' : 'light') : s;
      function updateTheme(s) {
        root.setAttribute('data-theme', s);
        const mode = getEffective(s);
        root.dataset.colorMode = mode;
        btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
      }
      const saved = localStorage.getItem(KEY) || 'auto';
      updateTheme(saved);
      btn.addEventListener('click', () => {
        const curr = localStorage.getItem(KEY) || 'auto';
        const next = curr === 'auto' ? 'dark' : curr === 'dark' ? 'light' : 'auto';
        localStorage.setItem(KEY, next);
        updateTheme(next);
      });
      media.addEventListener('change', () => {
        if ((localStorage.getItem(KEY) || 'auto') === 'auto') updateTheme('auto');
      });
      window.addEventListener('DOMContentLoaded', () => updateTheme(saved));
    })();
  </script>
</body>
</html>
