

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>مجموعه‌ها (Collections)</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/Gitab/" aria-current="page">خانه</a>
        <a href="/Gitab/books/list-books">کتاب‌ها</a>
       <a href="/Gitab/translator.html">مترجمین</a>
        <a href="/Gitab/giter.html">گیتر</a>
      </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل هفتم: <strong>مجموعه‌ها (Collections) 📚</strong></h1>
<p>.NET یک مجموعه استاندارد از نوع‌ها را برای ذخیره‌سازی و مدیریت مجموعه‌ای از اشیاء ارائه می‌دهد. این نوع‌ها شامل لیست‌های قابل تغییر اندازه (resizable lists)، لیست‌های پیوندی (linked lists)، دیکشنری‌های مرتب و نامرتب (sorted و unsorted dictionaries) و همچنین آرایه‌ها (arrays) هستند. از بین این‌ها، تنها آرایه‌ها بخشی از زبان C# را تشکیل می‌دهند؛ بقیه مجموعه‌ها فقط کلاس‌هایی هستند که می‌توانید مانند هر کلاس دیگری نمونه‌سازی (instantiate) کنید.</p>
<p>می‌توانیم نوع‌ها در BCL دات‌نت برای مجموعه‌ها را به دسته‌های زیر تقسیم کنیم:</p>
<p>• اینترفیس‌هایی که پروتکل‌های استاندارد مجموعه را تعریف می‌کنند</p>
<p>• کلاس‌های آماده برای استفاده در مجموعه‌ها (لیست‌ها، دیکشنری‌ها و غیره)</p>
<p>• کلاس‌های پایه برای نوشتن مجموعه‌های مخصوص برنامه</p>
<p>این فصل هر یک از این دسته‌ها را پوشش می‌دهد، به‌علاوه یک بخش اضافی درباره نوع‌هایی که برای تعیین برابری و ترتیب عناصر استفاده می‌شوند، ارائه می‌کند.</p>
<p>فضاهای نام (namespaces) مربوط به مجموعه‌ها به شرح زیر هستند:</p>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p><strong>شماره‌گذاری (Enumeration) 🔢</strong></p>
<p>در علوم کامپیوتر، مجموعه‌های مختلفی وجود دارند که از ساختارهای داده ساده مانند آرایه‌ها (arrays) یا لیست‌های پیوندی (linked lists)، تا ساختارهای پیچیده‌تر مانند درخت‌های قرمز/سیاه (red/black trees) و هشت‌جدول‌ها (hashtables) را شامل می‌شوند.</p>
<p>اگرچه پیاده‌سازی داخلی و ویژگی‌های خارجی این ساختارهای داده بسیار متفاوت است، اما توانایی پیمایش (traverse) محتویات مجموعه، نیاز تقریباً جهانی است. BCL دات‌نت این نیاز را از طریق یک جفت اینترفیس (IEnumerable و IEnumerator و نسخه‌های Generic آن‌ها) پشتیبانی می‌کند که به ساختارهای داده مختلف اجازه می‌دهد یک API مشترک برای پیمایش ارائه دهند.</p>
<p>این اینترفیس‌ها بخشی از مجموعه بزرگ‌تری از اینترفیس‌های مجموعه هستند که در شکل ۷-۱ نشان داده شده‌اند.</p>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p><strong>IEnumerable و IEnumerator 🔄</strong></p>
<p>اینترفیس <code>IEnumerator</code> پروتکل پایه و سطح پایین را تعریف می‌کند که با آن عناصر یک مجموعه به‌صورت پیش‌رونده (forward-only) پیمایش یا شماره‌گذاری (enumerate) می‌شوند. تعریف آن به صورت زیر است:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEnumerator</span>
{
  <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span>;
  <span class="hljs-built_in">object</span> Current { <span class="hljs-keyword">get</span>; }
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span>;
}
</code></pre>
<p>متد <code>MoveNext</code> عنصر فعلی یا «کرسر» (cursor) را به موقعیت بعدی منتقل می‌کند و اگر دیگر عنصری در مجموعه وجود نداشته باشد، مقدار <code>false</code> برمی‌گرداند. <code>Current</code> عنصری را که در موقعیت فعلی قرار دارد برمی‌گرداند (معمولاً از نوع <code>object</code> به نوع خاص‌تر تبدیل می‌شود). قبل از دسترسی به اولین عنصر، حتماً باید <code>MoveNext</code> فراخوانی شود — این کار اجازه می‌دهد تا مجموعه خالی نیز مدیریت شود. متد <code>Reset</code>، در صورت پیاده‌سازی، کرسر را به ابتدای مجموعه بازمی‌گرداند تا امکان پیمایش مجدد فراهم شود. وجود <code>Reset</code> بیشتر برای سازگاری با <strong>Component Object Model (COM)</strong> است؛ فراخوانی مستقیم آن معمولاً اجتناب می‌شود چون همیشه پشتیبانی نمی‌شود و به طور کلی لازم نیست، زیرا ایجاد یک نمونه جدید از enumerator اغلب ساده‌تر است.</p>
<p>معمولاً مجموعه‌ها خودشان enumerator را پیاده‌سازی نمی‌کنند؛ بلکه <strong>enumerator</strong> را از طریق اینترفیس <code>IEnumerable</code> فراهم می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEnumerable</span>
{
  <span class="hljs-function">IEnumerator <span class="hljs-title">GetEnumerator</span>()</span>;
}
</code></pre>
<p>با تعریف یک متد که یک enumerator بازمی‌گرداند، <code>IEnumerable</code> انعطاف‌پذیری ایجاد می‌کند تا منطق تکرار (iteration) به کلاس دیگری سپرده شود. همچنین این به این معنی است که چند مصرف‌کننده می‌توانند همزمان مجموعه را پیمایش کنند بدون اینکه با یکدیگر تداخل داشته باشند. می‌توان <code>IEnumerable</code> را «<code>IEnumeratorProvider</code>» در نظر گرفت، و این ابتدایی‌ترین اینترفیس است که کلاس‌های مجموعه پیاده‌سازی می‌کنند.</p>
<p>نمونه زیر استفاده سطح پایین از <code>IEnumerable</code> و <code>IEnumerator</code> را نشان می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;Hello&quot;</span>;
<span class="hljs-comment">// چون رشته String اینترفیس IEnumerable را پیاده‌سازی می‌کند، می‌توانیم GetEnumerator را فراخوانی کنیم:</span>
IEnumerator rator = s.GetEnumerator();
<span class="hljs-keyword">while</span> (rator.MoveNext())
{
  <span class="hljs-built_in">char</span> c = (<span class="hljs-built_in">char</span>) rator.Current;
  Console.Write(c + <span class="hljs-string">&quot;.&quot;</span>);
}
<span class="hljs-comment">// خروجی: H.e.l.l.o.</span>
</code></pre>
<p>با این حال، به‌ندرت پیش می‌آید که متدها روی enumerator به این شکل فراخوانی شوند، زیرا C# یک میان‌بر نحوی فراهم می‌کند: دستور <code>foreach</code>. مثال بالا با استفاده از <code>foreach</code> به شکل زیر بازنویسی می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;Hello&quot;</span>;      <span class="hljs-comment">// کلاس String اینترفیس IEnumerable را پیاده‌سازی می‌کند</span>
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> s)
  Console.Write(c + <span class="hljs-string">&quot;.&quot;</span>);
</code></pre>
<hr>
<h3><code>IEnumerable&lt;T&gt;</code> و <code>IEnumerator&lt;T&gt;</code> 🧩</h3>
<p><code>IEnumerator</code> و <code>IEnumerable</code> تقریباً همیشه همراه با نسخه‌های Generic خود پیاده‌سازی می‌شوند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEnumerator</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IEnumerator</span>, <span class="hljs-title">IDisposable</span>
{
  T Current { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IEnumerable</span>
{
  <span class="hljs-function">IEnumerator&lt;T&gt; <span class="hljs-title">GetEnumerator</span>()</span>;
}
</code></pre>
<p>با تعریف نسخه‌ای نوع‌دار (typed) از <code>Current</code> و <code>GetEnumerator</code>، این اینترفیس‌ها ایمنی نوع ایستا (static type safety) را تقویت می‌کنند، از سربار <strong>boxing</strong> در عناصر نوع مقدار (value-type) جلوگیری می‌کنند و برای مصرف‌کننده راحت‌تر هستند. آرایه‌ها به‌صورت خودکار <code>IEnumerable&lt;T&gt;</code> را پیاده‌سازی می‌کنند (که T نوع عضو آرایه است).</p>
<p>به لطف ایمنی نوع ایستا، فراخوانی متد زیر با آرایه‌ای از کاراکترها باعث ایجاد خطای زمان کامپایل می‌شود:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span> (<span class="hljs-params">IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; numbers</span>)</span> { ... }
</code></pre>
<p>یک روش استاندارد در کلاس‌های مجموعه این است که <code>IEnumerable&lt;T&gt;</code> را به‌صورت عمومی (public) نمایش دهند و <code>IEnumerable</code> غیر Generic را از طریق پیاده‌سازی صریح اینترفیس (explicit interface implementation) «مخفی» کنند. این کار به این دلیل است که اگر مستقیماً <code>GetEnumerator()</code> فراخوانی شود، یک <code>IEnumerator&lt;T&gt;</code> ایمن از نظر نوع بازگردانده شود.</p>
<p>با این حال، گاهی این قانون برای سازگاری با نسخه‌های قدیمی شکسته می‌شود (زیرا Genericها قبل از C# 2.0 وجود نداشتند). یک مثال خوب آرایه‌ها هستند — این‌ها باید <code>IEnumerator</code> غیر Generic (یا همان نسخه «کلاسیک») را برگردانند تا کدهای قبلی خراب نشوند. برای به دست آوردن <code>IEnumerator&lt;T&gt;</code> Generic، باید نوع را به صورت صریح تبدیل (cast) کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] data = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
<span class="hljs-keyword">var</span> rator = ((IEnumerable&lt;<span class="hljs-built_in">int</span>&gt;)data).GetEnumerator();
</code></pre>
<p>خوشبختانه به لطف دستور <code>foreach</code>، به ندرت نیاز است چنین کدی نوشته شود.</p>
<p><strong>IEnumerable<T> و IDisposable ♻️</strong></p>
<p><code>IEnumerator&lt;T&gt;</code> از <code>IDisposable</code> ارث‌بری می‌کند. این امکان را به enumerator می‌دهد که به منابعی مانند اتصال به پایگاه داده (database connections) دسترسی داشته باشد و اطمینان حاصل کند که این منابع پس از اتمام یا قطع پیمایش آزاد می‌شوند. دستور <code>foreach</code> این نکته را تشخیص می‌دهد و عبارت زیر را:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> somethingEnumerable) { ... }
</code></pre>
<p>به معادل منطقی زیر تبدیل می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> rator = somethingEnumerable.GetEnumerator())
  <span class="hljs-keyword">while</span> (rator.MoveNext())
  {
    <span class="hljs-keyword">var</span> element = rator.Current;
    ...
  }
</code></pre>
<p>بلوک <code>using</code> تضمین می‌کند که منابع به درستی Dispose شوند — درباره <code>IDisposable</code> در فصل ۱۲ بیشتر توضیح داده می‌شود.</p>
<hr>
<h3>استفاده از اینترفیس‌های غیر Generic ❓</h3>
<p>با توجه به ایمنی نوع اضافی که اینترفیس‌های مجموعه Generic مانند <code>IEnumerable&lt;T&gt;</code> ارائه می‌دهند، این سؤال مطرح می‌شود: آیا واقعاً نیاز به استفاده از <code>IEnumerable</code> غیر Generic (یا <code>ICollection</code> یا <code>IList</code>) وجود دارد؟</p>
<p>در مورد <code>IEnumerable</code>، باید این اینترفیس را همراه با <code>IEnumerable&lt;T&gt;</code> پیاده‌سازی کنید، زیرا نسخه Generic از نسخه غیر Generic ارث‌بری می‌کند. با این حال، بسیار نادر است که بخواهید این اینترفیس‌ها را از ابتدا پیاده‌سازی کنید؛ در اکثر موارد می‌توانید از روش‌های سطح بالاتر مانند <strong>iterator methods</strong>، <code>Collection&lt;T&gt;</code> و <strong>LINQ</strong> استفاده کنید.</p>
<hr>
<h3>به‌عنوان مصرف‌کننده 🔍</h3>
<p>در اکثر موارد، می‌توانید به‌طور کامل با اینترفیس‌های Generic کار کنید. با این حال، اینترفیس‌های غیر Generic هنوز گاهی مفید هستند، زیرا توانایی ارائه <strong>یکپارچگی نوع</strong> برای مجموعه‌ها با همه نوع عناصر را دارند.</p>
<p>برای مثال، متد زیر تعداد عناصر موجود در هر مجموعه‌ای را به‌صورت بازگشتی می‌شمارد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Count</span>(<span class="hljs-params">IEnumerable e</span>)</span>
{
    <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">object</span> element <span class="hljs-keyword">in</span> e)
    {
        <span class="hljs-keyword">var</span> subCollection = element <span class="hljs-keyword">as</span> IEnumerable;
        <span class="hljs-keyword">if</span> (subCollection != <span class="hljs-literal">null</span>)
            count += Count(subCollection);
        <span class="hljs-keyword">else</span>
            count++;
    }
    <span class="hljs-keyword">return</span> count;
}
</code></pre>
<p>چون C# با اینترفیس‌های Generic امکان <strong>covariance</strong> را ارائه می‌دهد، ممکن است فکر کنید می‌توانستیم به جای آن <code>IEnumerable&lt;object&gt;</code> دریافت کنیم. اما این روش با عناصر نوع مقدار (value-type) و مجموعه‌های قدیمی که <code>IEnumerable&lt;T&gt;</code> را پیاده‌سازی نکرده‌اند، شکست می‌خورد — مثالی از این نوع، <code>ControlCollection</code> در Windows Forms است.</p>
<blockquote>
<p>⚠️ نکته: در مثال بالا، ارجاعات چرخه‌ای (cyclic references) می‌توانند باعث بازگشت نامتناهی و کرش شدن برنامه شوند. ساده‌ترین راه حل، استفاده از <code>HashSet</code> است (به بخش &quot;HashSet<T> و SortedSet<T>&quot; در صفحه ۳۹۲ مراجعه کنید).</p>
</blockquote>
<hr>
<h3>پیاده‌سازی اینترفیس‌های Enumeration 🛠️</h3>
<p>ممکن است بخواهید <code>IEnumerable</code> یا <code>IEnumerable&lt;T&gt;</code> را به یکی یا چند دلیل زیر پیاده‌سازی کنید:</p>
<ul>
<li>پشتیبانی از دستور <code>foreach</code></li>
<li>همکاری با هر چیزی که مجموعه استاندارد انتظار دارد</li>
<li>رعایت نیازمندی‌های یک اینترفیس مجموعه پیشرفته‌تر</li>
<li>پشتیبانی از <strong>collection initializers</strong></li>
</ul>
<p>برای پیاده‌سازی <code>IEnumerable/IEnumerable&lt;T&gt;</code>، باید یک <strong>enumerator</strong> ارائه دهید. سه روش برای انجام این کار وجود دارد:</p>
<ol>
<li>اگر کلاس، مجموعه دیگری را <strong>wrapper</strong> می‌کند، با بازگرداندن enumerator مجموعه داخلی</li>
<li>از طریق یک <strong>iterator</strong> با استفاده از <code>yield return</code></li>
<li>با ایجاد نمونه‌ای از پیاده‌سازی خود <code>IEnumerator/IEnumerator&lt;T&gt;</code></li>
</ol>
<hr>
<h3>نمونه استفاده از iterator با <code>yield return</code> ✨</h3>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span> : <span class="hljs-title">IEnumerable</span>
{
    <span class="hljs-built_in">int</span>[] data = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>()</span>
    {
        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span> data)
            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> i;
    }
}
</code></pre>
<p>در نگاه اول، به نظر می‌رسد <code>GetEnumerator</code> هیچ enumerator‌ای باز نمی‌گرداند! اما کامپایلر هنگام پردازش <code>yield return</code>، یک کلاس enumerator پنهان می‌سازد و <code>GetEnumerator</code> را طوری تغییر می‌دهد که آن کلاس را نمونه‌سازی و بازگرداند.</p>
<p>این روش ساده، قدرتمند و در پیاده‌سازی <strong>LINQ-to-Objects</strong> بسیار استفاده می‌شود.</p>
<hr>
<h3>پیاده‌سازی نسخه Generic 🧩</h3>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenCollection</span> : <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">int</span>&gt;
{
    <span class="hljs-built_in">int</span>[] data = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetEnumerator</span>()</span>
    {
        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span> data)
            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> i;
    }

    <span class="hljs-comment">// پیاده‌سازی صریح نسخه غیر Generic:</span>
    IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
}
</code></pre>
<p>چون <code>IEnumerable&lt;T&gt;</code> از <code>IEnumerable</code> ارث‌بری می‌کند، باید هر دو نسخه Generic و غیر Generic از <code>GetEnumerator</code> پیاده‌سازی شوند. نسخه غیر Generic معمولاً به‌صورت صریح (explicit) پیاده‌سازی می‌شود تا بتواند نسخه Generic را فراخوانی کند، زیرا <code>IEnumerator&lt;T&gt;</code> از <code>IEnumerator</code> ارث‌بری می‌کند.</p>
<hr>
<h3>پیاده‌سازی مستقیم IEnumerator 🔧</h3>
<p>در برخی موارد، می‌توانید یک کلاس بنویسید که مستقیماً <code>IEnumerator</code> را پیاده‌سازی کند. مثال زیر یک مجموعه ثابت با اعداد 1، 2 و 3 را نشان می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyIntList</span> : <span class="hljs-title">IEnumerable</span>
{
    <span class="hljs-built_in">int</span>[] data = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>()</span> =&gt; <span class="hljs-keyword">new</span> Enumerator(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">class</span> <span class="hljs-title">Enumerator</span> : <span class="hljs-title">IEnumerator</span>
    {
        MyIntList collection;
        <span class="hljs-built_in">int</span> currentIndex = <span class="hljs-number">-1</span>;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Enumerator</span>(<span class="hljs-params">MyIntList items</span>)</span> =&gt; <span class="hljs-keyword">this</span>.collection = items;

        <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current
        {
            <span class="hljs-keyword">get</span>
            {
                <span class="hljs-keyword">if</span> (currentIndex == <span class="hljs-number">-1</span>)
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">&quot;Enumeration not started!&quot;</span>);
                <span class="hljs-keyword">if</span> (currentIndex == collection.data.Length)
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">&quot;Past end of list!&quot;</span>);
                <span class="hljs-keyword">return</span> collection.data[currentIndex];
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span>
        {
            <span class="hljs-keyword">if</span> (currentIndex &gt;= collection.data.Length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">return</span> ++currentIndex &lt; collection.data.Length;
        }

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span> =&gt; currentIndex = <span class="hljs-number">-1</span>;
    }
}
</code></pre>
<p>پیاده‌سازی <code>Reset</code> اختیاری است — می‌توانید به جای آن <code>NotSupportedException</code> پرتاب کنید.</p>
<hr>
<h3>پیاده‌سازی Generic مستقیم ✅</h3>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">MyIntList</span> : <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">int</span>&gt;
{
    <span class="hljs-built_in">int</span>[] data = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };

    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetEnumerator</span>()</span> =&gt; <span class="hljs-keyword">new</span> Enumerator(<span class="hljs-keyword">this</span>);
    IEnumerator IEnumerable.GetEnumerator() =&gt; <span class="hljs-keyword">new</span> Enumerator(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">class</span> <span class="hljs-title">Enumerator</span> : <span class="hljs-title">IEnumerator</span>&lt;<span class="hljs-title">int</span>&gt;
    {
        <span class="hljs-built_in">int</span> currentIndex = <span class="hljs-number">-1</span>;
        MyIntList collection;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Enumerator</span>(<span class="hljs-params">MyIntList items</span>)</span> =&gt; collection = items;

        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Current =&gt; collection.data[currentIndex];
        <span class="hljs-built_in">object</span> IEnumerator.Current =&gt; Current;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span> =&gt; ++currentIndex &lt; collection.data.Length;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span> =&gt; currentIndex = <span class="hljs-number">-1</span>;

        <span class="hljs-comment">// از آنجا که نیاز به Dispose نداریم، بهتر است صریح پیاده‌سازی شود تا از رابط عمومی مخفی بماند</span>
        <span class="hljs-keyword">void</span> IDisposable.Dispose() {}
    }
}
</code></pre>
<p>نسخه Generic سریع‌تر است زیرا <code>IEnumerator&lt;int&gt;.Current</code> نیاز به <strong>casting</strong> از <code>int</code> به <code>object</code> ندارد و سربار <strong>boxing</strong> را حذف می‌کند.</p>
<p><strong>اینترفیس‌های ICollection و IList 🗂️</strong></p>
<p>اگرچه اینترفیس‌های Enumeration یک پروتکل برای پیمایش <strong>فقط به جلو</strong> (forward-only) در مجموعه‌ها فراهم می‌کنند، اما مکانیزمی برای تعیین اندازه مجموعه، دسترسی به عضو از طریق اندیس، یا تغییر محتویات مجموعه ارائه نمی‌دهند. برای چنین قابلیت‌هایی، دات‌نت اینترفیس‌های <code>ICollection</code>، <code>IList</code> و <code>IDictionary</code> را تعریف کرده است. هرکدام از این اینترفیس‌ها نسخه‌های <strong>Generic</strong> و <strong>Non-Generic</strong> دارند؛ با این حال، نسخه‌های غیر Generic عمدتاً برای پشتیبانی از کدهای قدیمی وجود دارند.</p>
<p>شکل ۷-۱ سلسله مراتب ارث‌بری این اینترفیس‌ها را نشان داد. ساده‌ترین راه برای خلاصه‌سازی آن‌ها به شرح زیر است:</p>
<ul>
<li><code>IEnumerable&lt;T&gt;</code> (و <code>IEnumerable</code>)<br>
حداقل قابلیت‌ها را فراهم می‌کند (فقط پیمایش)</li>
<li><code>ICollection&lt;T&gt;</code> (و <code>ICollection</code>)<br>
قابلیت‌های متوسط را ارائه می‌دهد (مثلاً ویژگی <code>Count</code>)</li>
<li><code>IList&lt;T&gt;</code> / <code>IDictionary&lt;K,V&gt;</code> و نسخه‌های غیر Generic آن‌ها<br>
حداکثر قابلیت‌ها را ارائه می‌دهند (شامل دسترسی «تصادفی» به عناصر با اندیس یا کلید)</li>
</ul>
<p>به ندرت پیش می‌آید که نیاز داشته باشید هر یک از این اینترفیس‌ها را خودتان پیاده‌سازی کنید. در اکثر مواقع، هنگام نوشتن یک کلاس مجموعه، می‌توانید به جای آن از <strong>subclass</strong> کردن <code>Collection&lt;T&gt;</code> استفاده کنید (به بخش &quot;Customizable Collections and Proxies&quot; در صفحه ۴۰۱ مراجعه کنید). <strong>LINQ</strong> نیز گزینه دیگری ارائه می‌دهد که بسیاری از سناریوها را پوشش می‌دهد.</p>
<p>نسخه‌های Generic و Non-Generic تفاوت‌هایی فراتر از انتظار معمول دارند، به‌ویژه در مورد <code>ICollection</code>. این تفاوت‌ها عمدتاً تاریخی هستند: چون Genericها بعداً وارد شدند، اینترفیس‌های Generic با بهره‌مندی از تجربه پیشین توسعه یافتند و اعضای متفاوت (و بهتری) انتخاب شدند.</p>
<p>به همین دلیل:</p>
<ul>
<li><code>ICollection&lt;T&gt;</code> از <code>ICollection</code> ارث‌بری نمی‌کند</li>
<li><code>IList&lt;T&gt;</code> از <code>IList</code> ارث‌بری نمی‌کند</li>
<li><code>IDictionary&lt;TKey, TValue&gt;</code> از <code>IDictionary</code> ارث‌بری نمی‌کند</li>
</ul>
<p>البته، یک کلاس مجموعه می‌تواند هر دو نسخه یک اینترفیس را پیاده‌سازی کند اگر مفید باشد (که اغلب مفید است).</p>
<p>دلیل ظریف‌تر دیگری که باعث شده <code>IList&lt;T&gt;</code> از <code>IList</code> ارث‌بری نکند این است که اگر این کار انجام شود، تبدیل به <code>IList&lt;T&gt;</code> موجب بازگشت یک اینترفیس با اعضای <code>Add(T)</code> و <code>Add(object)</code> می‌شود، که در واقع ایمنی نوع ایستا (static type safety) را نقض می‌کند، زیرا می‌توانستید با هر نوع شیئی <code>Add</code> را فراخوانی کنید.</p>
<hr>
<h3>این بخش شامل چه مواردی است 📖</h3>
<p>این بخش به <code>ICollection&lt;T&gt;</code> و <code>IList&lt;T&gt;</code> و نسخه‌های غیر Generic آن‌ها می‌پردازد؛ <strong>دیکشنری‌ها</strong> در صفحه ۳۹۴ تحت پوشش قرار دارند.</p>
<p>در کتابخانه‌های دات‌نت، هیچ منطق یکپارچه‌ای برای استفاده از واژه‌های &quot;collection&quot; و &quot;list&quot; وجود ندارد.<br>
برای مثال، چون <code>IList&lt;T&gt;</code> نسخه‌ای با قابلیت بیشتر از <code>ICollection&lt;T&gt;</code> است، ممکن است انتظار داشته باشید کلاس <code>List&lt;T&gt;</code> به‌طور مشابه از کلاس <code>Collection&lt;T&gt;</code> کاربردی‌تر باشد، اما این‌گونه نیست. بهتر است این دو واژه را به‌طور کلی مترادف در نظر بگیرید، مگر آنکه نوع خاصی مدنظر باشد.</p>
<hr>
<h3>ICollection<T> و ICollection 📦</h3>
<p><code>ICollection&lt;T&gt;</code> اینترفیس استاندارد برای مجموعه‌های شمارش‌پذیر است. این اینترفیس امکان:</p>
<ul>
<li>تعیین اندازه مجموعه (<code>Count</code>)</li>
<li>بررسی وجود یک آیتم در مجموعه (<code>Contains</code>)</li>
<li>کپی مجموعه به آرایه (<code>ToArray</code>)</li>
<li>تعیین اینکه مجموعه فقط خواندنی است (<code>IsReadOnly</code>)</li>
</ul>
<p>و برای مجموعه‌های قابل نوشتن، امکان افزودن (<code>Add</code>)، حذف (<code>Remove</code>) و پاک کردن (<code>Clear</code>) عناصر را نیز فراهم می‌کند.<br>
همچنین چون از <code>IEnumerable&lt;T&gt;</code> ارث‌بری می‌کند، می‌توان از دستور <code>foreach</code> نیز برای پیمایش آن استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICollection</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">IEnumerable</span>
{
    <span class="hljs-built_in">int</span> Count { <span class="hljs-keyword">get</span>; }
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Contains</span>(<span class="hljs-params">T item</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CopyTo</span>(<span class="hljs-params">T[] array, <span class="hljs-built_in">int</span> arrayIndex</span>)</span>;
    <span class="hljs-built_in">bool</span> IsReadOnly { <span class="hljs-keyword">get</span>; }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span>;
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">T item</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span>;
}
</code></pre>
<p>نسخه غیر Generic <code>ICollection</code> مشابه است و مجموعه‌ای شمارش‌پذیر ارائه می‌دهد، اما قابلیت تغییر محتویات مجموعه یا بررسی عضویت عناصر را ندارد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICollection</span> : <span class="hljs-title">IEnumerable</span>
{
    <span class="hljs-built_in">int</span> Count { <span class="hljs-keyword">get</span>; }
    <span class="hljs-built_in">bool</span> IsSynchronized { <span class="hljs-keyword">get</span>; }
    <span class="hljs-built_in">object</span> SyncRoot { <span class="hljs-keyword">get</span>; }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CopyTo</span>(<span class="hljs-params">Array array, <span class="hljs-built_in">int</span> index</span>)</span>;
}
</code></pre>
<p>این نسخه غیر Generic همچنین ویژگی‌هایی برای کمک به <strong>سینک کردن (synchronization)</strong> دارد (فصل ۱۴) — این ویژگی‌ها در نسخه Generic حذف شدند زیرا <strong>Thread Safety</strong> دیگر ذاتاً بخشی از مجموعه‌ها محسوب نمی‌شود.</p>
<p>هر دو اینترفیس نسبتاً ساده برای پیاده‌سازی هستند. اگر بخواهید یک <code>ICollection&lt;T&gt;</code> فقط خواندنی پیاده‌سازی کنید، متدهای <code>Add</code>، <code>Remove</code> و <code>Clear</code> باید <code>NotSupportedException</code> پرتاب کنند.</p>
<p>معمولاً این اینترفیس‌ها همراه با <code>IList</code> یا <code>IDictionary</code> پیاده‌سازی می‌شوند.<br>
<strong>اینترفیس‌های IList<T> و IList 📋</strong></p>
<p><code>IList&lt;T&gt;</code> اینترفیس استاندارد برای مجموعه‌هایی است که می‌توان به عناصر آن‌ها با <strong>موقعیت (اندیس)</strong> دسترسی داشت. علاوه بر قابلیت‌هایی که از <code>ICollection&lt;T&gt;</code> و <code>IEnumerable&lt;T&gt;</code> به ارث برده، این اینترفیس امکان <strong>خواندن و نوشتن عنصر با استفاده از اندیس</strong> و <strong>درج/حذف عنصر بر اساس موقعیت</strong> را نیز فراهم می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">ICollection</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">IEnumerable</span>
{
    T <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">IndexOf</span>(<span class="hljs-params">T item</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, T item</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RemoveAt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span>;
}
</code></pre>
<p>متد <code>IndexOf</code> جستجوی خطی (linear search) در لیست انجام می‌دهد و اگر عنصر مشخص شده پیدا نشود، مقدار <code>-1</code> برمی‌گرداند.</p>
<p>نسخه غیر Generic <code>IList</code> اعضای بیشتری دارد، زیرا از <code>ICollection</code> کمتری ارث‌بری می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IList</span> : <span class="hljs-title">ICollection</span>, <span class="hljs-title">IEnumerable</span>
{
    <span class="hljs-built_in">object</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-built_in">bool</span> IsFixedSize { <span class="hljs-keyword">get</span>; }
    <span class="hljs-built_in">bool</span> IsReadOnly { <span class="hljs-keyword">get</span>; }
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span>;
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Contains</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span></span>)</span>;
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">IndexOf</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, <span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Remove</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RemoveAt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span>;
}
</code></pre>
<p>در نسخه غیر Generic، متد <code>Add</code> یک <strong>عدد صحیح (int)</strong> برمی‌گرداند که نشان‌دهنده <strong>اندیس عنصر اضافه‌شده</strong> است. در مقابل، متد <code>Add</code> در <code>ICollection&lt;T&gt;</code> دارای نوع بازگشتی <code>void</code> است.</p>
<p>کلاس عمومی <code>List&lt;T&gt;</code> نمونه بارز پیاده‌سازی هر دو اینترفیس <code>IList&lt;T&gt;</code> و <code>IList</code> است. آرایه‌های C# نیز هر دو نسخه Generic و Non-Generic <code>IList</code> را پیاده‌سازی می‌کنند، اگرچه متدهایی که برای اضافه یا حذف عناصر هستند، از طریق پیاده‌سازی صریح اینترفیس پنهان شده‌اند و در صورت فراخوانی، <code>NotSupportedException</code> پرتاب می‌کنند.</p>
<blockquote>
<p>⚠️ اگر تلاش کنید به یک <strong>آرایه چندبعدی</strong> از طریق ایندکسر <code>IList</code> دسترسی پیدا کنید، یک <code>ArgumentException</code> پرتاب خواهد شد. این نکته ممکن است هنگام نوشتن متدهایی مانند زیر مشکل‌ساز شود:</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-title">FirstOrNull</span>(<span class="hljs-params">IList list</span>)</span>
{
    <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.Count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> list[<span class="hljs-number">0</span>];
}
</code></pre>
<p>این کد ممکن است ظاهراً بی‌خطا باشد، اما اگر با آرایه چندبعدی فراخوانی شود، یک استثنا پرتاب خواهد کرد. می‌توان در زمان اجرا بررسی کرد که آیا آرایه چندبعدی است یا خیر:</p>
<pre class="hljs"><code>list.GetType().IsArray &amp;&amp; list.GetType().GetArrayRank() &gt; <span class="hljs-number">1</span>
</code></pre>
<hr>
<h3>IReadOnlyCollection<T> و IReadOnlyList<T> 🔒</h3>
<p>.NET اینترفیس‌های <strong>مجموعه و لیست فقط خواندنی</strong> نیز دارد که فقط اعضای لازم برای عملیات <strong>فقط خواندنی</strong> را ارائه می‌دهند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IReadOnlyCollection</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">T</span>&gt; : <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">IEnumerable</span>
{
    <span class="hljs-built_in">int</span> Count { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IReadOnlyList</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">T</span>&gt; : <span class="hljs-title">IReadOnlyCollection</span>&lt;<span class="hljs-title">T</span>&gt;,
                                       <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">IEnumerable</span>
{
    T <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] { <span class="hljs-keyword">get</span>; }
}
</code></pre>
<p>از آنجا که پارامتر نوع (<code>T</code>) تنها در <strong>موقعیت خروجی</strong> استفاده می‌شود، به صورت <strong>Covariant</strong> علامت‌گذاری شده است. این امکان را می‌دهد که مثلاً <strong>لیستی از گربه‌ها</strong> به عنوان یک <strong>لیست فقط خواندنی از حیوانات</strong> تلقی شود.</p>
<p>در مقابل، <code>T</code> در <code>ICollection&lt;T&gt;</code> و <code>IList&lt;T&gt;</code> Covariant نیست، زیرا در هر دو موقعیت ورودی و خروجی استفاده می‌شود.</p>
<p>این اینترفیس‌ها نمایی <strong>فقط خواندنی</strong> از یک مجموعه یا لیست ارائه می‌کنند؛ پیاده‌سازی واقعی ممکن است هنوز قابل نوشتن باشد. اکثر مجموعه‌های قابل تغییر (Mutable) هم اینترفیس‌های فقط خواندنی و هم خواندنی/نوشتنی را پیاده‌سازی می‌کنند.</p>
<p>علاوه بر امکان کار با مجموعه‌ها به صورت Covariant، اینترفیس‌های فقط خواندنی اجازه می‌دهند یک کلاس <strong>نمایی فقط خواندنی از یک مجموعه خصوصی قابل نوشتن</strong> را به صورت عمومی ارائه کند. این موضوع در بخش <code>ReadOnlyCollection&lt;T&gt;</code> در صفحه ۴۰۶ نشان داده شده است.</p>
<blockquote>
<p><code>IReadOnlyList&lt;T&gt;</code> با نوع Windows Runtime <code>IVectorView&lt;T&gt;</code> مطابقت دارد.</p>
</blockquote>
<hr>
<h3>کلاس Array 🗃️</h3>
<p>کلاس <code>Array</code> کلاس پایه <strong>ضمنی (implicit)</strong> برای تمام آرایه‌های تک‌بعدی و چندبعدی است و یکی از <strong>اساسی‌ترین نوع‌ها</strong> است که اینترفیس‌های استاندارد مجموعه را پیاده‌سازی می‌کند.</p>
<p>کلاس <code>Array</code> یکپارچگی نوع را فراهم می‌کند، بنابراین یک مجموعه از <strong>متدهای مشترک</strong> برای تمام آرایه‌ها، صرف‌نظر از اعلان یا نوع عناصر، در دسترس است.</p>
<p>از آنجا که آرایه‌ها بسیار اساسی هستند، C# <strong>سینتکس ویژه‌ای برای اعلان و مقداردهی اولیه آن‌ها</strong> ارائه می‌دهد (که در فصل‌های ۲ و ۳ توضیح داده شد). وقتی آرایه‌ای با سینتکس C# اعلام می‌شود، <strong>CLR به طور ضمنی</strong> کلاس <code>Array</code> را زیرنوع‌دهی می‌کند و یک <strong>Pseudo-Type</strong> مناسب برای ابعاد و نوع عناصر آرایه ایجاد می‌کند. این Pseudo-Type اینترفیس‌های Generic نوع‌دار را پیاده‌سازی می‌کند، مانند <code>IList&lt;string&gt;</code>.</p>
<p>CLR همچنین هنگام ساخت آرایه‌ها به آن‌ها به صورت ویژه نگاه می‌کند و <strong>فضای متوالی در حافظه</strong> برای آن‌ها اختصاص می‌دهد. این کار باعث می‌شود <strong>دسترسی با اندیس به آرایه‌ها بسیار کارآمد</strong> باشد، اما اجازه تغییر اندازه بعد از ساخت را نمی‌دهد.</p>
<p>کلاس <code>Array</code> اینترفیس‌های مجموعه را تا <code>IList&lt;T&gt;</code> پیاده‌سازی می‌کند، هم در نسخه Generic و هم غیر Generic. خود <code>IList&lt;T&gt;</code> به صورت صریح پیاده‌سازی شده تا <strong>متدهایی مانند Add و Remove</strong> که برای آرایه‌های با طول ثابت نامناسب هستند، از رابط عمومی <code>Array</code> پنهان بمانند و در صورت فراخوانی استثنا پرتاب کنند.</p>
<p>کلاس <code>Array</code> یک متد <strong>استاتیک <code>Resize</code></strong> نیز ارائه می‌دهد، اما این متد با <strong>ایجاد یک آرایه جدید و کپی کردن هر عنصر</strong> کار می‌کند. این روش نه تنها ناکارآمد است، بلکه مراجع به آرایه اصلی در بخش‌های دیگر برنامه همچنان به نسخه اولیه اشاره خواهند کرد. راه حل بهتر برای مجموعه‌های قابل تغییر، استفاده از کلاس <code>List&lt;T&gt;</code> است (که در بخش بعدی توضیح داده می‌شود).</p>
<p>آرایه می‌تواند شامل عناصر <strong>Value-Type</strong> یا <strong>Reference-Type</strong> باشد. عناصر Value-Type در محل آرایه ذخیره می‌شوند، بنابراین یک آرایه از سه عدد صحیح طولانی (هر کدام ۸ بایت) <strong>۲۴ بایت حافظه متوالی</strong> اشغال می‌کند. اما عنصر Reference-Type تنها به اندازه یک مرجع فضای آرایه را اشغال می‌کند (۴ بایت در محیط ۳۲ بیتی یا ۸ بایت در محیط ۶۴ بیتی).</p>
<p>شکل ۷-۲ تأثیر این موضوع را در حافظه نشان می‌دهد:</p>
<pre class="hljs"><code>StringBuilder[] builders = <span class="hljs-keyword">new</span> StringBuilder[<span class="hljs-number">5</span>];
builders[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;builder1&quot;</span>);
builders[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;builder2&quot;</span>);
builders[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;builder3&quot;</span>);

<span class="hljs-built_in">long</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">long</span>[<span class="hljs-number">3</span>];
numbers[<span class="hljs-number">0</span>] = <span class="hljs-number">12345</span>;
numbers[<span class="hljs-number">1</span>] = <span class="hljs-number">54321</span>;
</code></pre>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>چون <code>Array</code> یک کلاس است، <strong>آرایه‌ها همیشه خودشان نوع مرجع (Reference Type) هستند</strong>—صرف‌نظر از نوع عناصر آرایه. این بدان معناست که دستور زیر:</p>
<pre class="hljs"><code>arrayB = arrayA
</code></pre>
<p>منجر به ایجاد <strong>دو متغیری می‌شود که به همان آرایه ارجاع می‌دهند</strong>.</p>
<p>به همین ترتیب، <strong>دو آرایه مجزا همیشه در آزمون برابری شکست خواهند خورد</strong>، مگر اینکه از یک <strong>مقایسه‌کننده برابری ساختاری (Structural Equality Comparer)</strong> استفاده کنید که هر عنصر آرایه را مقایسه می‌کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span>[] a1 = { <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-number">123</span>, <span class="hljs-literal">true</span> };
<span class="hljs-built_in">object</span>[] a2 = { <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-number">123</span>, <span class="hljs-literal">true</span> };

Console.WriteLine(a1 == a2);                         <span class="hljs-comment">// False</span>
Console.WriteLine(a1.Equals(a2));                    <span class="hljs-comment">// False</span>

IStructuralEquatable se1 = a1;
Console.WriteLine(se1.Equals(a2, StructuralComparisons.StructuralEqualityComparer));   <span class="hljs-comment">// True</span>
</code></pre>
<p>آرایه‌ها می‌توانند با فراخوانی متد <code>Clone</code> کپی شوند:</p>
<pre class="hljs"><code>arrayB = arrayA.Clone();
</code></pre>
<p>اما این یک <strong>کپی سطحی (Shallow Clone)</strong> ایجاد می‌کند، یعنی فقط <strong>حافظه‌ای که خود آرایه اشغال کرده است</strong> کپی می‌شود. اگر آرایه شامل <strong>اشیاء Value-Type</strong> باشد، خود مقادیر کپی می‌شوند؛ اما اگر شامل <strong>اشیاء Reference-Type</strong> باشد، فقط <strong>ارجاعات (References)</strong> کپی می‌شوند، در نتیجه دو آرایه‌ای خواهید داشت که اعضای آن‌ها به <strong>همان اشیاء</strong> اشاره می‌کنند.</p>
<p>شکل ۷-۳ اثر این موضوع را هنگام افزودن کد زیر به مثال نشان می‌دهد:</p>
<pre class="hljs"><code>StringBuilder[] builders2 = builders;
StringBuilder[] shallowClone = (StringBuilder[]) builders.Clone();
</code></pre>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>برای ایجاد یک <strong>کپی عمیق (Deep Copy)</strong>—که در آن <strong>زیر اشیاء Reference-Type</strong> نیز تکرار می‌شوند—باید از آرایه عبور کرده و هر عنصر را به‌صورت دستی کپی کنید. همان قوانین برای سایر انواع مجموعه‌ها در .NET نیز صدق می‌کند.</p>
<p>اگرچه <code>Array</code> عمدتاً برای استفاده با <strong>ایندکس‌های ۳۲ بیتی</strong> طراحی شده، اما از <strong>ایندکس‌های ۶۴ بیتی</strong> نیز پشتیبانی محدودی دارد (که به صورت تئوری امکان دسترسی به تا $2^{64}$ عنصر را می‌دهد) از طریق چندین متدی که هم <strong>Int32</strong> و هم <strong>Int64</strong> را می‌پذیرند. این اورلودها در عمل بی‌فایده هستند، زیرا <strong>CLR اجازه نمی‌دهد هیچ شیء—از جمله آرایه‌ها—بزرگ‌تر از دو گیگابایت باشد</strong> (چه در محیط ۳۲ بیتی و چه ۶۴ بیتی).</p>
<p>بسیاری از متدهایی که انتظار دارید در کلاس <code>Array</code> <strong>متد نمونه (Instance Method)</strong> باشند، در واقع <strong>متدهای استاتیک</strong> هستند. این تصمیم طراحی کمی عجیب است و به این معناست که هنگام جستجوی یک متد در <code>Array</code> باید هم <strong>متدهای استاتیک</strong> و هم <strong>متدهای نمونه</strong> را بررسی کنید.</p>
<hr>
<h3>ایجاد و ایندکس‌گذاری آرایه‌ها 🗂️</h3>
<p>ساده‌ترین راه برای ایجاد و ایندکس کردن آرایه‌ها، استفاده از ساختارهای زبانی C# است:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] myArray = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
<span class="hljs-built_in">int</span> first = myArray[<span class="hljs-number">0</span>];
<span class="hljs-built_in">int</span> last = myArray[myArray.Length - <span class="hljs-number">1</span>];
</code></pre>
<p>همچنین می‌توانید یک آرایه را <strong>پویا (Dynamic)</strong> با استفاده از <code>Array.CreateInstance</code> بسازید. این روش به شما امکان می‌دهد نوع عنصر و <strong>بعد (Rank)</strong> را در زمان اجرا مشخص کنید و همچنین آرایه‌های <strong>غیر صفر-مبنا</strong> ایجاد کنید. آرایه‌های غیر صفر-مبنا با <strong>.NET Common Language Specification (CLS)</strong> سازگار نیستند و نباید به‌عنوان اعضای عمومی در کتابخانه‌هایی که ممکن است توسط برنامه‌ای در F# یا Visual Basic استفاده شوند، ارائه شوند.</p>
<p>متدهای <code>GetValue</code> و <code>SetValue</code> اجازه می‌دهند عناصر آرایه‌های پویا یا معمولی را دسترسی یا مقداردهی کنید:</p>
<pre class="hljs"><code><span class="hljs-comment">// ایجاد آرایه رشته‌ای با 2 عنصر</span>
Array a = Array.CreateInstance(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-number">2</span>);
a.SetValue(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-number">0</span>);       <span class="hljs-comment">// → a[0] = &quot;hi&quot;;</span>
a.SetValue(<span class="hljs-string">&quot;there&quot;</span>, <span class="hljs-number">1</span>);    <span class="hljs-comment">// → a[1] = &quot;there&quot;;</span>
<span class="hljs-built_in">string</span> s = (<span class="hljs-built_in">string</span>)a.GetValue(<span class="hljs-number">0</span>);  <span class="hljs-comment">// → s = a[0];</span>

<span class="hljs-comment">// تبدیل به آرایه C#:</span>
<span class="hljs-built_in">string</span>[] cSharpArray = (<span class="hljs-built_in">string</span>[])a;
<span class="hljs-built_in">string</span> s2 = cSharpArray[<span class="hljs-number">0</span>];
</code></pre>
<p>آرایه‌های صفر-مبنا که به‌صورت پویا ایجاد می‌شوند، می‌توانند به آرایه‌ای از نوع مشابه یا <strong>سازگار</strong> در C# تبدیل شوند. برای مثال، اگر <code>Apple</code> از <code>Fruit</code> ارث‌بری کند، می‌توان <code>Apple[]</code> را به <code>Fruit[]</code> تبدیل کرد. این مسئله دلیل استفاده از کلاس <code>Array</code> به جای <code>object[]</code> برای نوع یکنواخت را توضیح می‌دهد، زیرا <code>object[]</code> با <strong>آرایه‌های چندبعدی و Value-Type</strong> سازگار نیست.</p>
<p><code>GetValue</code> و <code>SetValue</code> همچنین روی آرایه‌های ساخته شده توسط کامپایلر نیز کار می‌کنند و زمانی که می‌خواهید <strong>متدی بنویسید که با هر نوع و بعدی از آرایه کار کند</strong> مفید هستند. برای آرایه‌های چندبعدی، آن‌ها <strong>آرایه‌ای از ایندکس‌ها</strong> می‌پذیرند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-title">GetValue</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] indices</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetValue</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span>, <span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] indices</span>)
</span></code></pre>
<p>مثال زیر، <strong>اولین عنصر هر آرایه‌ای را بدون توجه به بعد آن چاپ می‌کند</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteFirstValue</span>(<span class="hljs-params">Array a</span>)</span>
{
    Console.Write(a.Rank + <span class="hljs-string">&quot;-dimensional; &quot;</span>);
    <span class="hljs-built_in">int</span>[] indexers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[a.Rank]; <span class="hljs-comment">// خودکار صفر-مبنا</span>
    Console.WriteLine(<span class="hljs-string">&quot;First value is &quot;</span> + a.GetValue(indexers));
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Demo</span>()</span>
{
    <span class="hljs-built_in">int</span>[] oneD = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
    <span class="hljs-built_in">int</span>[,] twoD = { {<span class="hljs-number">5</span>,<span class="hljs-number">6</span>}, {<span class="hljs-number">8</span>,<span class="hljs-number">9</span>} };
    WriteFirstValue(oneD);   <span class="hljs-comment">// 1-dimensional; first value is 1</span>
    WriteFirstValue(twoD);   <span class="hljs-comment">// 2-dimensional; first value is 5</span>
}
</code></pre>
<hr>
<p>برای <strong>آرایه‌هایی با نوع ناشناخته اما بعد مشخص</strong>، <strong>Generics</strong> راهکار ساده‌تر و کارآمدتری ارائه می‌دهند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteFirstValue</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] array</span>)</span>
{
    Console.WriteLine(array[<span class="hljs-number">0</span>]);
}
</code></pre>
<p>متد <code>SetValue</code> در صورت ناسازگار بودن نوع عنصر با آرایه، استثنا پرتاب می‌کند.</p>
<p>هنگام ایجاد آرایه—چه با <strong>سینتکس زبان</strong> و چه با <code>Array.CreateInstance</code>—عناصر آرایه <strong>به‌صورت خودکار به مقدار پیش‌فرضشان مقداردهی می‌شوند</strong>. برای آرایه‌های Reference-Type، این مقداردهی با <code>null</code> انجام می‌شود؛ برای آرایه‌های Value-Type، اعضا به صورت بیت‌به‌بیت صفر می‌شوند.</p>
<p>کلاس <code>Array</code> همچنین متد <code>Clear</code> را ارائه می‌دهد تا به‌صورت اختیاری آرایه را پاکسازی کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>(<span class="hljs-params">Array array, <span class="hljs-built_in">int</span> index, <span class="hljs-built_in">int</span> length</span>)</span>;
</code></pre>
<p>این متد اندازه آرایه را تغییر نمی‌دهد، بر خلاف <code>ICollection&lt;T&gt;.Clear</code> که تعداد عناصر را به صفر کاهش می‌دهد.</p>
<hr>
<h3>پیمایش آرایه‌ها 🔄</h3>
<p>آرایه‌ها به‌راحتی با <strong>foreach</strong> پیمایش می‌شوند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] myArray = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> val <span class="hljs-keyword">in</span> myArray)
    Console.WriteLine(val);
</code></pre>
<p>همچنین می‌توان از <strong>متد استاتیک <code>Array.ForEach</code></strong> استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ForEach</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] array, Action&lt;T&gt; action</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T obj</span>)</span>;
</code></pre>
<p>مثال بازنویسی شده با <code>Array.ForEach</code>:</p>
<pre class="hljs"><code>Array.ForEach(<span class="hljs-keyword">new</span>[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> }, Console.WriteLine);
</code></pre>
<p>و در C# 12، می‌توان این را ساده‌تر کرد:</p>
<pre class="hljs"><code>Array.ForEach([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], Console.WriteLine);
</code></pre>
<h3>طول و بعد آرایه 📏</h3>
<p>کلاس <code>Array</code> متدها و ویژگی‌های زیر را برای <strong>پرس‌وجو درباره طول و بعد</strong> آرایه ارائه می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  <span class="hljs-title">GetLength</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> dimension</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> <span class="hljs-title">GetLongLength</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> dimension</span>)</span>;
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  Length { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> LongLength { <span class="hljs-keyword">get</span>; }

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLowerBound</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> dimension</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetUpperBound</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> dimension</span>)</span>;
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Rank { <span class="hljs-keyword">get</span>; }    <span class="hljs-comment">// تعداد بعدهای آرایه را باز می‌گرداند</span>
</code></pre>
<ul>
<li><code>GetLength</code> و <code>GetLongLength</code> طول یک بعد مشخص (0 برای آرایه‌های تک‌بعدی) را باز می‌گردانند.</li>
<li><code>Length</code> و <code>LongLength</code> تعداد کل عناصر آرایه را در <strong>تمامی ابعاد</strong> بازمی‌گردانند.</li>
<li><code>GetLowerBound</code> و <code>GetUpperBound</code> در آرایه‌های <strong>غیر صفر-مبنا</strong> کاربرد دارند. <code>GetUpperBound</code> همان نتیجه‌ی <code>GetLowerBound + GetLength</code> برای یک بعد مشخص را بازمی‌گرداند.</li>
</ul>
<hr>
<h3>جستجو در آرایه 🔍</h3>
<p>کلاس <code>Array</code> مجموعه‌ای از متدها را برای پیدا کردن عناصر در <strong>آرایه‌های تک‌بعدی</strong> ارائه می‌دهد:</p>
<ul>
<li>
<p><strong>متدهای BinarySearch</strong><br>
برای جستجوی سریع در یک آرایه مرتب برای یک عنصر مشخص.</p>
</li>
<li>
<p><strong>متدهای IndexOf / LastIndexOf</strong><br>
برای جستجوی آرایه‌های نامرتب برای یک عنصر خاص.</p>
</li>
<li>
<p><strong>متدهای Find / FindLast / FindIndex / FindLastIndex / FindAll / Exists / TrueForAll</strong><br>
برای جستجوی آرایه‌های نامرتب بر اساس معیار یک <strong>Predicate<T></strong>.</p>
</li>
</ul>
<p>نکات مهم:</p>
<ul>
<li>
<p>هیچ‌یک از متدهای جستجوی آرایه، در صورت پیدا نشدن عنصر، <strong>استثنا پرتاب نمی‌کنند</strong>.</p>
<ul>
<li>متدهایی که <strong>int</strong> بازمی‌گردانند، مقدار <code>-1</code> بازمی‌گردانند (فرض بر صفر-مبنا بودن آرایه).</li>
<li>متدهایی که نوع <strong>Generic</strong> بازمی‌گردانند، مقدار پیش‌فرض آن نوع را برمی‌گردانند (مثلاً <code>0</code> برای <code>int</code> یا <code>null</code> برای <code>string</code>).</li>
</ul>
</li>
<li>
<p><strong>BinarySearch</strong> سریع است، اما فقط روی آرایه‌های مرتب کار می‌کند و نیاز دارد عناصر <strong>ترتیب‌پذیر باشند</strong>. این متدها می‌توانند یک شیء <code>IComparer</code> یا <code>IComparer&lt;T&gt;</code> دریافت کنند تا ترتیب عناصر را تعیین کند (باید با ترتیبی که هنگام مرتب‌سازی اولیه استفاده شده، سازگار باشد). در صورت عدم ارائه، الگوریتم مرتب‌سازی پیش‌فرض نوع استفاده می‌شود (براساس <code>IComparable</code> / <code>IComparable&lt;T&gt;</code>).</p>
</li>
<li>
<p><strong>IndexOf / LastIndexOf</strong> صرفاً آرایه را پیمایش می‌کنند و موقعیت <strong>اولین یا آخرین عنصر مطابق</strong> را بازمی‌گردانند.</p>
</li>
<li>
<p>متدهای مبتنی بر <strong>Predicate</strong> اجازه می‌دهند <strong>Delegate</strong> یا <strong>Lambda Expression</strong> تصمیم بگیرد که آیا عنصر مشخصی با معیار موردنظر مطابقت دارد یا خیر.</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T obj</span>)</span>;
</code></pre>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span>[] names = { <span class="hljs-string">&quot;Rodney&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jill&quot;</span> };
<span class="hljs-built_in">string</span> match = Array.Find(names, ContainsA);
Console.WriteLine(match); <span class="hljs-comment">// Jack</span>

<span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">ContainsA</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> { <span class="hljs-keyword">return</span> name.Contains(<span class="hljs-string">&quot;a&quot;</span>); }
</code></pre>
<p>همان مثال با <strong>Lambda Expression</strong>:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span>[] names = { <span class="hljs-string">&quot;Rodney&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Jill&quot;</span> };
<span class="hljs-built_in">string</span> match = Array.Find(names, n =&gt; n.Contains(<span class="hljs-string">&quot;a&quot;</span>)); <span class="hljs-comment">// Jack</span>
</code></pre>
<ul>
<li>
<p><code>FindAll</code> آرایه‌ای شامل <strong>تمام عناصر مطابق با Predicate</strong> بازمی‌گرداند و مشابه <code>Enumerable.Where</code> در <code>System.Linq</code> است، با این تفاوت که خروجی به صورت آرایه است، نه <code>IEnumerable&lt;T&gt;</code>.</p>
</li>
<li>
<p><code>Exists</code> باز می‌گرداند <code>true</code> اگر <strong>هر عضو آرایه</strong> معیار Predicate را برآورده کند، مشابه <code>Any</code> در <code>System.Linq.Enumerable</code>.</p>
</li>
<li>
<p><code>TrueForAll</code> باز می‌گرداند <code>true</code> اگر <strong>همه عناصر</strong> معیار Predicate را برآورده کنند، مشابه <code>All</code> در <code>System.Linq.Enumerable</code>.</p>
</li>
</ul>
<h3>مرتب‌سازی آرایه 🗂️</h3>
<p>کلاس <code>Array</code> چندین متد <strong>مرتب‌سازی داخلی</strong> دارد:</p>
<pre class="hljs"><code><span class="hljs-comment">// مرتب‌سازی یک آرایه تک‌بعدی:</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] array</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params">Array array</span>)</span>;

<span class="hljs-comment">// مرتب‌سازی جفت آرایه‌ها:</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>&lt;<span class="hljs-title">TKey</span>,<span class="hljs-title">TValue</span>&gt;(<span class="hljs-params">TKey[] keys, TValue[] items</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Sort</span>(<span class="hljs-params">Array keys, Array items</span>)</span>;
</code></pre>
<p>هر یک از این متدها به‌صورت <strong>Overload</strong> می‌توانند پارامترهای زیر را هم بگیرند:</p>
<ul>
<li><code>int index</code> → شروع مرتب‌سازی از ایندکس مشخص</li>
<li><code>int length</code> → تعداد عناصر برای مرتب‌سازی</li>
<li><code>IComparer&lt;T&gt; comparer</code> → شیء تعیین‌کننده ترتیب عناصر</li>
<li><code>Comparison&lt;T&gt; comparison</code> → Delegate تعیین‌کننده ترتیب عناصر</li>
</ul>
<p>مثال ساده:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] numbers = { <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> };
Array.Sort(numbers);  <span class="hljs-comment">// آرایه حالا { 1, 2, 3 }</span>
</code></pre>
<p>متدهای <strong>جفت آرایه‌ای</strong>، عناصر هر دو آرایه را <strong>به‌صورت هم‌زمان مرتب</strong> می‌کنند و ترتیب را براساس آرایه اول اعمال می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] numbers = { <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> };
<span class="hljs-built_in">string</span>[] words = { <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;one&quot;</span> };
Array.Sort(numbers, words);
<span class="hljs-comment">// numbers → { 1, 2, 3 }</span>
<span class="hljs-comment">// words   → { &quot;one&quot;, &quot;two&quot;, &quot;three&quot; }</span>
</code></pre>
<blockquote>
<p>⚠️ نکته: <code>Array.Sort</code> نیاز دارد که عناصر آرایه <code>IComparable</code> را پیاده‌سازی کنند. اگر عناصر قابل مقایسه ذاتی نباشند یا بخواهید ترتیب پیش‌فرض را تغییر دهید، باید <strong>Comparison سفارشی</strong> یا شیء <code>IComparer&lt;T&gt;</code> ارائه دهید.</p>
</blockquote>
<p>مثال با <strong>Comparison Delegate</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Comparison</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T x, T y</span>)</span>;
</code></pre>
<ul>
<li>اگر <code>x</code> قبل از <code>y</code> باشد → عدد منفی بازمی‌گرداند</li>
<li>اگر <code>x</code> بعد از <code>y</code> باشد → عدد مثبت بازمی‌گرداند</li>
<li>اگر برابر باشند → <code>0</code> بازمی‌گرداند</li>
</ul>
<p>مثال عملی:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] numbers = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
Array.Sort(numbers, (x, y) =&gt; x % <span class="hljs-number">2</span> == y % <span class="hljs-number">2</span> ? <span class="hljs-number">0</span> : x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>);
<span class="hljs-comment">// numbers → { 1, 3, 5, 2, 4 }</span>
</code></pre>
<ul>
<li>به جای <code>Array.Sort</code> می‌توانید از <strong>LINQ</strong> و متدهای <code>OrderBy</code> و <code>ThenBy</code> استفاده کنید.<br>
این روش <strong>آرایه اصلی را تغییر نمی‌دهد</strong> و خروجی را به صورت یک <code>IEnumerable&lt;T&gt;</code> مرتب‌شده ارائه می‌دهد.</li>
</ul>
<hr>
<h3>معکوس کردن عناصر 🔄</h3>
<p>کلاس <code>Array</code> متدهایی برای معکوس کردن تمام یا بخشی از آرایه ارائه می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span>(<span class="hljs-params">Array array</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span>(<span class="hljs-params">Array array, <span class="hljs-built_in">int</span> index, <span class="hljs-built_in">int</span> length</span>)</span>;
</code></pre>
<hr>
<h3>کپی کردن آرایه 📋</h3>
<p>کلاس <code>Array</code> چهار روش برای <strong>کپی سطحی</strong> دارد: <code>Clone</code>، <code>CopyTo</code>، <code>Copy</code> و <code>ConstrainedCopy</code></p>
<ul>
<li>
<p><code>Clone</code> و <code>CopyTo</code> → <strong>متدهای نمونه‌ای</strong></p>
</li>
<li>
<p><code>Copy</code> و <code>ConstrainedCopy</code> → <strong>متدهای استاتیک</strong></p>
</li>
<li>
<p><code>Clone</code> → آرایه جدید (سطحی) بازمی‌گرداند</p>
</li>
<li>
<p><code>CopyTo</code> و <code>Copy</code> → بخش متوالی از آرایه را کپی می‌کنند</p>
<ul>
<li>برای آرایه‌های چندبعدی، باید <strong>ایندکس چندبعدی را به ایندکس خطی</strong> تبدیل کنید</li>
<li>مثال: خانه وسط <code>[1,1]</code> در آرایه 3×3 → <code>1 * 3 + 1 = 4</code></li>
<li>محدوده‌های منبع و مقصد می‌توانند <strong>همپوشانی داشته باشند</strong> بدون مشکل</li>
</ul>
</li>
<li>
<p><code>ConstrainedCopy</code> → عملیات <strong>اتمی</strong>؛ اگر همه عناصر نتوانند کپی شوند، عملیات بازگردانده می‌شود</p>
</li>
<li>
<p><code>AsReadOnly</code> → <strong>Wrapper</strong> بازمی‌گرداند که از تغییر عناصر جلوگیری می‌کند</p>
</li>
</ul>
<h3>تبدیل و تغییر اندازه آرایه 🔄📏</h3>
<p>کلاس <code>Array</code> متدهایی برای <strong>تبدیل عناصر آرایه</strong> و <strong>تغییر اندازه آرایه</strong> ارائه می‌دهد:</p>
<ul>
<li><code>Array.ConvertAll</code> → یک آرایه جدید از نوع <code>TOutput</code> ایجاد می‌کند و عناصر را با استفاده از <strong>Delegate تبدیل‌کننده</strong> کپی می‌کند.<br>
تعریف Delegate به شکل زیر است:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TOutput <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">TInput</span>, <span class="hljs-title">TOutput</span>&gt;(<span class="hljs-params">TInput input</span>)</span>;
</code></pre>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">float</span>[] reals = { <span class="hljs-number">1.3f</span>, <span class="hljs-number">1.5f</span>, <span class="hljs-number">1.8f</span> };
<span class="hljs-built_in">int</span>[] wholes = Array.ConvertAll(reals, r =&gt; Convert.ToInt32(r));
<span class="hljs-comment">// wholes → { 1, 2, 2 }</span>
</code></pre>
<ul>
<li><code>Array.Resize</code> → با ایجاد آرایه جدید و کپی عناصر، آرایه را تغییر اندازه می‌دهد و نتیجه را از طریق پارامتر مرجع بازمی‌گرداند.<br>
⚠️ توجه: سایر مراجع به آرایه اصلی <strong>تغییری نمی‌کنند</strong>.</li>
</ul>
<blockquote>
<p>فضای نام <code>System.Linq</code> هم تعداد زیادی <strong>Extension Method</strong> برای تبدیل آرایه ارائه می‌دهد که خروجی آن <code>IEnumerable&lt;T&gt;</code> است و می‌توان دوباره با <code>ToArray</code> به آرایه تبدیل کرد.</p>
</blockquote>
<hr>
<h3>لیست‌ها، صف‌ها، پشته‌ها و مجموعه‌ها 📚🛒</h3>
<p>.NET مجموعه‌ای از کلاس‌های <strong>مجموعه‌ای آماده</strong> ارائه می‌دهد که رابط‌های معرفی‌شده در این فصل را پیاده‌سازی می‌کنند.<br>
این بخش روی <strong>مجموعه‌های شبیه لیست</strong> تمرکز دارد و نه مجموعه‌های دیکشنری، که بعداً در فصل «Dictionaries» بررسی می‌کنیم.</p>
<ul>
<li>برای اکثر کلاس‌ها، می‌توانید نسخه <strong>Generic</strong> یا <strong>Non-Generic</strong> را انتخاب کنید.</li>
<li>کلاس‌های Generic از نظر <strong>انعطاف‌پذیری و عملکرد</strong> بهترند و نسخه غیرجنریک معمولاً فقط برای <strong>سازگاری با نسخه‌های قدیمی</strong> لازم است.</li>
<li>از بین این کلاس‌ها، <code>List&lt;T&gt;</code> پرکاربردترین است.</li>
</ul>
<hr>
<h3>کلاس‌های List<T> و ArrayList 📝</h3>
<ul>
<li>کلاس Generic <code>List&lt;T&gt;</code> و Non-Generic <code>ArrayList</code> آرایه‌ای <strong>پویا</strong> از اشیاء فراهم می‌کنند.</li>
<li><code>ArrayList</code> → پیاده‌سازی <code>IList</code></li>
<li><code>List&lt;T&gt;</code> → پیاده‌سازی <code>IList</code> و <code>IList&lt;T&gt;</code> (و نسخه فقط خواندنی <code>IReadOnlyList&lt;T&gt;</code>)</li>
</ul>
<blockquote>
<p>تفاوت با آرایه‌ها: تمام این رابط‌ها <strong>عمومی پیاده‌سازی</strong> شده‌اند و متدهایی مانند <code>Add</code> و <code>Remove</code> <strong>مستقیماً قابل استفاده</strong> هستند.</p>
</blockquote>
<h4>جزئیات داخلی</h4>
<ul>
<li><code>List&lt;T&gt;</code> و <code>ArrayList</code> یک <strong>آرایه داخلی</strong> دارند که هنگام پر شدن، جایگزین با آرایه بزرگ‌تر می‌شود.</li>
<li>افزودن عنصر → سریع (معمولاً جای خالی در انتها وجود دارد)</li>
<li>درج عنصر → کند (چون همه عناصر بعد از نقطه درج باید جابجا شوند)</li>
<li>حذف عنصر → کند، به‌خصوص در ابتدای آرایه</li>
<li>جستجو → سریع با <code>BinarySearch</code>، در غیر این صورت کند (چون باید همه عناصر بررسی شوند)</li>
</ul>
<blockquote>
<p>اگر <code>T</code> یک نوع مقدار (Value Type) باشد، <code>List&lt;T&gt;</code> چندین برابر سریع‌تر از <code>ArrayList</code> است، چون از <strong>Boxing/Unboxing</strong> جلوگیری می‌کند.</p>
</blockquote>
<hr>
<h3>سازنده‌ها و متدهای مهم <code>List&lt;T&gt;</code> ⚙️</h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IList</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">IReadOnlyList</span>&lt;<span class="hljs-title">T</span>&gt;</span>
{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>()</span>;                          <span class="hljs-comment">// آرایه خالی</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>(<span class="hljs-params">IEnumerable&lt;T&gt; collection</span>)</span>; <span class="hljs-comment">// کپی از مجموعه موجود</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> capacity</span>)</span>;               <span class="hljs-comment">// مشخص کردن ظرفیت اولیه</span>

  <span class="hljs-comment">// افزودن و درج</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddRange</span>(<span class="hljs-params">IEnumerable&lt;T&gt; collection</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, T item</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertRange</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, IEnumerable&lt;T&gt; collection</span>)</span>;

  <span class="hljs-comment">// حذف</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">T item</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveAt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveRange</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, <span class="hljs-built_in">int</span> count</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">RemoveAll</span>(<span class="hljs-params">Predicate&lt;T&gt; match</span>)</span>;

  <span class="hljs-comment">// دسترسی با ایندکس</span>
  <span class="hljs-keyword">public</span> T <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">GetRange</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, <span class="hljs-built_in">int</span> count</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Enumerator</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">GetEnumerator</span>()</span>;

  <span class="hljs-comment">// کپی و تبدیل</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> T[] <span class="hljs-title">ToArray</span>()</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CopyTo</span>(<span class="hljs-params">T[] array</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CopyTo</span>(<span class="hljs-params">T[] array, <span class="hljs-built_in">int</span> arrayIndex</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CopyTo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, T[] array, <span class="hljs-built_in">int</span> arrayIndex, <span class="hljs-built_in">int</span> count</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadOnlyCollection</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">AsReadOnly</span>()</span>;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">TOutput</span>&gt; <span class="hljs-title">ConvertAll</span>&lt;<span class="hljs-title">TOutput</span>&gt;(<span class="hljs-params">Converter&lt;T,TOutput&gt; converter</span>)</span>;

  <span class="hljs-comment">// سایر متدها</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reverse</span>()</span>;      <span class="hljs-comment">// معکوس کردن ترتیب عناصر</span>
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Capacity { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }  <span class="hljs-comment">// گسترش آرایه داخلی</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TrimExcess</span>()</span>;   <span class="hljs-comment">// کاهش آرایه داخلی به اندازه واقعی</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span>;        <span class="hljs-comment">// حذف تمام عناصر، Count=0</span>
}
</code></pre>
<ul>
<li><code>List&lt;T&gt;</code> همچنین <strong>نسخه‌های نمونه‌ای تمام متدهای جستجو و مرتب‌سازی آرایه</strong> را دارد.</li>
</ul>
<hr>
<h3>مثال عملی با List<T> 🎯</h3>
<pre class="hljs"><code><span class="hljs-keyword">var</span> words = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();          <span class="hljs-comment">// لیست رشته‌ای</span>
words.Add(<span class="hljs-string">&quot;melon&quot;</span>);
words.Add(<span class="hljs-string">&quot;avocado&quot;</span>);
words.AddRange([<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;plum&quot;</span>]);
words.Insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;lemon&quot;</span>);                <span class="hljs-comment">// درج در ابتدا</span>
words.InsertRange(<span class="hljs-number">0</span>, [<span class="hljs-string">&quot;peach&quot;</span>, <span class="hljs-string">&quot;nashi&quot;</span>]); <span class="hljs-comment">// درج چندگانه در ابتدا</span>
words.Remove(<span class="hljs-string">&quot;melon&quot;</span>);
words.RemoveAt(<span class="hljs-number">3</span>);                        <span class="hljs-comment">// حذف عنصر چهارم</span>
words.RemoveRange(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);                  <span class="hljs-comment">// حذف دو عنصر اول</span>
words.RemoveAll(s =&gt; s.StartsWith(<span class="hljs-string">&quot;n&quot;</span>)); <span class="hljs-comment">// حذف تمام رشته‌ها با شروع &#x27;n&#x27;</span>

Console.WriteLine(words[<span class="hljs-number">0</span>]);              <span class="hljs-comment">// اولین عنصر</span>
Console.WriteLine(words[words.Count<span class="hljs-number">-1</span>]);  <span class="hljs-comment">// آخرین عنصر</span>
<span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">string</span> s <span class="hljs-keyword">in</span> words) Console.WriteLine(s); <span class="hljs-comment">// تمام عناصر</span>

List&lt;<span class="hljs-built_in">string</span>&gt; subset = words.GetRange(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);      <span class="hljs-comment">// از دوم تا سوم</span>
<span class="hljs-built_in">string</span>[] wordsArray = words.ToArray();          <span class="hljs-comment">// تبدیل به آرایه</span>
<span class="hljs-built_in">string</span>[] existing = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">1000</span>];
words.CopyTo(<span class="hljs-number">0</span>, existing, <span class="hljs-number">998</span>, <span class="hljs-number">2</span>);             <span class="hljs-comment">// کپی دو عنصر اول به آرایه موجود</span>
List&lt;<span class="hljs-built_in">string</span>&gt; upperCaseWords = words.ConvertAll(s =&gt; s.ToUpper());
List&lt;<span class="hljs-built_in">int</span>&gt; lengths = words.ConvertAll(s =&gt; s.Length);
</code></pre>
<hr>
<h3>تفاوت با ArrayList ⚠️</h3>
<pre class="hljs"><code>ArrayList al = <span class="hljs-keyword">new</span> ArrayList();
al.Add(<span class="hljs-string">&quot;hello&quot;</span>);
<span class="hljs-built_in">string</span> first = (<span class="hljs-built_in">string</span>)al[<span class="hljs-number">0</span>];              <span class="hljs-comment">// نیاز به cast</span>
<span class="hljs-built_in">string</span>[] strArr = (<span class="hljs-built_in">string</span>[])al.ToArray(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>));
</code></pre>
<ul>
<li>چنین castهایی توسط کامپایلر <strong>چک نمی‌شوند</strong> و ممکن است در زمان اجرا خطا بدهند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">int</span> first = (<span class="hljs-built_in">int</span>)al[<span class="hljs-number">0</span>]; <span class="hljs-comment">// Exception در زمان اجرا</span>
</code></pre>
<ul>
<li><code>ArrayList</code> مشابه <code>List&lt;object&gt;</code> عمل می‌کند و برای <strong>لیست‌های چند نوعی</strong> مناسب است.</li>
<li>مزیت انتخاب <code>ArrayList</code> در این حالت: <strong>سهولت استفاده با Reflection</strong> نسبت به <code>List&lt;object&gt;</code></li>
</ul>
<blockquote>
<p>اگر <code>System.Linq</code> را وارد کنید، می‌توانید یک <code>ArrayList</code> را به یک <code>List&lt;T&gt;</code> جنریک تبدیل کنید:</p>
</blockquote>
<pre class="hljs"><code>ArrayList al = <span class="hljs-keyword">new</span> ArrayList();
al.AddRange(<span class="hljs-keyword">new</span>[] { <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span> });
List&lt;<span class="hljs-built_in">int</span>&gt; list = al.Cast&lt;<span class="hljs-built_in">int</span>&gt;().ToList();
</code></pre>
<ul>
<li><code>Cast</code> و <code>ToList</code> متدهای <strong>Extension</strong> در <code>System.Linq.Enumerable</code> هستند.</li>
</ul>
<h3>LinkedList<T> 🔗</h3>
<p><code>LinkedList&lt;T&gt;</code> یک <strong>لیست پیوندی دوطرفه (doubly linked list)</strong> جنریک است.</p>
<h4>ساختار</h4>
<ul>
<li>
<p>شامل <strong>گره‌ها (nodes)</strong> است که هر گره شامل سه چیز است:</p>
<ol>
<li><strong>مقدار (Value)</strong></li>
<li><strong>ارجاع به گره قبلی (Previous)</strong></li>
<li><strong>ارجاع به گره بعدی (Next)</strong></li>
</ol>
</li>
</ul>
<blockquote>
<p>شکل ساده:</p>
</blockquote>
<pre class="hljs"><code>null &lt;- [Node1] &lt;-&gt; [Node2] &lt;-&gt; [Node3] -&gt; null
</code></pre>
<h4>مزیت اصلی</h4>
<ul>
<li>درج عنصر در هر نقطه از لیست <strong>بسیار سریع و کارآمد</strong> است، زیرا فقط کافیست یک گره جدید بسازید و چند ارجاع را به‌روزرسانی کنید.</li>
</ul>
<h4>محدودیت</h4>
<ul>
<li><strong>دسترسی مستقیم با ایندکس وجود ندارد</strong>.</li>
<li>برای یافتن مکان درج یا جستجوی یک عنصر، باید از ابتدا یا انتهای لیست پیمایش کنید.</li>
<li><strong>جستجوی باینری یا دسترسی تصادفی به عناصر امکان‌پذیر نیست</strong>.</li>
</ul>
<blockquote>
<p>بنابراین <code>LinkedList&lt;T&gt;</code> زمانی مناسب است که <strong>عملیات درج و حذف در میانه لیست</strong> زیاد انجام می‌شود و نیاز به <strong>دسترسی مستقیم به عناصر کمتر</strong> است.</p>
</blockquote>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-5.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>LinkedList<T> 🔗 – ادامه</h3>
<p><code>LinkedList&lt;T&gt;</code> پیاده‌سازی می‌شود از <strong>IEnumerable<T> و ICollection<T></strong> (و نسخه‌های غیرجنریک آن‌ها) اما <strong>IList<T> پیاده‌سازی نمی‌شود</strong>، چون <strong>دسترسی بر اساس ایندکس پشتیبانی نمی‌شود</strong>.</p>
<h4>گره‌ها</h4>
<p>گره‌های لیست با کلاس زیر پیاده‌سازی می‌شوند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListNode</span>&lt;<span class="hljs-title">T</span>&gt;
{
  <span class="hljs-keyword">public</span> LinkedList&lt;T&gt; List { <span class="hljs-keyword">get</span>; }      <span class="hljs-comment">// ارجاع به لیست والد</span>
  <span class="hljs-keyword">public</span> LinkedListNode&lt;T&gt; Next { <span class="hljs-keyword">get</span>; }  <span class="hljs-comment">// گره بعدی</span>
  <span class="hljs-keyword">public</span> LinkedListNode&lt;T&gt; Previous { <span class="hljs-keyword">get</span>; } <span class="hljs-comment">// گره قبلی</span>
  <span class="hljs-keyword">public</span> T Value { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }            <span class="hljs-comment">// مقدار ذخیره‌شده</span>
}
</code></pre>
<h4>افزودن گره‌ها</h4>
<p>می‌توانید موقعیت گره جدید را <strong>نسبت به گره‌ای دیگر</strong> یا <strong>در ابتدای/انتهای لیست</strong> مشخص کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddFirst</span>(<span class="hljs-params">LinkedListNode&lt;T&gt; node</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> LinkedListNode&lt;T&gt; <span class="hljs-title">AddFirst</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddLast</span>(<span class="hljs-params">LinkedListNode&lt;T&gt; node</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> LinkedListNode&lt;T&gt; <span class="hljs-title">AddLast</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddAfter</span>(<span class="hljs-params">LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> LinkedListNode&lt;T&gt; <span class="hljs-title">AddAfter</span>(<span class="hljs-params">LinkedListNode&lt;T&gt; node, T <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddBefore</span>(<span class="hljs-params">LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> LinkedListNode&lt;T&gt; <span class="hljs-title">AddBefore</span>(<span class="hljs-params">LinkedListNode&lt;T&gt; node, T <span class="hljs-keyword">value</span></span>)</span>;
</code></pre>
<h4>حذف گره‌ها</h4>
<p>متدهای مشابه برای حذف عناصر وجود دارد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveFirst</span>()</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveLast</span>()</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">LinkedListNode&lt;T&gt; node</span>)</span>;
</code></pre>
<h4>خواص عمومی</h4>
<p>لیست داخلی LinkedList<T> شامل <strong>تعداد عناصر</strong> و <strong>سر و ته لیست</strong> است و با خواص زیر در دسترس قرار دارد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count { <span class="hljs-keyword">get</span>; }                     <span class="hljs-comment">// سریع</span>
<span class="hljs-keyword">public</span> LinkedListNode&lt;T&gt; First { <span class="hljs-keyword">get</span>; }       <span class="hljs-comment">// سریع</span>
<span class="hljs-keyword">public</span> LinkedListNode&lt;T&gt; Last { <span class="hljs-keyword">get</span>; }        <span class="hljs-comment">// سریع</span>
</code></pre>
<h4>جستجو</h4>
<p>LinkedList<T> متدهای جستجوی زیر را ارائه می‌دهد (با پیمایش داخلی لیست):</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Contains</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> LinkedListNode&lt;T&gt; <span class="hljs-title">Find</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> LinkedListNode&lt;T&gt; <span class="hljs-title">FindLast</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;
</code></pre>
<h4>کپی و پیمایش</h4>
<p>برای پردازش ایندکس‌بندی‌شده و استفاده از <code>foreach</code>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CopyTo</span>(<span class="hljs-params">T[] array, <span class="hljs-built_in">int</span> index</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> Enumerator&lt;T&gt; <span class="hljs-title">GetEnumerator</span>()</span>;
</code></pre>
<h4>مثال عملی</h4>
<pre class="hljs"><code><span class="hljs-keyword">var</span> tune = <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-built_in">string</span>&gt;();
tune.AddFirst(<span class="hljs-string">&quot;do&quot;</span>);                            <span class="hljs-comment">// do</span>
tune.AddLast(<span class="hljs-string">&quot;so&quot;</span>);                             <span class="hljs-comment">// do - so</span>
tune.AddAfter(tune.First, <span class="hljs-string">&quot;re&quot;</span>);                <span class="hljs-comment">// do - re - so</span>
tune.AddAfter(tune.First.Next, <span class="hljs-string">&quot;mi&quot;</span>);           <span class="hljs-comment">// do - re - mi - so</span>
tune.AddBefore(tune.Last, <span class="hljs-string">&quot;fa&quot;</span>);                <span class="hljs-comment">// do - re - mi - fa - so</span>
tune.RemoveFirst();                             <span class="hljs-comment">// re - mi - fa - so</span>
tune.RemoveLast();                              <span class="hljs-comment">// re - mi - fa</span>
LinkedListNode&lt;<span class="hljs-built_in">string</span>&gt; miNode = tune.Find(<span class="hljs-string">&quot;mi&quot;</span>);
tune.Remove(miNode);                            <span class="hljs-comment">// re - fa</span>
tune.AddFirst(miNode);                          <span class="hljs-comment">// mi - re - fa</span>

<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> s <span class="hljs-keyword">in</span> tune) 
    Console.WriteLine(s);
</code></pre>
<blockquote>
<p>این مثال نشان می‌دهد چگونه می‌توان عناصر را اضافه، حذف و جستجو کرد و از پیمایش foreach برای چاپ استفاده کرد.</p>
</blockquote>
<h3>Queue<T> و Stack<T> ⏳📚</h3>
<h4>Queue<T> – صف (FIFO)</h4>
<p><code>Queue&lt;T&gt;</code> و نسخه غیرجنریک <code>Queue</code> پیاده‌سازی می‌شوند از <strong>Enumerable و ICollection</strong> و نماینده یک ساختار داده <strong>First-In-First-Out (FIFO)</strong> هستند:</p>
<ul>
<li><strong>Enqueue(T item)</strong> → اضافه کردن به انتهای صف</li>
<li><strong>Dequeue()</strong> → حذف و بازگرداندن عنصر از ابتدای صف</li>
<li><strong>Peek()</strong> → مشاهده عنصر ابتدای صف بدون حذف آن</li>
<li><strong>Count</strong> → تعداد عناصر موجود</li>
<li><strong>ToArray()</strong> → کپی عناصر به یک آرایه برای دسترسی تصادفی</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> q = <span class="hljs-keyword">new</span> Queue&lt;<span class="hljs-built_in">int</span>&gt;();
q.Enqueue(<span class="hljs-number">10</span>);
q.Enqueue(<span class="hljs-number">20</span>);
<span class="hljs-built_in">int</span>[] data = q.ToArray();       <span class="hljs-comment">// کپی به آرایه</span>
Console.WriteLine(q.Count);     <span class="hljs-comment">// 2</span>
Console.WriteLine(q.Peek());    <span class="hljs-comment">// 10</span>
Console.WriteLine(q.Dequeue()); <span class="hljs-comment">// 10</span>
Console.WriteLine(q.Dequeue()); <span class="hljs-comment">// 20</span>
Console.WriteLine(q.Dequeue()); <span class="hljs-comment">// Exception (صف خالی)</span>
</code></pre>
<blockquote>
<p>صف‌ها معمولاً با آرایه داخلی پیاده‌سازی می‌شوند و اندیس‌های سر و ته صف باعث سریع بودن عملیات Enqueue/Dequeue می‌شوند.</p>
</blockquote>
<hr>
<h4>Stack<T> – پشته (LIFO)</h4>
<p><code>Stack&lt;T&gt;</code> و نسخه غیرجنریک <code>Stack</code> نماینده یک ساختار داده <strong>Last-In-First-Out (LIFO)</strong> هستند:</p>
<ul>
<li><strong>Push(T item)</strong> → افزودن به بالای پشته</li>
<li><strong>Pop()</strong> → حذف و بازگرداندن عنصر از بالای پشته</li>
<li><strong>Peek()</strong> → مشاهده عنصر بالای پشته بدون حذف آن</li>
<li><strong>Count</strong> → تعداد عناصر</li>
<li><strong>ToArray()</strong> → کپی عناصر برای دسترسی تصادفی</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">int</span>&gt;();
s.Push(<span class="hljs-number">1</span>);                      <span class="hljs-comment">// Stack = 1</span>
s.Push(<span class="hljs-number">2</span>);                      <span class="hljs-comment">// Stack = 1,2</span>
s.Push(<span class="hljs-number">3</span>);                      <span class="hljs-comment">// Stack = 1,2,3</span>
Console.WriteLine(s.Count);     <span class="hljs-comment">// 3</span>
Console.WriteLine(s.Peek());    <span class="hljs-comment">// 3</span>
Console.WriteLine(s.Pop());     <span class="hljs-comment">// 3</span>
Console.WriteLine(s.Pop());     <span class="hljs-comment">// 2</span>
Console.WriteLine(s.Pop());     <span class="hljs-comment">// 1</span>
Console.WriteLine(s.Pop());     <span class="hljs-comment">// Exception</span>
</code></pre>
<blockquote>
<p>پشته‌ها هم مشابه صف‌ها با آرایه داخلی پیاده‌سازی می‌شوند و در صورت نیاز به تغییر اندازه، آرایه داخلی بزرگ‌تر جایگزین می‌شود.</p>
</blockquote>
<hr>
<h4>BitArray – آرایه بیت 🟢⚫</h4>
<p><code>BitArray</code> یک <strong>مجموعه دینامیک از مقادیر bool</strong> است که <strong>هر عنصر فقط یک بیت حافظه اشغال می‌کند</strong> و نسبت به آرایه معمولی bool یا List<bool> بسیار حافظه‌کارآمد است.</p>
<ul>
<li>دسترسی به بیت‌ها با <strong>Indexer</strong>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> bits = <span class="hljs-keyword">new</span> BitArray(<span class="hljs-number">2</span>);
bits[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;
</code></pre>
<ul>
<li>عملیات‌های بیت به بیت: <strong>And, Or, Xor, Not</strong></li>
</ul>
<pre class="hljs"><code>bits.Xor(bits);               <span class="hljs-comment">// XOR بیت‌ها با خودشان</span>
Console.WriteLine(bits[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// False</span>
</code></pre>
<blockquote>
<p>BitArray برای ذخیره و پردازش مجموعه‌های بزرگ بیتی بسیار مناسب است.</p>
</blockquote>
<h3>HashSet<T> و SortedSet<T> 🔹🔸</h3>
<h4>ویژگی‌های مشترک</h4>
<p><code>HashSet&lt;T&gt;</code> و <code>SortedSet&lt;T&gt;</code> مجموعه‌هایی از عناصر یکتا هستند که چند ویژگی مهم دارند:</p>
<ul>
<li><strong>Contains</strong> بسیار سریع با استفاده از <strong>hash lookup</strong> اجرا می‌شود.</li>
<li><strong>عناصر تکراری ذخیره نمی‌شوند</strong> و اضافه کردن تکراری نادیده گرفته می‌شود.</li>
<li><strong>دسترسی به عنصر با موقعیت (index) امکان‌پذیر نیست.</strong></li>
</ul>
<h4>تفاوت اصلی</h4>
<ul>
<li><code>SortedSet&lt;T&gt;</code> عناصر را مرتب نگه می‌دارد.</li>
<li><code>HashSet&lt;T&gt;</code> ترتیب عناصر را حفظ نمی‌کند.</li>
</ul>
<p>هر دو پیاده‌سازی <code>ISet&lt;T&gt;</code>, <code>ICollection&lt;T&gt;</code> و از .NET 5 به بعد <code>IReadOnlySet&lt;T&gt;</code> را دارند.</p>
<ul>
<li><code>HashSet&lt;T&gt;</code> → با <strong>Hashtable</strong> پیاده‌سازی می‌شود.</li>
<li><code>SortedSet&lt;T&gt;</code> → با <strong>Red-Black Tree</strong> پیاده‌سازی می‌شود.</li>
</ul>
<p>متدهای پایه شامل <code>Contains</code>, <code>Add</code>, <code>Remove</code> و <code>RemoveWhere</code> هستند.</p>
<hr>
<h4>مثال HashSet<T></h4>
<pre class="hljs"><code><span class="hljs-keyword">var</span> letters = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">char</span>&gt;(<span class="hljs-string">&quot;the quick brown fox&quot;</span>);
Console.WriteLine(letters.Contains(<span class="hljs-string">&#x27;t&#x27;</span>)); <span class="hljs-comment">// true</span>
Console.WriteLine(letters.Contains(<span class="hljs-string">&#x27;j&#x27;</span>)); <span class="hljs-comment">// false</span>

<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> letters)
    Console.Write(c); <span class="hljs-comment">// عناصر بدون تکرار: the quickbrownfx</span>
</code></pre>
<hr>
<h4>عملیات مجموعه‌ای (Set Operations)</h4>
<p><strong>تغییر دهنده مجموعه (Destructive):</strong></p>
<ul>
<li><code>UnionWith(IEnumerable&lt;T&gt; other)</code> → ترکیب</li>
<li><code>IntersectWith(IEnumerable&lt;T&gt; other)</code> → اشتراک</li>
<li><code>ExceptWith(IEnumerable&lt;T&gt; other)</code> → حذف عناصر مشخص</li>
<li><code>SymmetricExceptWith(IEnumerable&lt;T&gt; other)</code> → فقط عناصر یکتا در یکی از مجموعه‌ها</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> letters = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">char</span>&gt;(<span class="hljs-string">&quot;the quick brown fox&quot;</span>);
letters.IntersectWith(<span class="hljs-string">&quot;aeiou&quot;</span>); <span class="hljs-comment">// فقط حروف صدادار</span>
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> letters) Console.Write(c); <span class="hljs-comment">// euio</span>
</code></pre>
<ul>
<li>روش‌های <strong>غیرتغییری (Non-destructive)</strong> برای بررسی مجموعه:<br>
<code>IsSubsetOf</code>, <code>IsProperSubsetOf</code>, <code>IsSupersetOf</code>, <code>IsProperSupersetOf</code>, <code>Overlaps</code>, <code>SetEquals</code></li>
</ul>
<hr>
<h4>SortedSet<T> ویژگی‌های اضافه</h4>
<ul>
<li><code>GetViewBetween(T lowerValue, T upperValue)</code> → بازه از عناصر</li>
<li><code>Reverse()</code> → بازگرداندن ترتیب معکوس</li>
<li><code>Min</code> و <code>Max</code> → کوچک‌ترین و بزرگ‌ترین عنصر</li>
<li>پذیرش <code>IComparer&lt;T&gt;</code> در سازنده برای سفارشی‌سازی ترتیب</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> letters = <span class="hljs-keyword">new</span> SortedSet&lt;<span class="hljs-built_in">char</span>&gt;(<span class="hljs-string">&quot;the quick brown fox&quot;</span>);
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> letters) Console.Write(c); <span class="hljs-comment">// bcefhiknoqrtuwx</span>
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> letters.GetViewBetween(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>))
    Console.Write(c); <span class="hljs-comment">// fhi</span>
</code></pre>
<hr>
<h3>نکته مهم</h3>
<ul>
<li>هر دو مجموعه قابل تکرار (<code>IEnumerable&lt;T&gt;</code>) هستند، بنابراین می‌توان هر نوع مجموعه یا لیست را به عنوان آرگومان در عملیات مجموعه‌ای استفاده کرد.</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-6.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>در <strong>نماد Big-O</strong>، زمان بازیابی (retrieval) بر اساس کلید برای انواع دیکشنری‌ها به شرح زیر است:</p>
<table>
<thead>
<tr>
<th>ساختار داده</th>
<th>زمان بازیابی (Big-O)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Hashtable</strong>, <strong>Dictionary</strong>, <strong>OrderedDictionary</strong></td>
<td>O(1) → تقریباً فوری</td>
</tr>
<tr>
<td><strong>SortedDictionary</strong>, <strong>SortedList</strong></td>
<td>O(log n) → لگاریتمی</td>
</tr>
<tr>
<td><strong>ListDictionary</strong> و انواع غیر دیکشنری مانند <strong>List<T></strong></td>
<td>O(n) → خطی، یعنی باید همه عناصر را بررسی کرد</td>
</tr>
</tbody>
</table>
<p><strong>توضیح:</strong></p>
<ul>
<li><code>n</code> تعداد عناصر موجود در مجموعه است.</li>
<li>دیکشنری‌های مبتنی بر هش (Hashtable, Dictionary) تقریباً ثابت هستند چون از hashing برای یافتن کلید استفاده می‌کنند.</li>
<li>دیکشنری‌های مرتب (SortedDictionary/SortedList) از درخت یا ساختار مرتب استفاده می‌کنند، بنابراین جستجو لگاریتمی است.</li>
<li>لیست‌های ساده یا ListDictionary باید عنصر به عنصر جستجو کنند، بنابراین زمان بازیابی خطی است.</li>
</ul>
<p>در این بخش، توضیح داده شده که <strong>IDictionary&lt;TKey, TValue&gt;</strong> و نسخه‌ی غیرجنریک آن <strong>IDictionary</strong> چگونه کار می‌کنند و کلاس‌های معمولی مانند <strong>Dictionary&lt;TKey, TValue&gt;</strong> و <strong>Hashtable</strong> از چه مکانیسمی استفاده می‌کنند. در ادامه خلاصه و نکات مهم آورده شده است:</p>
<hr>
<h3>۱. رابط IDictionary&lt;TKey,TValue&gt;</h3>
<p>رابط <strong>IDictionary&lt;TKey,TValue&gt;</strong> استانداردی برای مجموعه‌های کلید/مقدار ارائه می‌دهد و امکانات زیر را دارد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDictionary</span>&lt;<span class="hljs-title">TKey</span>, <span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">ICollection</span>&lt;<span class="hljs-title">KeyValuePair</span>&lt;<span class="hljs-title">TKey</span>, <span class="hljs-title">TValue</span>&gt;&gt;, <span class="hljs-title">IEnumerable</span>
{
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">ContainsKey</span>(<span class="hljs-params">TKey key</span>)</span>;
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">TryGetValue</span>(<span class="hljs-params">TKey key, <span class="hljs-keyword">out</span> TValue <span class="hljs-keyword">value</span></span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">TKey key, TValue <span class="hljs-keyword">value</span></span>)</span>;
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">TKey key</span>)</span>;
    TValue <span class="hljs-keyword">this</span>[TKey key] { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } <span class="hljs-comment">// دسترسی به مقدار بر اساس کلید</span>
    ICollection&lt;TKey&gt; Keys { <span class="hljs-keyword">get</span>; }     <span class="hljs-comment">// مجموعه کلیدها</span>
    ICollection&lt;TValue&gt; Values { <span class="hljs-keyword">get</span>; } <span class="hljs-comment">// مجموعه مقادیر</span>
}
</code></pre>
<ul>
<li><strong>Add</strong>: یک عنصر جدید اضافه می‌کند، اگر کلید تکراری باشد، استثناء می‌دهد.</li>
<li><strong>Indexer (<code>this[TKey]</code>)</strong>: اگر کلید موجود نباشد، استثناء پرتاب می‌کند.</li>
<li><strong>TryGetValue</strong>: سعی می‌کند مقدار را دریافت کند، اگر کلید نباشد <code>false</code> برمی‌گرداند.</li>
<li><strong>ContainsKey</strong>: بررسی می‌کند که کلید وجود دارد یا نه.</li>
</ul>
<hr>
<h3>۲. رابط IReadOnlyDictionary&lt;TKey,TValue&gt;</h3>
<ul>
<li>فقط دسترسی خواندنی (Read-Only) به اعضای دیکشنری را ارائه می‌دهد.</li>
</ul>
<hr>
<h3>۳. نسخه غیرجنریک IDictionary</h3>
<ul>
<li>هنگام دسترسی به کلید غیرموجود با <strong>indexer</strong> مقدار <code>null</code> بازمی‌گرداند (به جای استثناء).</li>
<li>از متد <strong>Contains</strong> برای بررسی وجود کلید استفاده می‌کند.</li>
<li>هنگام enumeration، از ساختار <strong>DictionaryEntry</strong> استفاده می‌کند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> DictionaryEntry
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Key { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Value { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<hr>
<h3>۴. Dictionary&lt;TKey,TValue&gt; و Hashtable</h3>
<ul>
<li><strong>Dictionary&lt;TKey,TValue&gt;</strong> کلاس عمومی و پرکاربرد است، مبتنی بر <strong>Hashtable</strong>.</li>
<li>نسخه غیرجنریک آن <strong>Hashtable</strong> است.</li>
<li>کلیدها با استفاده از <strong>GetHashCode</strong> به هش تبدیل می‌شوند و سپس در &quot;bucket&quot; مناسب قرار می‌گیرند.</li>
<li>اگر چند مقدار در یک bucket باشند، جستجو خطی در آن bucket انجام می‌شود.</li>
<li>کلیدها باید قابلیت محاسبه hash و بررسی برابری را داشته باشند.</li>
</ul>
<h4>مثال استفاده از Dictionary&lt;TKey,TValue&gt;</h4>
<pre class="hljs"><code><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">int</span>&gt;();
d.Add(<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-number">1</span>);
d[<span class="hljs-string">&quot;Two&quot;</span>] = <span class="hljs-number">2</span>;     <span class="hljs-comment">// اضافه کردن</span>
d[<span class="hljs-string">&quot;Two&quot;</span>] = <span class="hljs-number">22</span>;    <span class="hljs-comment">// بروزرسانی</span>
Console.WriteLine(d[<span class="hljs-string">&quot;Two&quot;</span>]);               <span class="hljs-comment">// 22</span>
Console.WriteLine(d.ContainsKey(<span class="hljs-string">&quot;One&quot;</span>));   <span class="hljs-comment">// true</span>
<span class="hljs-built_in">int</span> val = <span class="hljs-number">0</span>;
<span class="hljs-keyword">if</span> (!d.TryGetValue(<span class="hljs-string">&quot;onE&quot;</span>, <span class="hljs-keyword">out</span> val))
    Console.WriteLine(<span class="hljs-string">&quot;No val&quot;</span>);           <span class="hljs-comment">// &quot;No val&quot;</span>
</code></pre>
<ul>
<li>کلیدها <strong>تکراری نمی‌توانند باشند</strong>.</li>
<li>عناصر مرتب یا به ترتیب اضافه شدن <strong>ذخیره نمی‌شوند</strong>.</li>
</ul>
<hr>
<h3>۵. نکات عملکردی</h3>
<ul>
<li>استفاده از <strong>StringComparer.OrdinalIgnoreCase</strong> برای کلیدهای رشته‌ای می‌تواند برابری بدون حساسیت به حروف ایجاد کند.</li>
<li>مشخص کردن ظرفیت اولیه دیکشنری می‌تواند از resize داخلی جلوگیری کند و عملکرد را بهتر کند.</li>
</ul>
<h3>🗂️ OrderedDictionary</h3>
<p>یک <strong>OrderedDictionary</strong> یک دیکشنری غیرجنریک است که عناصر را در همان ترتیبی که اضافه شده‌اند نگه می‌دارد. با استفاده از <strong>OrderedDictionary</strong> می‌توانید به عناصر هم از طریق <strong>اندیس (index)</strong> و هم از طریق <strong>کلید (key)</strong> دسترسی داشته باشید.<br>
یک <strong>OrderedDictionary</strong>، دیکشنری مرتب (sorted) نیست.<br>
یک <strong>OrderedDictionary</strong> ترکیبی از <strong>Hashtable</strong> و <strong>ArrayList</strong> است. این یعنی تمام قابلیت‌های <strong>Hashtable</strong> را دارد، به علاوه توابعی مانند <strong>RemoveAt</strong> و یک اندیسری عددی. همچنین ویژگی‌های <strong>Keys</strong> و <strong>Values</strong> را ارائه می‌دهد که عناصر را در ترتیب اصلی‌شان باز می‌گردانند.<br>
این کلاس در <strong>.NET 2.0</strong> معرفی شد؛ اما به‌طور عجیب، نسخه جنریک ندارد.</p>
<hr>
<h3>📋 ListDictionary و HybridDictionary</h3>
<p><strong>ListDictionary</strong> از یک <strong>لیست پیوندی تک‌جهته (singly linked list)</strong> برای ذخیره داده‌ها استفاده می‌کند. این دیکشنری <strong>مرتب‌سازی</strong> انجام نمی‌دهد، اما ترتیب ورودی اصلی عناصر را حفظ می‌کند.<br>
<strong>ListDictionary</strong> با لیست‌های بزرگ بسیار کند است و تنها مزیت واقعی آن، کارایی بالا با لیست‌های بسیار کوچک (کمتر از ۱۰ عنصر) است.</p>
<p><strong>HybridDictionary</strong> یک <strong>ListDictionary</strong> است که هنگام رسیدن به اندازه خاصی به صورت خودکار به <strong>Hashtable</strong> تبدیل می‌شود تا مشکلات عملکردی <strong>ListDictionary</strong> رفع شود. ایده این است که وقتی دیکشنری کوچک است، مصرف حافظه کم باشد و وقتی دیکشنری بزرگ است، عملکرد مناسب داشته باشد. با این حال، با توجه به سربار تبدیل بین دو حالت—و این واقعیت که <strong>Dictionary</strong> در هر دو حالت سنگین یا کند نیست—استفاده از <strong>Dictionary</strong> از ابتدا هم انتخاب معقولی است.<br>
هر دو کلاس فقط در نسخه غیرجنریک ارائه می‌شوند.</p>
<hr>
<h3>📈 Sorted Dictionaries</h3>
<p><strong>BCL</strong> دات‌نت دو کلاس دیکشنری ارائه می‌دهد که به صورت داخلی همیشه بر اساس <strong>کلید</strong> مرتب هستند:</p>
<ul>
<li><strong>SortedDictionary&lt;TKey,TValue&gt;</strong></li>
<li><strong>SortedList&lt;TKey,TValue&gt;</strong></li>
</ul>
<p>(در این بخش، <code>&lt;TKey,TValue&gt;</code> را به <code>&lt;,&gt;</code> خلاصه می‌کنیم.)</p>
<p><strong>SortedDictionary&lt;,&gt;</strong> از <strong>درخت قرمز/سیاه (red/black tree)</strong> استفاده می‌کند: یک ساختار داده طراحی‌شده برای عملکرد پایدار در هر سناریوی درج یا بازیابی.<br>
<strong>SortedList&lt;,&gt;</strong> به صورت داخلی با یک جفت آرایه مرتب پیاده‌سازی شده است و دسترسی سریع (با جستجوی دودویی) ارائه می‌دهد، اما عملکرد درج ضعیفی دارد (چون مقادیر موجود باید برای اضافه کردن عنصر جدید جابه‌جا شوند).</p>
<p><strong>SortedDictionary&lt;,&gt;</strong> بسیار سریع‌تر از <strong>SortedList&lt;,&gt;</strong> در درج عناصر به صورت تصادفی است (خصوصاً با لیست‌های بزرگ). با این حال، <strong>SortedList&lt;,&gt;</strong> قابلیت اضافه دارد: دسترسی به عناصر هم از طریق <strong>اندیس</strong> و هم از طریق <strong>کلید</strong>. با یک <strong>SortedList</strong> می‌توانید مستقیماً به عنصر nام در ترتیب مرتب‌سازی بروید (از طریق اندیس در ویژگی‌های <strong>Keys/Values</strong>). برای انجام همین کار با <strong>SortedDictionary&lt;,&gt;</strong>، باید به صورت دستی روی n عنصر شمارش کنید. (یا می‌توانید یک کلاس بنویسید که <strong>SortedDictionary</strong> را با یک کلاس لیست ترکیب کند.)</p>
<p>هیچ‌یک از این سه مجموعه اجازه کلیدهای تکراری را نمی‌دهند (همانند همه دیکشنری‌ها).</p>
<p>همچنین یک نسخه غیرجنریک مشابه با عملکرد یکسان به نام <strong>SortedList</strong> وجود دارد.</p>
<hr>
<h3>🔍 مثال استفاده از SortedList</h3>
<p>مثال زیر با استفاده از <strong>reflection</strong>، تمام متدهای تعریف‌شده در <code>System.Object</code> را در یک <strong>SortedList</strong> با کلید نام متد بارگذاری می‌کند و سپس کلیدها و مقادیر آن‌ها را شمارش می‌کند:</p>
<pre class="hljs"><code><span class="hljs-comment">// MethodInfo در فضای نام System.Reflection است</span>
<span class="hljs-keyword">var</span> sorted = <span class="hljs-keyword">new</span> SortedList&lt;<span class="hljs-built_in">string</span>, MethodInfo&gt;();
<span class="hljs-keyword">foreach</span> (<span class="hljs-function">MethodInfo m <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>).<span class="hljs-title">GetMethods</span>())
    sorted[m.Name]</span> = m;

<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> name <span class="hljs-keyword">in</span> sorted.Keys)
    Console.WriteLine(name);

<span class="hljs-keyword">foreach</span> (MethodInfo m <span class="hljs-keyword">in</span> sorted.Values)
    Console.WriteLine(m.Name + <span class="hljs-string">&quot; returns a &quot;</span> + m.ReturnType);
</code></pre>
<p>نتیجه شمارش اول:</p>
<pre class="hljs"><code>Equals
GetHashCode
GetType
ReferenceEquals
ToString
</code></pre>
<p>نتیجه شمارش دوم:</p>
<pre class="hljs"><code>Equals returns a System.Boolean
GetHashCode returns a System.Int32
GetType returns a System.Type
ReferenceEquals returns a System.Boolean
ToString returns a System.String
</code></pre>
<p>توجه کنید که دیکشنری از طریق <strong>اندیسری (indexer)</strong> پر شد. اگر به جای آن از متد <strong>Add</strong> استفاده می‌کردیم، خطا رخ می‌داد چون کلاس <code>object</code> متد <strong>Equals</strong> را overload کرده و نمی‌توان همان کلید را دوبار اضافه کرد. با استفاده از اندیسری، ورودی بعدی جایگزین ورودی قبلی می‌شود و این خطا جلوگیری می‌شود.</p>
<p>همچنین می‌توانید چندین عضو با یک کلید را با تبدیل هر مقدار به یک <strong>لیست</strong> ذخیره کنید:</p>
<pre class="hljs"><code>SortedList&lt;<span class="hljs-built_in">string</span>, List&lt;MethodInfo&gt;&gt;
</code></pre>
<p>در ادامه مثال، بازیابی <code>MethodInfo</code> با کلید <code>&quot;GetHashCode&quot;</code> همانند یک دیکشنری معمولی انجام می‌شود:</p>
<pre class="hljs"><code>Console.WriteLine(sorted[<span class="hljs-string">&quot;GetHashCode&quot;</span>]);  <span class="hljs-comment">// Int32 GetHashCode()</span>
</code></pre>
<p>همه کارهایی که تاکنون انجام داده‌ایم، با <strong>SortedDictionary&lt;,&gt;</strong> نیز قابل اجرا است. اما دو خط زیر، که آخرین کلید و مقدار را بازیابی می‌کنند، فقط با <strong>SortedList</strong> کار می‌کنند:</p>
<pre class="hljs"><code>Console.WriteLine(sorted.Keys[sorted.Count - <span class="hljs-number">1</span>]);           <span class="hljs-comment">// ToString</span>
Console.WriteLine(sorted.Values[sorted.Count - <span class="hljs-number">1</span>].IsVirtual); <span class="hljs-comment">// True</span>
</code></pre>
<h3>🛠️ Collections قابل سفارشی‌سازی و پراکسی‌ها</h3>
<p>کلاس‌های مجموعه‌ای که در بخش‌های قبلی بررسی شد، راحت هستند چون می‌توانید مستقیماً نمونه‌سازی (instantiate) کنید، اما <strong>امکان کنترل رفتار هنگام افزودن یا حذف یک آیتم</strong> را به شما نمی‌دهند. در برنامه‌هایی با مجموعه‌های قوی‌تایپ (strongly typed)، گاهی به این کنترل نیاز دارید؛ برای مثال:</p>
<ul>
<li>🔹 اجرای یک <strong>رویداد (event)</strong> هنگام افزودن یا حذف آیتم</li>
<li>🔹 به‌روزرسانی <strong>ویژگی‌ها (properties)</strong> به خاطر آیتم اضافه یا حذف‌شده</li>
<li>🔹 تشخیص یک <strong>عملیات غیرمجاز افزودن/حذف</strong> و پرتاب استثنا (exception) (مثلاً اگر عملیات قوانین تجاری را نقض کند)</li>
</ul>
<p><strong>.NET BCL</strong> کلاس‌هایی برای این منظور ارائه می‌دهد که در فضای نام <code>System.Collections.ObjectModel</code> قرار دارند. این‌ها در اصل <strong>پراکسی‌ها یا wrapperها</strong> هستند که <code>IList&lt;T&gt;</code> یا <code>IDictionary&lt;,&gt;</code> را پیاده‌سازی می‌کنند و متدها را به یک مجموعه زیرین هدایت می‌کنند. هر عملیات <strong>Add</strong>، <strong>Remove</strong> یا <strong>Clear</strong> از طریق یک متد مجازی (virtual) هدایت می‌شود که هنگام override شدن به عنوان یک “درگاه” عمل می‌کند.</p>
<p>کلاس‌های مجموعه قابل سفارشی‌سازی معمولاً برای <strong>مجموعه‌های عمومی (publicly exposed)</strong> استفاده می‌شوند؛ مثلاً یک مجموعه از کنترل‌ها که به صورت عمومی در یک کلاس <code>System.Windows.Form</code> در دسترس است.</p>
<hr>
<h3>📦 Collection<T> و CollectionBase</h3>
<p>کلاس <strong>Collection<T></strong> یک <strong>wrapper قابل سفارشی‌سازی</strong> برای <code>List&lt;T&gt;</code> است.<br>
علاوه بر پیاده‌سازی <code>IList&lt;T&gt;</code> و <code>IList</code>، چهار متد مجازی و یک ویژگی محافظت‌شده (protected) اضافه ارائه می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">T</span>&gt; :
    <span class="hljs-title">IList</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">ICollection</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">IList</span>, <span class="hljs-title">ICollection</span>, <span class="hljs-title">IEnumerable</span>
{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClearItems</span>()</span>;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, T item</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, T item</span>)</span>;
    <span class="hljs-keyword">protected</span> IList&lt;T&gt; Items { <span class="hljs-keyword">get</span>; }
}
</code></pre>
<p>متدهای مجازی، <strong>درگاه</strong>ی برای “hook in” کردن شما فراهم می‌کنند تا رفتار پیش‌فرض لیست را تغییر یا تقویت کنید. ویژگی محافظت‌شده <strong>Items</strong> به پیاده‌ساز اجازه می‌دهد به <strong>لیست داخلی (inner list)</strong> دسترسی مستقیم داشته باشد و بدون فعال شدن متدهای مجازی، تغییرات داخلی ایجاد کند.</p>
<p>لازم نیست متدهای مجازی override شوند؛ می‌توان تا زمانی که نیازی به تغییر رفتار پیش‌فرض لیست وجود دارد، آن‌ها را دست‌نخورده گذاشت. مثال زیر استفاده معمولی <strong>Collection<T></strong> را نشان می‌دهد:</p>
<pre class="hljs"><code>Zoo zoo = <span class="hljs-keyword">new</span> Zoo();
zoo.Animals.Add(<span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&quot;Kangaroo&quot;</span>, <span class="hljs-number">10</span>));
zoo.Animals.Add(<span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&quot;Mr Sea Lion&quot;</span>, <span class="hljs-number">20</span>));
<span class="hljs-keyword">foreach</span> (Animal a <span class="hljs-keyword">in</span> zoo.Animals) Console.WriteLine(a.Name);

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Popularity;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> popularity</span>)</span>
    {
        Name = name; Popularity = popularity;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnimalCollection</span> : <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">Animal</span>&gt;
{
    <span class="hljs-comment">// AnimalCollection هم اکنون یک لیست کامل از حیوانات است.</span>
    <span class="hljs-comment">// نیازی به کد اضافی نیست.</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Zoo</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> AnimalCollection Animals = <span class="hljs-keyword">new</span> AnimalCollection();
}
</code></pre>
<p>همانطور که می‌بینیم، <strong>AnimalCollection</strong> از نظر عملکردی تفاوتی با یک <code>List&lt;Animal&gt;</code> ساده ندارد؛ نقش آن فراهم کردن پایه‌ای برای <strong>گسترش آینده</strong> است.</p>
<hr>
<h3>🔄 افزودن ویژگی Zoo به حیوانات و override متدهای مجازی</h3>
<p>اکنون می‌خواهیم به کلاس <code>Animal</code> ویژگی <code>Zoo</code> اضافه کنیم تا مرجع به باغ‌وحش خود را داشته باشد و همه متدهای مجازی <code>Collection&lt;Animal&gt;</code> را override کنیم تا این ویژگی به‌صورت خودکار مدیریت شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Popularity;
    <span class="hljs-keyword">public</span> Zoo Zoo { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">internal</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> popularity</span>)</span>
    {
        Name = name; Popularity = popularity;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnimalCollection</span> : <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">Animal</span>&gt;
{
    Zoo zoo;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnimalCollection</span>(<span class="hljs-params">Zoo zoo</span>)</span> { <span class="hljs-keyword">this</span>.zoo = zoo; }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, Animal item</span>)</span>
    {
        <span class="hljs-keyword">base</span>.InsertItem(index, item);
        item.Zoo = zoo;
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, Animal item</span>)</span>
    {
        <span class="hljs-keyword">base</span>.SetItem(index, item);
        item.Zoo = zoo;
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span>
    {
        <span class="hljs-keyword">this</span>[index].Zoo = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">base</span>.RemoveItem(index);
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClearItems</span>()</span>
    {
        <span class="hljs-keyword">foreach</span> (Animal a <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) a.Zoo = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">base</span>.ClearItems();
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Zoo</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> AnimalCollection Animals;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Zoo</span>()</span> { Animals = <span class="hljs-keyword">new</span> AnimalCollection(<span class="hljs-keyword">this</span>); }
}
</code></pre>
<p><strong>نکته مهم:</strong> <code>Collection&lt;T&gt;</code> همچنین یک سازنده می‌پذیرد که یک <code>IList&lt;T&gt;</code> موجود را دریافت می‌کند. برخلاف سایر کلاس‌های مجموعه، لیست ارائه‌شده <strong>proxied</strong> می‌شود نه کپی؛ بنابراین تغییرات بعدی در لیست اصلی، در <code>Collection&lt;T&gt;</code> نیز منعکس می‌شود (هرچند متدهای مجازی آن فعال نمی‌شوند). به همین ترتیب، تغییرات اعمال‌شده از طریق <code>Collection&lt;T&gt;</code>، لیست زیرین را تغییر می‌دهد.</p>
<hr>
<h3>⚙️ CollectionBase</h3>
<p><strong>CollectionBase</strong> نسخه غیرجنریک <code>Collection&lt;T&gt;</code> است. این کلاس بیشتر قابلیت‌های مشابه <code>Collection&lt;T&gt;</code> را ارائه می‌دهد اما استفاده از آن <strong>دست‌وپاگیرتر</strong> است.<br>
به جای متدهای قالبی <strong>InsertItem</strong>، <strong>RemoveItem</strong>، <strong>SetItem</strong> و <strong>ClearItems</strong>، <strong>CollectionBase</strong> دارای متدهای “hook” است که تعداد متدها را دو برابر می‌کند:</p>
<ul>
<li><code>OnInsert</code>, <code>OnInsertComplete</code></li>
<li><code>OnSet</code>, <code>OnSetComplete</code></li>
<li><code>OnRemove</code>, <code>OnRemoveComplete</code></li>
<li><code>OnClear</code>, <code>OnClearComplete</code></li>
</ul>
<p>چون <strong>CollectionBase</strong> غیرجنریک است، هنگام subclass کردن باید متدهای تایپ‌شده نیز پیاده‌سازی کنید؛ حداقل یک <strong>اندیسری تایپ‌شده (typed indexer)</strong> و متد <strong>Add</strong>.</p>
<h3>🗝️ KeyedCollection&lt;TKey,TItem&gt; و DictionaryBase</h3>
<p>کلاس <strong>KeyedCollection&lt;TKey,TItem&gt;</strong> از <code>Collection&lt;TItem&gt;</code> مشتق شده و هم <strong>ویژگی‌هایی اضافه می‌کند</strong> و هم <strong>ویژگی‌هایی را حذف می‌کند</strong>.</p>
<ul>
<li>آنچه اضافه می‌کند: <strong>امکان دسترسی به آیتم‌ها از طریق کلید (key)</strong>، درست مانند یک دیکشنری.</li>
<li>آنچه حذف می‌کند: <strong>امکان proxy کردن لیست داخلی خود</strong>.</li>
</ul>
<p>یک مجموعه keyed شباهت‌هایی به <code>OrderedDictionary</code> دارد، زیرا <strong>لیست خطی را با یک Hashtable ترکیب می‌کند</strong>. با این حال، برخلاف <code>OrderedDictionary</code>، <strong>IDictionary را پیاده‌سازی نمی‌کند</strong> و مفهوم کلید/مقدار (key/value) را پشتیبانی نمی‌کند. <strong>کلیدها از خود آیتم‌ها گرفته می‌شوند</strong>، از طریق متد انتزاعی <code>GetKeyForItem</code>. این یعنی <strong>enumeration</strong> یک مجموعه keyed دقیقاً مانند enumeration یک لیست معمولی است.</p>
<p>می‌توانید <strong>KeyedCollection&lt;TKey,TItem&gt;</strong> را به‌عنوان <code>Collection&lt;TItem&gt;</code> به اضافه <strong>جستجوی سریع بر اساس کلید</strong> در نظر بگیرید.</p>
<p>چون این کلاس از <code>Collection&lt;&gt;</code> مشتق شده، تمام عملکردهای Collection&lt;&gt; را به ارث می‌برد، به جز امکان تعیین یک لیست موجود در سازنده. اعضای اضافی که تعریف می‌کند به صورت زیر هستند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">KeyedCollection</span>&lt;<span class="hljs-title">TKey</span>, <span class="hljs-title">TItem</span>&gt; : <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">TItem</span>&gt;
{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> TKey <span class="hljs-title">GetKeyForItem</span>(<span class="hljs-params">TItem item</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ChangeItemKey</span>(<span class="hljs-params">TItem item, TKey newKey</span>)</span>;
    <span class="hljs-comment">// جستجوی سریع بر اساس کلید - علاوه بر جستجوی بر اساس اندیس</span>
    <span class="hljs-keyword">public</span> TItem <span class="hljs-keyword">this</span>[TKey key] { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">protected</span> IDictionary&lt;TKey, TItem&gt; Dictionary { <span class="hljs-keyword">get</span>; }
}
</code></pre>
<ul>
<li>متد <code>GetKeyForItem</code> توسط پیاده‌ساز override می‌شود تا <strong>کلید یک آیتم را از شیء زیرین</strong> دریافت کند.</li>
<li>متد <code>ChangeItemKey</code> باید <strong>هنگام تغییر کلید آیتم</strong> فراخوانی شود تا دیکشنری داخلی به‌روزرسانی شود.</li>
<li>ویژگی <code>Dictionary</code> دیکشنری داخلی را برمی‌گرداند که برای <strong>پیاده‌سازی جستجو</strong> استفاده می‌شود و هنگام افزودن اولین آیتم ساخته می‌شود. می‌توان رفتار ایجاد دیکشنری داخلی را با تعیین <strong>creation threshold</strong> در سازنده تغییر داد، به طوری که تا رسیدن به آستانه، جستجو با خطی انجام شود.</li>
</ul>
<p>یک دلیل خوب برای تعیین نکردن <strong>creation threshold</strong> این است که داشتن دیکشنری معتبر می‌تواند در <strong>دریافت ICollection&lt;&gt; از کلیدها</strong> مفید باشد، از طریق ویژگی <code>Keys</code> دیکشنری. این مجموعه سپس می‌تواند به یک ویژگی عمومی منتقل شود.</p>
<hr>
<h3>🐾 مثال: استفاده از KeyedCollection برای Zoo</h3>
<p>متداول‌ترین کاربرد <code>KeyedCollection&lt;,&gt;</code> فراهم کردن <strong>مجموعه‌ای از آیتم‌ها با دسترسی هم از طریق اندیس و هم از طریق نام</strong> است.</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>
{
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name
    {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> name; }
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">if</span> (Zoo != <span class="hljs-literal">null</span>) Zoo.Animals.NotifyNameChange(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">value</span>);
            name = <span class="hljs-keyword">value</span>;
        }
    }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Popularity;
    <span class="hljs-keyword">public</span> Zoo Zoo { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">internal</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> popularity</span>)</span>
    {
        Name = name; Popularity = popularity;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnimalCollection</span> : <span class="hljs-title">KeyedCollection</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">Animal</span>&gt;
{
    Zoo zoo;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnimalCollection</span>(<span class="hljs-params">Zoo zoo</span>)</span> { <span class="hljs-keyword">this</span>.zoo = zoo; }

    <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyNameChange</span>(<span class="hljs-params">Animal a, <span class="hljs-built_in">string</span> newName</span>)</span> =&gt;
        <span class="hljs-keyword">this</span>.ChangeItemKey(a, newName);

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetKeyForItem</span>(<span class="hljs-params">Animal item</span>)</span> =&gt; item.Name;

    <span class="hljs-comment">// متدهای زیر مشابه مثال قبلی پیاده‌سازی می‌شوند:</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, Animal item</span>)...
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, Animal item</span>)...
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)...
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClearItems</span>()...
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Zoo</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> AnimalCollection Animals;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Zoo</span>()</span> { Animals = <span class="hljs-keyword">new</span> AnimalCollection(<span class="hljs-keyword">this</span>); }
}
</code></pre>
<p>مثال استفاده از آن:</p>
<pre class="hljs"><code>Zoo zoo = <span class="hljs-keyword">new</span> Zoo();
zoo.Animals.Add(<span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&quot;Kangaroo&quot;</span>, <span class="hljs-number">10</span>));
zoo.Animals.Add(<span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&quot;Mr Sea Lion&quot;</span>, <span class="hljs-number">20</span>));
Console.WriteLine(zoo.Animals[<span class="hljs-number">0</span>].Popularity);               <span class="hljs-comment">// 10</span>
Console.WriteLine(zoo.Animals[<span class="hljs-string">&quot;Mr Sea Lion&quot;</span>].Popularity);   <span class="hljs-comment">// 20</span>
zoo.Animals[<span class="hljs-string">&quot;Kangaroo&quot;</span>].Name = <span class="hljs-string">&quot;Mr Roo&quot;</span>;
Console.WriteLine(zoo.Animals[<span class="hljs-string">&quot;Mr Roo&quot;</span>].Popularity);        <span class="hljs-comment">// 10</span>
</code></pre>
<hr>
<h3>🏛️ DictionaryBase</h3>
<p>نسخه غیرجنریک <code>KeyedCollection</code>، کلاس <strong>DictionaryBase</strong> است. این کلاس قدیمی <strong>رویکرد متفاوتی</strong> دارد:</p>
<ul>
<li><code>IDictionary</code> را پیاده‌سازی می‌کند</li>
<li>از متدهای hook دست‌وپاگیر مانند CollectionBase استفاده می‌کند:<br>
<code>OnInsert</code>, <code>OnInsertComplete</code>, <code>OnSet</code>, <code>OnSetComplete</code>, <code>OnRemove</code>, <code>OnRemoveComplete</code>, <code>OnClear</code>, <code>OnClearComplete</code> و همچنین <code>OnGet</code>.</li>
</ul>
<p>مزیت اصلی پیاده‌سازی IDictionary نسبت به KeyedCollection این است که <strong>نیازی به subclass کردن برای دسترسی به کلیدها نیست</strong>. اما چون هدف DictionaryBase در اصل subclass شدن است، این مزیت چندان کاربردی ندارد.</p>
<p>مدل بهبود یافته در <strong>KeyedCollection</strong> احتمالاً به این دلیل است که چند سال بعد نوشته شده و از تجربیات گذشته بهره‌مند بوده است.<br>
<strong>DictionaryBase</strong> بیشتر برای <strong>سازگاری با نسخه‌های قدیمی (backward compatibility)</strong> مفید است.</p>
<h3>🔒 ReadOnlyCollection<T></h3>
<p>کلاس <strong>ReadOnlyCollection<T></strong> یک <strong>wrapper</strong> یا <strong>proxy</strong> است که یک <strong>نمای فقط-خواندنی</strong> از یک مجموعه را فراهم می‌کند. این ویژگی به شما اجازه می‌دهد تا یک کلاس <strong>دسترسی عمومی فقط-خواندنی</strong> به یک مجموعه را ارائه دهد، در حالی که خود کلاس هنوز می‌تواند مجموعه را به‌صورت داخلی به‌روزرسانی کند.</p>
<p>یک مجموعه فقط-خواندنی، <strong>مجموعه ورودی را در سازنده خود دریافت می‌کند</strong> و یک <strong>ارجاع دائمی</strong> به آن نگه می‌دارد. این کلاس <strong>نسخه‌ای ایستا از مجموعه ورودی نمی‌سازد</strong>، بنابراین تغییرات بعدی در مجموعه ورودی از طریق wrapper فقط-خواندنی قابل مشاهده است.</p>
<p>برای مثال، فرض کنید کلاس شما می‌خواهد <strong>دسترسی عمومی فقط-خواندنی</strong> به لیستی از رشته‌ها به نام <code>Names</code> فراهم کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    List&lt;<span class="hljs-built_in">string</span>&gt; names = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();
    <span class="hljs-keyword">public</span> IReadOnlyList&lt;<span class="hljs-built_in">string</span>&gt; Names =&gt; names;
}
</code></pre>
<p>با اینکه <code>Names</code> یک رابط فقط-خواندنی بازمی‌گرداند، مصرف‌کننده هنوز می‌تواند در زمان اجرا به <code>List&lt;string&gt;</code> یا <code>IList&lt;string&gt;</code> <strong>downcast</strong> کند و سپس متدهای <code>Add</code>، <code>Remove</code> یا <code>Clear</code> را فراخوانی کند.</p>
<p>راه‌حل <strong>ReadOnlyCollection<T></strong> این مشکل را به صورت محکم‌تر حل می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    List&lt;<span class="hljs-built_in">string</span>&gt; names = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();
    <span class="hljs-keyword">public</span> ReadOnlyCollection&lt;<span class="hljs-built_in">string</span>&gt; Names { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span>()</span> =&gt; Names = <span class="hljs-keyword">new</span> ReadOnlyCollection&lt;<span class="hljs-built_in">string</span>&gt;(names);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddInternally</span>()</span> =&gt; names.Add(<span class="hljs-string">&quot;test&quot;</span>);
}
</code></pre>
<p>در این حالت، تنها اعضای داخل کلاس <strong>Test</strong> می‌توانند لیست <code>names</code> را تغییر دهند:</p>
<pre class="hljs"><code>Test t = <span class="hljs-keyword">new</span> Test();
Console.WriteLine(t.Names.Count);       <span class="hljs-comment">// 0</span>
t.AddInternally();
Console.WriteLine(t.Names.Count);       <span class="hljs-comment">// 1</span>
t.Names.Add(<span class="hljs-string">&quot;test&quot;</span>);                    <span class="hljs-comment">// خطای کامپایل</span>
((IList&lt;<span class="hljs-built_in">string</span>&gt;)t.Names).Add(<span class="hljs-string">&quot;test&quot;</span>);   <span class="hljs-comment">// NotSupportedException</span>
</code></pre>
<hr>
<h3>🛡️ Immutable Collections</h3>
<p>قبلاً توضیح دادیم که چگونه <strong>ReadOnlyCollection<T></strong> یک نمای فقط-خواندنی ایجاد می‌کند. محدود کردن توانایی نوشتن (mutate) یک مجموعه یا هر شیء دیگر، <strong>ساده‌سازی نرم‌افزار و کاهش باگ‌ها</strong> را به دنبال دارد.</p>
<p><strong>مجموعه‌های immutable</strong> این اصل را گسترش می‌دهند و <strong>مجموعه‌هایی ارائه می‌کنند که پس از مقداردهی اولیه اصلاً قابل تغییر نیستند</strong>. اگر بخواهید آیتمی به یک مجموعه immutable اضافه کنید، باید یک <strong>مجموعه جدید بسازید</strong> و مجموعه قدیمی بدون تغییر باقی بماند.</p>
<hr>
<h4>⚡ مزایای Immutable Collections</h4>
<ul>
<li><strong>از بین بردن تعداد زیادی از باگ‌ها</strong> که با تغییر وضعیت ایجاد می‌شوند.</li>
<li><strong>ساده‌سازی موازی‌سازی و چندنخی</strong> (multithreading) با اجتناب از بیشتر مشکلات thread-safety که در فصل‌های 14، 22 و 23 توضیح داده می‌شوند.</li>
<li><strong>ساده‌تر کردن منطق و تحلیل کد</strong>.</li>
</ul>
<h4>❌ معایب</h4>
<ul>
<li>هرگاه نیاز به تغییر باشد، باید <strong>کل شیء جدیدی ساخته شود</strong> که ممکن است <strong>هزینه عملکردی</strong> به همراه داشته باشد. با این حال، <strong>استراتژی‌هایی برای کاهش این هزینه</strong> وجود دارد، از جمله قابلیت <strong>استفاده مجدد از بخش‌هایی از ساختار اولیه</strong>.</li>
</ul>
<hr>
<p>مجموعه‌های immutable بخشی از <strong>.NET</strong> هستند (در .NET Framework، از طریق پکیج NuGet به نام <code>System.Collections.Immutable</code> قابل دسترسی‌اند). همه مجموعه‌ها در namespace زیر تعریف شده‌اند:</p>
<pre class="hljs"><code>System.Collections.Immutable
</code></pre>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-7.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>🧱 ImmutableArray<T> و ImmutableList<T></h3>
<p>انواع <strong>ImmutableArray<T></strong> و <strong>ImmutableList<T></strong> هر دو نسخه‌های <strong>immutable</strong> از <strong>List<T></strong> هستند. هر دو کار مشابهی انجام می‌دهند، اما <strong>ویژگی‌های عملکردی متفاوتی</strong> دارند که در بخش «Immutable Collections and Performance» در صفحه 409 بررسی شده است.</p>
<p>مجموعه‌های immutable یک <strong>رابط عمومی مشابه نسخه‌های قابل تغییر</strong> خود ارائه می‌کنند. تفاوت کلیدی این است که <strong>متدهایی که به نظر می‌رسد مجموعه را تغییر می‌دهند</strong> (مثل <code>Add</code> یا <code>Remove</code>) در واقع <strong>مجموعه اصلی را تغییر نمی‌دهند</strong>؛ بلکه <strong>یک مجموعه جدید با آیتم اضافه یا حذف شده</strong> برمی‌گردانند. به این رفتار <strong>nondestructive mutation</strong> گفته می‌شود.</p>
<p>توجه داشته باشید که <strong>مجموعه‌های immutable از اضافه یا حذف آیتم‌ها جلوگیری می‌کنند</strong>؛ اما این <strong>محدودیت روی خود آیتم‌ها اعمال نمی‌شود</strong>. برای بهره کامل از <strong>immutable بودن</strong>، باید اطمینان حاصل کنید که فقط <strong>آیتم‌های immutable</strong> در مجموعه immutable قرار می‌گیرند.</p>
<hr>
<h3>🏗️ ایجاد Immutable Collections</h3>
<p>هر نوع مجموعه immutable یک متد <strong>Create<T>()</strong> ارائه می‌دهد که <strong>مقادیر اولیه اختیاری</strong> را می‌پذیرد و <strong>یک مجموعه immutable مقداردهی‌شده</strong> برمی‌گرداند:</p>
<pre class="hljs"><code>ImmutableArray&lt;<span class="hljs-built_in">int</span>&gt; array = ImmutableArray.Create&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
</code></pre>
<p>همچنین متد <strong>CreateRange<T></strong> وجود دارد که مشابه <code>Create&lt;T&gt;</code> عمل می‌کند؛ تفاوت آن در این است که <strong>پارامتر آن از نوع IEnumerable<T></strong> است، نه <code>params T[]</code>.</p>
<p>می‌توانید یک <strong>مجموعه immutable</strong> را از یک <code>IEnumerable&lt;T&gt;</code> موجود با استفاده از <strong>extension methodهای مناسب</strong> بسازید (<code>ToImmutableArray</code>، <code>ToImmutableList</code>، <code>ToImmutableDictionary</code> و غیره):</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span>[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> }.ToImmutableList();
</code></pre>
<hr>
<h3>🔄 دستکاری Immutable Collections</h3>
<p>متد <strong>Add</strong> یک <strong>مجموعه جدید</strong> شامل <strong>عناصر موجود به‌علاوه عنصر جدید</strong> برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> oldList = ImmutableList.Create&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
ImmutableList&lt;<span class="hljs-built_in">int</span>&gt; newList = oldList.Add(<span class="hljs-number">4</span>);

Console.WriteLine(oldList.Count);   <span class="hljs-comment">// 3  (تغییر نکرده)</span>
Console.WriteLine(newList.Count);   <span class="hljs-comment">// 4</span>
</code></pre>
<p>متد <strong>Remove</strong> نیز به همین شکل عمل می‌کند و یک مجموعه جدید با آیتم حذف‌شده برمی‌گرداند.</p>
<p>اضافه یا حذف مکرر به این روش <strong>ناکارآمد است</strong>، زیرا برای هر عملیات یک مجموعه immutable جدید ساخته می‌شود.<br>
راه بهتر استفاده از <strong>AddRange</strong> یا <strong>RemoveRange</strong> است که یک <code>IEnumerable&lt;T&gt;</code> از آیتم‌ها می‌پذیرد و همه آیتم‌ها را <strong>یکجا اضافه یا حذف می‌کند</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> anotherList = oldList.AddRange(<span class="hljs-keyword">new</span>[] { <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> });
</code></pre>
<p>همچنین <strong>ImmutableList</strong> و <strong>ImmutableArray</strong> متدهای <strong>Insert</strong> و <strong>InsertRange</strong> برای درج آیتم در اندیس مشخص، <strong>RemoveAt</strong> برای حذف در اندیس مشخص و <strong>RemoveAll</strong> بر اساس predicate ارائه می‌دهند.</p>
<hr>
<h3>🏗️ Builders</h3>
<p>برای نیازهای مقداردهی پیچیده‌تر، هر کلاس مجموعه immutable دارای <strong>Builder</strong> متناظر است.<br>
Builders به لحاظ عملکرد مشابه یک <strong>مجموعه mutable</strong> هستند. پس از مقداردهی، با فراخوانی <code>.ToImmutable()</code> روی Builder، یک مجموعه immutable جدید دریافت می‌کنید:</p>
<pre class="hljs"><code>ImmutableArray&lt;<span class="hljs-built_in">int</span>&gt;.Builder builder = ImmutableArray.CreateBuilder&lt;<span class="hljs-built_in">int</span>&gt;();
builder.Add(<span class="hljs-number">1</span>);
builder.Add(<span class="hljs-number">2</span>);
builder.Add(<span class="hljs-number">3</span>);
builder.RemoveAt(<span class="hljs-number">0</span>);

ImmutableArray&lt;<span class="hljs-built_in">int</span>&gt; myImmutable = builder.ToImmutable();
</code></pre>
<p>همچنین می‌توانید <strong>چندین تغییر را روی یک مجموعه immutable موجود به‌صورت گروهی</strong> انجام دهید:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> builder2 = myImmutable.ToBuilder();
builder2.Add(<span class="hljs-number">4</span>);      <span class="hljs-comment">// کارآمد</span>
builder2.Remove(<span class="hljs-number">2</span>);   <span class="hljs-comment">// کارآمد</span>
<span class="hljs-comment">// تغییرات بیشتر روی builder...</span>
ImmutableArray&lt;<span class="hljs-built_in">int</span>&gt; myImmutable2 = builder2.ToImmutable(); <span class="hljs-comment">// مجموعه جدید با تمام تغییرات</span>
</code></pre>
<hr>
<h3>⚡ Immutable Collections و عملکرد</h3>
<p>بیشتر مجموعه‌های immutable از <strong>درخت AVL</strong> داخلی استفاده می‌کنند، که اجازه می‌دهد عملیات <strong>add/remove</strong> از بخش‌هایی از ساختار داخلی قبلی استفاده کنند و <strong>کل مجموعه دوباره ساخته نشود</strong>. این باعث می‌شود <strong>هزینه عملیات add/remove از بزرگ (در مجموعه‌های بزرگ) به متوسط کاهش یابد</strong>؛ اما خواندن داده‌ها کمی کندتر خواهد شد.<br>
نتیجه نهایی این است که بیشتر مجموعه‌های immutable <strong>برای خواندن و نوشتن کندتر</strong> از نسخه‌های mutable هستند.</p>
<ul>
<li>بیشترین تاثیر روی <strong>ImmutableList<T></strong> است، که <strong>خواندن و افزودن آیتم</strong> در آن <strong>10 تا 200 برابر کندتر از List<T></strong> است (بسته به اندازه لیست).</li>
<li>به همین دلیل <strong>ImmutableArray<T></strong> وجود دارد: با استفاده از یک <strong>آرایه داخلی</strong>، عملکرد خواندن بدون کاهش سرعت انجام می‌شود (مشابه آرایه mutable معمولی). اما افزودن آیتم‌ها کندتر از حتی ImmutableList<T> است، زیرا ساختار قبلی قابل استفاده مجدد نیست.</li>
</ul>
<p>بنابراین، <strong>ImmutableArray<T></strong> زمانی مطلوب است که بخواهید <strong>عملکرد خواندن بدون محدودیت</strong> داشته باشید و انتظار <strong>اضافه/حذف مکرر آیتم‌ها</strong> را نداشته باشید (بدون استفاده از Builder).</p>
<div align="center">
<p><img src="../../../assets/image/07/Table-7-8.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>❌ هزینه حذف در ImmutableArray</h3>
<p>فراخوانی <strong>Remove</strong> روی <strong>ImmutableArray</strong> گران‌تر از فراخوانی همان متد روی <strong>List<T></strong> است — حتی در <strong>بدترین حالت</strong> که اولین عنصر حذف شود — زیرا <strong>ایجاد مجموعه جدید فشار اضافی روی Garbage Collector وارد می‌کند</strong>.</p>
<p>با وجود اینکه مجموعه‌های immutable به‌طور کلی <strong>هزینه عملکردی قابل توجهی</strong> دارند، اما باید <strong>میزان واقعی را درک کرد</strong>. برای مثال، یک عملیات <strong>Add</strong> روی یک <strong>ImmutableList</strong> با یک میلیون عنصر، احتمالاً <strong>کمتر از یک میکروثانیه</strong> در یک لپ‌تاپ معمولی طول می‌کشد، و یک عملیات خواندن در <strong>کمتر از 100 نانوثانیه</strong> انجام می‌شود.</p>
<p>همچنین اگر نیاز باشد <strong>عملیات نوشتن در حلقه</strong> انجام شود، می‌توان با استفاده از <strong>Builder</strong> از هزینه تجمعی جلوگیری کرد.</p>
<hr>
<h3>⚡ کاهش هزینه‌ها در Immutable Collections</h3>
<p>عوامل زیر به کاهش هزینه‌ها کمک می‌کنند:</p>
<ul>
<li><strong>Immutable بودن</strong> امکان <strong>همزمانی و پردازش موازی ساده</strong> را فراهم می‌کند (Chapter 23)، بنابراین می‌توان از همه هسته‌های پردازنده استفاده کرد. پردازش موازی با حالت mutable به‌راحتی منجر به خطا می‌شود و نیاز به قفل‌ها یا مجموعه‌های همزمان دارد که هر دو عملکرد را کاهش می‌دهند.</li>
<li>با <strong>Immutable بودن</strong> نیازی به <strong>کپی حفاظتی (defensive copy)</strong> از مجموعه‌ها یا ساختارهای داده برای جلوگیری از تغییرات غیرمنتظره نیست. این یکی از دلایلی است که در نوشتن بخش‌های اخیر <strong>Visual Studio</strong> از مجموعه‌های immutable استفاده شد.</li>
<li>در اکثر برنامه‌های معمولی، تعداد کمی از مجموعه‌ها دارای آیتم کافی هستند که تفاوت ملموس باشد.</li>
</ul>
<p>علاوه بر <strong>Visual Studio</strong>، <strong>Microsoft Roslyn</strong> نیز با استفاده از مجموعه‌های immutable ساخته شده است، که نشان می‌دهد مزایا می‌توانند بر هزینه‌ها غالب شوند.</p>
<hr>
<h3>❄️ Frozen Collections</h3>
<p>از <strong>.NET 8</strong>، فضای نام <strong>System.Collections.Frozen</strong> شامل دو کلاس <strong>مجموعه فقط‌خواندنی</strong> است:</p>
<ul>
<li><code>FrozenDictionary&lt;TKey,TValue&gt;</code></li>
<li><code>FrozenSet&lt;T&gt;</code></li>
</ul>
<p>این مجموعه‌ها مشابه <strong>ImmutableDictionary&lt;K,V&gt;</strong> و <strong>ImmutableHashSet<T></strong> هستند، اما <strong>متدهایی برای nondestructive mutation</strong> (مثل Add یا Remove) ندارند و بنابراین <strong>عملکرد خواندن بهینه‌ای دارند</strong>.</p>
<p>برای ایجاد یک <strong>Frozen Collection</strong>، ابتدا با یک مجموعه یا دنباله شروع می‌کنید و سپس از <strong>extension method</strong>های <code>ToFrozenDictionary</code> یا <code>ToFrozenSet</code> استفاده می‌کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] numbers = { <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span> };
FrozenSet&lt;<span class="hljs-built_in">int</span>&gt; frozen = numbers.ToFrozenSet();
Console.WriteLine(frozen.Contains(<span class="hljs-number">10</span>));  <span class="hljs-comment">// True</span>
</code></pre>
<p>مجموعه‌های frozen برای <strong>جستجوهایی که در ابتدای برنامه مقداردهی می‌شوند و در طول برنامه استفاده می‌شوند</strong> عالی هستند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Disassembler</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">static</span> IReadOnlyDictionary&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt; OpCodeLookup =
        <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;()
        {
            { <span class="hljs-string">&quot;ADC&quot;</span>, <span class="hljs-string">&quot;Add with Carry&quot;</span> },
            { <span class="hljs-string">&quot;ADD&quot;</span>, <span class="hljs-string">&quot;Add&quot;</span> },
            { <span class="hljs-string">&quot;AND&quot;</span>, <span class="hljs-string">&quot;Logical AND&quot;</span> },
            { <span class="hljs-string">&quot;ANDN&quot;</span>, <span class="hljs-string">&quot;Logical AND NOT&quot;</span> },
            ...
        }
        .ToFrozenDictionary();
    ...
}
</code></pre>
<p>مجموعه‌های frozen <strong>رابط استاندارد dictionary/set</strong> و نسخه‌های فقط‌خواندنی آن‌ها را پیاده‌سازی می‌کنند. در مثال بالا، <strong>FrozenDictionary&lt;string,string&gt;</strong> به‌عنوان <strong>فیلدی از نوع IReadOnlyDictionary&lt;string,string&gt;</strong> در دسترس قرار گرفته است.</p>
<hr>
<h3>⚙️ Plugging in Equality and Order</h3>
<p>در بخش‌های <strong>“Equality Comparison”</strong> (صفحه 226) و <strong>“Order Comparison”</strong> (صفحه 355) پروتکل‌های استاندارد .NET توضیح داده شد که یک نوع را <strong>قابل مقایسه، قابل هش و equatable</strong> می‌کنند.</p>
<p>یک نوع که این پروتکل‌ها را پیاده‌سازی کند، می‌تواند به‌طور صحیح در <strong>dictionary</strong> یا <strong>sorted list</strong> استفاده شود:</p>
<ul>
<li>نوعی که <strong>Equals</strong> و <strong>GetHashCode</strong> نتایج معناداری برمی‌گرداند، می‌تواند به‌عنوان <strong>کلید در Dictionary یا Hashtable</strong> استفاده شود.</li>
<li>نوعی که <strong>IComparable / IComparable<T></strong> پیاده‌سازی کند، می‌تواند به‌عنوان <strong>کلید در هر dictionary یا لیست مرتب شده</strong> استفاده شود.</li>
</ul>
<p>پیاده‌سازی پیش‌فرض معمولاً رفتار طبیعی نوع را بازتاب می‌دهد، اما گاهی اوقات لازم است رفتار متفاوتی داشته باشید. برای مثال:</p>
<ul>
<li>یک dictionary با <strong>کلیدهای string بدون حساسیت به حروف</strong></li>
<li>یا یک <strong>sorted list از مشتریان، مرتب‌شده بر اساس کدپستی</strong></li>
</ul>
<p>به همین دلیل، .NET مجموعه‌ای از <strong>“plug-in” پروتکل‌ها</strong> را تعریف کرده است. این پروتکل‌ها دو کار انجام می‌دهند:</p>
<ul>
<li>امکان <strong>جایگزینی رفتار پیش‌فرض برای مقایسه و برابری</strong></li>
<li>استفاده از dictionary یا مجموعه مرتب با <strong>نوع کلیدی که به‌طور ذاتی equatable یا comparable نیست</strong></li>
</ul>
<p>پروتکل‌های plug-in شامل <strong>interfaceهای زیر</strong> هستند:</p>
<p><strong>IEqualityComparer و IEqualityComparer<T></strong></p>
<ul>
<li>انجام <strong>مقایسه و هشینگ جایگزین</strong></li>
<li>توسط <strong>Hashtable و Dictionary</strong> شناخته می‌شود</li>
</ul>
<p><strong>IComparer و IComparer<T></strong></p>
<ul>
<li>انجام <strong>مقایسه ترتیب جایگزین</strong></li>
<li>توسط <strong>sorted dictionaries و collections</strong> شناخته می‌شود؛ همچنین توسط <strong>Array.Sort</strong></li>
</ul>
<p>هر interface هم <strong>نسخه generic و nongeneric</strong> دارد.<br>
همچنین، <strong>IEqualityComparer</strong> شامل یک <strong>پیاده‌سازی پیش‌فرض در کلاس EqualityComparer</strong> است.<br>
علاوه بر این، <strong>interfaceهایی به نام IStructuralEquatable و IStructuralComparable</strong> وجود دارند که امکان <strong>مقایسه‌های ساختاری (structural comparisons)</strong> را برای کلاس‌ها و آرایه‌ها فراهم می‌کنند.</p>
<hr>
<h3>⚖️ IEqualityComparer و EqualityComparer</h3>
<p>یک <strong>equality comparer</strong> این امکان را فراهم می‌کند که رفتار <strong>برابری و هشینگ غیرپیش‌فرض</strong> جایگزین شود، عمدتاً برای کلاس‌های <strong>Dictionary</strong> و <strong>Hashtable</strong>.</p>
<p>به یاد بیاورید که یک <strong>dictionary مبتنی بر hashtable</strong> به دو سؤال برای هر کلید نیاز دارد:</p>
<ul>
<li>آیا این کلید <strong>همانند کلید دیگری</strong> است؟</li>
<li><strong>HashCode صحیح</strong> آن چیست؟</li>
</ul>
<p>یک equality comparer به این دو سؤال پاسخ می‌دهد با پیاده‌سازی <strong>interfaceهای IEqualityComparer</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEqualityComparer</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">T x, T y</span>)</span>;
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params">T obj</span>)</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEqualityComparer</span>   <span class="hljs-comment">// نسخه nongeneric</span>
{
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> x, <span class="hljs-built_in">object</span> y</span>)</span>;
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span>;
}
</code></pre>
<p>برای نوشتن <strong>comparer سفارشی</strong>، می‌توانید یکی یا هر دو interface را پیاده‌سازی کنید (پیاده‌سازی هر دو حداکثر سازگاری را فراهم می‌کند).</p>
<p>چون این کار کمی وقت‌گیر است، یک جایگزین استفاده از <strong>کلاس انتزاعی EqualityComparer</strong> است:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EqualityComparer</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IEqualityComparer</span>, <span class="hljs-title">IEqualityComparer</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">T x, T y</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params">T obj</span>)</span>;

    <span class="hljs-built_in">bool</span> IEqualityComparer.Equals(<span class="hljs-built_in">object</span> x, <span class="hljs-built_in">object</span> y);
    <span class="hljs-built_in">int</span> IEqualityComparer.GetHashCode(<span class="hljs-built_in">object</span> obj);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EqualityComparer&lt;T&gt; Default { <span class="hljs-keyword">get</span>; }
}
</code></pre>
<p>کلاس <strong>EqualityComparer</strong> هر دو interface را پیاده‌سازی می‌کند و تنها کاری که شما باید انجام دهید، <strong>override کردن دو متد انتزاعی</strong> است.</p>
<hr>
<h3>🧾 مثال: Customer و EqualityComparer سفارشی</h3>
<p>مثلاً یک کلاس <strong>Customer</strong> با دو فیلد داریم و یک equality comparer می‌نویسیم که هر دو <strong>نام و نام خانوادگی</strong> را مقایسه کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> last, <span class="hljs-built_in">string</span> first</span>)</span>
    {
        LastName = last;
        FirstName = first;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LastFirstEqComparer</span> : <span class="hljs-title">EqualityComparer</span>&lt;<span class="hljs-title">Customer</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Customer x, Customer y</span>)</span>
        =&gt; x.LastName == y.LastName &amp;&amp; x.FirstName == y.FirstName;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params">Customer obj</span>)</span>
        =&gt; (obj.LastName + <span class="hljs-string">&quot;;&quot;</span> + obj.FirstName).GetHashCode();
}
</code></pre>
<p>حالا دو customer ایجاد می‌کنیم:</p>
<pre class="hljs"><code>Customer c1 = <span class="hljs-keyword">new</span> Customer(<span class="hljs-string">&quot;Bloggs&quot;</span>, <span class="hljs-string">&quot;Joe&quot;</span>);
Customer c2 = <span class="hljs-keyword">new</span> Customer(<span class="hljs-string">&quot;Bloggs&quot;</span>, <span class="hljs-string">&quot;Joe&quot;</span>);
</code></pre>
<p>چون <strong>object.Equals</strong> را override نکرده‌ایم، رفتار پیش‌فرض <strong>reference equality</strong> اعمال می‌شود:</p>
<pre class="hljs"><code>Console.WriteLine(c1 == c2);       <span class="hljs-comment">// False</span>
Console.WriteLine(c1.Equals(c2));  <span class="hljs-comment">// False</span>
</code></pre>
<p>در استفاده از Dictionary بدون تعیین equality comparer، همین رفتار پیش‌فرض اعمال می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Dictionary&lt;Customer, <span class="hljs-built_in">string</span>&gt;();
d[c1] = <span class="hljs-string">&quot;Joe&quot;</span>;
Console.WriteLine(d.ContainsKey(c2));  <span class="hljs-comment">// False</span>
</code></pre>
<p>اما با استفاده از equality comparer سفارشی:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> eqComparer = <span class="hljs-keyword">new</span> LastFirstEqComparer();
<span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> Dictionary&lt;Customer, <span class="hljs-built_in">string</span>&gt;(eqComparer);
d[c1] = <span class="hljs-string">&quot;Joe&quot;</span>;
Console.WriteLine(d.ContainsKey(c2));  <span class="hljs-comment">// True</span>
</code></pre>
<p>⚠️ نکته: هنگام استفاده از Dictionary با یک <strong>comparer سفارشی</strong>، باید مراقب باشید که <strong>FirstName یا LastName مشتری تغییر نکند</strong>، چون تغییر HashCode باعث شکستن Dictionary می‌شود.</p>
<hr>
<h3>✅ EqualityComparer<T>.Default</h3>
<p>فراخوانی <code>EqualityComparer&lt;T&gt;.Default</code> یک <strong>equality comparer عمومی</strong> برمی‌گرداند که می‌توان آن را به جای <strong>object.Equals</strong> استفاده کرد.<br>
مزیت آن این است که ابتدا بررسی می‌کند آیا <strong>T IEquatable<T></strong> پیاده‌سازی کرده است یا خیر، و اگر کرده باشد، آن پیاده‌سازی را فراخوانی می‌کند و از <strong>boxing overhead</strong> جلوگیری می‌کند.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Foo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T x, T y</span>)</span>
{
    <span class="hljs-built_in">bool</span> same = EqualityComparer&lt;T&gt;.Default.Equals(x, y);
    ...
}
</code></pre>
<hr>
<h3>🧩 ReferenceEqualityComparer.Instance (.NET 5+)</h3>
<p>از <strong>.NET 5</strong>، <code>ReferenceEqualityComparer.Instance</code> یک <strong>equality comparer</strong> برمی‌گرداند که همیشه <strong>referential equality</strong> را اعمال می‌کند.<br>
در مورد <strong>value types</strong>، متد <strong>Equals</strong> آن همیشه <strong>false</strong> برمی‌گرداند.</p>
<h3>🏷️ IComparer و Comparer</h3>
<p><strong>Comparers</strong> برای جایگزینی منطق <strong>مرتب‌سازی سفارشی</strong> در <strong>dictionaries و collectionهای مرتب</strong> استفاده می‌شوند.</p>
<p>توجه کنید که <strong>comparerها برای دیکشنری‌های بدون ترتیب</strong> مانند <strong>Dictionary</strong> و <strong>Hashtable</strong> کاربردی ندارند—چرا که این‌ها نیاز به <strong>IEqualityComparer</strong> برای گرفتن hashcode دارند.<br>
به همین ترتیب، یک <strong>equality comparer</strong> برای دیکشنری‌ها یا collectionهای مرتب کاربردی ندارد.</p>
<p>تعاریف interface <strong>IComparer</strong> به شرح زیر است:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IComparer</span>
{
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> x, <span class="hljs-built_in">object</span> y</span>)</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IComparer</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>&gt;
{
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span>(<span class="hljs-params">T x, T y</span>)</span>;
}
</code></pre>
<p>همانند <strong>equality comparers</strong>، یک کلاس انتزاعی وجود دارد که می‌توانید آن را subclass کنید به جای پیاده‌سازی مستقیم interfaceها:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Comparer</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IComparer</span>, <span class="hljs-title">IComparer</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparer&lt;T&gt; Default { <span class="hljs-keyword">get</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span>(<span class="hljs-params">T x, T y</span>)</span>;          <span class="hljs-comment">// توسط شما پیاده‌سازی می‌شود</span>
    <span class="hljs-built_in">int</span> IComparer.Compare(<span class="hljs-built_in">object</span> x, <span class="hljs-built_in">object</span> y);     <span class="hljs-comment">// برای شما پیاده‌سازی شده</span>
}
</code></pre>
<hr>
<h3>مثال: مرتب‌سازی Wish بر اساس Priority</h3>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Wish</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Priority;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wish</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> priority</span>)</span>
    {
        Name = name;
        Priority = priority;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title">PriorityComparer</span> : <span class="hljs-title">Comparer</span>&lt;<span class="hljs-title">Wish</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span>(<span class="hljs-params">Wish x, Wish y</span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">object</span>.Equals(x, y)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// بهینه‌سازی</span>
        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">if</span> (y == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> x.Priority.CompareTo(y.Priority);
    }
}
</code></pre>
<p>✅ نکته: بررسی <code>object.Equals</code> اطمینان می‌دهد که هیچ‌گاه با روش <code>Equals</code> تناقض پیدا نکنیم. استفاده از متد <strong>static object.Equals</strong> بهتر از <code>x.Equals</code> است چون حتی وقتی <code>x</code> برابر null است، کار می‌کند.</p>
<p>مرتب‌سازی یک لیست با استفاده از <strong>PriorityComparer</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> wishList = <span class="hljs-keyword">new</span> List&lt;Wish&gt;();
wishList.Add(<span class="hljs-keyword">new</span> Wish(<span class="hljs-string">&quot;Peace&quot;</span>, <span class="hljs-number">2</span>));
wishList.Add(<span class="hljs-keyword">new</span> Wish(<span class="hljs-string">&quot;Wealth&quot;</span>, <span class="hljs-number">3</span>));
wishList.Add(<span class="hljs-keyword">new</span> Wish(<span class="hljs-string">&quot;Love&quot;</span>, <span class="hljs-number">2</span>));
wishList.Add(<span class="hljs-keyword">new</span> Wish(<span class="hljs-string">&quot;3 more wishes&quot;</span>, <span class="hljs-number">1</span>));

wishList.Sort(<span class="hljs-keyword">new</span> PriorityComparer());

<span class="hljs-keyword">foreach</span> (Wish w <span class="hljs-keyword">in</span> wishList)
    Console.Write(w.Name + <span class="hljs-string">&quot; | &quot;</span>);
<span class="hljs-comment">// OUTPUT: 3 more wishes | Love | Peace | Wealth |</span>
</code></pre>
<hr>
<h3>مثال: مرتب‌سازی رشته‌ها برای دفترچه تلفن</h3>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">SurnameComparer</span> : <span class="hljs-title">Comparer</span>&lt;<span class="hljs-title">string</span>&gt;
{
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Normalize</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>
    {
        s = s.Trim().ToUpper();
        <span class="hljs-keyword">if</span> (s.StartsWith(<span class="hljs-string">&quot;MC&quot;</span>)) s = <span class="hljs-string">&quot;MAC&quot;</span> + s.Substring(<span class="hljs-number">2</span>);
        <span class="hljs-keyword">return</span> s;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> x, <span class="hljs-built_in">string</span> y</span>)</span>
        =&gt; Normalize(x).CompareTo(Normalize(y));
}
</code></pre>
<p>استفاده در یک <strong>SortedDictionary</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dic = <span class="hljs-keyword">new</span> SortedDictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;(<span class="hljs-keyword">new</span> SurnameComparer());
dic.Add(<span class="hljs-string">&quot;MacPhail&quot;</span>, <span class="hljs-string">&quot;second!&quot;</span>);
dic.Add(<span class="hljs-string">&quot;MacWilliam&quot;</span>, <span class="hljs-string">&quot;third!&quot;</span>);
dic.Add(<span class="hljs-string">&quot;McDonald&quot;</span>, <span class="hljs-string">&quot;first!&quot;</span>);

<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> s <span class="hljs-keyword">in</span> dic.Values)
    Console.Write(s + <span class="hljs-string">&quot; &quot;</span>);  <span class="hljs-comment">// first! second! third!</span>
</code></pre>
<hr>
<h3>🔤 StringComparer</h3>
<p><code>StringComparer</code> یک کلاس plug-in پیش‌فرض برای <strong>برابری و مقایسه رشته‌ها</strong> است که امکان تعیین <strong>زبان و حساسیت به حروف بزرگ/کوچک</strong> را می‌دهد.<br>
این کلاس هم <strong>IEqualityComparer</strong> و هم <strong>IComparer</strong> (نسخه‌های generic و nongeneric) را پیاده‌سازی می‌کند، بنابراین می‌توان از آن با هر نوع dictionary یا collection مرتب استفاده کرد.</p>
<p>چون StringComparer انتزاعی است، نمونه‌ها از طریق <strong>static properties</strong> آن بدست می‌آیند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringComparer CurrentCulture { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringComparer CurrentCultureIgnoreCase { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringComparer InvariantCulture { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringComparer InvariantCultureIgnoreCase { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringComparer Ordinal { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringComparer OrdinalIgnoreCase { <span class="hljs-keyword">get</span>; }
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringComparer <span class="hljs-title">Create</span>(<span class="hljs-params">CultureInfo culture, <span class="hljs-built_in">bool</span> ignoreCase</span>)</span>;
</code></pre>
<p>مثال: دیکشنری حساس به حروف که <code>&quot;Joe&quot;</code> و <code>&quot;JOE&quot;</code> را برابر می‌داند:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;(StringComparer.OrdinalIgnoreCase);
</code></pre>
<p>مثال مرتب‌سازی آرایه‌ای با زبان <strong>انگلیسی استرالیا</strong>:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span>[] names = { <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;HARRY&quot;</span>, <span class="hljs-string">&quot;sheila&quot;</span> };
CultureInfo ci = <span class="hljs-keyword">new</span> CultureInfo(<span class="hljs-string">&quot;en-AU&quot;</span>);
Array.Sort&lt;<span class="hljs-built_in">string</span>&gt;(names, StringComparer.Create(ci, <span class="hljs-literal">false</span>));
</code></pre>
<p>نسخه‌ای culture-aware از <strong>SurnameComparer</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">SurnameComparer</span> : <span class="hljs-title">Comparer</span>&lt;<span class="hljs-title">string</span>&gt;
{
    StringComparer strCmp;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SurnameComparer</span>(<span class="hljs-params">CultureInfo ci</span>)</span>
    {
        <span class="hljs-comment">// ایجاد string comparer حساس به فرهنگ و حساس به حروف</span>
        strCmp = StringComparer.Create(ci, <span class="hljs-literal">false</span>);
    }

    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Normalize</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>
    {
        s = s.Trim();
        <span class="hljs-keyword">if</span> (s.ToUpper().StartsWith(<span class="hljs-string">&quot;MC&quot;</span>)) s = <span class="hljs-string">&quot;MAC&quot;</span> + s.Substring(<span class="hljs-number">2</span>);
        <span class="hljs-keyword">return</span> s;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> x, <span class="hljs-built_in">string</span> y</span>)</span>
    {
        <span class="hljs-keyword">return</span> strCmp.Compare(Normalize(x), Normalize(y));
    }
}
</code></pre>
<hr>
<h3>⚙️ IStructuralEquatable و IStructuralComparable</h3>
<p>همان‌طور که در فصل ۶ گفتیم، <strong>structها به طور پیش‌فرض</strong> مقایسه ساختاری دارند: دو struct برابر هستند اگر تمام فیلدهایشان برابر باشند.<br>
گاهی اوقات، <strong>برابری و مرتب‌سازی ساختاری</strong> برای انواع دیگر مانند آرایه‌ها نیز مفید است.</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IStructuralEquatable</span>
{
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> other, IEqualityComparer comparer</span>)</span>;
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>(<span class="hljs-params">IEqualityComparer comparer</span>)</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IStructuralComparable</span>
{
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">CompareTo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> other, IComparer comparer</span>)</span>;
}
</code></pre>
<p><strong>IEqualityComparer / IComparer</strong> که پاس داده می‌شوند، روی <strong>هر عنصر از شیء مرکب</strong> اعمال می‌شوند.</p>
<p>مثال مقایسه آرایه‌ها:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] a1 = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
<span class="hljs-built_in">int</span>[] a2 = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
IStructuralEquatable se1 = a1;

Console.Write(a1.Equals(a2));                                  <span class="hljs-comment">// False</span>
Console.Write(se1.Equals(a2, EqualityComparer&lt;<span class="hljs-built_in">int</span>&gt;.Default));  <span class="hljs-comment">// True</span>
</code></pre>
<p>مثال دیگر:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span>[] a1 = <span class="hljs-string">&quot;the quick brown fox&quot;</span>.Split();
<span class="hljs-built_in">string</span>[] a2 = <span class="hljs-string">&quot;THE QUICK BROWN FOX&quot;</span>.Split();
IStructuralEquatable se1 = a1;
<span class="hljs-built_in">bool</span> isTrue = se1.Equals(a2, StringComparer.InvariantCultureIgnoreCase);
</code></pre>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
