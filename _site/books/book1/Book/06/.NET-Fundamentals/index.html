

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>مبانی .NET</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

       <nav class="nav">
         <a href="/Gitab/" >خانه</a>
         <a href="/Gitab/books/list-books" >کتاب‌ها</a>
        <a href="/Gitab/translator.html" >مترجمین</a>
         <a href="/Gitab/giter.html" >گیتر</a>
       </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل ششم: مبانی .NET</h1>
<p>بسیاری از امکانات اصلی که هنگام برنامه‌نویسی به آن‌ها نیاز دارید، توسط خود زبان <strong>C#</strong> فراهم نمی‌شوند، بلکه توسط <strong>انواع (Types)</strong> موجود در <strong>BCL</strong> یا همان <strong>.NET Base Class Library</strong> ارائه می‌شوند.</p>
<p>در این فصل، با انواعی آشنا می‌شوید که در انجام کارهای پایه‌ای برنامه‌نویسی به شما کمک می‌کنند، مانند:</p>
<ul>
<li>مقایسه برابری مجازی (Virtual Equality Comparison)</li>
<li>مقایسه ترتیب (Order Comparison)</li>
<li>تبدیل نوع (Type Conversion)</li>
</ul>
<p>همچنین با انواع پایه‌ای <strong>.NET</strong> مانند <strong>String</strong>، <strong>DateTime</strong> و <strong>Enum</strong> نیز آشنا خواهید شد.</p>
<p>انواعی که در این بخش پوشش داده می‌شوند، بیشتر در فضای نام (<strong>Namespace</strong>) <strong>System</strong> قرار دارند، به جز موارد زیر:</p>
<ul>
<li><strong>StringBuilder</strong> و انواع مربوط به <strong>کدگذاری متن (Text Encodings)</strong> در فضای نام <strong>System.Text</strong> قرار دارند.</li>
<li><strong>CultureInfo</strong> و انواع مرتبط با آن در <strong>System.Globalization</strong> قرار دارند.</li>
<li><strong>XmlConvert</strong> در <strong>System.Xml</strong> تعریف شده است.</li>
</ul>
<hr>
<h3>مدیریت رشته و متن 📝</h3>
<h4><strong>Char</strong></h4>
<p>یک <strong>char</strong> در زبان <strong>C#</strong> نشان‌دهنده یک کاراکتر یونیکد (Unicode Character) واحد است و در واقع معادل ساختار (<strong>struct</strong>) <strong>System.Char</strong> است.</p>
<p>در فصل ۲ توضیح دادیم که چگونه <strong>لیترال‌های char</strong> را بیان کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>;
<span class="hljs-built_in">char</span> newLine = <span class="hljs-string">&#x27;\n&#x27;</span>;
</code></pre>
<p>ساختار <strong>System.Char</strong> مجموعه‌ای از متدهای <strong>static</strong> برای کار با کاراکترها ارائه می‌دهد، مانند <strong>ToUpper</strong>، <strong>ToLower</strong> و <strong>IsWhiteSpace</strong>. شما می‌توانید این متدها را هم از طریق <strong>System.Char</strong> و هم از طریق <strong>char</strong> فراخوانی کنید:</p>
<pre class="hljs"><code>Console.WriteLine (System.Char.ToUpper (<span class="hljs-string">&#x27;c&#x27;</span>));    <span class="hljs-comment">// C</span>
Console.WriteLine (<span class="hljs-built_in">char</span>.IsWhiteSpace (<span class="hljs-string">&#x27;\t&#x27;</span>));     <span class="hljs-comment">// True</span>
</code></pre>
<p>متدهای <strong>ToUpper</strong> و <strong>ToLower</strong> به <strong>محلی‌سازی (Locale)</strong> کاربر نهایی احترام می‌گذارند و این می‌تواند گاهی منجر به بروز خطاهای ظریف شود. به عنوان مثال، عبارت زیر در کشور ترکیه مقدار <strong>false</strong> را برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span>.ToUpper (<span class="hljs-string">&#x27;i&#x27;</span>) == <span class="hljs-string">&#x27;I&#x27;</span>
</code></pre>
<p>دلیل این موضوع این است که در ترکیه، نتیجه‌ی <strong>char.ToUpper ('i')</strong> برابر با <strong>'İ'</strong> است (به نقطه روی حرف توجه کنید!).</p>
<p>برای جلوگیری از این مشکل، <strong>System.Char</strong> (و همچنین <strong>System.String</strong>) نسخه‌های <strong>culture-invariant</strong> از متدهای <strong>ToUpper</strong> و <strong>ToLower</strong> را ارائه می‌دهند که با پسوند <strong>Invariant</strong> مشخص می‌شوند. این متدها همیشه از قوانین فرهنگ انگلیسی استفاده می‌کنند:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-built_in">char</span>.ToUpperInvariant (<span class="hljs-string">&#x27;i&#x27;</span>));    <span class="hljs-comment">// I</span>
</code></pre>
<p>این در واقع یک میانبر برای کد زیر است:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-built_in">char</span>.ToUpper (<span class="hljs-string">&#x27;i&#x27;</span>, CultureInfo.InvariantCulture))
</code></pre>
<p>برای اطلاعات بیشتر درباره <strong>locale</strong>‌ها و فرهنگ‌ها، به بخش <strong>Formatting and Parsing</strong> در صفحه <strong>317</strong> مراجعه کنید.</p>
<p>بیشتر متدهای <strong>static</strong> دیگر در <strong>char</strong> مربوط به <strong>دسته‌بندی کاراکترها</strong> هستند. <strong>جدول 6-1</strong> این متدها را نشان می‌دهد.</p>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>دسته‌بندی دقیق‌تر کاراکترها 🔠</h3>
<p>برای دسته‌بندی دقیق‌تر، نوع <strong>char</strong> متدی <strong>static</strong> به نام <strong>GetUnicodeCategory</strong> ارائه می‌دهد؛ این متد یک مقدار از نوع شمارش (<strong>Enumeration</strong>) <strong>UnicodeCategory</strong> برمی‌گرداند که اعضای آن در ستون سمت راست <strong>جدول 6-1</strong> نشان داده شده‌اند.</p>
<p>با <strong>Casting</strong> صریح از یک عدد صحیح (<strong>int</strong>) می‌توان یک <strong>char</strong> تولید کرد که خارج از مجموعه تخصیص‌داده‌شده‌ی یونیکد باشد. برای آزمایش اعتبار یک کاراکتر، متد <strong>char.GetUnicodeCategory</strong> را فراخوانی کنید؛ اگر نتیجه برابر با <strong>UnicodeCategory.OtherNotAssigned</strong> باشد، آن کاراکتر نامعتبر است.</p>
<p>یک <strong>char</strong> دارای پهنای <strong>16 بیت</strong> است—به اندازه‌ای که بتواند هر کاراکتر یونیکد را در <strong>Basic Multilingual Plane (BMP)</strong> نمایش دهد. برای فراتر رفتن از این محدوده، باید از <strong>Surrogate Pairs</strong> استفاده کنید؛ روش‌های انجام این کار در بخش <strong>“Text Encodings and Unicode”</strong> در صفحه <strong>301</strong> توضیح داده شده‌اند.</p>
<hr>
<h3><strong>String</strong></h3>
<p>یک <strong>string</strong> در زبان <strong>C#</strong> (یا همان <strong>System.String</strong>) دنباله‌ای از کاراکترهاست که <strong>تغییرناپذیر (Immutable)</strong> است؛ یعنی پس از ایجاد، قابل تغییر نیست. در فصل ۲ نحوه‌ی نوشتن <strong>لیترال‌های رشته‌ای (String Literals)</strong>، انجام <strong>مقایسه برابری (Equality Comparisons)</strong> و <strong>اتصال دو رشته (Concatenation)</strong> را توضیح دادیم.</p>
<p>در این بخش، به سایر قابلیت‌های کار با رشته‌ها می‌پردازیم که از طریق اعضای <strong>static</strong> و <strong>instance</strong> کلاس <strong>System.String</strong> ارائه شده‌اند.</p>
<hr>
<h3>ساخت رشته‌ها 🏗️</h3>
<p>ساده‌ترین روش ساخت یک رشته، انتساب یک <strong>لیترال</strong> است (همان‌طور که در فصل ۲ دیدیم):</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">&quot;Hello&quot;</span>;
<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">&quot;First Line\r\nSecond Line&quot;</span>;
<span class="hljs-built_in">string</span> s3 = <span class="hljs-string">@&quot;\\server\fileshare\helloworld.cs&quot;</span>;
</code></pre>
<p>برای ساخت یک توالی تکراری از کاراکترها، می‌توانید از <strong>سازنده (Constructor)</strong> رشته استفاده کنید:</p>
<pre class="hljs"><code>Console.Write (<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> (<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">10</span>));      <span class="hljs-comment">// **********</span>
</code></pre>
<p>همچنین می‌توانید یک رشته را از یک <strong>آرایه‌ی char</strong> بسازید. متد <strong>ToCharArray</strong> برعکس این کار را انجام می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span>[] ca = <span class="hljs-string">&quot;Hello&quot;</span>.ToCharArray();
<span class="hljs-built_in">string</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> (ca);              <span class="hljs-comment">// s = &quot;Hello&quot;</span>
</code></pre>
<p>سازنده‌های رشته همچنین <strong>Overload</strong> شده‌اند تا انواع مختلفی از <strong>Pointer</strong>‌های ناامن (<strong>unsafe</strong>) مانند <strong>char</strong>* را نیز بپذیرند و رشته‌هایی از این انواع بسازند.</p>
<hr>
<h3>رشته‌های تهی و خالی ⚠️</h3>
<p>یک رشته‌ی خالی (<strong>Empty String</strong>) طولی برابر با صفر دارد. برای ساخت رشته‌ی خالی می‌توانید از یک <strong>لیترال</strong> یا فیلد <strong>static</strong> به نام <strong>string.Empty</strong> استفاده کنید. برای بررسی خالی بودن یک رشته می‌توانید از مقایسه‌ی برابری یا بررسی ویژگی <strong>Length</strong> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> empty = <span class="hljs-string">&quot;&quot;</span>;
Console.WriteLine (empty == <span class="hljs-string">&quot;&quot;</span>);              <span class="hljs-comment">// True</span>
Console.WriteLine (empty == <span class="hljs-built_in">string</span>.Empty);    <span class="hljs-comment">// True</span>
Console.WriteLine (empty.Length == <span class="hljs-number">0</span>);        <span class="hljs-comment">// True</span>
</code></pre>
<p>از آن‌جایی که رشته‌ها <strong>Reference Type</strong> هستند، می‌توانند مقدار <strong>null</strong> نیز داشته باشند:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> nullString = <span class="hljs-literal">null</span>;
Console.WriteLine (nullString == <span class="hljs-literal">null</span>);        <span class="hljs-comment">// True</span>
Console.WriteLine (nullString == <span class="hljs-string">&quot;&quot;</span>);          <span class="hljs-comment">// False</span>
Console.WriteLine (nullString.Length == <span class="hljs-number">0</span>);    <span class="hljs-comment">// NullReferenceException</span>
</code></pre>
<p>متد <strong>static string.IsNullOrEmpty</strong> میانبری مفید برای بررسی این است که آیا یک رشته <strong>null</strong> یا <strong>خالی</strong> است یا خیر.</p>
<hr>
<h3>دسترسی به کاراکترهای داخل یک رشته 🔍</h3>
<p><strong>Indexer</strong> رشته یک کاراکتر را در شاخص مشخص‌شده برمی‌گرداند. همانند سایر عملیات روی رشته‌ها، شاخص‌گذاری از <strong>صفر</strong> شروع می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> str  = <span class="hljs-string">&quot;abcde&quot;</span>;
<span class="hljs-built_in">char</span> letter = str[<span class="hljs-number">1</span>];        <span class="hljs-comment">// letter == &#x27;b&#x27;</span>
</code></pre>
<p>نوع <strong>string</strong> رابط <strong>IEnumerable<char></strong> را پیاده‌سازی می‌کند، بنابراین می‌توانید با دستور <strong>foreach</strong> روی کاراکترهای آن حلقه بزنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;123&quot;</span>) Console.Write (c + <span class="hljs-string">&quot;,&quot;</span>);    <span class="hljs-comment">// 1,2,3,</span>
</code></pre>
<hr>
<h3>جستجو در رشته‌ها 🔎</h3>
<p>ساده‌ترین متدهای جستجو در رشته‌ها عبارتند از <strong>StartsWith</strong>، <strong>EndsWith</strong> و <strong>Contains</strong>. هر سه مقدار <strong>true</strong> یا <strong>false</strong> برمی‌گردانند:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-string">&quot;quick brown fox&quot;</span>.EndsWith (<span class="hljs-string">&quot;fox&quot;</span>));      <span class="hljs-comment">// True</span>
Console.WriteLine (<span class="hljs-string">&quot;quick brown fox&quot;</span>.Contains (<span class="hljs-string">&quot;brown&quot;</span>));    <span class="hljs-comment">// True</span>
</code></pre>
<p>این متدها <strong>Overload</strong> شده‌اند تا بتوانید یک <strong>StringComparison enum</strong> مشخص کنید و حساسیت نسبت به <strong>حروف کوچک و بزرگ</strong> و <strong>فرهنگ (Culture)</strong> را کنترل کنید (به بخش <strong>“Ordinal versus culture comparison”</strong> در صفحه <strong>297</strong> مراجعه کنید). حالت پیش‌فرض، یک مقایسه‌ی <strong>حساس به حروف بزرگ و کوچک</strong> با استفاده از قوانین فرهنگ جاری (محلی‌سازی شده) است. کد زیر یک جستجوی <strong>غیرحساس به حروف بزرگ و کوچک</strong> را با استفاده از قوانین فرهنگ <strong>Invariant</strong> انجام می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-string">&quot;abcdef&quot;</span>.StartsWith (<span class="hljs-string">&quot;aBc&quot;</span>, StringComparison.InvariantCultureIgnoreCase)
</code></pre>
<p>متد <strong>IndexOf</strong> موقعیت اولین وقوع یک کاراکتر یا زیررشته را برمی‌گرداند (یا <strong>−1</strong> اگر زیررشته یافت نشود):</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-string">&quot;abcde&quot;</span>.IndexOf (<span class="hljs-string">&quot;cd&quot;</span>));   <span class="hljs-comment">// 2</span>
</code></pre>
<p><strong>IndexOf</strong> همچنین <strong>Overload</strong> شده تا یک <strong>startPosition</strong> (شاخص شروع جستجو) و همچنین یک <strong>StringComparison enum</strong> را بپذیرد:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-string">&quot;abcde abcde&quot;</span>.IndexOf (<span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-number">6</span>,
                  StringComparison.CurrentCultureIgnoreCase));    <span class="hljs-comment">// 8</span>
</code></pre>
<p>متد <strong>LastIndexOf</strong> مشابه <strong>IndexOf</strong> است، با این تفاوت که از انتهای رشته به ابتدا جستجو می‌کند.</p>
<p>متد <strong>IndexOfAny</strong> اولین موقعیت یک یا چند کاراکتر مشخص را برمی‌گرداند:</p>
<pre class="hljs"><code>Console.Write (<span class="hljs-string">&quot;ab,cd ef&quot;</span>.IndexOfAny (<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] {<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>} ));       <span class="hljs-comment">// 2</span>
Console.Write (<span class="hljs-string">&quot;pas5w0rd&quot;</span>.IndexOfAny (<span class="hljs-string">&quot;0123456789&quot;</span>.ToCharArray() ));  <span class="hljs-comment">// 3</span>
</code></pre>
<p><strong>LastIndexOfAny</strong> نیز همین کار را انجام می‌دهد اما در جهت معکوس.</p>
<hr>
<h3>دستکاری رشته‌ها ✂️</h3>
<p>از آن‌جا که <strong>String</strong> تغییرناپذیر (<strong>Immutable</strong>) است، تمام متدهایی که رشته را «دستکاری» می‌کنند، در واقع یک رشته‌ی جدید برمی‌گردانند و رشته‌ی اصلی را بدون تغییر باقی می‌گذارند (این موضوع زمانی هم که یک متغیر رشته را دوباره مقداردهی می‌کنید صادق است).</p>
<hr>
<h4><strong>متد Substring</strong> – جدا کردن بخشی از رشته</h4>
<pre class="hljs"><code><span class="hljs-built_in">string</span> left3 = <span class="hljs-string">&quot;12345&quot;</span>.Substring (<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);     <span class="hljs-comment">// left3 = &quot;123&quot;;</span>
<span class="hljs-built_in">string</span> mid3  = <span class="hljs-string">&quot;12345&quot;</span>.Substring (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);     <span class="hljs-comment">// mid3 = &quot;234&quot;;</span>
</code></pre>
<p>اگر طول (<strong>length</strong>) را مشخص نکنید، باقی‌مانده‌ی رشته بازگردانده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> end3  = <span class="hljs-string">&quot;12345&quot;</span>.Substring (<span class="hljs-number">2</span>);        <span class="hljs-comment">// end3 = &quot;345&quot;;</span>
</code></pre>
<hr>
<h4><strong>متدهای Insert و Remove</strong> – درج یا حذف کاراکتر</h4>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">&quot;helloworld&quot;</span>.Insert (<span class="hljs-number">5</span>, <span class="hljs-string">&quot;, &quot;</span>);    <span class="hljs-comment">// s1 = &quot;hello, world&quot;</span>
<span class="hljs-built_in">string</span> s2 = s1.Remove (<span class="hljs-number">5</span>, <span class="hljs-number">2</span>);                 <span class="hljs-comment">// s2 = &quot;helloworld&quot;;</span>
</code></pre>
<hr>
<h4><strong>PadLeft و PadRight</strong> – پر کردن رشته</h4>
<p>این متدها رشته را تا طول مشخصی با کاراکتر دلخواه (یا اگر مشخص نشود، با فاصله) پر می‌کنند:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-string">&quot;12345&quot;</span>.PadLeft (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;*&#x27;</span>));  <span class="hljs-comment">// ****12345</span>
Console.WriteLine (<span class="hljs-string">&quot;12345&quot;</span>.PadLeft (<span class="hljs-number">9</span>));       <span class="hljs-comment">//     12345</span>
</code></pre>
<p>اگر طول مشخص‌شده کوتاه‌تر از طول رشته باشد، رشته‌ی اصلی بدون تغییر برگردانده می‌شود.</p>
<hr>
<h4><strong>TrimStart، TrimEnd و Trim</strong> – حذف کاراکترهای اضافی</h4>
<p>این متدها کاراکترهای مشخص‌شده را از ابتدای رشته (<strong>TrimStart</strong>) یا انتهای رشته (<strong>TrimEnd</strong>) حذف می‌کنند؛ <strong>Trim</strong> هر دو را انجام می‌دهد. به‌طور پیش‌فرض، این متدها فاصله‌ها و کاراکترهای خالی (<strong>Whitespace</strong>) مانند فاصله، تب، خطوط جدید و نسخه‌های یونیکد این‌ها را حذف می‌کنند:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-string">&quot;  abc \t\r\n &quot;</span>.Trim().Length);   <span class="hljs-comment">// 3</span>
</code></pre>
<hr>
<h4><strong>Replace</strong> – جایگزینی کاراکتر یا زیررشته</h4>
<p>این متد تمام (غیرهم‌پوشان) رخدادهای یک کاراکتر یا زیررشته را جایگزین می‌کند:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-string">&quot;to be done&quot;</span>.Replace (<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot; | &quot;</span>) );  <span class="hljs-comment">// to | be | done</span>
Console.WriteLine (<span class="hljs-string">&quot;to be done&quot;</span>.Replace (<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>)    );  <span class="hljs-comment">// tobedone</span>
</code></pre>
<hr>
<h4><strong>ToUpper و ToLower</strong> – تبدیل به حروف بزرگ یا کوچک</h4>
<p>این متدها نسخه‌ی حروف بزرگ و کوچک رشته را برمی‌گردانند. به‌طور پیش‌فرض، به <strong>تنظیمات زبان جاری کاربر</strong> احترام می‌گذارند؛ در حالی که <strong>ToUpperInvariant</strong> و <strong>ToLowerInvariant</strong> همیشه از قوانین حروف الفبای انگلیسی استفاده می‌کنند.</p>
<hr>
<h3>تقسیم و اتصال رشته‌ها 🔗</h3>
<h4><strong>Split</strong> – تقسیم رشته</h4>
<p>متد <strong>Split</strong> یک رشته را به بخش‌هایی تقسیم می‌کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span>[] words = <span class="hljs-string">&quot;The quick brown fox&quot;</span>.Split();
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> word <span class="hljs-keyword">in</span> words)
    Console.Write (word + <span class="hljs-string">&quot;|&quot;</span>);    <span class="hljs-comment">// The|quick|brown|fox|</span>
</code></pre>
<p>به‌طور پیش‌فرض، <strong>Split</strong> از کاراکترهای فاصله به‌عنوان جداکننده استفاده می‌کند. این متد همچنین <strong>Overload</strong> شده تا یک آرایه‌ی <strong>params</strong> از <strong>char</strong> یا <strong>string</strong>‌های جداکننده بپذیرد. همچنین می‌تواند یک <strong>StringSplitOptions enum</strong> دریافت کند که گزینه‌ای برای حذف ورودی‌های خالی دارد؛ این قابلیت زمانی مفید است که کلمات با چندین جداکننده‌ی پشت‌سرهم از هم جدا شده باشند.</p>
<hr>
<h4><strong>Join و Concat</strong> – اتصال رشته‌ها</h4>
<p>متد <strong>Join</strong> عکس <strong>Split</strong> عمل می‌کند. این متد به یک جداکننده و یک آرایه‌ی رشته نیاز دارد:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span>[] words = <span class="hljs-string">&quot;The quick brown fox&quot;</span>.Split();
<span class="hljs-built_in">string</span> together = <span class="hljs-built_in">string</span>.Join (<span class="hljs-string">&quot; &quot;</span>, words);      <span class="hljs-comment">// The quick brown fox</span>
</code></pre>
<p>متد <strong>Concat</strong> مشابه <strong>Join</strong> است اما تنها یک آرایه‌ی رشته به‌صورت <strong>params</strong> می‌پذیرد و جداکننده‌ای اعمال نمی‌کند. <strong>Concat</strong> دقیقاً معادل عملگر <strong>+</strong> است (در واقع کامپایلر <strong>+</strong> را به <strong>Concat</strong> تبدیل می‌کند):</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> sentence     = <span class="hljs-built_in">string</span>.Concat (<span class="hljs-string">&quot;The&quot;</span>, <span class="hljs-string">&quot; quick&quot;</span>, <span class="hljs-string">&quot; brown&quot;</span>, <span class="hljs-string">&quot; fox&quot;</span>);
<span class="hljs-built_in">string</span> sameSentence = <span class="hljs-string">&quot;The&quot;</span> + <span class="hljs-string">&quot; quick&quot;</span> + <span class="hljs-string">&quot; brown&quot;</span> + <span class="hljs-string">&quot; fox&quot;</span>;
</code></pre>
<hr>
<h3><strong>String.Format</strong> و رشته‌های ترکیبی</h3>
<p>متد <strong>static Format</strong> راهی راحت برای ساخت رشته‌هایی است که در آن‌ها مقادیر متغیرها گنجانده می‌شوند. این مقادیر می‌توانند از هر نوعی باشند؛ <strong>Format</strong> تنها متد <strong>ToString</strong> را روی آن‌ها صدا می‌زند.</p>
<p>رشته‌ای که شامل متغیرهای جاسازی‌شده است، <strong>رشته‌ی قالب ترکیبی (Composite Format String)</strong> نام دارد. هنگام فراخوانی <strong>String.Format</strong>، شما رشته‌ی قالب ترکیبی را به همراه هر یک از متغیرها ارسال می‌کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> composite = <span class="hljs-string">&quot;It&#x27;s {0} degrees in {1} on this {2} morning&quot;</span>;
<span class="hljs-built_in">string</span> s = <span class="hljs-built_in">string</span>.Format (composite, <span class="hljs-number">35</span>, <span class="hljs-string">&quot;Perth&quot;</span>, DateTime.Now.DayOfWeek);
<span class="hljs-comment">// s == &quot;It&#x27;s 35 degrees in Perth on this Friday morning&quot;</span>
</code></pre>
<p>(و این دما <strong>سلسیوس</strong> است!)</p>
<p>ما می‌توانیم از <strong>رشته‌های درون‌یابی‌شده (Interpolated String Literals)</strong> هم برای همین کار استفاده کنیم (به بخش <strong>“String Type”</strong> در صفحه <strong>58</strong> مراجعه کنید). کافی است رشته را با علامت <strong>$</strong> شروع کرده و عبارات را داخل آکولاد قرار دهید:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">$&quot;It&#x27;s hot this <span class="hljs-subst">{DateTime.Now.DayOfWeek}</span> morning&quot;</span>;
</code></pre>
<hr>
<p>هر عدد داخل آکولاد <strong>آیتم قالب (Format Item)</strong> نامیده می‌شود. این عدد به <strong>موقعیت آرگومان</strong> مربوط است و می‌تواند به‌صورت اختیاری موارد زیر را دنبال کند:</p>
<ul>
<li><strong>ویرگول و حداقل عرض (Minimum Width)</strong></li>
<li><strong>دو‌نقطه و یک رشته‌ی قالب (Format String)</strong></li>
</ul>
<p>حداقل عرض برای <strong>تراز کردن ستون‌ها</strong> مفید است. اگر مقدار <strong>منفی</strong> باشد، داده به‌صورت <strong>چپ‌چین</strong> قرار می‌گیرد؛ در غیر این صورت <strong>راست‌چین</strong> خواهد شد:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> composite = <span class="hljs-string">&quot;Name={0,-20} Credit Limit={1,15:C}&quot;</span>;
Console.WriteLine (<span class="hljs-built_in">string</span>.Format (composite, <span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-number">500</span>));
Console.WriteLine (<span class="hljs-built_in">string</span>.Format (composite, <span class="hljs-string">&quot;Elizabeth&quot;</span>, <span class="hljs-number">20000</span>));
</code></pre>
<p>نتیجه:</p>
<pre class="hljs"><code>Name=Mary                 Credit Limit=        $500.00
Name=Elizabeth            Credit Limit=     $20,000.00
</code></pre>
<p>معادل همین بدون استفاده از <strong>string.Format</strong>:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;Name=&quot;</span> + <span class="hljs-string">&quot;Mary&quot;</span>.PadRight (<span class="hljs-number">20</span>) +
           <span class="hljs-string">&quot; Credit Limit=&quot;</span> + <span class="hljs-number">500.</span>ToString (<span class="hljs-string">&quot;C&quot;</span>).PadLeft (<span class="hljs-number">15</span>);
</code></pre>
<p>محدودیت اعتبار (<strong>Credit Limit</strong>) به‌واسطه‌ی رشته‌ی قالب <strong>&quot;C&quot;</strong> به‌صورت واحد پولی فرمت شده است. جزئیات رشته‌های قالب را در بخش <strong>“Formatting and Parsing”</strong> در صفحه <strong>317</strong> شرح داده‌ایم.</p>
<hr>
<h3>مقایسه‌ی رشته‌ها 🔠</h3>
<p>هنگام مقایسه‌ی دو مقدار، <a href="http://xn--2ug.NET">‎.NET</a> بین دو مفهوم <strong>مقایسه‌ی برابری (Equality Comparison)</strong> و <strong>مقایسه‌ی ترتیب (Order Comparison)</strong> تفاوت قائل می‌شود.</p>
<ul>
<li><strong>مقایسه‌ی برابری</strong> بررسی می‌کند که آیا دو نمونه از نظر معنایی یکسان هستند یا نه.</li>
<li><strong>مقایسه‌ی ترتیب</strong> مشخص می‌کند کدام‌یک از دو نمونه (در صورت وجود تفاوت) در هنگام مرتب‌سازی به ترتیب صعودی یا نزولی، زودتر یا دیرتر قرار می‌گیرد.</li>
</ul>
<p>نکته‌ی مهم این است که <strong>مقایسه‌ی برابری زیرمجموعه‌ای از مقایسه‌ی ترتیب نیست</strong>؛ هر کدام هدف متفاوتی دارند. برای مثال، امکان دارد دو مقدار نابرابر در یک موقعیت ترتیب‌دهی مشابه قرار بگیرند. در بخش <strong>“Equality Comparison” در صفحه‌ی 226</strong> دوباره به این موضوع بازمی‌گردیم.</p>
<p>برای مقایسه‌ی برابری رشته‌ها می‌توانید از <strong>عملگر ==</strong> یا یکی از <strong>متدهای Equals</strong> در نوع رشته استفاده کنید. متدهای Equals انعطاف‌پذیرتر هستند زیرا اجازه می‌دهند گزینه‌هایی مانند <strong>بی‌تفاوتی به حروف کوچک و بزرگ (Case Insensitivity)</strong> را مشخص کنید.</p>
<p>یک تفاوت دیگر این است که <strong>عملگر ==</strong> روی رشته‌ها زمانی که متغیرها به نوع <strong>object</strong> تبدیل (Cast) شوند به‌طور قابل‌اعتماد عمل نمی‌کند. دلیل این موضوع را در <strong>“Equality Comparison” صفحه‌ی 226</strong> توضیح خواهیم داد.</p>
<p>برای مقایسه‌ی ترتیب رشته‌ها می‌توانید از <strong>متد CompareTo</strong> (نمونه‌ای یا Instance) یا متدهای استاتیک <strong>Compare</strong> و <strong>CompareOrdinal</strong> استفاده کنید. این متدها یک عدد مثبت، منفی یا صفر برمی‌گردانند که نشان می‌دهد مقدار اول بعد از، قبل از یا هم‌تراز مقدار دوم قرار می‌گیرد.</p>
<p>قبل از بررسی جزئیات هرکدام، لازم است با الگوریتم‌های مقایسه‌ی رشته‌ای <a href="http://xn--2ug.NET">‎.NET</a> آشنا شویم.</p>
<hr>
<h3>مقایسه‌ی ترتیبی (Ordinal) در برابر مقایسه‌ی مبتنی بر فرهنگ (Culture) 🌍</h3>
<p>دو الگوریتم اصلی برای مقایسه‌ی رشته‌ها وجود دارد:</p>
<ol>
<li><strong>Ordinal (ترتیبی)</strong>: کاراکترها را صرفاً به‌عنوان عدد (بر اساس مقدار عددی یونیکد آن‌ها) تفسیر می‌کند.</li>
<li><strong>Culture-Sensitive (حساس به فرهنگ)</strong>: کاراکترها را با توجه به الفبای یک فرهنگ خاص تفسیر می‌کند.</li>
</ol>
<p>دو فرهنگ خاص در <a href="http://xn--2ug.NET">‎.NET</a> وجود دارد:</p>
<ul>
<li><strong>Current Culture (فرهنگ فعلی)</strong>: براساس تنظیمات زبان و منطقه‌ای که از <strong>Control Panel</strong> رایانه گرفته شده است.</li>
<li><strong>Invariant Culture (فرهنگ ثابت)</strong>: در همه‌ی رایانه‌ها یکسان است (و تقریباً معادل فرهنگ انگلیسی آمریکایی است).</li>
</ul>
<p>برای <strong>مقایسه‌ی برابری</strong>، هر دو الگوریتم ترتیبی و حساس به فرهنگ کاربرد دارند.<br>
اما برای <strong>مرتب‌سازی</strong> تقریباً همیشه مقایسه‌ی حساس به فرهنگ ترجیح داده می‌شود، چون برای مرتب‌سازی الفبایی به یک الفبا نیاز است. الگوریتم ترتیبی صرفاً به مقادیر یونیکد تکیه دارد، که حروف انگلیسی را به ترتیب الفبایی قرار می‌دهد، ولی دقیقاً همان‌طور که انتظار دارید نیست.</p>
<p>برای مثال، فرض کنید حساسیت به بزرگی و کوچکی حروف فعال است و رشته‌های زیر را داریم:</p>
<ul>
<li><code>&quot;Atom&quot;</code></li>
<li><code>&quot;atom&quot;</code></li>
<li><code>&quot;Zamia&quot;</code></li>
</ul>
<p>فرهنگ ثابت (Invariant) آن‌ها را به این ترتیب مرتب می‌کند:</p>
<pre class="hljs"><code>&quot;atom&quot;, &quot;Atom&quot;, &quot;Zamia&quot;
</code></pre>
<p>اما الگوریتم ترتیبی (Ordinal) نتیجه‌ی زیر را تولید می‌کند:</p>
<pre class="hljs"><code>&quot;Atom&quot;, &quot;Zamia&quot;, &quot;atom&quot;
</code></pre>
<p>دلیل این تفاوت این است که فرهنگ ثابت حروف کوچک و بزرگ را در کنار هم قرار می‌دهد (aA bB cC ...)، ولی الگوریتم ترتیبی همه‌ی حروف بزرگ را ابتدا و سپس همه‌ی حروف کوچک را قرار می‌دهد (A...Z, a...z). این رفتار در واقع برگرفته از <strong>مجموعه‌کاراکتر ASCII</strong> است که در دهه‌ی 1960 ساخته شده بود.</p>
<hr>
<h3>مقایسه‌ی برابری رشته‌ها ✍️</h3>
<p>با وجود محدودیت‌های الگوریتم ترتیبی، <strong>عملگر == در رشته‌ها همیشه از مقایسه‌ی ترتیبی حساس به بزرگی حروف استفاده می‌کند</strong>. همین‌طور، متد نمونه‌ای <strong>string.Equals</strong> وقتی بدون آرگومان فراخوانی شود نیز همین رفتار پیش‌فرض را دارد.</p>
<p>این الگوریتم برای == و Equals انتخاب شده زیرا:</p>
<ul>
<li>بسیار سریع و کارآمد است.</li>
<li>نتیجه‌ی قطعی و قابل پیش‌بینی دارد.</li>
<li>مقایسه‌ی برابری یک عملیات بنیادی است و بسیار بیشتر از مقایسه‌ی ترتیب استفاده می‌شود.</li>
<li>استفاده از == به‌طور کلی با مفهوم برابری دقیق هم‌خوانی دارد.</li>
</ul>
<p>برای مقایسه‌های آگاه به فرهنگ یا بی‌تفاوت به بزرگی حروف، متدهای زیر وجود دارند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span>, StringComparison comparisonType</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b, StringComparison comparisonType</span>)</span>;
</code></pre>
<p>نسخه‌ی استاتیک حتی زمانی که یکی یا هر دو رشته null باشند نیز به درستی کار می‌کند.<br>
<strong>StringComparison</strong> یک <strong>Enum</strong> است که به‌صورت زیر تعریف شده است:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> StringComparison
{
    CurrentCulture,               <span class="hljs-comment">// حساس به بزرگی حروف</span>
    CurrentCultureIgnoreCase,
    InvariantCulture,             <span class="hljs-comment">// حساس به بزرگی حروف</span>
    InvariantCultureIgnoreCase,
    Ordinal,                      <span class="hljs-comment">// حساس به بزرگی حروف</span>
    OrdinalIgnoreCase
}
</code></pre>
<p>مثال‌ها:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-built_in">string</span>.Equals (<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;FOO&quot;</span>,
                   StringComparison.OrdinalIgnoreCase));   <span class="hljs-comment">// True</span>

Console.WriteLine (<span class="hljs-string">&quot;ṻ&quot;</span> == <span class="hljs-string">&quot;ǖ&quot;</span>);                            <span class="hljs-comment">// False</span>

Console.WriteLine (<span class="hljs-built_in">string</span>.Equals (<span class="hljs-string">&quot;ṻ&quot;</span>, <span class="hljs-string">&quot;ǖ&quot;</span>,
                   StringComparison.CurrentCulture));      <span class="hljs-comment">// ?</span>
</code></pre>
<p>(نتیجه‌ی مثال سوم بستگی به تنظیمات زبان فعلی رایانه دارد.)</p>
<hr>
<h3>مقایسه‌ی ترتیب رشته‌ها 📊</h3>
<p>متد <strong>CompareTo</strong> (نمونه‌ای) روی رشته‌ها یک <strong>مقایسه‌ی حساس به فرهنگ و حساس به بزرگی حروف</strong> انجام می‌دهد. برخلاف عملگر ==، این متد از مقایسه‌ی ترتیبی استفاده نمی‌کند، چون برای مرتب‌سازی، مقایسه‌ی حساس به فرهنگ مفیدتر است.</p>
<p>تعریف متد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CompareTo</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> strB</span>)</span>;
</code></pre>
<p>این متد رابط <strong>IComparable</strong> را پیاده‌سازی می‌کند که یک پروتکل استاندارد مقایسه در کتابخانه‌های <a href="http://xn--2ug.NET">‎.NET</a> است. بنابراین متد CompareTo <strong>رفتار پیش‌فرض مرتب‌سازی رشته‌ها</strong> را در کاربردهایی مثل مجموعه‌های مرتب‌شده تعریف می‌کند.<br>
برای اطلاعات بیشتر درباره‌ی <strong>IComparable</strong> به بخش <strong>“Order Comparison” در صفحه‌ی 355</strong> مراجعه کنید.</p>
<p>برای سایر انواع مقایسه، متدهای استاتیک زیر نیز وجود دارند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> strA, <span class="hljs-built_in">string</span> strB,
                           StringComparison comparisonType</span>)</span>;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> strA, <span class="hljs-built_in">string</span> strB, <span class="hljs-built_in">bool</span> ignoreCase,
                           CultureInfo culture</span>)</span>;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> strA, <span class="hljs-built_in">string</span> strB, <span class="hljs-built_in">bool</span> ignoreCase</span>)</span>;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CompareOrdinal</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> strA, <span class="hljs-built_in">string</span> strB</span>)</span>;
</code></pre>
<p>دو متد آخر در واقع میان‌بری برای فراخوانی دو متد اول هستند.</p>
<p>تمام متدهای مقایسه‌ی ترتیب، عددی <strong>مثبت</strong>، <strong>منفی</strong> یا <strong>صفر</strong> برمی‌گردانند که نشان‌دهنده‌ی ترتیب دو مقدار است:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-string">&quot;Boston&quot;</span>.CompareTo (<span class="hljs-string">&quot;Austin&quot;</span>));    <span class="hljs-comment">// 1</span>
Console.WriteLine (<span class="hljs-string">&quot;Boston&quot;</span>.CompareTo (<span class="hljs-string">&quot;Boston&quot;</span>));    <span class="hljs-comment">// 0</span>
Console.WriteLine (<span class="hljs-string">&quot;Boston&quot;</span>.CompareTo (<span class="hljs-string">&quot;Chicago&quot;</span>));   <span class="hljs-comment">// -1</span>
Console.WriteLine (<span class="hljs-string">&quot;ṻ&quot;</span>.CompareTo (<span class="hljs-string">&quot;ǖ&quot;</span>));              <span class="hljs-comment">// 1</span>
Console.WriteLine (<span class="hljs-string">&quot;foo&quot;</span>.CompareTo (<span class="hljs-string">&quot;FOO&quot;</span>));          <span class="hljs-comment">// -1</span>
</code></pre>
<p>برای انجام یک مقایسه‌ی بی‌تفاوت به بزرگی حروف با فرهنگ فعلی:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-built_in">string</span>.Compare (<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-literal">true</span>));   <span class="hljs-comment">// 0</span>
</code></pre>
<p>با ارائه‌ی یک شیء <strong>CultureInfo</strong>، می‌توانید هر الفبای دلخواهی را وارد کنید:</p>
<pre class="hljs"><code><span class="hljs-comment">// CultureInfo در فضای نام System.Globalization تعریف شده است</span>
CultureInfo german = CultureInfo.GetCultureInfo (<span class="hljs-string">&quot;de-DE&quot;</span>);
<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">string</span>.Compare (<span class="hljs-string">&quot;Müller&quot;</span>, <span class="hljs-string">&quot;Muller&quot;</span>, <span class="hljs-literal">false</span>, german);
</code></pre>
<hr>
<h3>🔠 <strong>StringBuilder (رشته‌ساز)</strong></h3>
<p>کلاس <strong>StringBuilder</strong> در فضای نام <strong>System.Text</strong> نشان‌دهنده‌ی یک رشته‌ی <strong>قابل‌تغییر (Mutable)</strong> است. یعنی می‌توان آن را ویرایش کرد. با استفاده از <strong>StringBuilder</strong> می‌توانید بخش‌هایی از متن را <strong>اضافه (Append)</strong>، <strong>درج (Insert)</strong>، <strong>حذف (Remove)</strong> یا <strong>جایگزین (Replace)</strong> کنید، بدون این‌که نیاز باشد کل رشته را دوباره بسازید.</p>
<p>سازنده‌ی <strong>StringBuilder</strong> (Constructor) می‌تواند به‌صورت اختیاری یک مقدار اولیه‌ی رشته و همچنین اندازه‌ی شروع ظرفیت داخلی را دریافت کند (ظرفیت پیش‌فرض برابر با <strong>۱۶ کاراکتر</strong> است). اگر اندازه‌ی رشته از این ظرفیت فراتر رود، <strong>StringBuilder</strong> به‌صورت خودکار ساختار داخلی خود را برای جا دادن داده‌های جدید تغییر اندازه می‌دهد (با اندکی کاهش کارایی) تا زمانی که به حداکثر ظرفیت خود برسد (پیش‌فرض برابر با <strong>int.MaxValue</strong> است).</p>
<p>یکی از استفاده‌های رایج <strong>StringBuilder</strong>، ساخت یک رشته‌ی طولانی با اضافه‌کردن مداوم بخش‌های جدید است. این روش <strong>بسیار سریع‌تر و بهینه‌تر</strong> از چسباندن (Concatenate) رشته‌های معمولی است:</p>
<pre class="hljs"><code>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) sb.Append(i).Append(<span class="hljs-string">&quot;,&quot;</span>);
Console.WriteLine(sb.ToString());
</code></pre>
<p>خروجی:</p>
<pre class="hljs"><code>0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,
27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,
</code></pre>
<p>برای گرفتن نتیجه‌ی نهایی، از متد <strong>ToString()</strong> استفاده می‌کنیم.</p>
<ul>
<li><strong>AppendLine</strong> همانند Append عمل می‌کند، با این تفاوت که در انتها یک خط جدید (<code>&quot;\r\n&quot;</code> در ویندوز) اضافه می‌کند.</li>
<li><strong>AppendFormat</strong> یک رشته‌ی قالب‌بندی شده را مشابه <strong>String.Format</strong> اضافه می‌کند.</li>
</ul>
<p>علاوه بر متدهای <strong>Insert</strong>، <strong>Remove</strong> و <strong>Replace</strong> (که Replace مشابه Replace در کلاس string عمل می‌کند)، کلاس <strong>StringBuilder</strong> ویژگی‌های زیر را دارد:</p>
<ul>
<li>ویژگی <strong>Length</strong> برای گرفتن یا تنظیم طول رشته.</li>
<li>یک <strong>ایندکسر قابل‌نوشتن</strong> برای گرفتن یا تغییر کاراکترهای جداگانه.</li>
</ul>
<p>برای پاک‌کردن محتوای یک <strong>StringBuilder</strong>، می‌توانید یکی از دو روش زیر را استفاده کنید:</p>
<ol>
<li>ایجاد یک نمونه‌ی جدید.</li>
<li>قرار دادن مقدار <strong>Length</strong> برابر با صفر.</li>
</ol>
<blockquote>
<p>⚠️ توجه: تنظیم <strong>Length = 0</strong> ظرفیت داخلی را کاهش نمی‌دهد. یعنی اگر رشته‌ی شما قبلاً یک میلیون کاراکتر داشته باشد، پس از صفر کردن طول، همچنان حدود <strong>۲ مگابایت حافظه</strong> اشغال خواهد کرد. برای آزادسازی حافظه باید یک <strong>StringBuilder</strong> جدید ایجاد کنید و نمونه‌ی قبلی را از محدوده‌ی استفاده خارج کنید (تا توسط <strong>Garbage Collector</strong> حذف شود).</p>
</blockquote>
<hr>
<h3>🌐 <strong>کدگذاری متن و یونیکد (Text Encodings and Unicode)</strong></h3>
<p><strong>مجموعه‌کاراکتر (Character Set)</strong> مجموعه‌ای از کاراکترهاست که هر کدام یک <strong>کد عددی (Code Point)</strong> دارند. دو مجموعه‌کاراکتر رایج عبارت‌اند از:</p>
<ul>
<li><strong>Unicode (یونیکد)</strong>: دارای فضای آدرس‌دهی حدود <strong>۱ میلیون کاراکتر</strong> است که تقریباً <strong>۱۰۰٬۰۰۰ کاراکتر</strong> تاکنون تخصیص یافته‌اند. این مجموعه شامل اکثر زبان‌های گفتاری دنیا، برخی زبان‌های تاریخی و نمادهای خاص است.</li>
<li><strong>ASCII (اَسکی)</strong>: شامل <strong>۱۲۸ کاراکتر اول</strong> مجموعه‌ی یونیکد است که عمدتاً کاراکترهای موجود روی صفحه‌کلیدهای آمریکایی را پوشش می‌دهد. ASCII حدود <strong>۳۰ سال</strong> قبل از یونیکد معرفی شده و هنوز هم به‌دلیل سادگی و کارایی استفاده می‌شود (هر کاراکتر یک <strong>بایت</strong> است).</li>
</ul>
<p>سیستم تایپ در <strong>.NET</strong> برای کار با <strong>یونیکد</strong> طراحی شده است. با این حال، چون ASCII زیرمجموعه‌ای از یونیکد است، به‌صورت ضمنی پشتیبانی می‌شود.</p>
<p><strong>کدگذاری متن (Text Encoding)</strong> وظیفه دارد کاراکترها را از <strong>کد عددی (Code Point)</strong> به <strong>نمایش دودویی (Binary)</strong> و بالعکس تبدیل کند. در <strong>.NET</strong>، کدگذاری‌ها بیشتر هنگام کار با فایل‌های متنی یا جریان‌های داده (Streams) استفاده می‌شوند. برای مثال، وقتی یک فایل متنی را به رشته تبدیل می‌کنید، <strong>Encoder</strong> داده‌های باینری را به نمایش داخلی یونیکد که انواع <strong>char</strong> و <strong>string</strong> نیاز دارند، تبدیل می‌کند.</p>
<p>کدگذاری‌ها می‌توانند تعیین کنند:</p>
<ul>
<li>چه کاراکترهایی قابل نمایش هستند.</li>
<li>چقدر فضا برای ذخیره‌سازی نیاز است.</li>
</ul>
<p>در .NET دو دسته اصلی از کدگذاری‌ها وجود دارد:</p>
<ol>
<li>
<p><strong>کدگذاری‌هایی که کاراکترهای یونیکد را به یک مجموعه‌کاراکتر دیگر نگاشت می‌کنند</strong></p>
<ul>
<li>شامل کدگذاری‌های قدیمی مثل <strong>EBCDIC</strong> شرکت IBM و مجموعه‌های ۸ بیتی که قبل از یونیکد رایج بودند (شناخته‌شده به‌وسیله‌ی <strong>Code Page</strong>).</li>
<li><strong>ASCII</strong> نیز در این دسته قرار می‌گیرد: تنها ۱۲۸ کاراکتر اول را پشتیبانی می‌کند و باقی را حذف می‌کند.</li>
<li><strong>GB18030</strong> نیز در این دسته است و از سال ۲۰۰۰ به‌عنوان استاندارد اجباری برای نرم‌افزارهای مورد استفاده یا فروخته‌شده در چین معرفی شد.</li>
</ul>
</li>
<li>
<p><strong>کدگذاری‌هایی که از طرح‌های استاندارد یونیکد استفاده می‌کنند</strong></p>
<ul>
<li>
<p>شامل <strong>UTF-8</strong>، <strong>UTF-16</strong> و <strong>UTF-32</strong> (و <strong>UTF-7</strong> قدیمی).</p>
</li>
<li>
<p>هر کدام از نظر فضای ذخیره‌سازی متفاوت‌اند:</p>
<ul>
<li><strong>UTF-8</strong>: بین ۱ تا ۴ بایت برای هر کاراکتر. ۱۲۸ کاراکتر اول فقط ۱ بایت می‌گیرند (سازگار با ASCII). پرکاربردترین کدگذاری، مخصوصاً در اینترنت، و پیش‌فرض بسیاری از عملیات <strong>I/O</strong> در .NET است.</li>
<li><strong>UTF-16</strong>: از یک یا دو واژه‌ی ۱۶ بیتی برای هر کاراکتر استفاده می‌کند. این همان قالب داخلی .NET برای نمایش رشته‌ها و کاراکترهاست.</li>
<li><strong>UTF-32</strong>: ناکارآمدترین از نظر فضا؛ هر کاراکتر دقیقاً <strong>۴ بایت</strong> می‌گیرد. به‌ندرت استفاده می‌شود اما برای دسترسی تصادفی به کاراکترها بسیار ساده است.</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3>🔑 <strong>دریافت یک شیء Encoding</strong></h3>
<p>کلاس <strong>Encoding</strong> در فضای نام <strong>System.Text</strong>، پایه‌ی مشترک تمام کلاس‌های مرتبط با کدگذاری است. این کلاس چند زیرکلاس دارد که خانواده‌های مختلف کدگذاری را پیاده‌سازی می‌کنند. رایج‌ترین کدگذاری‌ها از طریق ویژگی‌های <strong>استاتیک (Static Properties)</strong> کلاس <strong>Encoding</strong> در دسترس هستند.</p>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>به‌دست آوردن سایر Encodingها 🎛️</h3>
<p>می‌توانید با استفاده از متد <strong>Encoding.GetEncoding</strong> و وارد کردن یک نام استاندارد کاراکترست از <strong>Internet Assigned Numbers Authority (IANA)</strong> سایر Encodingها را به‌دست آورید:</p>
<pre class="hljs"><code><span class="hljs-comment">// در .NET 5+ و .NET Core، ابتدا باید RegisterProvider را فراخوانی کنید:</span>
Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
Encoding chinese = Encoding.GetEncoding(<span class="hljs-string">&quot;GB18030&quot;</span>);
</code></pre>
<p>متد ایستای <strong>GetEncodings</strong> فهرستی از تمام Encodingهای پشتیبانی‌شده را همراه با نام‌های استاندارد IANA برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (EncodingInfo info <span class="hljs-keyword">in</span> Encoding.GetEncodings())
    Console.WriteLine(info.Name);
</code></pre>
<p>روش دیگر برای به‌دست آوردن یک Encoding این است که مستقیماً یک کلاس Encoding را نمونه‌سازی کنید. این کار به شما اجازه می‌دهد گزینه‌های مختلفی را از طریق آرگومان‌های سازنده مشخص کنید، از جمله:</p>
<ul>
<li>آیا در صورت مواجهه با دنباله بایت نامعتبر در هنگام Decode کردن، استثنا (Exception) پرتاب شود یا خیر. مقدار پیش‌فرض <strong>false</strong> است.</li>
<li>آیا UTF-16/UTF-32 با بایت‌های پرارزش‌تر در ابتدا (<strong>big endian</strong>) یا بایت‌های کم‌ارزش‌تر در ابتدا (<strong>little endian</strong>) رمزگذاری/رمزگشایی شوند. مقدار پیش‌فرض <strong>little endian</strong> است که استاندارد سیستم‌عامل ویندوز محسوب می‌شود.</li>
<li>آیا یک <strong>Byte-Order Mark (BOM)</strong> یا همان پیشوند نشان‌دهنده نوع Endianness صادر شود یا خیر.</li>
</ul>
<hr>
<h3>Encoding برای فایل‌ها و جریان‌ها (File و Stream I/O) 📂</h3>
<p>رایج‌ترین کاربرد یک شیء Encoding کنترل نحوه خواندن و نوشتن متن در فایل یا جریان است. برای مثال، کد زیر رشته <code>&quot;Testing...&quot;</code> را در فایلی به نام <strong>data.txt</strong> با Encoding <strong>UTF-16</strong> می‌نویسد:</p>
<pre class="hljs"><code>System.IO.File.WriteAllText(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;Testing...&quot;</span>, Encoding.Unicode);
</code></pre>
<p>اگر آرگومان نهایی را حذف کنید، <strong>WriteAllText</strong> از <strong>UTF-8</strong> استفاده می‌کند که رایج‌ترین و پیش‌فرض Encoding برای تمام عملیات فایل و جریان است.</p>
<p>ما در فصل ۱۵، در بخش <strong>“Stream Adapters”</strong> در صفحه 709 دوباره به این موضوع بازخواهیم گشت.</p>
<hr>
<h3>Encoding برای آرایه‌های بایتی 💾</h3>
<p>می‌توانید از یک شیء Encoding برای تبدیل بین <strong>string</strong> و <strong>byte[]</strong> استفاده کنید.</p>
<ul>
<li>متد <strong>GetBytes</strong> از string به byte[] تبدیل می‌کند.</li>
<li>متد <strong>GetString</strong> برعکس عمل می‌کند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">byte</span>[] utf8Bytes  = System.Text.Encoding.UTF8.GetBytes(<span class="hljs-string">&quot;0123456789&quot;</span>);
<span class="hljs-built_in">byte</span>[] utf16Bytes = System.Text.Encoding.Unicode.GetBytes(<span class="hljs-string">&quot;0123456789&quot;</span>);
<span class="hljs-built_in">byte</span>[] utf32Bytes = System.Text.Encoding.UTF32.GetBytes(<span class="hljs-string">&quot;0123456789&quot;</span>);

Console.WriteLine(utf8Bytes.Length);   <span class="hljs-comment">// 10</span>
Console.WriteLine(utf16Bytes.Length);  <span class="hljs-comment">// 20</span>
Console.WriteLine(utf32Bytes.Length);  <span class="hljs-comment">// 40</span>

<span class="hljs-built_in">string</span> original1 = System.Text.Encoding.UTF8.GetString(utf8Bytes);
<span class="hljs-built_in">string</span> original2 = System.Text.Encoding.Unicode.GetString(utf16Bytes);
<span class="hljs-built_in">string</span> original3 = System.Text.Encoding.UTF32.GetString(utf32Bytes);

Console.WriteLine(original1);   <span class="hljs-comment">// 0123456789</span>
Console.WriteLine(original2);   <span class="hljs-comment">// 0123456789</span>
Console.WriteLine(original3);   <span class="hljs-comment">// 0123456789</span>
</code></pre>
<hr>
<h3>UTF-16 و جفت‌های جایگزین (Surrogate Pairs) 🧩</h3>
<p>یادتان باشد که .NET کاراکترها و رشته‌ها را در <strong>UTF-16</strong> ذخیره می‌کند. چون UTF-16 برای هر کاراکتر به یک یا دو کلمه ۱۶ بیتی نیاز دارد و نوع <strong>char</strong> فقط ۱۶ بیت طول دارد، برخی از کاراکترهای Unicode نیاز به دو char دارند. پیامدهای این موضوع:</p>
<ul>
<li>ویژگی <strong>Length</strong> یک رشته ممکن است بزرگ‌تر از تعداد واقعی کاراکترها باشد.</li>
<li>یک <strong>char</strong> همیشه به‌تنهایی نمی‌تواند یک کاراکتر Unicode را به‌طور کامل نشان دهد.</li>
</ul>
<p>اکثر برنامه‌ها این موضوع را نادیده می‌گیرند زیرا تقریباً همه کاراکترهای رایج در <strong>Basic Multilingual Plane (BMP)</strong> جا می‌گیرند که تنها به یک کلمه ۱۶ بیتی نیاز دارد. BMP شامل چندین زبان جهانی و بیش از ۳۰,۰۰۰ کاراکتر چینی است.</p>
<p>اما کاراکترهای خارج از BMP شامل زبان‌های باستانی، نمادهای نت‌نویسی موسیقی، برخی کاراکترهای نادر چینی و بیشتر ایموجی‌ها هستند.</p>
<p>برای پشتیبانی از کاراکترهای دوکلمه‌ای می‌توانید از متدهای ایستای <strong>char</strong> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ConvertFromUtf32</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> utf32</span>)
<span class="hljs-built_in">int</span>    <span class="hljs-title">ConvertToUtf32</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> highSurrogate, <span class="hljs-built_in">char</span> lowSurrogate</span>)
</span></code></pre>
<p>کاراکترهای دوکلمه‌ای <strong>Surrogate</strong> نامیده می‌شوند و به‌راحتی قابل تشخیص‌اند چون هر کلمه در بازه <strong>0xD800 تا 0xDFFF</strong> قرار دارد. متدهای مفید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsSurrogate</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> c</span>)
<span class="hljs-built_in">bool</span> <span class="hljs-title">IsHighSurrogate</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> c</span>)
<span class="hljs-built_in">bool</span> <span class="hljs-title">IsLowSurrogate</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> c</span>)
<span class="hljs-built_in">bool</span> <span class="hljs-title">IsSurrogatePair</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> highSurrogate, <span class="hljs-built_in">char</span> lowSurrogate</span>)
</span></code></pre>
<p>کلاس <strong>StringInfo</strong> در فضای نام <strong>System.Globalization</strong> نیز متدها و ویژگی‌هایی برای کار با کاراکترهای دوکلمه‌ای فراهم می‌کند.</p>
<p>کاراکترهای خارج از BMP معمولاً به فونت‌های خاص نیاز دارند و پشتیبانی محدودی در سیستم‌عامل دارند.</p>
<hr>
<h3>تاریخ‌ها و زمان‌ها ⏰</h3>
<p>ساختارهای (Struct) تغییرناپذیر (Immutable) زیر در فضای نام <strong>System</strong> برای نمایش تاریخ و زمان به کار می‌روند:</p>
<pre class="hljs"><code>DateTime, DateTimeOffset, TimeSpan, DateOnly, TimeOnly
</code></pre>
<p>زبان C# هیچ کلیدواژه خاصی برای این انواع تعریف نکرده است.</p>
<hr>
<h3>TimeSpan</h3>
<p><strong>TimeSpan</strong> یک بازه زمانی یا زمان روز را نمایش می‌دهد. در نقش دوم، این زمان همان زمان ساعت (بدون تاریخ) است که معادل مدت‌زمان سپری‌شده از نیمه‌شب است، فرض بر این‌که تغییر ساعت تابستانی وجود ندارد.</p>
<ul>
<li>دقت: <strong>100 نانوثانیه</strong></li>
<li>بیشترین مقدار: حدود <strong>۱۰ میلیون روز</strong></li>
<li>می‌تواند مثبت یا منفی باشد</li>
</ul>
<p>سه روش برای ساخت یک TimeSpan وجود دارد:</p>
<ul>
<li>استفاده از یکی از سازنده‌ها (Constructors)</li>
<li>فراخوانی یکی از متدهای ایستای <strong>From…</strong></li>
<li>کم کردن یک <strong>DateTime</strong> از دیگری</li>
</ul>
<p>نمونه سازنده‌ها:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimeSpan</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> hours, <span class="hljs-built_in">int</span> minutes, <span class="hljs-built_in">int</span> seconds</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimeSpan</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> days, <span class="hljs-built_in">int</span> hours, <span class="hljs-built_in">int</span> minutes, <span class="hljs-built_in">int</span> seconds</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimeSpan</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> days, <span class="hljs-built_in">int</span> hours, <span class="hljs-built_in">int</span> minutes, <span class="hljs-built_in">int</span> seconds, <span class="hljs-built_in">int</span> milliseconds</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimeSpan</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> days, <span class="hljs-built_in">int</span> hours, <span class="hljs-built_in">int</span> minutes, <span class="hljs-built_in">int</span> seconds, <span class="hljs-built_in">int</span> milliseconds, <span class="hljs-built_in">int</span> microseconds</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimeSpan</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> ticks</span>)</span>;   <span class="hljs-comment">// هر tick = 100ns</span>
</code></pre>
<p>نمونه متدهای <strong>From…</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TimeSpan <span class="hljs-title">FromDays</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TimeSpan <span class="hljs-title">FromHours</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TimeSpan <span class="hljs-title">FromMinutes</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TimeSpan <span class="hljs-title">FromSeconds</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TimeSpan <span class="hljs-title">FromMilliseconds</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span></span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TimeSpan <span class="hljs-title">FromMicroseconds</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span></span>)</span>;
</code></pre>
<p>نمونه استفاده:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-keyword">new</span> TimeSpan(<span class="hljs-number">2</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>));     <span class="hljs-comment">// 02:30:00</span>
Console.WriteLine(TimeSpan.FromHours(<span class="hljs-number">2.5</span>));    <span class="hljs-comment">// 02:30:00</span>
Console.WriteLine(TimeSpan.FromHours(<span class="hljs-number">-2.5</span>));   <span class="hljs-comment">// -02:30:00</span>
</code></pre>
<p>عملگرهای <code>&lt;</code> و <code>&gt;</code> و همچنین <code>+</code> و <code>-</code> برای TimeSpan سربارگذاری شده‌اند:</p>
<pre class="hljs"><code>TimeSpan.FromHours(<span class="hljs-number">2</span>) + TimeSpan.FromMinutes(<span class="hljs-number">30</span>); <span class="hljs-comment">// 2.5 ساعت</span>
TimeSpan.FromDays(<span class="hljs-number">10</span>) - TimeSpan.FromSeconds(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 9.23:59:59</span>
</code></pre>
<p>ویژگی‌های عددی:</p>
<pre class="hljs"><code>TimeSpan nearlyTenDays = TimeSpan.FromDays(<span class="hljs-number">10</span>) - TimeSpan.FromSeconds(<span class="hljs-number">1</span>);

Console.WriteLine(nearlyTenDays.Days);         <span class="hljs-comment">// 9</span>
Console.WriteLine(nearlyTenDays.Hours);        <span class="hljs-comment">// 23</span>
Console.WriteLine(nearlyTenDays.Minutes);      <span class="hljs-comment">// 59</span>
Console.WriteLine(nearlyTenDays.Seconds);      <span class="hljs-comment">// 59</span>
Console.WriteLine(nearlyTenDays.Milliseconds); <span class="hljs-comment">// 0</span>
</code></pre>
<p>ویژگی‌های <strong>Total…</strong> مقادیر اعشاری (double) را برای کل بازه برمی‌گردانند:</p>
<pre class="hljs"><code>Console.WriteLine(nearlyTenDays.TotalDays);         <span class="hljs-comment">// 9.99998842592593</span>
Console.WriteLine(nearlyTenDays.TotalHours);        <span class="hljs-comment">// 239.999722222222</span>
Console.WriteLine(nearlyTenDays.TotalMinutes);      <span class="hljs-comment">// 14399.9833333333</span>
Console.WriteLine(nearlyTenDays.TotalSeconds);      <span class="hljs-comment">// 863999</span>
Console.WriteLine(nearlyTenDays.TotalMilliseconds); <span class="hljs-comment">// 863999000</span>
</code></pre>
<p>متد ایستای <strong>Parse</strong> رشته را به TimeSpan تبدیل می‌کند (برعکس <strong>ToString</strong>). متد <strong>TryParse</strong> مشابه است ولی به‌جای پرتاب استثنا در صورت خطا، <strong>false</strong> برمی‌گرداند.</p>
<p>کلاس <strong>XmlConvert</strong> نیز متدهایی برای تبدیل TimeSpan/رشته طبق پروتکل‌های استاندارد XML دارد.</p>
<p>مقدار پیش‌فرض TimeSpan برابر با <strong>TimeSpan.Zero</strong> است.</p>
<p>برای نمایش زمان روز (مدت‌زمان سپری‌شده از نیمه‌شب)، می‌توانید از ویژگی <strong>DateTime.Now.TimeOfDay</strong> استفاده کنید.</p>
<hr>
<h3>DateTime و DateTimeOffset ⏰</h3>
<p><code>DateTime</code> و <code>DateTimeOffset</code> دو <strong>struct</strong> تغییرناپذیر (<strong>immutable</strong>) برای نمایش یک تاریخ و در صورت نیاز، زمان هستند. این دو دارای <strong>دقتی معادل 100 نانوثانیه</strong> بوده و محدوده‌ای از سال <strong>0001</strong> تا <strong>9999</strong> را پوشش می‌دهند.</p>
<p><code>DateTimeOffset</code> از نظر کارکرد شبیه <code>DateTime</code> است. تفاوت اصلی آن در این است که <strong>یک اختلاف زمانی (offset) نسبت به زمان هماهنگ جهانی (UTC)</strong> را هم ذخیره می‌کند؛ این موضوع باعث می‌شود مقایسه مقادیر در مناطق زمانی مختلف دقیق‌تر انجام شود.</p>
<hr>
<h3>انتخاب بین DateTime و DateTimeOffset 🤔</h3>
<p>تفاوت اصلی این دو در <strong>نحوه مدیریت مناطق زمانی (Time Zone)</strong> است:</p>
<ul>
<li>
<p><code>DateTime</code> دارای یک <strong>پرچم سه‌حالته</strong> است که مشخص می‌کند تاریخ و زمان نسبت به کدام گزینه است:</p>
<ul>
<li>زمان محلی روی کامپیوتر فعلی</li>
<li><code>UTC</code> (معادل مدرن زمان گرینویچ)</li>
<li><strong>نامشخص (Unspecified)</strong></li>
</ul>
</li>
<li>
<p>اما <code>DateTimeOffset</code> دقیق‌تر است؛ این نوع <strong>اختلاف زمانی نسبت به UTC را به‌صورت یک شیء از نوع TimeSpan ذخیره می‌کند</strong>:<br>
<strong>July 01 2019 03:00:00 -06:00</strong></p>
</li>
</ul>
<p>این موضوع در <strong>مقایسه‌ی برابری (Equality)</strong> اهمیت دارد و معیار انتخاب یکی از این دو است:</p>
<ul>
<li><code>DateTime</code> پرچم سه‌حالته را در مقایسه‌ها نادیده می‌گیرد و دو مقدار را <strong>برابر</strong> می‌داند اگر سال، ماه، روز، ساعت، دقیقه و ... آنها یکی باشد.</li>
<li><code>DateTimeOffset</code> دو مقدار را <strong>برابر</strong> می‌داند اگر به <strong>یک نقطه زمانی یکسان</strong> اشاره کنند.</li>
</ul>
<p>مثال مهم: <strong>ساعت تابستانی (Daylight Saving Time)</strong> می‌تواند این تفاوت را حتی اگر برنامه شما نیازی به پشتیبانی از مناطق زمانی مختلف نداشته باشد، مهم کند.</p>
<p><strong>نمونه:</strong><br>
<code>DateTime</code> مقادیر زیر را <strong>متفاوت</strong> می‌داند، در حالی که <code>DateTimeOffset</code> آنها را <strong>برابر</strong> می‌داند:</p>
<ul>
<li>July 01 2019 09:00:00 +00:00 (GMT)</li>
<li>July 01 2019 03:00:00 -06:00 (محلی، آمریکای مرکزی)</li>
</ul>
<hr>
<h3>مزیت DateTimeOffset در بیشتر موارد 🌍</h3>
<p>در اکثر سناریوها، <strong>منطق برابری DateTimeOffset بهتر است</strong>.<br>
مثلاً برای <strong>مقایسه زمان دو رویداد بین‌المللی</strong>، <code>DateTimeOffset</code> به‌صورت پیش‌فرض پاسخ درست را ارائه می‌دهد.<br>
حتی یک <strong>هکر</strong> که قصد اجرای یک حمله‌ی <strong>Distributed Denial of Service</strong> داشته باشد نیز از <code>DateTimeOffset</code> استفاده می‌کند!</p>
<p>اما در <code>DateTime</code> برای دستیابی به همین دقت باید همه‌چیز را در <strong>یک منطقه زمانی واحد (معمولاً UTC)</strong> استاندارد کنید که این دو مشکل دارد:</p>
<ul>
<li>برای کاربرپسند بودن، نیاز به <strong>تبدیل صریح UTC به زمان محلی</strong> قبل از نمایش دارید.</li>
<li>ممکن است <strong>فراموش کنید و زمان محلی را به‌صورت تصادفی وارد کنید</strong>.</li>
</ul>
<hr>
<h3>مزیت DateTime در زمان‌های محلی 🖥️</h3>
<p>با این حال، <code>DateTime</code> در مشخص کردن زمان <strong>نسبت به ساعت محلی سیستم اجرا</strong> مناسب‌تر است.<br>
مثلاً اگر بخواهید برای هر دفتر بین‌المللی خود یک <strong>آرشیو هفتگی</strong> در <strong>ساعت ۳ صبح به وقت محلی</strong> انجام دهید، <code>DateTime</code> بهتر است چون به زمان محلی هر سایت احترام می‌گذارد.</p>
<blockquote>
<p><strong>نکته:</strong><br>
<code>DateTimeOffset</code> برای ذخیره‌ی اختلاف زمانی از یک عدد صحیح کوتاه (short) استفاده می‌کند و این اختلاف را برحسب <strong>دقیقه</strong> ذخیره می‌کند.<br>
اما <strong>اطلاعات منطقه زمانی (Region)</strong> را ذخیره نمی‌کند. یعنی نمی‌دانیم اختلاف <strong>+08:00</strong> به <strong>زمان سنگاپور</strong> اشاره دارد یا <strong>پرت</strong>.</p>
</blockquote>
<p>ما در بخش <strong>“Dates and Time Zones” صفحه 312</strong> دوباره به موضوع مناطق زمانی و مقایسه‌ی برابری بازمی‌گردیم.</p>
<p>همچنین <strong>SQL Server 2008</strong> پشتیبانی مستقیم از <code>DateTimeOffset</code> را با معرفی یک <strong>نوع داده‌ی جدید با همین نام</strong> اضافه کرده است.</p>
<hr>
<h3>ساخت یک DateTime 🛠️</h3>
<p><code>DateTime</code> چندین <strong>سازنده (Constructor)</strong> دارد که مقادیر سال، ماه و روز را به‌صورت اعداد صحیح دریافت می‌کنند و در صورت نیاز می‌توان <strong>ساعت، دقیقه، ثانیه، میلی‌ثانیه (و از .NET 7 میکروثانیه)</strong> را هم مشخص کرد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DateTime</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> year, <span class="hljs-built_in">int</span> month, <span class="hljs-built_in">int</span> day</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DateTime</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> year, <span class="hljs-built_in">int</span> month, <span class="hljs-built_in">int</span> day,
                 <span class="hljs-built_in">int</span> hour, <span class="hljs-built_in">int</span> minute, <span class="hljs-built_in">int</span> second, <span class="hljs-built_in">int</span> millisecond</span>)</span>;
</code></pre>
<ul>
<li>اگر فقط تاریخ مشخص شود، زمان به‌صورت پیش‌فرض <strong>نیمه‌شب (0:00)</strong> تنظیم می‌شود.</li>
</ul>
<hr>
<h3>مشخص کردن DateTimeKind 🧭</h3>
<p>سازنده‌های <code>DateTime</code> به شما اجازه می‌دهند <strong>یک مقدار از نوع enum به نام DateTimeKind</strong> هم مشخص کنید که شامل این مقادیر است:</p>
<ul>
<li><code>Unspecified</code></li>
<li><code>Local</code></li>
<li><code>Utc</code></li>
</ul>
<p>این مقدار همان پرچم سه‌حالته‌ای است که در بخش قبلی توضیح داده شد.</p>
<ul>
<li><code>Unspecified</code> پیش‌فرض است و به این معنی است که زمان به منطقه زمانی خاصی وابسته نیست.</li>
<li><code>Local</code> یعنی زمان نسبت به <strong>منطقه زمانی سیستم فعلی</strong> است.</li>
</ul>
<p><strong>توجه:</strong> <code>DateTime</code> برخلاف <code>DateTimeOffset</code> <strong>اطلاعات دقیق منطقه زمانی یا اختلاف عددی از UTC را ذخیره نمی‌کند</strong>.</p>
<blockquote>
<p>مقدار <strong>Kind</strong> در یک شیء DateTime نشان‌دهنده‌ی همین حالت است.</p>
</blockquote>
<hr>
<h3>استفاده از تقویم‌های مختلف 📅</h3>
<p>سازنده‌های <code>DateTime</code> قابلیت دریافت یک شیء <strong>Calendar</strong> را هم دارند.<br>
این امکان به شما اجازه می‌دهد <strong>از هر زیرکلاسی از Calendar در System.Globalization</strong> برای ایجاد تاریخ استفاده کنید:</p>
<pre class="hljs"><code>DateTime d = <span class="hljs-keyword">new</span> DateTime (<span class="hljs-number">5767</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,
                          <span class="hljs-keyword">new</span> System.Globalization.HebrewCalendar());
Console.WriteLine (d);    <span class="hljs-comment">// 12/12/2006 12:00:00 AM</span>
</code></pre>
<blockquote>
<p>نمایش تاریخ به تنظیمات کنترل پنل سیستم شما بستگی دارد.<br>
در نهایت، <code>DateTime</code> همیشه از تقویم <strong>میلادی (Gregorian)</strong> برای ذخیره استفاده می‌کند و این تبدیل فقط در زمان ساخت شیء انجام می‌شود.</p>
</blockquote>
<p>اگر بخواهید محاسباتی با یک تقویم خاص انجام دهید، باید <strong>مستقیماً متدهای همان زیرکلاس Calendar</strong> را به‌کار ببرید.</p>
<hr>
<h3>ساخت DateTime با Ticks یا زمان‌های خاص ⏳</h3>
<ul>
<li>می‌توانید یک <code>DateTime</code> را با مقدار <code>ticks</code> بسازید که یک عدد از نوع <strong>long</strong> است.</li>
<li>هر tick برابر است با <strong>یک بازه‌ی 100 نانوثانیه از نیمه‌شب 01/01/0001</strong>.</li>
</ul>
<p>همچنین برای سازگاری با سیستم‌های دیگر، متدهای استاتیک زیر وجود دارند:</p>
<ul>
<li><strong>FromFileTime</strong> و <strong>FromFileTimeUtc</strong>: تبدیل زمان فایل‌های ویندوز (long) به DateTime.</li>
<li><strong>FromOADate</strong>: تبدیل زمان <strong>OLE Automation</strong> (double) به DateTime.</li>
</ul>
<hr>
<h3>ساخت DateTime از رشته‌های متنی 🔤</h3>
<p>برای ساخت یک <code>DateTime</code> از رشته‌ها، می‌توانید از متدهای استاتیک زیر استفاده کنید:</p>
<ul>
<li><code>Parse</code></li>
<li><code>ParseExact</code></li>
</ul>
<p>هر دو متد <strong>پارامترهای اختیاری</strong> برای مشخص کردن <strong>پرچم‌ها (flags)</strong> و <strong>فرمت‌دهنده‌ها (format providers)</strong> دارند؛ همچنین <code>ParseExact</code> یک <strong>رشته‌ی فرمت</strong> هم دریافت می‌کند.</p>
<p>توضیحات کامل‌تر در بخش <strong>“Formatting and Parsing” صفحه 317</strong> آمده است.</p>
<hr>
<h3>ساخت DateTimeOffset و کار با آن ⏰</h3>
<p><code>DateTimeOffset</code> مشابه <code>DateTime</code> عمل می‌کند، اما <strong>اضافه بر تاریخ و زمان، یک اختلاف زمانی نسبت به UTC</strong> هم دریافت می‌کند.</p>
<h4>سازنده‌ها (Constructors)</h4>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DateTimeOffset</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> year, <span class="hljs-built_in">int</span> month, <span class="hljs-built_in">int</span> day,
                       <span class="hljs-built_in">int</span> hour, <span class="hljs-built_in">int</span> minute, <span class="hljs-built_in">int</span> second,
                       TimeSpan offset</span>)</span>;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DateTimeOffset</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> year, <span class="hljs-built_in">int</span> month, <span class="hljs-built_in">int</span> day,
                       <span class="hljs-built_in">int</span> hour, <span class="hljs-built_in">int</span> minute, <span class="hljs-built_in">int</span> second, <span class="hljs-built_in">int</span> millisecond,
                       TimeSpan offset</span>)</span>;
</code></pre>
<ul>
<li><strong>محدودیت:</strong> TimeSpan باید <strong>به دقیقه کامل</strong> باشد، در غیر این صورت Exception رخ می‌دهد.</li>
<li>سازنده‌ها همچنین نسخه‌هایی دارند که <strong>Calendar، ticks، یا رشته</strong> دریافت می‌کنند (<code>Parse</code> و <code>ParseExact</code>).</li>
</ul>
<hr>
<h4>ساخت از یک DateTime موجود</h4>
<p>می‌توانید یک <code>DateTimeOffset</code> را از یک شیء <code>DateTime</code> بسازید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DateTimeOffset</span> (<span class="hljs-params">DateTime dateTime</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DateTimeOffset</span> (<span class="hljs-params">DateTime dateTime, TimeSpan offset</span>)</span>;
</code></pre>
<p>همچنین امکان <strong>تبدیل ضمنی (implicit cast)</strong> از <code>DateTime</code> به <code>DateTimeOffset</code> وجود دارد:</p>
<pre class="hljs"><code>DateTimeOffset dt = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
</code></pre>
<blockquote>
<p>این کار مفید است چون اکثر کتابخانه‌های BCL .NET هنوز <code>DateTime</code> را پشتیبانی می‌کنند، نه <code>DateTimeOffset</code>.</p>
</blockquote>
<h4>قوانین پیش‌فرض برای offset</h4>
<ul>
<li>اگر <code>DateTime.Kind == Utc</code> → offset = 0</li>
<li>اگر <code>DateTime.Kind == Local</code> یا <code>Unspecified</code> → offset از <strong>منطقه زمانی محلی سیستم</strong> گرفته می‌شود.</li>
</ul>
<hr>
<h3>تبدیل DateTimeOffset به DateTime</h3>
<p>سه ویژگی (<code>property</code>) برای تبدیل وجود دارد:</p>
<ul>
<li><code>UtcDateTime</code> → DateTime به زمان UTC</li>
<li><code>LocalDateTime</code> → DateTime به زمان محلی سیستم</li>
<li><code>DateTime</code> → DateTime با همان منطقه زمانی که مقدار original داشت، با <code>Kind = Unspecified</code></li>
</ul>
<hr>
<h3>زمان فعلی (Now, Today, UtcNow)</h3>
<table>
<thead>
<tr>
<th>نوع</th>
<th>ویژگی</th>
<th>توضیح</th>
</tr>
</thead>
<tbody>
<tr>
<td>DateTime</td>
<td><code>Now</code></td>
<td>تاریخ و زمان محلی</td>
</tr>
<tr>
<td>DateTimeOffset</td>
<td><code>Now</code></td>
<td>تاریخ و زمان محلی + offset</td>
</tr>
<tr>
<td>DateTime</td>
<td><code>Today</code></td>
<td>فقط تاریخ، زمان صفر (نیمه‌شب)</td>
</tr>
<tr>
<td>DateTime/DateTimeOffset</td>
<td><code>UtcNow</code></td>
<td>تاریخ و زمان در UTC</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code>Console.WriteLine(DateTime.Now);         <span class="hljs-comment">// 11/11/2019 1:23:45 PM</span>
Console.WriteLine(DateTimeOffset.Now);   <span class="hljs-comment">// 11/11/2019 1:23:45 PM -06:00</span>
Console.WriteLine(DateTime.Today);       <span class="hljs-comment">// 11/11/2019 12:00:00 AM</span>
Console.WriteLine(DateTime.UtcNow);      <span class="hljs-comment">// 11/11/2019 7:23:45 AM</span>
Console.WriteLine(DateTimeOffset.UtcNow);<span class="hljs-comment">// 11/11/2019 7:23:45 AM +00:00</span>
</code></pre>
<blockquote>
<p>دقت این مقادیر معمولاً بین <strong>۱۰ تا ۲۰ میلی‌ثانیه</strong> است و به سیستم عامل بستگی دارد.</p>
</blockquote>
<hr>
<h3>دسترسی به اجزای تاریخ و زمان</h3>
<pre class="hljs"><code>DateTime dt = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);

Console.WriteLine(dt.Year);         <span class="hljs-comment">// 2000</span>
Console.WriteLine(dt.Month);        <span class="hljs-comment">// 2</span>
Console.WriteLine(dt.Day);          <span class="hljs-comment">// 3</span>
Console.WriteLine(dt.DayOfWeek);    <span class="hljs-comment">// Thursday</span>
Console.WriteLine(dt.DayOfYear);    <span class="hljs-comment">// 34</span>
Console.WriteLine(dt.Hour);         <span class="hljs-comment">// 10</span>
Console.WriteLine(dt.Minute);       <span class="hljs-comment">// 20</span>
Console.WriteLine(dt.Second);       <span class="hljs-comment">// 30</span>
Console.WriteLine(dt.Millisecond);  <span class="hljs-comment">// 0</span>
Console.WriteLine(dt.Ticks);        <span class="hljs-comment">// 630851700300000000</span>
Console.WriteLine(dt.TimeOfDay);    <span class="hljs-comment">// 10:20:30  (TimeSpan)</span>
</code></pre>
<ul>
<li><code>DateTimeOffset</code> علاوه بر این‌ها، ویژگی <strong>Offset</strong> از نوع TimeSpan دارد.</li>
</ul>
<hr>
<h3>محاسبات روی تاریخ و زمان</h3>
<p>متدهای نمونه برای تغییر مقادیر تاریخ/زمان (برمی‌گردانند یک <strong>شیء جدید</strong>):</p>
<pre class="hljs"><code>AddYears, AddMonths, AddDays,
AddHours, AddMinutes, AddSeconds,
AddMilliseconds, AddTicks
</code></pre>
<ul>
<li>ورودی می‌تواند منفی باشد تا <strong>کم کردن زمان</strong> را انجام دهد.</li>
<li><code>Add</code> یک TimeSpan به تاریخ اضافه می‌کند؛ عملگر <code>+</code> نیز مشابه عمل می‌کند:</li>
</ul>
<pre class="hljs"><code>TimeSpan ts = TimeSpan.FromMinutes(<span class="hljs-number">90</span>);
Console.WriteLine(dt.Add(ts));
Console.WriteLine(dt + ts); <span class="hljs-comment">// مشابه بالا</span>
</code></pre>
<ul>
<li>می‌توان TimeSpan را کم کرد یا دو DateTime/DateTimeOffset را از هم کم کرد تا یک TimeSpan حاصل شود:</li>
</ul>
<pre class="hljs"><code>DateTime thisYear = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2015</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
DateTime nextYear = thisYear.AddYears(<span class="hljs-number">1</span>);
TimeSpan oneYear = nextYear - thisYear;
</code></pre>
<hr>
<h3>قالب‌بندی و پارس کردن (Formatting &amp; Parsing)</h3>
<ul>
<li><code>ToString()</code> در DateTime → تاریخ کوتاه + زمان طولانی (شامل ثانیه‌ها)<br>
مثال: <code>11/11/2019 11:50:30 AM</code></li>
<li><code>ToString()</code> در DateTimeOffset → همان، اما <strong>offset نیز نمایش داده می‌شود</strong>: <code>11/11/2019 11:50:30 AM -06:00</code></li>
<li><code>ToShortDateString</code>, <code>ToLongDateString</code> → فقط تاریخ</li>
<li><code>ToShortTimeString</code>, <code>ToLongTimeString</code> → فقط زمان</li>
</ul>
<blockquote>
<p>این متدها در واقع <strong>میانبرهایی برای قالب‌های استاندارد</strong> هستند. <code>ToString</code> می‌تواند <strong>فرمت سفارشی و provider</strong> نیز دریافت کند.</p>
</blockquote>
<h4>جلوگیری از پارس اشتباه</h4>
<p>اگر تنظیمات Culture هنگام parse با زمان فرمت شده متفاوت باشد، ممکن است parse اشتباه شود.<br>
راه حل: از <strong>فرمت culture-agnostic</strong> استفاده کنید، مثلاً <code>&quot;o&quot;</code>:</p>
<pre class="hljs"><code>DateTime dt1 = DateTime.Now;
<span class="hljs-built_in">string</span> cannotBeMisparsed = dt1.ToString(<span class="hljs-string">&quot;o&quot;</span>);
DateTime dt2 = DateTime.Parse(cannotBeMisparsed);
</code></pre>
<ul>
<li>متدهای استاتیک <code>Parse</code>, <code>TryParse</code>, <code>ParseExact</code>, <code>TryParseExact</code> رشته را به DateTime یا DateTimeOffset تبدیل می‌کنند.</li>
<li>نسخه‌های <code>Try*</code> به جای پرتاب Exception، <code>false</code> برمی‌گردانند.</li>
</ul>
<hr>
<p><strong>TimeZoneInfo</strong> ⏰🌍</p>
<p>کلاس <strong>TimeZoneInfo</strong> اطلاعاتی درباره نام مناطق زمانی، افست‌های UTC و قوانین <strong>Daylight Saving Time</strong> ارائه می‌دهد.</p>
<hr>
<h3>TimeZone</h3>
<p>متد ایستا <strong>TimeZone.CurrentTimeZone</strong> یک شیء <strong>TimeZone</strong> برمی‌گرداند:</p>
<pre class="hljs"><code>TimeZone zone = TimeZone.CurrentTimeZone;
Console.WriteLine (zone.StandardName);      <span class="hljs-comment">// Pacific Standard Time</span>
Console.WriteLine (zone.DaylightName);      <span class="hljs-comment">// Pacific Daylight Time</span>
</code></pre>
<p>متد <strong>GetDaylightChanges</strong> اطلاعات خاص مربوط به <strong>Daylight Saving Time</strong> برای یک سال مشخص را برمی‌گرداند:</p>
<pre class="hljs"><code>DaylightTime day = zone.GetDaylightChanges (<span class="hljs-number">2019</span>);
Console.WriteLine (day.Start.ToString (<span class="hljs-string">&quot;M&quot;</span>));       <span class="hljs-comment">// 10 March</span>
Console.WriteLine (day.End.ToString (<span class="hljs-string">&quot;M&quot;</span>));         <span class="hljs-comment">// 03 November</span>
Console.WriteLine (day.Delta);                      <span class="hljs-comment">// 01:00:00</span>
</code></pre>
<hr>
<h3>TimeZoneInfo</h3>
<p>متد ایستا <strong>TimeZoneInfo.Local</strong> یک شیء <strong>TimeZoneInfo</strong> بر اساس تنظیمات محلی جاری برمی‌گرداند. مثال زیر نتیجه اجرای آن در کالیفرنیا را نشان می‌دهد:</p>
<pre class="hljs"><code>TimeZoneInfo zone = TimeZoneInfo.Local;
Console.WriteLine (zone.StandardName);      <span class="hljs-comment">// Pacific Standard Time</span>
Console.WriteLine (zone.DaylightName);      <span class="hljs-comment">// Pacific Daylight Time</span>
</code></pre>
<p>متدهای <strong>IsDaylightSavingTime</strong> و <strong>GetUtcOffset</strong> به شکل زیر کار می‌کنند:</p>
<pre class="hljs"><code>DateTime dt1 = <span class="hljs-keyword">new</span> DateTime (<span class="hljs-number">2019</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">// DateTimeOffset هم کار می‌کند</span>
DateTime dt2 = <span class="hljs-keyword">new</span> DateTime (<span class="hljs-number">2019</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>);
Console.WriteLine (zone.IsDaylightSavingTime (dt1));     <span class="hljs-comment">// True</span>
Console.WriteLine (zone.IsDaylightSavingTime (dt2));     <span class="hljs-comment">// False</span>
Console.WriteLine (zone.GetUtcOffset (dt1));             <span class="hljs-comment">// -08:00:00</span>
Console.WriteLine (zone.GetUtcOffset (dt2));             <span class="hljs-comment">// -07:00:00</span>
</code></pre>
<p>برای دریافت <strong>TimeZoneInfo</strong> هر منطقه زمانی جهان، از متد <strong>FindSystemTimeZoneById</strong> استفاده می‌کنیم. در اینجا به منطقه غرب استرالیا می‌رویم:</p>
<pre class="hljs"><code>TimeZoneInfo wa = TimeZoneInfo.FindSystemTimeZoneById
                  (<span class="hljs-string">&quot;W. Australia Standard Time&quot;</span>);
Console.WriteLine (wa.Id);                   <span class="hljs-comment">// W. Australia Standard Time</span>
Console.WriteLine (wa.DisplayName);          <span class="hljs-comment">// (GMT+08:00) Perth</span>
Console.WriteLine (wa.BaseUtcOffset);        <span class="hljs-comment">// 08:00:00</span>
Console.WriteLine (wa.SupportsDaylightSavingTime);     <span class="hljs-comment">// True</span>
</code></pre>
<p>ویژگی <strong>Id</strong> همان مقداری است که به <strong>FindSystemTimeZoneById</strong> پاس داده شده است.<br>
متد ایستا <strong>GetSystemTimeZones</strong> تمام مناطق زمانی جهان را برمی‌گرداند و می‌توان تمام شناسه‌های معتبر را لیست کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (TimeZoneInfo z <span class="hljs-keyword">in</span> TimeZoneInfo.GetSystemTimeZones())
    Console.WriteLine (z.Id);
</code></pre>
<p>می‌توان یک منطقه زمانی سفارشی ایجاد کرد با <strong>TimeZoneInfo.CreateCustomTimeZone</strong>.<br>
چون <strong>TimeZoneInfo</strong> غیرقابل تغییر است، همه اطلاعات لازم باید هنگام ایجاد به متد داده شوند.</p>
<p>همچنین می‌توان یک منطقه زمانی از پیش تعریف‌شده یا سفارشی را با <strong>ToSerializedString</strong> به رشته‌ای نیمه‌قابل‌خواندن برای انسان تبدیل کرد و با <strong>TimeZoneInfo.FromSerializedString</strong> دوباره بازیابی نمود.</p>
<hr>
<p>متد ایستا <strong>ConvertTime</strong> یک <strong>DateTime</strong> یا <strong>DateTimeOffset</strong> را از یک منطقه زمانی به منطقه‌ای دیگر تبدیل می‌کند. می‌توان تنها منطقه مقصد را مشخص کرد یا هر دو منطقه مبدأ و مقصد را وارد نمود. تبدیل مستقیم از/به UTC نیز با متدهای <strong>ConvertTimeFromUtc</strong> و <strong>ConvertTimeToUtc</strong> ممکن است.</p>
<hr>
<p>برای کار با <strong>Daylight Saving Time</strong>، <strong>TimeZoneInfo</strong> متدهای اضافی زیر را فراهم می‌کند:</p>
<ul>
<li><strong>IsInvalidTime</strong>: true برمی‌گرداند اگر یک <strong>DateTime</strong> در ساعتی باشد که در جلو بردن ساعت‌ها حذف شده است.</li>
<li><strong>IsAmbiguousTime</strong>: true برمی‌گرداند اگر یک <strong>DateTime</strong> یا <strong>DateTimeOffset</strong> در ساعتی باشد که در عقب بردن ساعت‌ها تکرار شده است.</li>
<li><strong>GetAmbiguousTimeOffsets</strong>: آرایه‌ای از <strong>TimeSpan</strong> برمی‌گرداند که انتخاب‌های معتبر افست برای یک زمان مبهم را نشان می‌دهد.</li>
</ul>
<hr>
<p>برای گرفتن تاریخ‌های شروع و پایان <strong>Daylight Saving Time</strong> از یک <strong>TimeZoneInfo</strong>، باید <strong>GetAdjustmentRules</strong> را صدا زد که خلاصه قوانین DST را برای همه سال‌ها برمی‌گرداند. هر قانون دارای <strong>DateStart</strong> و <strong>DateEnd</strong> است:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (TimeZoneInfo.AdjustmentRule rule <span class="hljs-keyword">in</span> wa.GetAdjustmentRules())
    Console.WriteLine (<span class="hljs-string">&quot;Rule: applies from &quot;</span> + rule.DateStart +
                                        <span class="hljs-string">&quot; to &quot;</span> + rule.DateEnd);
</code></pre>
<p>مثال: غرب استرالیا اولین بار <strong>Daylight Saving Time</strong> را در ۲۰۰۶ معرفی کرد و سپس در ۲۰۰۹ لغو نمود. سال اول نیاز به قانون ویژه داشت، بنابراین دو قانون داریم:</p>
<pre class="hljs"><code>Rule: applies from 1/01/2006 12:00:00 AM to 31/12/2006 12:00:00 AM
Rule: applies from 1/01/2007 12:00:00 AM to 31/12/2009 12:00:00 AM
</code></pre>
<p>هر <strong>AdjustmentRule</strong> دارای <strong>DaylightDelta</strong> از نوع <strong>TimeSpan</strong> (معمولاً یک ساعت) و ویژگی‌های <strong>DaylightTransitionStart</strong> و <strong>DaylightTransitionEnd</strong> است که از نوع <strong>TimeZoneInfo.TransitionTime</strong> بوده و ویژگی‌های زیر را دارند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsFixedDateRule { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> DayOfWeek DayOfWeek { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Week { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Day { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Month { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> DateTime TimeOfDay { <span class="hljs-keyword">get</span>; }
</code></pre>
<hr>
<p>زمان انتقال (TransitionTime) می‌تواند هم تاریخ ثابت و هم شناور را نشان دهد. مثال تاریخ شناور: «آخرین یک‌شنبه ماه مارس».<br>
قوانین تفسیر TransitionTime:</p>
<p>1️⃣ اگر برای <strong>End Transition</strong>، <strong>IsFixedDateRule=true</strong>، <strong>Day=1</strong>، <strong>Month=1</strong> و <strong>TimeOfDay=DateTime.MinValue</strong>، آن سال پایان DST وجود ندارد (معمولاً در نیم‌کره جنوبی).<br>
2️⃣ اگر <strong>IsFixedDateRule=true</strong>، <strong>Month</strong>، <strong>Day</strong> و <strong>TimeOfDay</strong> تعیین‌کننده شروع یا پایان قانون هستند.<br>
3️⃣ اگر <strong>IsFixedDateRule=false</strong>، <strong>Month</strong>، <strong>DayOfWeek</strong>، <strong>Week</strong> و <strong>TimeOfDay</strong> تعیین‌کننده شروع یا پایان قانون هستند.</p>
<p>در حالت آخر، <strong>Week</strong> شماره هفته ماه است و «۵» یعنی آخرین هفته.</p>
<hr>
<p>مثال قوانین انتقال <strong>wa</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (TimeZoneInfo.AdjustmentRule rule <span class="hljs-keyword">in</span> wa.GetAdjustmentRules())
{
    Console.WriteLine (<span class="hljs-string">&quot;Rule: applies from &quot;</span> + rule.DateStart +
                                        <span class="hljs-string">&quot; to &quot;</span> + rule.DateEnd);
    Console.WriteLine (<span class="hljs-string">&quot;   Delta: &quot;</span> + rule.DaylightDelta);
    Console.WriteLine (<span class="hljs-string">&quot;   Start: &quot;</span> + FormatTransitionTime
                                   (rule.DaylightTransitionStart, <span class="hljs-literal">false</span>));
    Console.WriteLine (<span class="hljs-string">&quot;   End:   &quot;</span> + FormatTransitionTime
                                   (rule.DaylightTransitionEnd, <span class="hljs-literal">true</span>));
    Console.WriteLine();
}
</code></pre>
<p>در <strong>FormatTransitionTime</strong> قوانین فوق رعایت می‌شوند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">FormatTransitionTime</span> (<span class="hljs-params">TimeZoneInfo.TransitionTime tt,
                                    <span class="hljs-built_in">bool</span> endTime</span>)</span>
{
    <span class="hljs-keyword">if</span> (endTime &amp;&amp; tt.IsFixedDateRule
                &amp;&amp; tt.Day == <span class="hljs-number">1</span> &amp;&amp; tt.Month == <span class="hljs-number">1</span>
                &amp;&amp; tt.TimeOfDay == DateTime.MinValue)
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-&quot;</span>;
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">if</span> (tt.IsFixedDateRule)
        s = tt.Day.ToString();
    <span class="hljs-keyword">else</span>
        s = <span class="hljs-string">&quot;The &quot;</span> +
            <span class="hljs-string">&quot;first second third fourth last&quot;</span>.Split()[tt.Week - <span class="hljs-number">1</span>] +
            <span class="hljs-string">&quot; &quot;</span> + tt.DayOfWeek + <span class="hljs-string">&quot; in&quot;</span>;
    <span class="hljs-keyword">return</span> s + <span class="hljs-string">&quot; &quot;</span> + DateTimeFormatInfo.CurrentInfo.MonthNames [tt.Month<span class="hljs-number">-1</span>]
             + <span class="hljs-string">&quot; at &quot;</span> + tt.TimeOfDay.TimeOfDay;
}
</code></pre>
<h3>Daylight Saving Time و DateTime 🌞🕒</h3>
<p>اگر از <strong>DateTimeOffset</strong> یا یک <strong>UTC DateTime</strong> استفاده کنید، مقایسه برابری تحت تأثیر <strong>Daylight Saving Time</strong> قرار نمی‌گیرد. اما با <strong>DateTime</strong>های محلی، <strong>DST</strong> می‌تواند مشکل‌ساز باشد.</p>
<p>می‌توان قوانین را به‌طور خلاصه به این صورت بیان کرد:</p>
<ul>
<li><strong>Daylight Saving</strong> فقط بر زمان محلی تأثیر می‌گذارد، نه بر زمان UTC.</li>
<li>وقتی ساعت‌ها عقب کشیده می‌شوند، مقایسه‌هایی که به حرکت زمان رو به جلو وابسته‌اند، خراب می‌شوند <strong>فقط اگر</strong> از <strong>DateTime</strong> محلی استفاده کنند.</li>
<li>همیشه می‌توان به‌صورت قابل اعتماد بین زمان UTC و محلی رفت و برگشت کرد (روی همان کامپیوتر) حتی وقتی ساعت‌ها عقب می‌روند.</li>
</ul>
<p>متد <strong>IsDaylightSavingTime</strong> مشخص می‌کند که یک <strong>DateTime</strong> محلی تحت <strong>DST</strong> قرار دارد یا نه. زمان‌های UTC همیشه false برمی‌گردانند:</p>
<pre class="hljs"><code>Console.Write (DateTime.Now.IsDaylightSavingTime());     <span class="hljs-comment">// True یا False</span>
Console.Write (DateTime.UtcNow.IsDaylightSavingTime());  <span class="hljs-comment">// همیشه False</span>
</code></pre>
<p>اگر <strong>dto</strong> یک <strong>DateTimeOffset</strong> باشد، عبارت زیر همان عملکرد را دارد:</p>
<pre class="hljs"><code>dto.LocalDateTime.IsDaylightSavingTime
</code></pre>
<p>پایان <strong>Daylight Saving Time</strong> برای الگوریتم‌هایی که از زمان محلی استفاده می‌کنند، پیچیدگی ایجاد می‌کند؛ زیرا وقتی ساعت‌ها عقب کشیده می‌شوند، همان ساعت (یا دقیق‌تر، <strong>Delta</strong>) دوباره تکرار می‌شود.</p>
<p>مقایسه مطمئن بین هر دو <strong>DateTime</strong> با صدا زدن <strong>ToUniversalTime</strong> روی هرکدام انجام می‌شود. این روش تنها در صورتی شکست می‌خورد که <strong>یکی از آن‌ها DateTimeKind.Unspecified</strong> باشد.<br>
این احتمال خطا دلیل دیگری برای ترجیح دادن <strong>DateTimeOffset</strong> است.</p>
<hr>
<h3>Formatting و Parsing 📝</h3>
<p><strong>Formatting</strong> یعنی تبدیل به رشته؛ <strong>Parsing</strong> یعنی تبدیل از رشته.<br>
نیاز به <strong>format</strong> یا <strong>parse</strong> در برنامه‌نویسی بسیار رایج است، و .NET مکانیزم‌های متعددی برای آن ارائه می‌دهد:</p>
<p>1️⃣ <strong>ToString و Parse</strong><br>
این متدها عملکرد پیش‌فرض را برای بسیاری از انواع فراهم می‌کنند.</p>
<p>2️⃣ <strong>Format Providers</strong><br>
این‌ها به شکل متدهای اضافی <strong>ToString</strong> و <strong>Parse</strong> ظاهر می‌شوند و رشته فرمت و/یا یک <strong>format provider</strong> می‌گیرند. <strong>Format Providers</strong> بسیار منعطف و آگاه به فرهنگ (culture-aware) هستند. .NET شامل <strong>format provider</strong> برای انواع عددی و <strong>DateTime/DateTimeOffset</strong> است.</p>
<p>3️⃣ <strong>XmlConvert</strong><br>
یک کلاس ایستا که فرمت و پارس کردن را با رعایت استانداردهای XML انجام می‌دهد. همچنین برای تبدیل مستقل از فرهنگ یا جلوگیری از اشتباه در پارس کردن مفید است. از انواع عددی، <strong>bool</strong>، <strong>DateTime</strong>, <strong>DateTimeOffset</strong>, <strong>TimeSpan</strong> و <strong>Guid</strong> پشتیبانی می‌کند.</p>
<p>4️⃣ <strong>Type Converters</strong><br>
این‌ها مخصوص طراحان و <strong>XAML parsers</strong> هستند.</p>
<p>در این بخش، ما روی دو مکانیزم اول تمرکز می‌کنیم، مخصوصاً <strong>Format Providers</strong>، سپس <strong>XmlConvert</strong> و <strong>Type Converters</strong> را بررسی خواهیم کرد.</p>
<hr>
<h3>ToString و Parse 🔄</h3>
<p>ساده‌ترین مکانیزم فرمتینگ <strong>متد ToString</strong> است. این متد خروجی معنادار برای انواع ساده (bool, DateTime, DateTimeOffset, TimeSpan, Guid و انواع عددی) ارائه می‌دهد.<br>
برای عملیات معکوس، هرکدام از این انواع متد <strong>Parse</strong> ایستا دارند:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-literal">true</span>.ToString();     <span class="hljs-comment">// s = &quot;True&quot;</span>
<span class="hljs-built_in">bool</span> b = <span class="hljs-built_in">bool</span>.Parse(s);         <span class="hljs-comment">// b = true</span>
</code></pre>
<p>اگر پارس کردن شکست بخورد، <strong>FormatException</strong> پرتاب می‌شود.<br>
بسیاری از انواع همچنین متد <strong>TryParse</strong> دارند که اگر تبدیل شکست بخورد، false برمی‌گرداند به‌جای پرتاب استثنا:</p>
<pre class="hljs"><code><span class="hljs-built_in">bool</span> failure = <span class="hljs-built_in">int</span>.TryParse(<span class="hljs-string">&quot;qwerty&quot;</span>, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> i1);
<span class="hljs-built_in">bool</span> success = <span class="hljs-built_in">int</span>.TryParse(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> i2);
</code></pre>
<p>اگر به خروجی نیاز ندارید و فقط می‌خواهید بررسی کنید که پارس موفق می‌شود یا نه، می‌توانید از <strong>discard</strong> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">bool</span> success = <span class="hljs-built_in">int</span>.TryParse(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> _);
</code></pre>
<p>اگر انتظار خطا دارید، <strong>TryParse</strong> سریع‌تر و شیک‌تر از استفاده از <strong>Parse</strong> در بلوک <strong>try/catch</strong> است.</p>
<hr>
<h3>فرهنگ و Parse/ToString 🌐</h3>
<p>متدهای <strong>Parse</strong> و <strong>TryParse</strong> برای <strong>DateTime(Offset)</strong> و انواع عددی به تنظیمات فرهنگ محلی احترام می‌گذارند.<br>
می‌توان با مشخص کردن یک شیء <strong>CultureInfo</strong> این رفتار را تغییر داد. استفاده از <strong>InvariantCulture</strong> معمولاً ایده خوبی است:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-built_in">double</span>.Parse(<span class="hljs-string">&quot;1.234&quot;</span>));  <span class="hljs-comment">// 1234 در آلمان</span>
<span class="hljs-built_in">double</span> x = <span class="hljs-built_in">double</span>.Parse(<span class="hljs-string">&quot;1.234&quot;</span>, CultureInfo.InvariantCulture);
<span class="hljs-built_in">string</span> y = <span class="hljs-number">1.234</span>.ToString(CultureInfo.InvariantCulture);
</code></pre>
<p>از .NET 8 به بعد، انواع عددی و تاریخ/زمان امکان فرمتینگ و پارس مستقیم <strong>UTF-8</strong> را دارند با متدهای <strong>TryFormat</strong> و <strong>Parse/TryParse</strong> که روی <strong>byte array یا Span<byte></strong> کار می‌کنند. این در سناریوهای با عملکرد بالا می‌تواند کارآمدتر از کار با رشته‌های UTF-16 و تبدیل جداگانه باشد.</p>
<hr>
<h3>Format Providers و IFormattable 🛠️</h3>
<p>گاهی نیاز دارید کنترل بیشتری روی فرمتینگ و پارس داشته باشید.<br>
در .NET، همه انواع عددی و <strong>DateTime(Offset)</strong> اینترفیس <strong>IFormattable</strong> را پیاده‌سازی می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IFormattable</span>
{
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> format, IFormatProvider formatProvider</span>)</span>;
}
</code></pre>
<ul>
<li>پارامتر اول: رشته فرمت</li>
<li>پارامتر دوم: <strong>Format Provider</strong></li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code>NumberFormatInfo f = <span class="hljs-keyword">new</span> NumberFormatInfo();
f.CurrencySymbol = <span class="hljs-string">&quot;$$&quot;</span>;
Console.WriteLine(<span class="hljs-number">3.</span>ToString(<span class="hljs-string">&quot;C&quot;</span>, f));  <span class="hljs-comment">// $$ 3.00</span>
</code></pre>
<p>اینجا <code>&quot;C&quot;</code> رشته فرمت برای <strong>Currency</strong> است و <strong>NumberFormatInfo</strong> مشخص می‌کند که پول و سایر نمایش‌های عددی چگونه رندر شوند.</p>
<hr>
<p>اگر رشته فرمت یا <strong>provider</strong> برابر null باشد، یک مقدار پیش‌فرض استفاده می‌شود: <strong>CultureInfo.CurrentCulture</strong>، که تنظیمات کنترل پنل سیستم را منعکس می‌کند:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-number">10.3</span>.ToString(<span class="hljs-string">&quot;C&quot;</span>));  <span class="hljs-comment">// $10.30</span>
Console.WriteLine(<span class="hljs-number">10.3</span>.ToString(<span class="hljs-string">&quot;F4&quot;</span>)); <span class="hljs-comment">// 10.3000</span>
</code></pre>
<hr>
<h3>سه Format Provider اصلی</h3>
<ul>
<li><strong>NumberFormatInfo</strong></li>
<li><strong>DateTimeFormatInfo</strong></li>
<li><strong>CultureInfo</strong></li>
</ul>
<p>تمام Enumها نیز قابل فرمت هستند، گرچه کلاس ویژه <strong>IFormatProvider</strong> ندارند.</p>
<hr>
<h3>CultureInfo و Format Providers 🌎</h3>
<p><strong>CultureInfo</strong> میانجی برای <strong>NumberFormatInfo</strong> و <strong>DateTimeFormatInfo</strong> است، که تنظیمات منطقه‌ای فرهنگ را اعمال می‌کنند:</p>
<pre class="hljs"><code>CultureInfo uk = CultureInfo.GetCultureInfo(<span class="hljs-string">&quot;en-GB&quot;</span>);
Console.WriteLine(<span class="hljs-number">3.</span>ToString(<span class="hljs-string">&quot;C&quot;</span>, uk));  <span class="hljs-comment">// £3.00</span>
</code></pre>
<p>فرمت تاریخ با <strong>InvariantCulture</strong> همیشه یکسان است، صرف‌نظر از تنظیمات سیستم:</p>
<pre class="hljs"><code>DateTime dt = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
CultureInfo iv = CultureInfo.InvariantCulture;
Console.WriteLine(dt.ToString(iv));      <span class="hljs-comment">// 01/02/2000 00:00:00</span>
Console.WriteLine(dt.ToString(<span class="hljs-string">&quot;d&quot;</span>, iv)); <span class="hljs-comment">// 01/02/2000</span>
</code></pre>
<p>ویژگی‌های <strong>InvariantCulture</strong>:</p>
<ul>
<li>نماد ارز ☼ به جای $</li>
<li>تاریخ و زمان با صفر پیش‌رو (ماه اول)</li>
<li>زمان با فرمت ۲۴ ساعته بدون AM/PM</li>
</ul>
<h3>استفاده از NumberFormatInfo یا DateTimeFormatInfo 🔢📅</h3>
<p>در مثال بعد، یک <strong>NumberFormatInfo</strong> ایجاد می‌کنیم و جداکننده گروه (Group Separator) را از ویرگول به فاصله تغییر می‌دهیم. سپس از آن برای فرمت کردن یک عدد با سه رقم اعشار استفاده می‌کنیم:</p>
<pre class="hljs"><code>NumberFormatInfo f = <span class="hljs-keyword">new</span> NumberFormatInfo();
f.NumberGroupSeparator = <span class="hljs-string">&quot; &quot;</span>;
Console.WriteLine(<span class="hljs-number">12345.6789</span>.ToString(<span class="hljs-string">&quot;N3&quot;</span>, f));  <span class="hljs-comment">// 12 345.679</span>
</code></pre>
<p>تنظیمات اولیه برای <strong>NumberFormatInfo</strong> یا <strong>DateTimeFormatInfo</strong> بر اساس <strong>InvariantCulture</strong> هستند.<br>
گاهی اوقات مفیدتر است که نقطه شروع متفاوتی انتخاب کنید. برای این کار می‌توانید یک <strong>Format Provider</strong> موجود را <strong>Clone</strong> کنید:</p>
<pre class="hljs"><code>NumberFormatInfo f = (NumberFormatInfo)
                     CultureInfo.CurrentCulture.NumberFormat.Clone();
</code></pre>
<p>یک <strong>Format Provider</strong> کلون‌شده همیشه قابل نوشتن است، حتی اگر نمونه اصلی فقط خواندنی باشد.</p>
<hr>
<h3>فرمت ترکیبی (Composite Formatting) 🧩</h3>
<p>رشته‌های فرمت ترکیبی اجازه می‌دهند جایگزینی متغیرها با رشته فرمت را ترکیب کنید.<br>
متد استاتیک <strong>string.Format</strong> یک رشته فرمت ترکیبی می‌گیرد:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> composite = <span class="hljs-string">&quot;Credit={0:C}&quot;</span>;
Console.WriteLine(<span class="hljs-built_in">string</span>.Format(composite, <span class="hljs-number">500</span>));  <span class="hljs-comment">// Credit=$500.00</span>
</code></pre>
<p>خود کلاس <strong>Console</strong> متدهای <strong>Write</strong> و <strong>WriteLine</strong> را برای پشتیبانی از فرمت ترکیبی اورلود کرده است:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-string">&quot;Credit={0:C}&quot;</span>, <span class="hljs-number">500</span>);  <span class="hljs-comment">// Credit=$500.00</span>
</code></pre>
<p>می‌توانید رشته فرمت ترکیبی را به <strong>StringBuilder</strong> (با <strong>AppendFormat</strong>) یا به یک <strong>TextWriter</strong> برای I/O اضافه کنید.</p>
<p><strong>string.Format</strong> می‌تواند یک <strong>Format Provider</strong> اختیاری هم بگیرد. مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-built_in">string</span>.Format(CultureInfo.InvariantCulture, <span class="hljs-string">&quot;{0}&quot;</span>, someObject);
</code></pre>
<p>این معادل است با:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s;
<span class="hljs-keyword">if</span> (someObject <span class="hljs-keyword">is</span> IFormattable)
    s = ((IFormattable)someObject).ToString(<span class="hljs-literal">null</span>, CultureInfo.InvariantCulture);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (someObject == <span class="hljs-literal">null</span>)
    s = <span class="hljs-string">&quot;&quot;</span>;
<span class="hljs-keyword">else</span>
    s = someObject.ToString();
</code></pre>
<hr>
<h3>پارس کردن با Format Providers 🔧</h3>
<p>هیچ اینترفیس استانداردی برای پارس کردن از طریق <strong>Format Provider</strong> وجود ندارد.<br>
در عوض، هر نوع شرکت‌کننده، متد استاتیک <strong>Parse</strong> و <strong>TryParse</strong> خود را اورلود کرده تا <strong>Format Provider</strong> را بپذیرد و به صورت اختیاری <strong>NumberStyles</strong> یا <strong>DateTimeStyles</strong> را هم دریافت کند.</p>
<p><strong>NumberStyles</strong> و <strong>DateTimeStyles</strong> کنترل می‌کنند که پارس کردن چگونه انجام شود، مانند اینکه آیا پرانتز یا نماد ارز می‌تواند در ورودی باشد یا نه. (به‌طور پیش‌فرض، هر دو گزینه پاسخ <strong>نه</strong> هستند.)</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> error = <span class="hljs-built_in">int</span>.Parse(<span class="hljs-string">&quot;(2)&quot;</span>);  <span class="hljs-comment">// Exception پرتاب می‌شود</span>
<span class="hljs-built_in">int</span> minusTwo = <span class="hljs-built_in">int</span>.Parse(<span class="hljs-string">&quot;(2)&quot;</span>, NumberStyles.Integer | NumberStyles.AllowParentheses);  <span class="hljs-comment">// OK</span>
<span class="hljs-built_in">decimal</span> fivePointTwo = <span class="hljs-built_in">decimal</span>.Parse(<span class="hljs-string">&quot;£5.20&quot;</span>, NumberStyles.Currency,
                                      CultureInfo.GetCultureInfo(<span class="hljs-string">&quot;en-GB&quot;</span>));
</code></pre>
<p>بخش بعدی تمام اعضای <strong>NumberStyles</strong> و <strong>DateTimeStyles</strong> و قوانین پیش‌فرض پارس هر نوع را فهرست می‌کند.</p>
<hr>
<h3>IFormatProvider و ICustomFormatter 🛠️</h3>
<p>تمام <strong>Format Providers</strong> اینترفیس <strong>IFormatProvider</strong> را پیاده‌سازی می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IFormatProvider</span> 
{ 
    <span class="hljs-function"><span class="hljs-built_in">object</span> <span class="hljs-title">GetFormat</span>(<span class="hljs-params">Type formatType</span>)</span>; 
}
</code></pre>
<p>هدف این متد ایجاد <strong>indirection</strong> است؛ این همان چیزی است که اجازه می‌دهد <strong>CultureInfo</strong> به <strong>NumberFormatInfo</strong> یا <strong>DateTimeFormatInfo</strong> مناسب ارجاع دهد.</p>
<p>با پیاده‌سازی <strong>IFormatProvider</strong> و <strong>ICustomFormatter</strong>، می‌توانید <strong>Format Provider</strong> سفارشی خود را بسازید که با انواع موجود کار کند.</p>
<p><strong>ICustomFormatter</strong> یک متد دارد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Format</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> format, <span class="hljs-built_in">object</span> arg, IFormatProvider formatProvider</span>)</span>;
</code></pre>
<p>مثال یک <strong>Format Provider</strong> سفارشی که اعداد را به کلمات تبدیل می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WordyFormatProvider</span> : <span class="hljs-title">IFormatProvider</span>, <span class="hljs-title">ICustomFormatter</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span>[] _numberWords = <span class="hljs-string">&quot;zero one two three four five six seven eight nine minus point&quot;</span>.Split();
    IFormatProvider _parent;   <span class="hljs-comment">// امکان زنجیره سازی Format Providerها</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WordyFormatProvider</span>() : <span class="hljs-title">this</span>(<span class="hljs-params">CultureInfo.CurrentCulture</span>)</span> { }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WordyFormatProvider</span>(<span class="hljs-params">IFormatProvider parent</span>)</span> =&gt; _parent = parent;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-title">GetFormat</span>(<span class="hljs-params">Type formatType</span>)</span>
    {
        <span class="hljs-keyword">if</span> (formatType == <span class="hljs-keyword">typeof</span>(ICustomFormatter)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Format</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> format, <span class="hljs-built_in">object</span> arg, IFormatProvider prov</span>)</span>
    {
        <span class="hljs-comment">// اگر رشته فرمت ما نبود، به parent واگذار کن:</span>
        <span class="hljs-keyword">if</span> (arg == <span class="hljs-literal">null</span> || format != <span class="hljs-string">&quot;W&quot;</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(_parent, <span class="hljs-string">&quot;{0:&quot;</span> + format + <span class="hljs-string">&quot;}&quot;</span>, arg);

        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-built_in">string</span> digitList = <span class="hljs-built_in">string</span>.Format(CultureInfo.InvariantCulture, <span class="hljs-string">&quot;{0}&quot;</span>, arg);

        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> digit <span class="hljs-keyword">in</span> digitList)
        {
            <span class="hljs-built_in">int</span> i = <span class="hljs-string">&quot;0123456789-.&quot;</span>.IndexOf(digit, StringComparison.InvariantCulture);
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span> (result.Length &gt; <span class="hljs-number">0</span>) result.Append(<span class="hljs-string">&#x27; &#x27;</span>);
            result.Append(_numberWords[i]);
        }

        <span class="hljs-keyword">return</span> result.ToString();
    }
}
</code></pre>
<p>نکته: در متد <strong>Format</strong> از <strong>string.Format</strong> با <strong>InvariantCulture</strong> برای تبدیل عدد به رشته استفاده شد. این اطمینان می‌دهد که فقط کاراکترهای <code>0123456789-.</code> استفاده شوند و نه نسخه‌های بین‌المللی.</p>
<p>مثال استفاده از <strong>WordyFormatProvider</strong>:</p>
<pre class="hljs"><code><span class="hljs-built_in">double</span> n = <span class="hljs-number">-123.45</span>;
IFormatProvider fp = <span class="hljs-keyword">new</span> WordyFormatProvider();
Console.WriteLine(<span class="hljs-built_in">string</span>.Format(fp, <span class="hljs-string">&quot;{0:C} in words is {0:W}&quot;</span>, n));
<span class="hljs-comment">// -$123.45 in words is minus one two three point four five</span>
</code></pre>
<p>توجه: <strong>Custom Format Providers</strong> تنها در <strong>Composite Format Strings</strong> قابل استفاده هستند.</p>
<h3>رشته‌های فرمت استاندارد و پرچم‌های پارس 🔢📏</h3>
<p>رشته‌های فرمت استاندارد تعیین می‌کنند که یک نوع عددی یا <strong>DateTime/DateTimeOffset</strong> چگونه به رشته تبدیل شود. دو نوع رشته فرمت وجود دارد:</p>
<hr>
<h4>رشته‌های فرمت استاندارد ✅</h4>
<p>با این رشته‌ها، راهنمایی کلی ارائه می‌دهید.<br>
یک رشته فرمت استاندارد از یک حرف تشکیل شده و به‌طور اختیاری می‌تواند یک رقم بعد از آن داشته باشد (که معنی آن بستگی به حرف دارد).<br>
مثال‌ها: <code>&quot;C&quot;</code> یا <code>&quot;F2&quot;</code></p>
<hr>
<h4>رشته‌های فرمت سفارشی 🎨</h4>
<p>با این رشته‌ها، می‌توانید هر کاراکتر را با قالب مشخص مدیریت کنید.<br>
مثال: <code>&quot;0:#.000E+00&quot;</code></p>
<p>توجه: رشته‌های فرمت سفارشی با <strong>Format Provider</strong>های سفارشی ارتباطی ندارند.</p>
<hr>
<h3>رشته‌های فرمت عددی 🧮</h3>
<p>جدول 6-2 تمام رشته‌های فرمت استاندارد عددی را فهرست می‌کند.</p>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>ارائه نکردن رشته فرمت عددی 🔢❌</h3>
<p>اگر هیچ رشته فرمت عددی ارائه ندهید (یا رشته <code>null</code> یا خالی باشد)، معادل استفاده از رشته فرمت استاندارد <code>&quot;G&quot;</code> بدون رقم بعدی است. این رفتار به شرح زیر است:</p>
<ul>
<li>اعداد کوچکتر از $10^{-4}$ یا بزرگ‌تر از دقت نوع، به <strong>نمای علمی (Exponential/Scientific)</strong> تبدیل می‌شوند.</li>
<li>دو رقم اعشاری در حد دقت <code>float</code> یا <code>double</code> گرد می‌شوند تا ناپیوستگی‌های ذاتی تبدیل از شکل باینری به ده‌دهی پنهان بماند.</li>
</ul>
<p>گرد کردن خودکار توضیح داده‌شده معمولاً مفید است و معمولاً متوجه آن نمی‌شویم. با این حال، ممکن است مشکلاتی ایجاد کند اگر بخواهید یک عدد را <strong>round-trip</strong> کنید؛ یعنی آن را به رشته تبدیل کرده و دوباره بازگردانید (شاید چند بار) بدون آن‌که برابری مقدار از بین برود.</p>
<p>برای همین منظور، رشته‌های فرمت <strong>R، G17، و G9</strong> وجود دارند تا از گرد کردن ضمنی جلوگیری کنند.</p>
<p>جدول 6-3، رشته‌های فرمت عددی سفارشی را فهرست می‌کند.</p>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>NumberStyles 🔢</h3>
<p>هر نوع عددی (<code>numeric type</code>) یک متد <code>Parse</code> ایستا (static) تعریف می‌کند که یک آرگومان <code>NumberStyles</code> می‌پذیرد. <code>NumberStyles</code> یک <strong>enum با قابلیت flags</strong> است که به شما امکان می‌دهد مشخص کنید رشته چگونه به عدد تبدیل شود. اعضای قابل ترکیب آن عبارت‌اند از:</p>
<ul>
<li><code>AllowLeadingWhite</code></li>
<li><code>AllowTrailingWhite</code></li>
<li><code>AllowLeadingSign</code></li>
<li><code>AllowTrailingSign</code></li>
<li><code>AllowParentheses</code></li>
<li><code>AllowDecimalPoint</code></li>
<li><code>AllowThousands</code></li>
<li><code>AllowExponent</code></li>
<li><code>AllowCurrencySymbol</code></li>
<li><code>AllowHexSpecifier</code></li>
</ul>
<p>علاوه بر این، <code>NumberStyles</code> اعضای مرکب زیر را نیز تعریف می‌کند:</p>
<ul>
<li><code>None</code></li>
<li><code>Integer</code></li>
<li><code>Float</code></li>
<li><code>Number</code></li>
<li><code>HexNumber</code></li>
<li><code>Currency</code></li>
<li><code>Any</code></li>
</ul>
<p>به جز <code>None</code>، همه مقادیر مرکب شامل <code>AllowLeadingWhite</code> و <code>AllowTrailingWhite</code> هستند. شکل 6-1 ترکیب باقی‌مانده آن‌ها را نشان می‌دهد، که سه مورد مفیدتر، برجسته شده‌اند.</p>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-5.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>وقتی که متد <strong>Parse</strong> را بدون مشخص کردن هیچ پرچمی (flag) فراخوانی می‌کنید، مقادیر پیش‌فرض نشان داده‌شده در <strong>شکل ۶-۲</strong> اعمال می‌شوند. 🔹</p>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-6.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>اگر نمی‌خواهید از مقادیر پیش‌فرض نشان داده‌شده در <strong>شکل ۶-۲</strong> استفاده کنید، باید صریحاً <strong>NumberStyles</strong> را مشخص کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> thousand = <span class="hljs-built_in">int</span>.Parse(<span class="hljs-string">&quot;3E8&quot;</span>, NumberStyles.HexNumber);
<span class="hljs-built_in">int</span> minusTwo = <span class="hljs-built_in">int</span>.Parse(<span class="hljs-string">&quot;(2)&quot;</span>, NumberStyles.Integer | NumberStyles.AllowParentheses);
<span class="hljs-built_in">double</span> aMillion = <span class="hljs-built_in">double</span>.Parse(<span class="hljs-string">&quot;1,000,000&quot;</span>, NumberStyles.Any);
<span class="hljs-built_in">decimal</span> threeMillion = <span class="hljs-built_in">decimal</span>.Parse(<span class="hljs-string">&quot;3e6&quot;</span>, NumberStyles.Any);
<span class="hljs-built_in">decimal</span> fivePointTwo = <span class="hljs-built_in">decimal</span>.Parse(<span class="hljs-string">&quot;$5.20&quot;</span>, NumberStyles.Currency);
</code></pre>
<p>چون ما <strong>format provider</strong> مشخص نکردیم، این مثال با نماد پول محلی، جداکننده گروهی (group separator)، نقطه اعشار و غیره در سیستم شما کار می‌کند.</p>
<p>مثال بعدی به صورت سخت‌کد شده (hardcoded) است تا با علامت یورو و یک فاصله به عنوان جداکننده گروهی برای ارزها کار کند:</p>
<pre class="hljs"><code>NumberFormatInfo ni = <span class="hljs-keyword">new</span> NumberFormatInfo();
ni.CurrencySymbol = <span class="hljs-string">&quot;€&quot;</span>;
ni.CurrencyGroupSeparator = <span class="hljs-string">&quot; &quot;</span>;
<span class="hljs-built_in">double</span> million = <span class="hljs-built_in">double</span>.Parse(<span class="hljs-string">&quot;€1 000 000&quot;</span>, NumberStyles.Currency, ni);
</code></pre>
<h3>رشته‌های قالب‌بندی تاریخ/زمان 🕒</h3>
<p>رشته‌های قالب‌بندی برای <strong>DateTime/DateTimeOffset</strong> را می‌توان بر اساس اینکه تنظیمات فرهنگ (<strong>culture</strong>) و <strong>format provider</strong> را رعایت می‌کنند یا خیر به دو گروه تقسیم کرد. جدول ۶-۴ آن‌هایی را که رعایت می‌کنند نشان می‌دهد و جدول ۶-۵ آن‌هایی را که رعایت نمی‌کنند. خروجی نمونه از قالب‌بندی <strong>DateTime</strong> زیر به دست آمده است (با فرهنگ ثابت <strong>InvariantCulture</strong> در مورد جدول ۶-۴):</p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>);
</code></pre>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-7.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-8.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>رشته‌های قالب‌بندی <code>&quot;r&quot;</code>, <code>&quot;R&quot;</code> و <code>&quot;u&quot;</code> پسوندی تولید می‌کنند که <strong>UTC</strong> را نشان می‌دهد؛ اما به‌طور خودکار یک <strong>DateTime محلی</strong> را به UTC تبدیل نمی‌کنند، بنابراین شما خودتان باید تبدیل را انجام دهید. جالب اینجاست که <code>&quot;U&quot;</code> به‌طور خودکار به UTC تبدیل می‌شود، اما پسوند منطقه زمانی را نمی‌نویسد! در واقع، <code>&quot;o&quot;</code> تنها مشخصه قالب در این گروه است که می‌تواند یک <strong>DateTime بدون ابهام</strong> را بدون دخالت کاربر نمایش دهد.</p>
<p><strong>DateTimeFormatInfo</strong> همچنین از رشته‌های قالب‌بندی سفارشی پشتیبانی می‌کند: این‌ها مشابه رشته‌های قالب‌بندی سفارشی عددی هستند. فهرست کامل آن‌ها گسترده است و در مستندات مایکروسافت آنلاین موجود است. یک مثال از رشته قالب‌بندی سفارشی:</p>
<pre class="hljs"><code>yyyy-MM-dd HH:mm:ss
</code></pre>
<h3>تجزیه و اشتباه در تجزیه DateTime 🕒</h3>
<p>رشته‌هایی که ماه یا روز را ابتدا می‌گذارند، <strong>ابهام‌آمیز</strong> هستند و می‌توانند به‌راحتی اشتباه تجزیه شوند—به‌ویژه اگر مشتریان جهانی داشته باشید. این مشکل در کنترل‌های رابط کاربری وجود ندارد، زیرا همان تنظیمات هنگام تجزیه و قالب‌بندی اعمال می‌شوند.</p>
<p>اما هنگام نوشتن در یک فایل، مثلاً، <strong>اشتباه در تشخیص روز/ماه</strong> می‌تواند مشکل‌ساز شود. دو راه‌حل وجود دارد:</p>
<ul>
<li>همیشه <strong>فرهنگ مشخص و یکسان</strong> را هنگام قالب‌بندی و تجزیه مشخص کنید (مثلاً <strong>InvariantCulture</strong>).</li>
<li><strong>DateTime و DateTimeOffset را به‌گونه‌ای قالب‌بندی کنید که مستقل از فرهنگ باشد.</strong></li>
</ul>
<p>روش دوم مقاوم‌تر است—به‌ویژه اگر قالبی انتخاب کنید که سال چهاررقمی را ابتدا قرار دهد؛ چنین رشته‌هایی برای تجزیه اشتباه توسط طرف دیگر سخت‌تر هستند. علاوه بر این، رشته‌هایی که با قالب سال‌اول استاندارد (مانند <code>&quot;o&quot;</code>) قالب‌بندی شده‌اند، می‌توانند به‌درستی در کنار رشته‌های قالب‌بندی‌شده محلی تجزیه شوند—مانند یک «دهنده جهانی». (تاریخ‌هایی که با <code>&quot;s&quot;</code> یا <code>&quot;u&quot;</code> قالب‌بندی شده‌اند، مزیت اضافه‌ای هم دارند: قابلیت مرتب‌سازی.)</p>
<p>برای مثال، فرض کنید یک رشته <strong>DateTime</strong> مستقل از فرهنگ تولید می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = DateTime.Now.ToString(<span class="hljs-string">&quot;o&quot;</span>);
</code></pre>
<p>رشته قالب <code>&quot;o&quot;</code> میلی‌ثانیه‌ها را در خروجی شامل می‌کند.</p>
<p>رشته قالب سفارشی زیر همان خروجی <code>&quot;o&quot;</code> را بدون میلی‌ثانیه می‌دهد:</p>
<pre class="hljs"><code>yyyy-MM-ddTHH:mm:ss K
</code></pre>
<p>ما می‌توانیم این رشته را به دو روش تجزیه کنیم:</p>
<ul>
<li><strong>ParseExact</strong> نیاز به رعایت دقیق رشته قالب مشخص شده دارد:</li>
</ul>
<pre class="hljs"><code>DateTime dt1 = DateTime.ParseExact(s, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-literal">null</span>);
</code></pre>
<p>(می‌توانید نتیجه مشابهی با متدهای <code>XmlConvert.ToString</code> و <code>XmlConvert.ToDateTime</code> به دست آورید.)</p>
<ul>
<li><strong>Parse</strong> به‌طور ضمنی هم قالب <code>&quot;o&quot;</code> و هم قالب <strong>CurrentCulture</strong> را می‌پذیرد:</li>
</ul>
<pre class="hljs"><code>DateTime dt2 = DateTime.Parse(s);
</code></pre>
<p>این روش هم برای <strong>DateTime</strong> و هم <strong>DateTimeOffset</strong> کار می‌کند.</p>
<p>استفاده از <strong>ParseExact</strong> معمولاً ترجیح داده می‌شود اگر قالب رشته‌ای که تجزیه می‌کنید را می‌دانید، زیرا اگر رشته به‌درستی قالب‌بندی نشده باشد، <strong>یک استثناء</strong> پرتاب می‌شود—که معمولاً بهتر از ریسک تجزیه اشتباه تاریخ است.</p>
<hr>
<h3>DateTimeStyles ⚙️</h3>
<p><strong>DateTimeStyles</strong> یک <strong>flags enum</strong> است که دستورالعمل‌های اضافی هنگام فراخوانی <code>Parse</code> روی <strong>DateTime(Offset)</strong> ارائه می‌دهد. اعضای آن عبارتند از:</p>
<pre class="hljs"><code>None, AllowLeadingWhite, AllowTrailingWhite, AllowInnerWhite,
AssumeLocal, AssumeUniversal, AdjustToUniversal,
NoCurrentDateDefault, RoundTripKind
</code></pre>
<p>همچنین یک عضو ترکیبی به نام <strong>AllowWhiteSpaces</strong> وجود دارد:</p>
<pre class="hljs"><code>AllowWhiteSpaces = AllowLeadingWhite | AllowTrailingWhite | AllowInnerWhite
</code></pre>
<p>مقدار پیش‌فرض <strong>None</strong> است، به این معنی که فضای خالی اضافی معمولاً مجاز نیست (فضای خالی که بخشی از الگوی استاندارد DateTime است، مستثنی است).</p>
<ul>
<li><strong>AssumeLocal</strong> و <strong>AssumeUniversal</strong> زمانی اعمال می‌شوند که رشته دارای پسوند منطقه زمانی نباشد (مانند <code>Z</code> یا <code>+9:00</code>).</li>
<li><strong>AdjustToUniversal</strong> همچنان به پسوندهای منطقه زمانی احترام می‌گذارد، اما سپس با استفاده از تنظیمات منطقه‌ای فعلی، آن را به UTC تبدیل می‌کند.</li>
</ul>
<p>اگر رشته‌ای شامل زمان اما بدون تاریخ باشد، به‌طور پیش‌فرض <strong>تاریخ امروز</strong> اعمال می‌شود. اگر پرچم <strong>NoCurrentDateDefault</strong> را اعمال کنید، به جای آن از <strong>1 ژانویه 0001</strong> استفاده می‌شود.</p>
<hr>
<h3>رشته‌های قالب‌بندی Enum 🔢</h3>
<p>در بخش «Enums» در صفحه ۱۵۴، قالب‌بندی و تجزیه مقادیر enum را توضیح دادیم.<br>
جدول ۶-۶ هر رشته قالب‌بندی و نتیجه اعمال آن روی عبارت زیر را نشان می‌دهد:</p>
<pre class="hljs"><code>Console.WriteLine(System.ConsoleColor.Red.ToString(formatString));
</code></pre>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-9.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>مکانیزم‌های دیگر تبدیل 🔄</h3>
<p>در دو بخش قبلی، <strong>فرمت پروایدرها</strong> را بررسی کردیم—مکانیزم اصلی .NET برای قالب‌بندی و تجزیه. سایر مکانیزم‌های مهم تبدیل در انواع و فضای نام‌های مختلف پراکنده‌اند. برخی تبدیل به/از رشته انجام می‌دهند و برخی انواع دیگری از تبدیل‌ها را ارائه می‌کنند. در این بخش، موضوعات زیر را بررسی می‌کنیم:</p>
<ul>
<li>
<p><strong>کلاس Convert و توابع آن</strong>:</p>
<ul>
<li>تبدیل اعداد حقیقی به اعداد صحیح با <strong>گرد کردن</strong> به جای قطع کردن</li>
<li>تجزیه اعداد در مبناهای ۲، ۸ و ۱۶</li>
<li>تبدیل‌های داینامیک</li>
<li>ترجمه‌های <strong>Base-64</strong></li>
</ul>
</li>
<li>
<p><strong>XmlConvert</strong> و نقش آن در قالب‌بندی و تجزیه برای XML</p>
</li>
<li>
<p><strong>Type converters</strong> و نقش آن‌ها در قالب‌بندی و تجزیه برای طراحان و XAML</p>
</li>
<li>
<p><strong>BitConverter</strong> برای تبدیل‌های باینری</p>
</li>
</ul>
<hr>
<h3>Convert ⚡</h3>
<p>.NET انواع زیر را <strong>base types</strong> می‌نامد:</p>
<ul>
<li><code>bool</code>, <code>char</code>, <code>string</code>, <code>System.DateTime</code>, و <code>System.DateTimeOffset</code></li>
<li>همه انواع عددی C#</li>
</ul>
<p>کلاس <strong>static Convert</strong> متدهایی برای تبدیل هر <strong>base type</strong> به هر <strong>base type</strong> دیگر ارائه می‌دهد. متأسفانه بیشتر این متدها کاربردی نیستند: یا <strong>استثناء پرتاب می‌کنند</strong> یا در کنار <strong>کست‌های ضمنی</strong> اضافی هستند. با این حال، در بین این متدها، برخی متدهای مفید نیز وجود دارند که در بخش‌های بعدی آورده شده‌اند.</p>
<p>تمام <strong>base types</strong> به‌طور صریح <strong>IConvertible</strong> را پیاده‌سازی می‌کنند، که متدهایی برای تبدیل به تمام <strong>base type</strong>های دیگر تعریف می‌کند. در بیشتر موارد، پیاده‌سازی این متدها صرفاً یک متد در <strong>Convert</strong> را فراخوانی می‌کند. در موارد نادر، نوشتن متدی که یک آرگومان از نوع <strong>IConvertible</strong> بپذیرد، مفید است.</p>
<hr>
<h3>تبدیل اعداد حقیقی به صحیح با گرد کردن 🔢</h3>
<p>در فصل ۲ دیدیم که <strong>کست‌های ضمنی و صریح</strong> اجازه می‌دهند بین انواع عددی تبدیل انجام دهید:</p>
<ul>
<li>کست‌های <strong>ضمنی</strong> برای تبدیل‌های بدون افت کار می‌کنند (مثلاً <code>int</code> به <code>double</code>).</li>
<li>کست‌های <strong>صریح</strong> برای تبدیل‌های با افت لازم هستند (مثلاً <code>double</code> به <code>int</code>).</li>
</ul>
<p>کست‌ها برای کارایی بهینه شده‌اند؛ بنابراین داده‌هایی که جا نمی‌شوند، <strong>قطع می‌شوند</strong>. این مشکل هنگام تبدیل از عدد حقیقی به عدد صحیح پیش می‌آید، زیرا معمولاً می‌خواهید <strong>گرد کنید نه قطع کنید</strong>. متدهای تبدیل عددی <strong>Convert</strong> این مشکل را حل می‌کنند—همیشه <strong>گرد می‌کنند</strong>:</p>
<pre class="hljs"><code><span class="hljs-built_in">double</span> d = <span class="hljs-number">3.9</span>;
<span class="hljs-built_in">int</span> i = Convert.ToInt32(d);    <span class="hljs-comment">// i == 4</span>
</code></pre>
<p>Convert از <strong>Banker’s Rounding</strong> استفاده می‌کند، که مقادیر وسط را به عدد صحیح زوج نزدیک می‌کند (این از ایجاد <strong>سوگیری مثبت یا منفی</strong> جلوگیری می‌کند). اگر Banker’s Rounding مشکل‌ساز است، ابتدا می‌توانید <code>Math.Round</code> را روی عدد حقیقی فراخوانی کنید که آرگومانی برای کنترل گرد کردن مقادیر وسط دارد.</p>
<hr>
<h3>تجزیه اعداد در مبناهای ۲، ۸ و ۱۶ 🔢</h3>
<p>در بین متدهای <code>To(integral-type)</code>، <strong>overloadهایی</strong> وجود دارند که اعداد را در مبنای دیگر تجزیه می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> thirty = Convert.ToInt32(<span class="hljs-string">&quot;1E&quot;</span>, <span class="hljs-number">16</span>);    <span class="hljs-comment">// تجزیه هگزادسیمال</span>
<span class="hljs-built_in">uint</span> five  = Convert.ToUInt32(<span class="hljs-string">&quot;101&quot;</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// تجزیه باینری</span>
</code></pre>
<p>آرگومان دوم <strong>مبنا</strong> را مشخص می‌کند. می‌تواند هر مبنایی باشد—تا زمانی که ۲، ۸، ۱۰ یا ۱۶ باشد!</p>
<hr>
<h3>تبدیل‌های داینامیک ⚡</h3>
<p>گاهی نیاز دارید از یک نوع به نوع دیگر تبدیل کنید، اما تا زمان اجرا <strong>نوع‌ها مشخص نیستند</strong>. برای این منظور، کلاس Convert متد <code>ChangeType</code> را ارائه می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> <span class="hljs-title">ChangeType</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span>, Type conversionType</span>)</span>;
</code></pre>
<p>نوع منبع و مقصد باید یکی از <strong>base type</strong>ها باشد. <code>ChangeType</code> همچنین آرگومان اختیاری <code>IFormatProvider</code> را می‌پذیرد. مثال:</p>
<pre class="hljs"><code>Type targetType = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>);
<span class="hljs-built_in">object</span> source = <span class="hljs-string">&quot;42&quot;</span>;
<span class="hljs-built_in">object</span> result = Convert.ChangeType(source, targetType);

Console.WriteLine(result);             <span class="hljs-comment">// 42</span>
Console.WriteLine(result.GetType());   <span class="hljs-comment">// System.Int32</span>
</code></pre>
<p>یک کاربرد مفید آن، نوشتن یک <strong>deserializer</strong> است که بتواند با چند نوع مختلف کار کند. همچنین می‌تواند هر <strong>enum</strong> را به نوع عددی متناظر خود تبدیل کند. محدودیت <code>ChangeType</code> این است که نمی‌توانید <strong>رشته قالب یا پرچم تجزیه</strong> مشخص کنید.</p>
<hr>
<h3>تبدیل Base-64 📄</h3>
<p>گاهی نیاز است داده باینری مانند یک <strong>bitmap</strong> را در یک سند متنی مانند <strong>XML</strong> یا ایمیل قرار دهید. <strong>Base-64</strong> روش متداولی است که داده باینری را با استفاده از ۶۴ کاراکتر از مجموعه ASCII به صورت قابل خواندن رمزگذاری می‌کند.</p>
<ul>
<li><code>Convert.ToBase64String</code> یک آرایه بایت را به Base-64 تبدیل می‌کند.</li>
<li><code>Convert.FromBase64String</code> عکس آن را انجام می‌دهد.</li>
</ul>
<h3>XmlConvert 🗂️</h3>
<p>اگر با داده‌هایی سروکار دارید که منبع آن‌ها <strong>XML</strong> است یا قرار است در یک فایل XML ذخیره شوند، کلاس <strong>XmlConvert</strong> (در فضای نام <code>System.Xml</code>) مناسب‌ترین متدها را برای قالب‌بندی و تجزیه فراهم می‌کند. متدهای XmlConvert بدون نیاز به رشته قالب‌بندی خاص، جزئیات فرمت XML را مدیریت می‌کنند. برای مثال، مقدار <code>true</code> در XML به صورت <code>&quot;true&quot;</code> است و نه <code>&quot;True&quot;</code>. کتابخانه BCL در .NET به طور گسترده از XmlConvert استفاده می‌کند.</p>
<p>XmlConvert همچنین برای <strong>سریال‌سازی مستقل از فرهنگ</strong> نیز مناسب است. متدهای قالب‌بندی در XmlConvert به صورت <strong>overloaded ToString</strong> ارائه می‌شوند و متدهای تجزیه به شکل <code>ToBoolean</code>, <code>ToDateTime</code> و غیره هستند:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = XmlConvert.ToString(<span class="hljs-literal">true</span>);         <span class="hljs-comment">// s = &quot;true&quot;</span>
<span class="hljs-built_in">bool</span> isTrue = XmlConvert.ToBoolean(s);
</code></pre>
<p>متدهایی که به/از DateTime تبدیل می‌کنند، آرگومانی به نام <strong>XmlDateTimeSerializationMode</strong> می‌پذیرند که یک enum با مقادیر زیر است:</p>
<ul>
<li>
<p><code>Unspecified</code></p>
</li>
<li>
<p><code>Local</code></p>
</li>
<li>
<p><code>Utc</code></p>
</li>
<li>
<p><code>RoundtripKind</code></p>
</li>
<li>
<p><code>Local</code> و <code>Utc</code> هنگام قالب‌بندی، تبدیل انجام می‌دهند (اگر DateTime در آن منطقه زمانی نباشد) و منطقه زمانی به رشته اضافه می‌شود:</p>
</li>
</ul>
<pre class="hljs"><code>2010-02-22T14:08:30.9375           // Unspecified
2010-02-22T14:07:30.9375+09:00     // Local
2010-02-22T05:08:30.9375Z          // Utc
</code></pre>
<ul>
<li><code>Unspecified</code> هرگونه اطلاعات منطقه زمانی را از DateTime حذف می‌کند.</li>
<li><code>RoundtripKind</code> نوع DateTime را حفظ می‌کند تا هنگام تجزیه مجدد، DateTime دقیقاً همان باشد که بود.</li>
</ul>
<hr>
<h3>Type Converters 🎨</h3>
<p><strong>Type converters</strong> برای قالب‌بندی و تجزیه در محیط‌های <strong>design-time</strong> طراحی شده‌اند. آن‌ها همچنین مقادیر را در اسناد <strong>XAML</strong> تجزیه می‌کنند—مثلاً در <strong>WPF</strong>.</p>
<p>در .NET بیش از ۱۰۰ نوع مبدل وجود دارد که مواردی مانند رنگ‌ها، تصاویر و URIs را پوشش می‌دهند. در مقابل، فرمت پروایدرها تنها برای چند نوع ساده ارزشمند هستند.</p>
<p>Type converters معمولاً رشته‌ها را به روش‌های مختلف بدون نیاز به راهنما تجزیه می‌کنند. برای مثال، در یک برنامه WPF در Visual Studio، اگر رنگ پس‌زمینه یک کنترل را با نوشتن <code>&quot;Beige&quot;</code> در پنجره ویژگی‌ها تعیین کنید، <strong>TypeConverter</strong> نوع Color تشخیص می‌دهد که شما به نام رنگ اشاره کرده‌اید نه رشته RGB یا رنگ سیستم. این انعطاف‌پذیری گاهی کاربرد Type converters را فراتر از طراحان و اسناد XAML مفید می‌کند.</p>
<p>تمام Type converters از کلاس <strong>TypeConverter</strong> در <code>System.ComponentModel</code> مشتق می‌شوند. برای دریافت یک TypeConverter، از متد <code>TypeDescriptor.GetConverter</code> استفاده کنید. مثال برای نوع Color:</p>
<pre class="hljs"><code>TypeConverter cc = TypeDescriptor.GetConverter(<span class="hljs-keyword">typeof</span>(Color));
</code></pre>
<p>TypeConverter متدهایی مانند <code>ConvertToString</code> و <code>ConvertFromString</code> دارد:</p>
<pre class="hljs"><code>Color beige  = (Color) cc.ConvertFromString(<span class="hljs-string">&quot;Beige&quot;</span>);
Color purple = (Color) cc.ConvertFromString(<span class="hljs-string">&quot;#800080&quot;</span>);
Color window = (Color) cc.ConvertFromString(<span class="hljs-string">&quot;Window&quot;</span>);
</code></pre>
<p>به طور قراردادی، نام Type converters با <strong>Converter</strong> پایان می‌یابد و معمولاً در همان فضای نام نوع مورد نظر قرار دارند. هر نوع با <strong>TypeConverterAttribute</strong> به مبدل خود متصل است تا طراحان به‌طور خودکار مبدل‌ها را شناسایی کنند.</p>
<p>Type converters همچنین می‌توانند خدمات design-time ارائه دهند، مانند ایجاد فهرست مقادیر استاندارد برای منوهای کشویی یا کمک به <strong>سریال‌سازی کد</strong>.</p>
<hr>
<h3>BitConverter 🔢</h3>
<p>بیشتر <strong>base types</strong> را می‌توان به آرایه بایت تبدیل کرد با فراخوانی:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">byte</span> b <span class="hljs-keyword">in</span> BitConverter.GetBytes(<span class="hljs-number">3.5</span>))
    Console.Write(b + <span class="hljs-string">&quot; &quot;</span>);   <span class="hljs-comment">// 0 0 0 0 0 0 12 64</span>
</code></pre>
<p>BitConverter همچنین متدهایی مانند <code>ToDouble</code> برای تبدیل برعکس ارائه می‌دهد.</p>
<p>توجه: انواع <code>decimal</code> و <code>DateTime(Offset)</code> توسط BitConverter پشتیبانی نمی‌شوند، اما می‌توانید:</p>
<ul>
<li><strong>decimal</strong> را با <code>decimal.GetBits</code> به آرایه <code>int</code> تبدیل کنید</li>
<li>برای برعکس، سازنده‌ای در decimal وجود دارد که آرایه <code>int</code> می‌پذیرد</li>
<li>برای DateTime، متد <code>ToBinary</code> یک <code>long</code> بازمی‌گرداند (که می‌توان با BitConverter استفاده کرد). متد <code>DateTime.FromBinary</code> عکس آن را انجام می‌دهد.</li>
</ul>
<hr>
<h3>جهانی‌سازی 🌍</h3>
<p>برای بین‌المللی کردن یک برنامه، دو جنبه وجود دارد: <strong>Globalization</strong> و <strong>Localization</strong>.</p>
<ul>
<li>
<p><strong>Globalization</strong> به سه کار مرتبط است (به ترتیب اهمیت):</p>
<ol>
<li>اطمینان از اینکه برنامه در فرهنگ‌های دیگر خراب نمی‌شود</li>
<li>رعایت قوانین قالب‌بندی فرهنگ محلی (مثلاً نمایش تاریخ)</li>
<li>طراحی برنامه به‌گونه‌ای که داده‌ها و رشته‌های خاص فرهنگ از <strong>satellite assemblies</strong> خوانده شوند</li>
</ol>
</li>
<li>
<p><strong>Localization</strong> انجام کار سوم است با نوشتن <strong>satellite assemblies</strong> برای فرهنگ‌های مشخص، که بعد از نوشتن برنامه امکان‌پذیر است.</p>
</li>
</ul>
<p>.NET برای کار دوم کمک می‌کند و به طور پیش‌فرض قوانین فرهنگ محلی را اعمال می‌کند. همانطور که دیدیم، فراخوانی <code>ToString</code> روی DateTime یا عدد، قوانین قالب‌بندی محلی را رعایت می‌کند. اما این می‌تواند باعث شکست برنامه شود اگر انتظار داشته باشید تاریخ یا اعداد طبق یک فرهنگ فرضی قالب‌بندی شوند. راه‌حل:</p>
<ul>
<li>یا <strong>یک فرهنگ مشخص</strong> (مثلاً Invariant Culture) هنگام قالب‌بندی و تجزیه تعیین کنید</li>
<li>یا از روش‌های <strong>مستقل از فرهنگ</strong> مانند XmlConvert و <code>ToString(&quot;o&quot;)</code> استفاده کنید</li>
</ul>
<p><strong>چک‌لیست جهانی‌سازی</strong>:</p>
<ul>
<li>Unicode و <strong>Text Encodings</strong> را بشناسید</li>
<li>توجه داشته باشید که متدهای <code>ToUpper</code> و <code>ToLower</code> روی char و string <strong>حساس به فرهنگ</strong> هستند؛ در صورت نیاز به حساسیت مستقل از فرهنگ، از <code>ToUpperInvariant</code> و <code>ToLowerInvariant</code> استفاده کنید</li>
<li>برای DateTime و DateTimeOffset، از مکانیزم‌های قالب‌بندی و تجزیه مستقل از فرهنگ استفاده کنید</li>
<li>در غیر این صورت، هنگام قالب‌بندی/تجزیه اعداد یا تاریخ‌ها یک فرهنگ مشخص کنید (مگر اینکه رفتار فرهنگ محلی مد نظر باشد)</li>
</ul>
<h3>تست کردن 🧪</h3>
<p>می‌توانید برنامه خود را با فرهنگ‌های مختلف آزمایش کنید با <strong>تعیین مجدد ویژگی <code>CurrentCulture</code></strong> در کلاس <strong>Thread</strong> (<code>System.Threading</code>). مثال زیر فرهنگ جاری را به ترکیه تغییر می‌دهد:</p>
<pre class="hljs"><code>Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(<span class="hljs-string">&quot;tr-TR&quot;</span>);
</code></pre>
<p>ترکیه یک مورد آزمایشی ویژه است زیرا:</p>
<ul>
<li><code>&quot;i&quot;.ToUpper() != &quot;I&quot;</code> و <code>&quot;I&quot;.ToLower() != &quot;i&quot;</code></li>
<li>تاریخ‌ها به شکل <strong>روز.ماه.سال</strong> قالب‌بندی می‌شوند (نقطه به عنوان جداکننده)</li>
<li>نشانگر اعشار به جای نقطه، <strong>ویرگول</strong> است</li>
</ul>
<p>همچنین می‌توانید با تغییر <strong>تنظیمات قالب‌بندی اعداد و تاریخ</strong> در <strong>کنترل پنل ویندوز</strong> آزمایش کنید؛ این تغییرات در فرهنگ پیش‌فرض (<code>CultureInfo.CurrentCulture</code>) منعکس می‌شوند.</p>
<p>متد <code>CultureInfo.GetCultures()</code> آرایه‌ای از <strong>تمام فرهنگ‌های موجود</strong> را بازمی‌گرداند.</p>
<p>Thread و CultureInfo همچنین از ویژگی <strong>CurrentUICulture</strong> پشتیبانی می‌کنند که بیشتر با <strong>Localization</strong> مرتبط است و در فصل ۱۷ بررسی می‌شود.</p>
<hr>
<h3>کار با اعداد 🔢</h3>
<h4>تبدیل‌ها</h4>
<p>ما تبدیل‌های عددی را در فصل‌ها و بخش‌های قبلی پوشش دادیم؛ <strong>جدول ۶-۷</strong> تمام گزینه‌ها را خلاصه می‌کند.</p>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-10.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>کلاس Math ➗</h3>
<p><strong>جدول ۶-۸</strong> اعضای کلیدی کلاس <strong>static Math</strong> را فهرست می‌کند.</p>
<ul>
<li>
<p>توابع مثلثاتی آرگومان‌هایی از نوع <strong>double</strong> می‌پذیرند.</p>
</li>
<li>
<p>سایر متدها، مانند <strong>Max</strong>، برای تمام نوع‌های عددی <strong>overload</strong> شده‌اند.</p>
</li>
<li>
<p>کلاس <strong>Math</strong> همچنین <strong>ثابت‌های ریاضی</strong> زیر را تعریف می‌کند:</p>
<ul>
<li><strong>E</strong> (عدد اویلر)</li>
<li><strong>PI</strong> (π)</li>
</ul>
</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/06/Table-6-11.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>روش‌های گرد کردن و کلاس‌های عددی 🔢</h3>
<ul>
<li>متد <strong>Round</strong> امکان مشخص کردن تعداد ارقام اعشاری برای گرد کردن و همچنین نحوه‌ی مدیریت مقادیر وسطی (گرد کردن به سمت صفر یا <strong>banker’s rounding</strong>) را فراهم می‌کند.</li>
<li><strong>Floor</strong> و <strong>Ceiling</strong> به نزدیک‌ترین عدد صحیح گرد می‌کنند: <strong>Floor</strong> همیشه پایین می‌رود و <strong>Ceiling</strong> همیشه بالا می‌رود—even برای اعداد منفی.</li>
</ul>
<hr>
<h3>Max و Min</h3>
<ul>
<li>این متدها تنها دو آرگومان می‌پذیرند.</li>
<li>برای آرایه‌ها یا دنباله‌های عددی، از <strong>extension method</strong>های <strong>Max</strong> و <strong>Min</strong> در <strong>System.Linq.Enumerable</strong> استفاده کنید.</li>
</ul>
<hr>
<h3>BigInteger 🧮</h3>
<ul>
<li>ساختار <strong>BigInteger</strong> یک نوع عددی تخصصی است که در فضای نام <strong>System.Numerics</strong> قرار دارد و امکان نمایش اعداد صحیح بسیار بزرگ بدون از دست دادن دقت را فراهم می‌کند.</li>
<li>C# به صورت بومی از <strong>BigInteger</strong> پشتیبانی نمی‌کند، بنابراین نمی‌توان <strong>literal</strong>های BigInteger را نوشت. با این حال، می‌توان از هر نوع صحیح دیگر به صورت <strong>implicit</strong> به BigInteger تبدیل کرد:</li>
</ul>
<pre class="hljs"><code>BigInteger twentyFive = <span class="hljs-number">25</span>;  <span class="hljs-comment">// تبدیل ضمنی از integer</span>
</code></pre>
<ul>
<li>برای نمایش عدد بزرگ‌تر مانند یک گوگول $10¹⁰⁰$ می‌توان از متدهای static مانند <strong>Pow</strong> استفاده کرد:</li>
</ul>
<pre class="hljs"><code>BigInteger googol = BigInteger.Pow(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);
</code></pre>
<ul>
<li>یا با <strong>Parse</strong> یک رشته:</li>
</ul>
<pre class="hljs"><code>BigInteger googol = BigInteger.Parse(<span class="hljs-string">&quot;1&quot;</span>.PadRight(<span class="hljs-number">101</span>, <span class="hljs-string">&#x27;0&#x27;</span>));
</code></pre>
<ul>
<li>متد <strong>ToString()</strong> همه ارقام را چاپ می‌کند:</li>
</ul>
<pre class="hljs"><code>Console.WriteLine(googol.ToString());
</code></pre>
<ul>
<li>تبدیل‌های ممکن اما با احتمال از دست دادن دقت بین BigInteger و انواع عددی استاندارد با استفاده از <strong>explicit cast</strong> انجام می‌شود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">double</span> g2 = (<span class="hljs-built_in">double</span>)googol;        <span class="hljs-comment">// تبدیل صریح</span>
BigInteger g3 = (BigInteger)g2;    <span class="hljs-comment">// تبدیل صریح</span>
</code></pre>
<ul>
<li><strong>BigInteger</strong> همه عملگرهای حسابی از جمله باقی‌مانده (%) و عملگرهای مقایسه و برابری را overload کرده است.</li>
<li>همچنین می‌توان یک <strong>BigInteger</strong> را از یک آرایه بایت ساخت، که برای کاربردهای رمزنگاری مفید است:</li>
</ul>
<pre class="hljs"><code>RandomNumberGenerator rand = RandomNumberGenerator.Create();
<span class="hljs-built_in">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">32</span>];
rand.GetBytes(bytes);
<span class="hljs-keyword">var</span> bigRandomNumber = <span class="hljs-keyword">new</span> BigInteger(bytes);
</code></pre>
<ul>
<li>مزیت ذخیره این اعداد در BigInteger نسبت به آرایه بایت این است که <strong>semantics نوع مقداری (value-type semantics)</strong> حفظ می‌شود.</li>
</ul>
<hr>
<h3>Half 🟰</h3>
<ul>
<li><strong>Half</strong> یک نوع عدد اعشاری ۱۶ بیتی است که با .NET 5 معرفی شد و بیشتر برای تعامل با پردازنده‌های کارت گرافیک طراحی شده است.</li>
<li>تبدیل بین <strong>Half</strong> و <strong>float/double</strong> با <strong>explicit cast</strong> امکان‌پذیر است:</li>
</ul>
<pre class="hljs"><code>Half h = (Half)<span class="hljs-number">123.456</span>;
Console.WriteLine(h); <span class="hljs-comment">// 123.44  (توجه به از دست رفتن دقت)</span>
</code></pre>
<ul>
<li>عملیات حسابی برای این نوع تعریف نشده است؛ بنابراین باید قبل از محاسبه آن را به float یا double تبدیل کنید.</li>
<li>محدوده Half: -65500 تا 65500</li>
</ul>
<hr>
<h3>Complex 🔷</h3>
<ul>
<li><strong>Complex</strong> یک نوع عددی تخصصی برای اعداد مختلط با اجزای <strong>double</strong> است و در همان فضای نام BigInteger قرار دارد.</li>
<li>نمونه‌سازی:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> Complex(<span class="hljs-number">2</span>, <span class="hljs-number">3.5</span>);
<span class="hljs-keyword">var</span> c2 = <span class="hljs-keyword">new</span> Complex(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>);
</code></pre>
<ul>
<li>ویژگی‌ها: <strong>Real، Imaginary، Phase، Magnitude</strong></li>
<li>ساخت بر اساس قطب (magnitude و phase):</li>
</ul>
<pre class="hljs"><code>Complex c3 = Complex.FromPolarCoordinates(<span class="hljs-number">1.3</span>, <span class="hljs-number">5</span>);
</code></pre>
<ul>
<li>عملگرهای حسابی استاندارد نیز برای Complex overload شده‌اند.</li>
</ul>
<hr>
<h3>Random 🎲</h3>
<ul>
<li>کلاس <strong>Random</strong> دنباله‌ای شبه‌تصادفی از بایت‌ها، اعداد صحیح یا doubleها تولید می‌کند.</li>
<li>می‌توان یک seed برای تولید عدد تصادفی مشخص کرد تا نتایج تکرارپذیر باشد:</li>
</ul>
<pre class="hljs"><code>Random r1 = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">1</span>);
Random r2 = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">1</span>);
</code></pre>
<ul>
<li><strong>Next(n)</strong> عدد صحیح تصادفی بین ۰ و n-1 تولید می‌کند.</li>
<li><strong>NextDouble()</strong> عدد اعشاری تصادفی بین ۰ و ۱ می‌دهد.</li>
<li>از .NET 8، متدهای <strong>GetItems</strong> و <strong>Shuffle</strong> برای انتخاب و مرتب‌سازی تصادفی عناصر فراهم شده است.</li>
<li>برای کاربردهای امنیتی، باید از <strong>System.Security.Cryptography.RandomNumberGenerator</strong> استفاده کرد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> rand = System.Security.Cryptography.RandomNumberGenerator.Create();
<span class="hljs-built_in">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">32</span>];
rand.GetBytes(bytes);
</code></pre>
<p>این توضیحات پایه‌های کار با اعداد و انواع تخصصی در C# را پوشش می‌دهند.</p>
<h3>BitOperations 🔧</h3>
<p>کلاس <strong>System.Numerics.BitOperations</strong> (از .NET 6) متدهایی را برای عملیات پایه‌ای بر مبنای ۲ ارائه می‌دهد:</p>
<ul>
<li><strong>IsPow2</strong><br>
بررسی می‌کند که آیا یک عدد توان ۲ است یا خیر.</li>
<li><strong>LeadingZeroCount / TrailingZeroCount</strong><br>
تعداد صفرهای پیشرو یا پسرو را وقتی عدد به صورت یک unsigned integer ۳۲ یا ۶۴ بیتی نمایش داده می‌شود، برمی‌گرداند.</li>
<li><strong>Log2</strong><br>
لگاریتم پایه ۲ یک عدد unsigned را برمی‌گرداند.</li>
<li><strong>PopCount</strong><br>
تعداد بیت‌های تنظیم‌شده روی ۱ در یک unsigned integer را برمی‌گرداند.</li>
<li><strong>RotateLeft / RotateRight</strong><br>
چرخش بیتی به چپ یا راست انجام می‌دهد.</li>
<li><strong>RoundUpToPowerOf2</strong><br>
یک unsigned integer را به نزدیک‌ترین توان ۲ گرد می‌کند.</li>
</ul>
<hr>
<h3>Enumها ⚙️</h3>
<p>در فصل ۳، نوع <strong>enum</strong> در C# را معرفی کردیم و نحوه ترکیب اعضا، تست برابری، استفاده از عملگرهای منطقی و انجام تبدیل‌ها را توضیح دادیم. .NET پشتیبانی از enumها را با نوع <strong>System.Enum</strong> گسترش می‌دهد که دو نقش دارد:</p>
<ul>
<li><strong>یکپارچه‌سازی نوعی</strong> برای همه enumها</li>
<li>تعریف متدهای <strong>utility</strong> استاتیک</li>
</ul>
<p><strong>یکپارچه‌سازی نوعی</strong> یعنی می‌توانید هر عضو enum را به صورت implicit به یک instance از System.Enum تبدیل کنید:</p>
<pre class="hljs"><code>Display(Nut.Macadamia);     <span class="hljs-comment">// Nut.Macadamia</span>
Display(Size.Large);        <span class="hljs-comment">// Size.Large</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>(<span class="hljs-params">Enum <span class="hljs-keyword">value</span></span>)</span>
{
    Console.WriteLine(<span class="hljs-keyword">value</span>.GetType().Name + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-keyword">value</span>.ToString());
}

<span class="hljs-built_in">enum</span> Nut  { Walnut, Hazelnut, Macadamia }
<span class="hljs-built_in">enum</span> Size { Small, Medium, Large }
</code></pre>
<p>متدهای utility استاتیک روی <strong>System.Enum</strong> بیشتر برای انجام تبدیل‌ها و گرفتن لیست اعضا استفاده می‌شوند.</p>
<hr>
<h3>تبدیل Enumها 🔄</h3>
<p>سه روش برای نمایش مقدار یک enum وجود دارد:</p>
<ol>
<li>به عنوان <strong>عضو enum</strong></li>
<li>به عنوان <strong>مقدار صحیح underlying</strong></li>
<li>به عنوان <strong>رشته (string)</strong></li>
</ol>
<h4>Enum به عدد صحیح</h4>
<p>تبدیل صریح بین عضو enum و مقدار عددی آن امکان‌پذیر است:</p>
<pre class="hljs"><code>[<span class="hljs-meta">Flags</span>] 
<span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> BorderSides { Left=<span class="hljs-number">1</span>, Right=<span class="hljs-number">2</span>, Top=<span class="hljs-number">4</span>, Bottom=<span class="hljs-number">8</span> }

<span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>) BorderSides.Top;       <span class="hljs-comment">// i == 4</span>
BorderSides side = (BorderSides)i;   <span class="hljs-comment">// side == BorderSides.Top</span>
</code></pre>
<p>برای یک <strong>System.Enum</strong>، ابتدا به <strong>object</strong> تبدیل کنید و سپس به نوع عددی:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetIntegralValue</span>(<span class="hljs-params">Enum anyEnum</span>)</span>
{
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)(<span class="hljs-built_in">object</span>)anyEnum;
}
</code></pre>
<ul>
<li>اگر نوع عددی enum مشخص نباشد، این روش ممکن است با خطا مواجه شود.</li>
</ul>
<p>روش دیگر استفاده از <strong>Convert.ToDecimal</strong> است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">decimal</span> <span class="hljs-title">GetAnyIntegralValue</span>(<span class="hljs-params">Enum anyEnum</span>)</span>
{
    <span class="hljs-keyword">return</span> Convert.ToDecimal(anyEnum);
}
</code></pre>
<p>روش سوم، استفاده از <strong>Enum.GetUnderlyingType</strong> و <strong>Convert.ChangeType</strong> است تا نوع اصلی حفظ شود:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> <span class="hljs-title">GetBoxedIntegralValue</span>(<span class="hljs-params">Enum anyEnum</span>)</span>
{
    Type integralType = Enum.GetUnderlyingType(anyEnum.GetType());
    <span class="hljs-keyword">return</span> Convert.ChangeType(anyEnum, integralType);
}

<span class="hljs-built_in">object</span> result = GetBoxedIntegralValue(BorderSides.Top);
Console.WriteLine(result);           <span class="hljs-comment">// 4</span>
Console.WriteLine(result.GetType()); <span class="hljs-comment">// System.Int32</span>
</code></pre>
<p>همچنین می‌توانید از <strong>ToString(&quot;D&quot;)</strong> برای گرفتن مقدار عددی به صورت رشته استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetIntegralValueAsString</span>(<span class="hljs-params">Enum anyEnum</span>)</span>
{
    <span class="hljs-keyword">return</span> anyEnum.ToString(<span class="hljs-string">&quot;D&quot;</span>);  <span class="hljs-comment">// خروجی چیزی شبیه &quot;4&quot;</span>
}
</code></pre>
<h4>عدد صحیح به Enum</h4>
<p>برای تبدیل عدد صحیح به enum، از <strong>Enum.ToObject</strong> استفاده می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span> bs = Enum.ToObject(<span class="hljs-keyword">typeof</span>(BorderSides), <span class="hljs-number">3</span>);
Console.WriteLine(bs);  <span class="hljs-comment">// Left, Right</span>
</code></pre>
<p>این نسخه داینامیک معادل:</p>
<pre class="hljs"><code>BorderSides bs = (BorderSides)<span class="hljs-number">3</span>;
</code></pre>
<p>است و برای همه نوع‌های عددی و object قابل استفاده است.</p>
<h4>تبدیل به رشته</h4>
<ul>
<li>
<p>برای تبدیل enum به رشته، می‌توانید از <strong>Enum.Format</strong> یا <strong>ToString</strong> استفاده کنید.</p>
</li>
<li>
<p>فرمت‌ها:</p>
<ul>
<li>&quot;G&quot; : پیش‌فرض</li>
<li>&quot;D&quot; : مقدار عددی underlying</li>
<li>&quot;X&quot; : همان مقدار به صورت هگزادسیمال</li>
<li>&quot;F&quot; : فرمت اعضای ترکیبی بدون <strong>Flags</strong></li>
</ul>
</li>
</ul>
<h4>تبدیل رشته به Enum</h4>
<ul>
<li>برای تبدیل رشته به enum از <strong>Enum.Parse</strong> استفاده کنید:</li>
</ul>
<pre class="hljs"><code>BorderSides leftRight = (BorderSides) Enum.Parse(
    <span class="hljs-keyword">typeof</span>(BorderSides),
    <span class="hljs-string">&quot;Left, Right&quot;</span>
);
</code></pre>
<ul>
<li>آرگومان اختیاری سوم برای حساسیت به حروف بزرگ و کوچک است.</li>
<li>اگر عضو پیدا نشود، <strong>ArgumentException</strong> پرتاب می‌شود.</li>
</ul>
<h3>پیمایش مقادیر Enum 🔍</h3>
<p>متد <strong>Enum.GetValues</strong> آرایه‌ای شامل تمام اعضای یک نوع enum مشخص را برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (Enum <span class="hljs-keyword">value</span> <span class="hljs-keyword">in</span> Enum.GetValues(<span class="hljs-keyword">typeof</span>(BorderSides)))
    Console.WriteLine(<span class="hljs-keyword">value</span>);
</code></pre>
<ul>
<li>اعضای مرکب مانند <code>LeftRight = Left | Right</code> نیز شامل می‌شوند.</li>
<li><strong>Enum.GetNames</strong> عملکرد مشابه دارد اما آرایه‌ای از رشته‌ها برمی‌گرداند.</li>
<li>در واقع، CLR با <strong>reflection</strong> روی فیلدهای نوع enum، این متدها را پیاده‌سازی می‌کند و نتایج را برای بهینه‌سازی در حافظه کش می‌کند.</li>
</ul>
<hr>
<h3>نحوه کار Enum ⚙️</h3>
<ul>
<li>معنای Enumها عمدتاً توسط <strong>کامپایلر</strong> اعمال می‌شود.</li>
<li>در CLR، تفاوت زمان اجرا بین یک instance از enum (هنگام unboxed بودن) و مقدار عددی underlying آن وجود ندارد.</li>
<li>تعریف یک enum در CLR فقط یک subtype از <strong>System.Enum</strong> با فیلدهای استاتیک عددی برای هر عضو است.</li>
<li>این باعث می‌شود استفاده معمول از enum بسیار بهینه باشد و هزینه اجرای آن مشابه ثابت‌های عددی باشد.</li>
</ul>
<p><strong>نکته منفی:</strong> Enumها نوع ایمنی قوی ارائه نمی‌دهند. مثال:</p>
<pre class="hljs"><code>[<span class="hljs-meta">Flags</span>] <span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> BorderSides { Left=<span class="hljs-number">1</span>, Right=<span class="hljs-number">2</span>, Top=<span class="hljs-number">4</span>, Bottom=<span class="hljs-number">8</span> }
BorderSides b = BorderSides.Left;
b += <span class="hljs-number">1234</span>;  <span class="hljs-comment">// خطا ندارد!</span>
</code></pre>
<ul>
<li>وقتی کامپایلر قادر به اعتبارسنجی نباشد، runtime کمکی برای پرتاب استثنا ندارد.</li>
</ul>
<p>با وجود اینکه یک instance از enum و مقدار عددی آن در runtime تفاوتی ندارند، اما کد زیر به شکل متفاوتی عمل می‌کند:</p>
<pre class="hljs"><code>Console.WriteLine(BorderSides.Right.ToString());    <span class="hljs-comment">// Right</span>
Console.WriteLine(BorderSides.Right.GetType().Name); <span class="hljs-comment">// BorderSides</span>
</code></pre>
<ul>
<li>دلیل این رفتار این است که <strong>C#</strong> قبل از فراخوانی متدهای virtual مثل <code>ToString</code> یا <code>GetType</code>، instance را boxing می‌کند و یک wrapper runtime برای نوع enum ایجاد می‌شود.</li>
</ul>
<hr>
<h3>Struct Guid 🆔</h3>
<ul>
<li><strong>Guid</strong> نماینده یک <strong>شناسه یکتا جهانی</strong> است: یک مقدار ۱۶ بایتی که تقریباً همیشه در جهان یکتا است.</li>
<li>از Guidها معمولاً به عنوان کلید در برنامه‌ها و پایگاه‌های داده استفاده می‌شود.</li>
<li>تعداد کل Guidهای یکتا: $2^{128}$ یا تقریباً $3.4 × 10^{38}$.</li>
</ul>
<p><strong>ساخت یک Guid جدید:</strong></p>
<pre class="hljs"><code>Guid g = Guid.NewGuid();
Console.WriteLine(g.ToString());  <span class="hljs-comment">// 0d57629c-7d6e-4847-97cb-9e2fc25083fe</span>
</code></pre>
<p><strong>ساخت Guid از مقادیر موجود:</strong></p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Guid</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>[] b</span>)</span>;  <span class="hljs-comment">// آرایه 16 بایتی</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Guid</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> g</span>)</span>;   <span class="hljs-comment">// رشته قالب‌بندی شده</span>
</code></pre>
<ul>
<li>فرمت رشته‌ای: ۳۲ رقم هگزادسیمال با خط تیره اختیاری بعد از رقم‌های ۸، ۱۲، ۱۶ و ۲۰.</li>
<li>می‌توان کل رشته را در براکت یا آکولاد قرار داد:</li>
</ul>
<pre class="hljs"><code>Guid g1 = <span class="hljs-keyword">new</span> Guid(<span class="hljs-string">&quot;{0d57629c-7d6e-4847-97cb-9e2fc25083fe}&quot;</span>);
Guid g2 = <span class="hljs-keyword">new</span> Guid(<span class="hljs-string">&quot;0d57629c7d6e484797cb9e2fc25083fe&quot;</span>);
Console.WriteLine(g1 == g2);  <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>Guid به عنوان struct رفتار value-type دارد، بنابراین عملگر equality در مثال بالا درست کار می‌کند.</li>
<li>متد <strong>ToByteArray</strong> یک Guid را به آرایه بایت تبدیل می‌کند.</li>
<li><strong>Guid.Empty</strong> یک Guid خالی (تمام صفر) برمی‌گرداند که اغلب به جای null استفاده می‌شود.</li>
</ul>
<hr>
<h3>مقایسه برابری ⚖️</h3>
<ul>
<li>تا اینجا فرض کردیم که عملگرهای <code>==</code> و <code>!=</code> برای مقایسه کافی هستند، اما مسئله برابری پیچیده‌تر است.</li>
<li>دو نوع برابری وجود دارد:</li>
</ul>
<ol>
<li>
<p><strong>Value equality</strong></p>
<ul>
<li>دو مقدار از نظر محتوا برابر هستند.</li>
</ul>
</li>
<li>
<p><strong>Referential equality</strong></p>
<ul>
<li>دو reference به همان شیء اشاره می‌کنند.</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>مگر اینکه override شده باشد:</p>
<ul>
<li><strong>Value types</strong> از برابری مقداری استفاده می‌کنند.</li>
<li><strong>Reference types</strong> از برابری مرجع استفاده می‌کنند (مگر در anonymous types و records).</li>
</ul>
</li>
</ul>
<p>مثال برابری مقداری:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">5</span>;
Console.WriteLine(x == y);  <span class="hljs-comment">// True</span>
</code></pre>
<p>مثال برابری مقداری پیچیده‌تر با DateTimeOffset:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dt1 = <span class="hljs-keyword">new</span> DateTimeOffset(<span class="hljs-number">2010</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, TimeSpan.FromHours(<span class="hljs-number">8</span>));
<span class="hljs-keyword">var</span> dt2 = <span class="hljs-keyword">new</span> DateTimeOffset(<span class="hljs-number">2010</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, TimeSpan.FromHours(<span class="hljs-number">9</span>));
Console.WriteLine(dt1 == dt2);  <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li><strong>DateTimeOffset</strong> struct است و رفتار برابری آن طوری تعریف شده که اگر نقطه زمانی یکسان باشد، مقدار برابر تلقی شود.</li>
</ul>
<p>مثال برابری مرجع:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X; }
Foo f1 = <span class="hljs-keyword">new</span> Foo { X = <span class="hljs-number">5</span> };
Foo f2 = <span class="hljs-keyword">new</span> Foo { X = <span class="hljs-number">5</span> };
Console.WriteLine(f1 == f2); <span class="hljs-comment">// False</span>

Foo f3 = f1;
Console.WriteLine(f1 == f3); <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>می‌توان reference types را طوری سفارشی کرد که رفتار برابری مقداری داشته باشند، مانند کلاس <strong>Uri</strong>:</li>
</ul>
<pre class="hljs"><code>Uri uri1 = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">&quot;http://www.linqpad.net&quot;</span>);
Uri uri2 = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">&quot;http://www.linqpad.net&quot;</span>);
Console.WriteLine(uri1 == uri2);  <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>کلاس <strong>string</strong> رفتار مشابه دارد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&quot;http://www.linqpad.net&quot;</span>;
<span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&quot;http://&quot;</span> + <span class="hljs-string">&quot;www.linqpad.net&quot;</span>;
Console.WriteLine(s1 == s2);  <span class="hljs-comment">// True</span>
</code></pre>
<h3>پروتکل‌های استاندارد برابری ⚖️</h3>
<p>سه پروتکل استاندارد برای مقایسه برابری در C# وجود دارد:</p>
<ol>
<li>عملگرهای <code>==</code> و <code>!=</code></li>
<li>متد <strong>virtual Equals</strong> در <code>object</code></li>
<li>اینترفیس <strong>IEquatable<T></strong></li>
</ol>
<p>همچنین، پروتکل‌های قابل اتصال (pluggable) و اینترفیس <strong>IStructuralEquatable</strong> نیز وجود دارند که در فصل ۷ توضیح داده می‌شوند.</p>
<hr>
<h3>عملگرهای == و !=</h3>
<ul>
<li>این عملگرها <strong>static</strong> هستند و <strong>در زمان کامپایل</strong> تصمیم می‌گیرند که چه نوعی مقایسه را انجام دهد.</li>
<li>مثال:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-built_in">int</span> y = <span class="hljs-number">5</span>;
Console.WriteLine(x == y);  <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>اما اگر از object استفاده کنیم:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">object</span> x = <span class="hljs-number">5</span>;
<span class="hljs-built_in">object</span> y = <span class="hljs-number">5</span>;
Console.WriteLine(x == y);  <span class="hljs-comment">// False</span>
</code></pre>
<ul>
<li>چرا؟ چون object یک نوع مرجع است و عملگر <code>==</code> برای آن <strong>برابری مرجع</strong> (referential equality) را اعمال می‌کند.</li>
<li>نتیجه <code>False</code> است چون x و y هر کدام به یک شیء boxed جداگانه اشاره دارند.</li>
</ul>
<hr>
<h3>متد virtual Object.Equals</h3>
<ul>
<li>متد <strong>Equals</strong> در <code>System.Object</code> تعریف شده و برای تمام نوع‌ها در دسترس است.</li>
<li>این متد <strong>در زمان اجرا</strong> (runtime) بر اساس نوع واقعی شیء تصمیم می‌گیرد.</li>
<li>مثال:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">object</span> x = <span class="hljs-number">5</span>;
<span class="hljs-built_in">object</span> y = <span class="hljs-number">5</span>;
Console.WriteLine(x.Equals(y));  <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>
<p>توضیح:</p>
<ul>
<li>برای <strong>struct</strong>ها، Equals با مقایسه ساختاری (structural) روی همه فیلدها کار می‌کند.</li>
<li>برای <strong>reference type</strong>ها، به صورت پیش‌فرض مقایسه مرجع انجام می‌دهد.</li>
</ul>
</li>
</ul>
<hr>
<h3>چرا پیچیدگی وجود دارد؟</h3>
<p>چرا <code>==</code> virtual نیست و دقیقاً مثل Equals عمل نمی‌کند؟ دلایل:</p>
<ol>
<li>اگر اولین آرگومان null باشد، Equals با <strong>NullReferenceException</strong> مواجه می‌شود؛ عملگر static چنین خطایی ندارد.</li>
<li>گاهی مفید است که <code>==</code> و <code>Equals</code> تعاریف متفاوتی از برابری داشته باشند.</li>
<li>چون <code>==</code> <strong>static و compile-time</strong> است، بسیار سریع اجرا می‌شود؛ این برای کدهای محاسباتی سنگین اهمیت دارد.</li>
</ol>
<hr>
<h3>مثال: مقایسه ایمن دو شیء</h3>
<p>روش نامطمئن (ممکن است خطای null بدهد):</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">AreEqual</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj1, <span class="hljs-built_in">object</span> obj2</span>)</span> 
    =&gt; obj1.Equals(obj2);
</code></pre>
<p>روش ایمن با بررسی null:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">AreEqual</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj1, <span class="hljs-built_in">object</span> obj2</span>)</span>
{
    <span class="hljs-keyword">if</span> (obj1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj2 == <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> obj1.Equals(obj2);
}
</code></pre>
<p>نسخه کوتاه‌تر:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">AreEqual</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj1, <span class="hljs-built_in">object</span> obj2</span>)</span>
    =&gt; obj1 == <span class="hljs-literal">null</span> ? obj2 == <span class="hljs-literal">null</span> : obj1.Equals(obj2);
</code></pre>
<h3>متد ایستا <code>object.Equals</code></h3>
<p>کلاس <code>object</code> یک متد ایستا <strong>Equals</strong> هم دارد که همان کار <code>AreEqual</code> را انجام می‌دهد، اما با دو پارامتر:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> objA, <span class="hljs-built_in">object</span> objB</span>)
</span></code></pre>
<ul>
<li>این متد <strong>null-safe</strong> است و برای مواقعی که نوع‌ها در زمان کامپایل مشخص نیستند مناسب است:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">object</span> x = <span class="hljs-number">3</span>, y = <span class="hljs-number">3</span>;
Console.WriteLine(<span class="hljs-built_in">object</span>.Equals(x, y)); <span class="hljs-comment">// True</span>

x = <span class="hljs-literal">null</span>;
Console.WriteLine(<span class="hljs-built_in">object</span>.Equals(x, y)); <span class="hljs-comment">// False</span>

y = <span class="hljs-literal">null</span>;
Console.WriteLine(<span class="hljs-built_in">object</span>.Equals(x, y)); <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>
<p>کاربرد مفید: <strong>نوشتن نوع‌های generic</strong>.</p>
<ul>
<li>اگر از عملگر <code>==</code> یا <code>!=</code> استفاده کنیم، کامپایل نمی‌شود.</li>
<li>مثال:</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt;
{
    T _value;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetValue</span>(<span class="hljs-params">T newValue</span>)</span>
    {
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">object</span>.Equals(newValue, _value))
        {
            _value = newValue;
            OnValueChanged();
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnValueChanged</span>()</span> { ... }
}
</code></pre>
<ul>
<li>جایگزین بهینه: استفاده از <strong>EqualityComparer<T></strong> (از Boxing جلوگیری می‌کند):</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (!EqualityComparer&lt;T&gt;.Default.Equals(newValue, _value))
</code></pre>
<hr>
<h3>متد ایستا <code>object.ReferenceEquals</code></h3>
<ul>
<li>برای اعمال <strong>برابری مرجع</strong> (referential equality) استفاده می‌شود:</li>
</ul>
<pre class="hljs"><code>Widget w1 = <span class="hljs-keyword">new</span> Widget();
Widget w2 = <span class="hljs-keyword">new</span> Widget();
Console.WriteLine(<span class="hljs-built_in">object</span>.ReferenceEquals(w1, w2)); <span class="hljs-comment">// False</span>
</code></pre>
<ul>
<li>کاربرد: اگر کلاس <code>Widget</code> متد <code>Equals</code> را override کرده باشد یا <code>==</code> را overload کرده باشد، <code>ReferenceEquals</code> تضمین می‌کند که برابری واقعی مرجع بررسی شود.</li>
<li>جایگزین دیگر: cast به <code>object</code> و سپس استفاده از <code>==</code>.</li>
</ul>
<hr>
<h3>اینترفیس <code>IEquatable&lt;T&gt;</code></h3>
<ul>
<li>مشکل <code>object.Equals</code> این است که برای <strong>value type</strong>ها boxing ایجاد می‌کند، که هزینه‌بر است.</li>
<li>راه حل: <code>IEquatable&lt;T&gt;</code>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEquatable</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">T other</span>)</span>;
}
</code></pre>
<ul>
<li>مزیت: همان نتیجه <code>Equals</code> را می‌دهد ولی بدون boxing.</li>
<li>مثال استفاده در generic:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">IEquatable</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsEqual</span>(<span class="hljs-params">T a, T b</span>)</span>
    {
        <span class="hljs-keyword">return</span> a.Equals(b); <span class="hljs-comment">// بدون boxing</span>
    }
}
</code></pre>
<hr>
<h3>زمانی که <code>Equals</code> و <code>==</code> برابر نیستند</h3>
<ul>
<li>مثال با <code>double.NaN</code>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">double</span> x = <span class="hljs-built_in">double</span>.NaN;
Console.WriteLine(x == x);       <span class="hljs-comment">// False</span>
Console.WriteLine(x.Equals(x));  <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>
<p>دلیل:</p>
<ul>
<li><code>==</code> از نظر ریاضیاتی، NaN را حتی با خودش برابر نمی‌داند.</li>
<li><code>Equals</code> باید <strong>بازتابی (reflexive)</strong> باشد و همیشه <code>x.Equals(x)</code> true برگرداند.</li>
</ul>
</li>
<li>
<p>استفاده عملی: Collections و دیکشنری‌ها برای پیدا کردن آیتم‌ها به رفتار <code>Equals</code> تکیه دارند.</p>
</li>
<li>
<p>مثال با <code>StringBuilder</code>:</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> sb1 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;foo&quot;</span>);
<span class="hljs-keyword">var</span> sb2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;foo&quot;</span>);

Console.WriteLine(sb1 == sb2);       <span class="hljs-comment">// False (برابری مرجع)</span>
Console.WriteLine(sb1.Equals(sb2));  <span class="hljs-comment">// True  (برابری مقدار)</span>
</code></pre>
<ul>
<li>نتیجه: در نوع‌های reference، اغلب <code>Equals</code> برای برابری مقدار سفارشی شده و <code>==</code> برای برابری مرجع باقی می‌ماند.</li>
</ul>
<h3>برابری و نوع‌های سفارشی</h3>
<h4>رفتار پیش‌فرض برابری</h4>
<ul>
<li><strong>Value types</strong> از <strong>value equality</strong> استفاده می‌کنند.</li>
<li><strong>Reference types</strong> از <strong>referential equality</strong> استفاده می‌کنند مگر اینکه override شود (مثلاً در anonymous types و records).</li>
<li>متد <code>Equals</code> در struct به‌طور پیش‌فرض <strong>structural value equality</strong> اعمال می‌کند (هر فیلد مقایسه می‌شود).</li>
</ul>
<p>گاهی لازم است این رفتار را تغییر دهید:</p>
<ol>
<li>
<p><strong>تغییر معنای برابری</strong></p>
<ul>
<li>وقتی رفتار پیش‌فرض <code>==</code> یا <code>Equals</code> برای نوع شما طبیعی نیست یا مصرف‌کننده انتظار دیگری دارد.</li>
<li>مثال: <code>DateTimeOffset</code> که می‌خواهیم فقط UTC DateTime مقایسه شود و نه offset.</li>
<li>مثال دیگر: انواع عددی با NaN مثل <code>float</code> و <code>double</code>.</li>
<li>در کلاس‌ها، گاهی <strong>value equality</strong> طبیعی‌تر است تا <strong>referential equality</strong> (مثلاً <code>System.Uri</code> یا <code>System.String</code>).</li>
<li>در <strong>records</strong>، کامپایلر به‌طور خودکار structural equality ایجاد می‌کند، اما گاهی نیاز به اصلاح مقایسه برخی فیلدها داریم.</li>
</ul>
</li>
<li>
<p><strong>افزایش سرعت برابری برای structs</strong></p>
<ul>
<li>الگوریتم پیش‌فرض مقایسه struct کند است.</li>
<li>با override کردن <code>Equals</code> و پیاده‌سازی <code>IEquatable&lt;T&gt;</code> و overload کردن <code>==</code> می‌توان سرعت را چند برابر کرد.</li>
<li>برای reference types، override برابری تأثیر چندانی روی سرعت ندارد چون برابری مرجع سریع است.</li>
</ul>
</li>
</ol>
<h4>مراحل override برابری</h4>
<ol>
<li>Override کردن <strong>GetHashCode()</strong> و <strong>Equals()</strong></li>
<li>(اختیاری) overload کردن <strong>!=</strong> و <strong>==</strong></li>
<li>(اختیاری) پیاده‌سازی <strong>IEquatable<T></strong></li>
</ol>
<ul>
<li>در <strong>records</strong>: کامپایلر خود به خود این‌ها را override می‌کند. اگر بخواهید تغییر دهید، متد <code>Equals</code> باید به شکل زیر باشد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">record</span> <span class="hljs-title">Test</span>(<span class="hljs-title">int</span> <span class="hljs-title">X</span>, <span class="hljs-title">int</span> <span class="hljs-title">Y</span>)
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Test t</span>)</span> =&gt; t != <span class="hljs-literal">null</span> &amp;&amp; t.X == X &amp;&amp; t.Y == Y;
}
</code></pre>
<ul>
<li>متد <code>Equals</code> <strong>virtual</strong> است و پارامتر actual record type را می‌گیرد.</li>
<li>باید <code>GetHashCode</code> هم override شود، اما نیازی به overload کردن <code>==</code> و <code>!=</code> یا پیاده‌سازی <code>IEquatable&lt;T&gt;</code> نیست.</li>
</ul>
<hr>
<h3>Override کردن <code>GetHashCode</code></h3>
<ul>
<li>
<p>کاربرد: بهینه‌سازی برای <strong>Hashtable</strong> و <strong>Dictionary&lt;TKey,TValue&gt;</strong></p>
</li>
<li>
<p>نکات:</p>
<ul>
<li>اگر <code>Equals(a,b)</code> true بود، <code>GetHashCode(a)</code> و <code>GetHashCode(b)</code> باید یکسان باشد.</li>
<li>نباید exception بدهد.</li>
<li>باید مقدار ثابت برگرداند مگر اینکه شیء تغییر کرده باشد.</li>
</ul>
</li>
<li>
<p>برای structs، override کردن <code>GetHashCode</code> می‌تواند الگوریتم hashing را بهینه کند.</p>
</li>
<li>
<p>برای classes، مقدار پیش‌فرض بر اساس internal object token است.</p>
</li>
<li>
<p>هش قابل اعتماد معمولاً بر اساس <strong>immutable fields</strong> محاسبه می‌شود تا بعد از افزودن به دیکشنری، دسترسی از بین نرود.</p>
</li>
</ul>
<hr>
<h3>Override کردن <code>Equals</code></h3>
<ul>
<li>
<p>اصول:</p>
<ul>
<li>شیء نمی‌تواند برابر null باشد (مگر nullable type)</li>
<li>بازتابی (reflexive): <code>x.Equals(x)</code> همیشه true</li>
<li>جابجایی (commutative): اگر <code>a.Equals(b)</code> آنگاه <code>b.Equals(a)</code></li>
<li>ترانزیتیو (transitive): اگر <code>a.Equals(b)</code> و <code>b.Equals(c)</code> آنگاه <code>a.Equals(c)</code></li>
<li>قابل تکرار و reliable باشد</li>
</ul>
</li>
</ul>
<hr>
<h3>Overload کردن <code>==</code> و <code>!=</code></h3>
<ul>
<li>
<p>اغلب در structs انجام می‌شود، چون بدون آن <code>==</code> و <code>!=</code> کار نمی‌کنند.</p>
</li>
<li>
<p>در classes:</p>
<ol>
<li>رها کردن <code>==</code> و <code>!=</code> برای برابری مرجع (رایج‌ترین)</li>
<li>overload کردن آنها مطابق <code>Equals</code> برای کلاس‌های immutable (مثل <code>string</code> و <code>Uri</code>)</li>
</ol>
</li>
<li>
<p>نکته: overload کردن <code>!=</code> که معنای متفاوتی نسبت به <code>!(==)</code> بدهد، بسیار نادر است.</p>
<ul>
<li>مثال: انواع <code>System.Data.SqlTypes</code> که منطق مقایسه null را مطابق SQL اعمال می‌کنند.</li>
</ul>
</li>
</ul>
<h3>پیاده‌سازی <code>IEquatable&lt;T&gt;</code></h3>
<p>پیاده‌سازی <code>IEquatable&lt;T&gt;</code> به شما اجازه می‌دهد که متد <code>Equals</code> سریع‌تر و بدون boxing برای <strong>value types</strong> اجرا شود. نتایج آن باید با <code>object.Equals</code> مطابقت داشته باشد.</p>
<h4>مثال: struct Area</h4>
<p>فرض کنید struct‌ای داریم که مساحت را نشان می‌دهد و طول و عرض قابل تبادل هستند (مثلاً 5 × 10 با 10 × 5 برابر است):</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Area : IEquatable&lt;Area&gt;
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Measure1;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Measure2;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Area</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> m1, <span class="hljs-built_in">int</span> m2</span>)</span>
    {
        Measure1 = Math.Min(m1, m2);
        Measure2 = Math.Max(m1, m2);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> other</span>)</span>
        =&gt; other <span class="hljs-keyword">is</span> Area a &amp;&amp; Equals(a);  <span class="hljs-comment">// فراخوانی Equals نوع خاص</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Area other</span>)          <span class="hljs-comment">// پیاده‌سازی IEquatable&lt;Area&gt;</span></span>
        =&gt; Measure1 == other.Measure1 &amp;&amp; Measure2 == other.Measure2;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>()</span>
        =&gt; HashCode.Combine(Measure1, Measure2);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> ==(Area a1, Area a2) =&gt; Equals(a1, a2);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> !=(Area a1, Area a2) =&gt; !(a1 == a2);
}
</code></pre>
<ul>
<li>از <code>HashCode.Combine</code> برای تولید <strong>hashcode ترکیبی</strong> استفاده شده است.</li>
<li>از C# 10 به بعد، می‌توان این struct را به صورت <strong>record struct</strong> تعریف کرد و نیاز به کد بعد از constructor نیست.</li>
</ul>
<h4>استفاده از struct Area</h4>
<pre class="hljs"><code>Area a1 = <span class="hljs-keyword">new</span> Area(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);
Area a2 = <span class="hljs-keyword">new</span> Area(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);

Console.WriteLine(a1.Equals(a2));  <span class="hljs-comment">// True</span>
Console.WriteLine(a1 == a2);       <span class="hljs-comment">// True</span>
</code></pre>
<hr>
<h3>مقایسه قابل پیکربندی (Pluggable Equality Comparers)</h3>
<p>اگر بخواهید نوعی رفتار برابری مخصوص یک سناریو داشته باشد، می‌توانید از <strong><code>IEqualityComparer</code></strong> استفاده کنید. این برای کلاس‌های collection استاندارد بسیار مفید است و در فصل بعد (“Plugging in Equality and Order”) توضیح داده می‌شود.</p>
<hr>
<h3>مقایسه ترتیب (Order Comparison)</h3>
<p>C# و .NET دو پروتکل استاندارد برای ترتیب‌دهی اشیا دارند:</p>
<ol>
<li><strong>رابط‌های IComparable</strong> (<code>IComparable</code> و <code>IComparable&lt;T&gt;</code>)</li>
<li><strong>اپراتورهای &lt; و &gt;</strong></li>
</ol>
<ul>
<li>رابط‌های IComparable برای الگوریتم‌های مرتب‌سازی عمومی استفاده می‌شوند.</li>
<li>اپراتورهای &lt; و &gt; بیشتر برای انواع عددی هستند و statically resolved هستند، بنابراین سریع و مناسب محاسبات سنگین می‌شوند.</li>
<li>همچنین پروتکل‌های قابل پیکربندی ترتیب‌دهی از طریق <strong>IComparer</strong> فراهم شده‌اند (فصل 7).</li>
</ul>
<h4>IComparable و IComparable<T></h4>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IComparable</span>       { <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">CompareTo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> other</span>)</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IComparable</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>&gt; { <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">CompareTo</span>(<span class="hljs-params">T other</span>)</span>; }
</code></pre>
<ul>
<li>
<p><code>CompareTo</code> رفتار زیر را دارد:</p>
<ul>
<li>اگر <code>a</code> بعد از <code>b</code> باشد → مثبت</li>
<li>اگر <code>a</code> با <code>b</code> برابر باشد → صفر</li>
<li>اگر <code>a</code> قبل از <code>b</code> باشد → منفی</li>
</ul>
</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-string">&quot;Beck&quot;</span>.CompareTo(<span class="hljs-string">&quot;Anne&quot;</span>));   <span class="hljs-comment">// 1</span>
Console.WriteLine(<span class="hljs-string">&quot;Beck&quot;</span>.CompareTo(<span class="hljs-string">&quot;Beck&quot;</span>));   <span class="hljs-comment">// 0</span>
Console.WriteLine(<span class="hljs-string">&quot;Beck&quot;</span>.CompareTo(<span class="hljs-string">&quot;Chris&quot;</span>));  <span class="hljs-comment">// -1</span>
</code></pre>
<ul>
<li>بیشتر <strong>base types</strong> هر دو این رابط‌ها را پیاده‌سازی می‌کنند.</li>
<li>هنگام تعریف custom types هم می‌توان این رابط‌ها را پیاده‌سازی کرد تا مرتب‌سازی نوع شما به راحتی انجام شود.</li>
</ul>
<h3>IComparable در مقابل Equals</h3>
<p>وقتی یک نوع هم <code>Equals</code> را override کرده و هم رابط‌های <code>IComparable</code> را پیاده‌سازی می‌کند، انتظار داریم که:</p>
<ul>
<li>اگر <code>Equals</code> برابر بودن دو شی را گزارش دهد → <code>CompareTo</code> باید 0 بازگرداند.</li>
<li>اما اگر <code>Equals</code> برابر بودن را رد کند → <code>CompareTo</code> می‌تواند هر عددی بازگرداند، فقط باید <strong>داخلی سازگار باشد</strong>.</li>
</ul>
<p>به عبارت دیگر، برابری می‌تواند سخت‌گیرتر از ترتیب باشد، اما ترتیب نمی‌تواند سخت‌گیرتر از برابری باشد.</p>
<h4>مثال System.String</h4>
<ul>
<li><code>Equals</code> و <code>==</code> از <strong>مقایسه ordinal</strong> استفاده می‌کنند (مقادیر Unicode هر کاراکتر).</li>
<li><code>CompareTo</code> از <strong>مقایسه وابسته به فرهنگ</strong> استفاده می‌کند، پس ممکن است چندین کاراکتر در یک موقعیت مرتب‌سازی قرار بگیرند.</li>
</ul>
<blockquote>
<p>توجه: اگر بخواهید نظم مرتب‌سازی متفاوتی داشته باشید، می‌توانید از <strong>IComparer قابل پیکربندی</strong> استفاده کنید (مثلاً مقایسه بدون حساسیت به حروف کوچک/بزرگ).</p>
</blockquote>
<hr>
<h3>پیاده‌سازی IComparable و اپراتورهای &lt; و &gt;</h3>
<ul>
<li>وقتی <code>CompareTo</code> را پیاده‌سازی می‌کنید، خط اول آن بهتر است همیشه چنین باشد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (Equals(other)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</code></pre>
<ul>
<li>
<p>بعد از آن، می‌تواند هر مقدار سازگار برگرداند.</p>
</li>
<li>
<p>اپراتورهای <code>&lt;</code> و <code>&gt;</code> معمولاً با <code>IComparable</code> سازگار هستند و استاندارد در .NET است.</p>
</li>
<li>
<p>اکثر انواع .NET که <code>IComparable</code> را پیاده‌سازی می‌کنند، <code>&lt;</code> و <code>&gt;</code> را overload نمی‌کنند.</p>
</li>
</ul>
<h4>شرایطی که <code>&lt;</code> و <code>&gt;</code> overload می‌شوند</h4>
<ol>
<li>نوع مفهومی قوی از &quot;بزرگتر از&quot; و &quot;کوچکتر از&quot; دارد.</li>
<li>تنها یک روش یا زمینه برای مقایسه وجود دارد.</li>
<li>نتیجه مقایسه مستقل از فرهنگ است.</li>
</ol>
<blockquote>
<p>مثال: <code>System.String</code> فرهنگ‌محور است و بنابراین <code>&lt;</code> و <code>&gt;</code> را overload نمی‌کند.</p>
</blockquote>
<hr>
<h3>مثال struct Note</h3>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Note : IComparable&lt;Note&gt;, IEquatable&lt;Note&gt;, IComparable
{
    <span class="hljs-built_in">int</span> _semitonesFromA;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> SemitonesFromA =&gt; _semitonesFromA;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Note</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> semitonesFromA</span>)</span>
    {
        _semitonesFromA = semitonesFromA;
    }

    <span class="hljs-comment">// IComparable&lt;Note&gt;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CompareTo</span>(<span class="hljs-params">Note other</span>)</span>
    {
        <span class="hljs-keyword">if</span> (Equals(other)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// Fail-safe</span>
        <span class="hljs-keyword">return</span> _semitonesFromA.CompareTo(other._semitonesFromA);
    }

    <span class="hljs-comment">// IComparable</span>
    <span class="hljs-built_in">int</span> IComparable.CompareTo(<span class="hljs-built_in">object</span> other)
    {
        <span class="hljs-keyword">if</span> (!(other <span class="hljs-keyword">is</span> Note)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">&quot;CompareTo: Not a note&quot;</span>);
        <span class="hljs-keyword">return</span> CompareTo((Note)other);
    }

    <span class="hljs-comment">// اپراتورهای &lt; و &gt;</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> &lt;(Note n1, Note n2) =&gt; n1.CompareTo(n2) &lt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> &gt;(Note n1, Note n2) =&gt; n1.CompareTo(n2) &gt; <span class="hljs-number">0</span>;

    <span class="hljs-comment">// IEquatable&lt;Note&gt;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Note other</span>)</span> =&gt; _semitonesFromA == other._semitonesFromA;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> other</span>)</span>
    {
        <span class="hljs-keyword">if</span> (!(other <span class="hljs-keyword">is</span> Note)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> Equals((Note)other);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>()</span> =&gt; _semitonesFromA.GetHashCode();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> ==(Note n1, Note n2) =&gt; Equals(n1, n2);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> !=(Note n1, Note n2) =&gt; !(n1 == n2);
}
</code></pre>
<p>✅ نکات مهم:</p>
<ul>
<li>استفاده از <code>Equals</code> در <code>CompareTo</code> تضمین می‌کند که قوانین ترتیب و برابری سازگار هستند.</li>
<li>اپراتورهای <code>&lt;</code> و <code>&gt;</code> براساس <code>CompareTo</code> تعریف شده‌اند.</li>
<li><code>IEquatable&lt;T&gt;</code> برای سرعت و جلوگیری از boxing برای value types پیاده‌سازی شده است.</li>
<li><code>GetHashCode</code> و <code>Equals</code> برای سازگاری و استفاده در collectionها override شده‌اند.</li>
</ul>
<h3>کلاس‌های کمکی (Utility Classes) در .NET</h3>
<h4><strong>Console</strong></h4>
<p>کلاس استاتیک <code>Console</code> برای مدیریت ورودی/خروجی در برنامه‌های کنسولی استفاده می‌شود:</p>
<ul>
<li><strong>ورودی:</strong> از صفحه‌کلید با متدهای <code>Read</code>, <code>ReadKey</code>, <code>ReadLine</code></li>
<li><strong>خروجی:</strong> به پنجره متن با متدهای <code>Write</code>, <code>WriteLine</code></li>
</ul>
<p>ویژگی‌های مفید:</p>
<ul>
<li><strong>پنجره و اندازه‌ها:</strong> <code>WindowLeft</code>, <code>WindowTop</code>, <code>WindowHeight</code>, <code>WindowWidth</code></li>
<li><strong>رنگ‌ها:</strong> <code>ForegroundColor</code>, <code>BackgroundColor</code></li>
<li><strong>مکان‌نمای کنسول:</strong> <code>CursorLeft</code>, <code>CursorTop</code>, <code>CursorSize</code></li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code>Console.WindowWidth = Console.LargestWindowWidth;
Console.ForegroundColor = ConsoleColor.Green;
Console.Write(<span class="hljs-string">&quot;test... 50%&quot;</span>);
Console.CursorLeft -= <span class="hljs-number">3</span>;
Console.Write(<span class="hljs-string">&quot;90%&quot;</span>); <span class="hljs-comment">// test... 90%</span>
</code></pre>
<ul>
<li><code>Write</code> و <code>WriteLine</code> از <strong>string.Format</strong> پشتیبانی می‌کنند، اما فرمت فرهنگ (<code>CultureInfo</code>) را نمی‌توان تغییر داد مگر اینکه مستقیماً <code>string.Format</code> استفاده کنید.</li>
<li><code>Console.Out</code> یک <code>TextWriter</code> برمی‌گرداند، که می‌توان آن را به متدی داد که <code>TextWriter</code> می‌خواهد.</li>
<li>ورودی و خروجی کنسول را می‌توان با <code>Console.SetIn</code> و <code>Console.SetOut</code> تغییر مسیر داد.</li>
</ul>
<hr>
<h4><strong>Environment</strong></h4>
<p>کلاس استاتیک <code>System.Environment</code> اطلاعات مفیدی درباره سیستم فراهم می‌کند:</p>
<ul>
<li><strong>فایل‌ها و پوشه‌ها:</strong> <code>CurrentDirectory</code>, <code>SystemDirectory</code>, <code>CommandLine</code></li>
<li><strong>کامپیوتر و OS:</strong> <code>MachineName</code>, <code>ProcessorCount</code>, <code>OSVersion</code>, <code>NewLine</code></li>
<li><strong>کاربر:</strong> <code>UserName</code>, <code>UserInteractive</code>, <code>UserDomainName</code></li>
<li><strong>تشخیص و دیباگ:</strong> <code>TickCount</code>, <code>StackTrace</code>, <code>WorkingSet</code>, <code>Version</code></li>
</ul>
<p>امکان دسترسی به <strong>متغیرهای محیطی</strong>:<br>
<code>GetEnvironmentVariable</code>, <code>GetEnvironmentVariables</code>, <code>SetEnvironmentVariable</code></p>
<ul>
<li><code>ExitCode</code> برای تنظیم کد بازگشت برنامه</li>
<li><code>FailFast</code> برای خاتمه فوری برنامه بدون انجام cleanup</li>
</ul>
<blockquote>
<p>در Windows Store apps، تعداد اعضای <code>Environment</code> محدود است.</p>
</blockquote>
<hr>
<h4><strong>Process</strong></h4>
<p>کلاس <code>System.Diagnostics.Process</code> برای اجرای فرآیندها و تعامل با آنها:</p>
<ul>
<li>ساده‌ترین شکل اجرا:</li>
</ul>
<pre class="hljs"><code>Process.Start(<span class="hljs-string">&quot;notepad.exe&quot;</span>);
Process.Start(<span class="hljs-string">&quot;notepad.exe&quot;</span>, <span class="hljs-string">&quot;e:\\file.txt&quot;</span>);
</code></pre>
<ul>
<li>انعطاف‌پذیرترین شکل با <code>ProcessStartInfo</code> برای گرفتن ورودی/خروجی و خطا:</li>
</ul>
<pre class="hljs"><code>ProcessStartInfo psi = <span class="hljs-keyword">new</span> ProcessStartInfo
{
    FileName = <span class="hljs-string">&quot;cmd.exe&quot;</span>,
    Arguments = <span class="hljs-string">&quot;/c ipconfig /all&quot;</span>,
    RedirectStandardOutput = <span class="hljs-literal">true</span>,
    UseShellExecute = <span class="hljs-literal">false</span>
};
Process p = Process.Start(psi);
<span class="hljs-built_in">string</span> result = p.StandardOutput.ReadToEnd();
Console.WriteLine(result);
</code></pre>
<ul>
<li>اگر خروجی و خطا را redirect کنید، باید همزمان بخوانید تا ترتیب داده‌ها مشکل‌ساز نشود.</li>
<li>راه‌حل: خواندن یکی از جریان‌ها به صورت <strong>غیرهمزمان</strong> و استفاده از eventها:</li>
</ul>
<pre class="hljs"><code>(<span class="hljs-built_in">string</span> output, <span class="hljs-built_in">string</span> errors) Run(<span class="hljs-built_in">string</span> exePath, <span class="hljs-built_in">string</span> <span class="hljs-keyword">args</span> = <span class="hljs-string">&quot;&quot;</span>)
{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> p = Process.Start(<span class="hljs-keyword">new</span> ProcessStartInfo(exePath, <span class="hljs-keyword">args</span>)
    {
        RedirectStandardOutput = <span class="hljs-literal">true</span>,
        RedirectStandardError = <span class="hljs-literal">true</span>,
        UseShellExecute = <span class="hljs-literal">false</span>
    });

    <span class="hljs-keyword">var</span> errors = <span class="hljs-keyword">new</span> StringBuilder();
    p.ErrorDataReceived += (sender, errorArgs) =&gt;
    {
        <span class="hljs-keyword">if</span> (errorArgs.Data != <span class="hljs-literal">null</span>) errors.AppendLine(errorArgs.Data);
    };
    p.BeginErrorReadLine();

    <span class="hljs-built_in">string</span> output = p.StandardOutput.ReadToEnd();
    p.WaitForExit();
    <span class="hljs-keyword">return</span> (output, errors.ToString());
}
</code></pre>
<ul>
<li>برای <strong>Windows Store apps</strong> نمی‌توان به‌طور مستقیم Process ایجاد کرد، باید از <code>Windows.System.Launcher</code> برای باز کردن فایل یا URI استفاده کنید.</li>
</ul>
<hr>
<h3><strong>UseShellExecute</strong></h3>
<p><code>UseShellExecute</code> مشخص می‌کند که چگونه CLR یک فرآیند را شروع کند.</p>
<ul>
<li>
<p><strong>پیش‌فرض:</strong></p>
<ul>
<li>در <strong>.NET 5+ و .NET Core:</strong> <code>false</code></li>
<li>در <strong>.NET Framework:</strong> <code>true</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>این تفاوت یک تغییر ناسازگار (breaking change) است و هنگام مهاجرت کد از .NET Framework باید بررسی شود.</p>
</blockquote>
<hr>
<h4><strong>با <code>UseShellExecute = true</code>:</strong></h4>
<ul>
<li>می‌توان مسیر یک فایل یا سند (نه فقط یک اجرایی) را مشخص کرد و سیستم عامل آن را با برنامه مرتبط باز می‌کند.</li>
<li>می‌توان URL مشخص کرد و مرورگر پیش‌فرض سیستم باز می‌شود.</li>
<li>(ویندوز فقط) می‌توان <strong>Verb</strong> مشخص کرد، مثلاً <code>&quot;runas&quot;</code> برای اجرای برنامه با سطح دسترسی ادمین.</li>
</ul>
<p><strong>محدودیت:</strong> نمی‌توان جریان‌های ورودی/خروجی را redirect کرد.</p>
<blockquote>
<p>اگر نیاز به redirect باشد، می‌توانید <code>UseShellExecute = false</code> و cmd.exe با <code>/c</code> استفاده کنید (مانند مثال ipconfig).</p>
</blockquote>
<p><strong>عملکرد داخلی:</strong></p>
<ul>
<li><strong>ویندوز:</strong> CLR از <code>ShellExecute</code> به جای <code>CreateProcess</code> استفاده می‌کند.</li>
<li><strong>لینوکس:</strong> CLR از <code>xdg-open</code>, <code>gnome-open</code> یا <code>kfmclient</code> استفاده می‌کند.</li>
</ul>
<hr>
<h3><strong>AppContext</strong></h3>
<p>کلاس استاتیک <code>System.AppContext</code> دو ویژگی اصلی و چند قابلیت مدیریت وضعیت ارائه می‌دهد:</p>
<ul>
<li>
<p><strong>BaseDirectory:</strong> مسیر پوشه‌ای که برنامه از آن شروع شده.</p>
<ul>
<li>کاربرد: پیدا کردن اسمبلی‌ها و فایل‌های تنظیمات (<code>appsettings.json</code>).</li>
</ul>
</li>
<li>
<p><strong>TargetFrameworkName:</strong> نام و نسخه runtime .NET هدف (طبق <code>.runtimeconfig.json</code>).</p>
<ul>
<li>ممکن است قدیمی‌تر از runtime واقعی باشد.</li>
</ul>
</li>
</ul>
<hr>
<h4><strong>مدیریت سوئیچ‌های ویژگی‌ها</strong></h4>
<ul>
<li>یک دیکشنری سراسری با کلید رشته‌ای و مقدار Boolean برای کنترل ویژگی‌ها فراهم می‌کند.</li>
<li><strong>فعال‌سازی ویژگی توسط مصرف‌کننده کتابخانه:</strong></li>
</ul>
<pre class="hljs"><code>AppContext.SetSwitch(<span class="hljs-string">&quot;MyLibrary.SomeBreakingChange&quot;</span>, <span class="hljs-literal">true</span>);
</code></pre>
<ul>
<li><strong>بررسی وضعیت سوئیچ در کتابخانه:</strong></li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">bool</span> isDefined, switchValue;
isDefined = AppContext.TryGetSwitch(<span class="hljs-string">&quot;MyLibrary.SomeBreakingChange&quot;</span>, <span class="hljs-keyword">out</span> switchValue);
</code></pre>
<ul>
<li><code>TryGetSwitch</code> <strong>false</strong> برمی‌گرداند اگر سوئیچ تعریف نشده باشد؛ این امکان را می‌دهد تا تفاوت بین undefined و false مشخص شود.</li>
</ul>
<blockquote>
<p>نکته طراحی: پارامتر <code>out</code> در این API ضروری نیست و بهتر بود nullable bool برگرداند تا مقدار <code>true</code>, <code>false</code> یا <code>null</code> برای undefined داشته باشیم.<br>
مثال پیشنهادی:</p>
</blockquote>
<pre class="hljs"><code><span class="hljs-built_in">bool</span> switchValue = AppContext.GetSwitch(<span class="hljs-string">&quot;...&quot;</span>) ?? <span class="hljs-literal">false</span>;
</code></pre>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
