

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>مبانی زبان سی‌شارپ</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/Gitab/" aria-current="page">خانه</a>
        <a href="/Gitab/books/list-books">کتاب‌ها</a>
       <a href="/Gitab/translator.html">مترجمین</a>
        <a href="/Gitab/giter.html">گیتر</a>
      </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل دوم: مبانی زبان سی شارپ</h1>
<p>در این فصل، با مبانی زبان سی شارپ آشنا می‌شویم.</p>
<p>تقریباً تمام مثال‌های کدی که در این کتاب آمده‌اند، به صورت نمونه‌های تعاملی (Interactive Samples) در LINQPad در دسترس هستند. کار کردن با این نمونه‌ها در کنار مطالعه کتاب، باعث می‌شود یادگیری شما بسیار سریع‌تر شود، چون می‌توانید کدها را ویرایش کرده و نتیجه را فوراً ببینید، بدون اینکه نیازی به ساخت پروژه‌ها و راه‌حل‌ها (Solutions) در Visual Studio داشته باشید.</p>
<p>برای دانلود نمونه‌ها، در LINQPad روی تب Samples کلیک کنید و سپس گزینه Download more samples را انتخاب نمایید.</p>
<p>💡 نکته:<br>
LINQPad رایگان است. می‌توانید آن را از این آدرس دانلود کنید:<br>
<a href="http://www.linqpad.net">http://www.linqpad.net</a></p>
<h2>اولین برنامه سی‌شارپ</h2>
<p>در ادامه، برنامه‌ای را می‌بینید که عدد ۱۲ را در ۳۰ ضرب کرده و نتیجه‌ی ۳۶۰ را روی صفحه چاپ می‌کند. علامت دو اسلش (//) نشان می‌دهد که بقیه‌ی خط یک توضیح (کامنت) است:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">12</span> * <span class="hljs-number">30</span>;                  <span class="hljs-comment">// دستور 1</span>
System.Console.WriteLine(x);      <span class="hljs-comment">// دستور 2</span>
</code></pre>
<p>برنامه‌ی ما از دو دستور تشکیل شده است. در سی شارپ، دستورات به ترتیب اجرا می‌شوند و با یک سمی‌کالن (;) پایان می‌یابند.</p>
<p>🔹 دستور اول عبارت 12 * 30 را محاسبه کرده و نتیجه را در متغیری به نام x ذخیره می‌کند که نوع آن یک عدد صحیح ۳۲ بیتی (int) است.</p>
<p>🔹 دستور دوم متد WriteLine را از کلاسی به نام Console فراخوانی می‌کند که در یک فضای نام (namespace) به نام System تعریف شده است. این دستور مقدار متغیر x را در یک پنجره متنی روی صفحه نمایش چاپ می‌کند.</p>
<p>یک متد یک وظیفه انجام می‌دهد؛ یک کلاس اعضای تابعی و اعضای داده‌ای را گروه‌بندی می‌کند تا یک بلوک ساختاری شیء‌گرا شکل گیرد. کلاس <strong>Console</strong> اعضایی را گروه‌بندی می‌کند که وظیفه‌ی مدیریت ورودی/خروجی (I/O) خط فرمان را دارند، مانند متد <strong>WriteLine</strong>. یک کلاس نوعی از <strong>type</strong> است که در بخش «Type Basics» در صفحه ۳۶ بررسی می‌کنیم. 🏗️</p>
<p>در بالاترین سطح، انواع (types) در <strong>namespace</strong>ها سازمان‌دهی شده‌اند. بسیاری از انواع پرکاربرد — از جمله کلاس <strong>Console</strong> — در <strong>System namespace</strong> قرار دارند. کتابخانه‌های .NET در <strong>nested namespaces</strong> سازمان‌دهی شده‌اند. برای مثال، <strong>System.Text namespace</strong> شامل انواعی برای مدیریت متن است و <strong><a href="http://System.IO">System.IO</a></strong> شامل انواعی برای ورودی/خروجی می‌باشد. 📚</p>
<p>هر بار که کلاس <strong>Console</strong> را با <strong>System namespace</strong> صدا بزنید، کد شما شلوغ می‌شود. دستور <strong>using</strong> به شما اجازه می‌دهد این شلوغی را حذف کنید و یک namespace را وارد کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;   <span class="hljs-comment">// وارد کردن System namespace</span>
<span class="hljs-built_in">int</span> x = <span class="hljs-number">12</span> * <span class="hljs-number">30</span>;
Console.WriteLine(x);    <span class="hljs-comment">// نیازی به نوشتن System. نیست</span>
</code></pre>
<p>یک شکل پایه‌ای از <strong>code reuse</strong> این است که توابع سطح بالاتر بنویسیم که توابع سطح پایین‌تر را صدا می‌زنند. می‌توانیم برنامه خود را با یک متد قابل استفاده مجدد به نام <strong>FeetToInches</strong> بازسازی کنیم که یک عدد صحیح را در ۱۲ ضرب می‌کند، به صورت زیر:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;

Console.WriteLine(FeetToInches(<span class="hljs-number">30</span>));      <span class="hljs-comment">// 360</span>
Console.WriteLine(FeetToInches(<span class="hljs-number">100</span>));     <span class="hljs-comment">// 1200</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">FeetToInches</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> feet</span>)</span>
{
    <span class="hljs-built_in">int</span> inches = feet * <span class="hljs-number">12</span>;
    <span class="hljs-keyword">return</span> inches;
}
</code></pre>
<p>متد ما شامل مجموعه‌ای از دستورات است که توسط یک جفت آکولاد احاطه شده‌اند. به این مجموعه، <strong>statement block</strong> گفته می‌شود.</p>
<p>یک متد می‌تواند داده ورودی را از فراخواننده دریافت کند با مشخص کردن <strong>parameters</strong> و داده خروجی را به فراخواننده برگرداند با مشخص کردن <strong>return type</strong>. متد <strong>FeetToInches</strong> ما یک پارامتر برای ورودی <strong>feet</strong> دارد و یک نوع بازگشتی برای خروجی <strong>inches</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">FeetToInches</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> feet</span>)
...
</span></code></pre>
<p>🟠 اعداد ۳۰ و ۱۰۰ مقادیری هستند که به متد <strong>FeetToInches</strong> ارسال شده‌اند و به آن <strong>arguments</strong> گفته می‌شود.</p>
<p>اگر یک متد ورودی دریافت نمی‌کند، از پرانتز خالی استفاده کنید. اگر هیچ مقداری باز نمی‌گرداند، از کلیدواژه <strong>void</strong> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;

SayHello();

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SayHello</span>()</span>
{
    Console.WriteLine(<span class="hljs-string">&quot;Hello, world&quot;</span>);
}
</code></pre>
<p>متدها یکی از انواع مختلف <strong>functions</strong> در سی شارپ هستند. نوع دیگری از توابع که در برنامه نمونه ما استفاده شد، عملگر <code>*</code> بود که <strong>ضرب</strong> را انجام می‌دهد. 🔢</p>
<p>همچنین <strong>constructors</strong>، <strong>properties</strong>، <strong>events</strong>، <strong>indexers</strong> و <strong>finalizers</strong> نیز وجود دارند.</p>
<h3>🛠️ کامپایل (Compilation)</h3>
<p>کامپایلر زبان سی شارپ، کد منبع (مجموعه‌ای از فایل‌ها با پسوند .cs) را به یک Assembly تبدیل می‌کند.<br>
یک Assembly واحد اصلی بسته‌بندی و انتشار در .NET است.</p>
<p>📦 <strong>اسمبلی</strong> می‌تواند:</p>
<p>🔹 یک برنامه (Application) باشد.</p>
<p>🔹 یک کتابخانه (Library) باشد.</p>
<p>یک برنامه معمولی کنسول یا ویندوز، دارای نقطه شروع (Entry Point) است، در حالی که کتابخانه این نقطه شروع را ندارد. هدف کتابخانه این است که توسط یک برنامه یا کتابخانه‌های دیگر فراخوانی (Reference) شود.<br>
خود .NET نیز مجموعه‌ای از کتابخانه‌ها (و همچنین یک محیط اجرایی Runtime) است.</p>
<hr>
<p><strong>✏️ Top-Level Statements</strong></p>
<p>تمام برنامه‌های بخش قبلی، مستقیماً با مجموعه‌ای از دستورات شروع می‌شدند که به آن‌ها Top-Level Statements گفته می‌شود.<br>
وجود این نوع دستورات، به طور ضمنی یک نقطه شروع برای برنامه کنسول یا ویندوز ایجاد می‌کند.</p>
<p>بدون Top-Level Statements، متد Main به‌عنوان نقطه شروع برنامه در نظر گرفته می‌شود. (توضیحات بیشتر در بخش Custom Types صفحه 37 آمده است.)</p>
<p><strong>📂 تفاوت پسوندها در .NET 8</strong></p>
<p>برخلاف .NET Framework، اسمبلی‌های .NET 8 هرگز پسوند .exe ندارند.<br>
فایلی که پس از ساخت یک برنامه .NET 8 با پسوند .exe می‌بینید، در واقع یک بارگذار (Loader) بومی و وابسته به پلتفرم است که مسئول اجرای اسمبلی اصلی شما با پسوند .dll می‌باشد.</p>
<p><strong>📦 انتشار Self-Contained</strong></p>
<p>در .NET 8 می‌توانید یک Self-Contained Deployment ایجاد کنید که شامل:</p>
<p>🔹 Loader</p>
<p>🔹 اسمبلی‌های شما</p>
<p>🔹 بخش‌های لازم از Runtime</p>
<p>همه این موارد در قالب یک فایل .exe تکی قرار می‌گیرند.</p>
<p>همچنین .NET 8 از کامپایل AOT (Ahead-Of-Time) نیز پشتیبانی می‌کند که باعث:</p>
<p>🔹 شروع سریع‌تر برنامه 🚀</p>
<p>🔹 مصرف کمتر حافظه 💾<br>
می‌شود.</p>
<p><strong>💻 ابزار dotnet</strong></p>
<p>ابزار dotnet (یا dotnet.exe در ویندوز) برای مدیریت کد منبع و فایل‌های باینری .NET از خط فرمان استفاده می‌شود.</p>
<p>با این ابزار می‌توانید:</p>
<p>🔹 برنامه خود را بسازید (Build)</p>
<p>🔹 آن را اجرا کنید (Run)</p>
<p>این کار جایگزینی برای استفاده از محیط‌های توسعه یکپارچه مثل Visual Studio یا Visual Studio Code است.</p>
<p><strong>📍 محل نصب پیش‌فرض:</strong></p>
<p>🔹 ویندوز: %ProgramFiles%\dotnet</p>
<p>🔹 لینوکس (Ubuntu): /usr/bin/dotnet</p>
<p><strong>📝 ساخت یک پروژه کنسول جدید</strong></p>
<p>برای کامپایل برنامه، ابزار dotnet به یک فایل پروژه و حداقل یک فایل C# نیاز دارد.<br>
دستور زیر ساختار اولیه یک پروژه کنسول را ایجاد می‌کند:</p>
<pre class="hljs"><code>dotnet new Console -n MyFirstProgram
</code></pre>
<p>🔹 این دستور یک پوشه به نام MyFirstProgram ایجاد می‌کند که شامل:</p>
<p>🔹 فایل پروژه: MyFirstProgram.csproj</p>
<p>🔹 فایل کد: Program.cs (که پیام &quot;Hello world&quot; را چاپ می‌کند)</p>
<p><strong>▶️ اجرای برنامه</strong></p>
<p>برای ساخت و اجرای برنامه از پوشه پروژه:</p>
<pre class="hljs"><code>dotnet run MyFirstProgram
</code></pre>
<p>فقط برای ساخت (بدون اجرا):</p>
<pre class="hljs"><code>dotnet build MyFirstProgram.csproj
</code></pre>
<p>📌 خروجی اسمبلی در یک زیرپوشه از مسیر bin\debug ذخیره می‌شود.</p>
<p>توضیحات کامل در مورد اسمبلی‌ها در فصل 17 خواهد آمد. 📖</p>
<h3>نحو (Syntax)</h3>
<p>نحو یا Syntax در C# از زبان‌های C و C++ الهام گرفته شده است. در این بخش، ما اجزای نحو زبان C# را با استفاده از برنامه‌ی زیر توضیح می‌دهیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-built_in">int</span> x = <span class="hljs-number">12</span> * <span class="hljs-number">30</span>;
Console.WriteLine(x);
</code></pre>
<h4>شناسه‌ها (Identifiers) و کلمات کلیدی (Keywords)</h4>
<p>شناسه‌ها (Identifiers) همان نام‌هایی هستند که برنامه‌نویس برای کلاس‌ها، متدها، متغیرها و سایر اجزای برنامه انتخاب می‌کند. در مثال بالا، شناسه‌ها به ترتیب ظاهر شدن عبارتند از:</p>
<pre class="hljs"><code>System   x   <span class="hljs-built_in">Console</span>   WriteLine
</code></pre>
<p>یک شناسه باید یک کلمه کامل باشد که اساساً از کاراکترهای یونیکد (Unicode) ساخته شده و با یک حرف یا خط زیرین (_) شروع شود.<br>
شناسه‌ها در C# به بزرگی و کوچکی حروف حساس هستند.</p>
<p>به صورت قراردادی:</p>
<p>🔹 پارامترها، متغیرهای محلی و فیلدهای خصوصی باید به شکل camelCase نوشته شوند. مثال:</p>
<pre class="hljs"><code><span class="hljs-attribute">myVariable</span>
</code></pre>
<p>🔹 سایر شناسه‌ها (مثل نام کلاس‌ها و متدها) باید به شکل PascalCase باشند. مثال:</p>
<pre class="hljs"><code><span class="hljs-attribute">MyMethod</span>
</code></pre>
<p><strong>کلمات کلیدی (Keywords)</strong></p>
<p>کلمات کلیدی، نام‌هایی هستند که برای کامپایلر معنای خاصی دارند. در مثال ما، دو کلمه کلیدی وجود دارد:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span>   <span class="hljs-type">int</span>
</code></pre>
<p>بیشتر کلمات کلیدی رزرو شده هستند، به این معنی که شما نمی‌توانید آن‌ها را به عنوان شناسه استفاده کنید. در اینجا لیست کامل کلمات کلیدی رزرو شده سی‌شارپ آمده است:</p>
<pre class="hljs"><code><span class="hljs-keyword">abstract</span>    <span class="hljs-keyword">do</span>          <span class="hljs-keyword">protected</span>     <span class="hljs-built_in">sbyte</span>
<span class="hljs-keyword">as</span>          <span class="hljs-built_in">double</span>      <span class="hljs-keyword">public</span>        <span class="hljs-keyword">sealed</span>
<span class="hljs-keyword">base</span>        <span class="hljs-keyword">else</span>        <span class="hljs-keyword">readonly</span>      <span class="hljs-built_in">short</span>
<span class="hljs-built_in">bool</span>        <span class="hljs-built_in">enum</span>        <span class="hljs-keyword">record</span>        <span class="hljs-title">sizeof</span>
<span class="hljs-title">break</span>       <span class="hljs-title">event</span>       <span class="hljs-title">ref</span>           <span class="hljs-title">stackalloc</span>
<span class="hljs-title">byte</span>        <span class="hljs-title">explicit</span>    <span class="hljs-title">return</span>        <span class="hljs-title">static</span>
<span class="hljs-title">case</span>        <span class="hljs-title">extern</span>      <span class="hljs-title">float</span>         <span class="hljs-title">string</span>
<span class="hljs-title">catch</span>       <span class="hljs-title">false</span>       <span class="hljs-title">for</span>           <span class="hljs-title">struct</span>
<span class="hljs-title">char</span>        <span class="hljs-title">finally</span>     <span class="hljs-title">foreach</span>       <span class="hljs-title">switch</span>
<span class="hljs-title">checked</span>     <span class="hljs-title">fixed</span>       <span class="hljs-title">goto</span>          <span class="hljs-title">this</span>
<span class="hljs-title">class</span>       <span class="hljs-title">if</span>          <span class="hljs-title">throw</span>         <span class="hljs-title">true</span>
<span class="hljs-title">const</span>       <span class="hljs-title">implicit</span>    <span class="hljs-title">try</span>           <span class="hljs-title">typeof</span>
<span class="hljs-title">continue</span>    <span class="hljs-title">in</span>          <span class="hljs-title">uint</span>          <span class="hljs-title">ulong</span>
<span class="hljs-title">decimal</span>     <span class="hljs-title">int</span>         <span class="hljs-title">unchecked</span>     <span class="hljs-title">unsafe</span>
<span class="hljs-title">default</span>     <span class="hljs-title">interface</span>   <span class="hljs-title">ushort</span>        <span class="hljs-title">using</span>
<span class="hljs-title">delegate</span>    <span class="hljs-title">internal</span>    <span class="hljs-title">virtual</span>       <span class="hljs-title">void</span>
            <span class="hljs-title">is</span>          <span class="hljs-title">volatile</span>      <span class="hljs-title">while</span>
            <span class="hljs-title">lock</span>
            <span class="hljs-title">long</span>
            <span class="hljs-title">namespace</span>
            <span class="hljs-title">new</span>
            <span class="hljs-title">null</span>
            <span class="hljs-title">object</span>
            <span class="hljs-title">operator</span>
            <span class="hljs-title">out</span>
            <span class="hljs-title">override</span>
            <span class="hljs-title">params</span>
            <span class="hljs-title">private</span>
</code></pre>
<p>اگر واقعاً بخواهید از یک شناسه استفاده کنید که با یک کلمه کلیدی رزرو شده تداخل دارد، می‌توانید با استفاده از پیشوند @ این کار را انجام دهید. مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> <span class="hljs-keyword">using</span> = <span class="hljs-number">123</span>;      <span class="hljs-comment">// غیرمجاز ❌</span>
<span class="hljs-built_in">int</span> @using = <span class="hljs-number">123</span>;     <span class="hljs-comment">// مجاز ✅</span>
</code></pre>
<p>علامت @ بخشی از خود شناسه محسوب نمی‌شود. بنابراین:</p>
<pre class="hljs"><code><span class="hljs-keyword">@myVariable</span>
</code></pre>
<p>و</p>
<pre class="hljs"><code><span class="hljs-attribute">myVariable</span>
</code></pre>
<p>کاملاً یکسان هستند. 🖋️</p>
<h3>کلمات کلیدی متنی</h3>
<p>برخی از کلمات کلیدی متنی (contextual) هستند، به این معنی که می‌توانید از آن‌ها به عنوان شناسه نیز استفاده کنید—بدون نماد @:</p>
<pre class="hljs"><code><span class="hljs-keyword">add</span>         <span class="hljs-keyword">descending</span>  <span class="hljs-keyword">global</span>        <span class="hljs-keyword">notnull</span>     <span class="hljs-keyword">remove</span>      <span class="hljs-keyword">var</span>
<span class="hljs-keyword">alias</span>       <span class="hljs-built_in">dynamic</span>     <span class="hljs-keyword">group</span>         <span class="hljs-built_in">nuint</span>       <span class="hljs-keyword">required</span>    <span class="hljs-keyword">with</span>
<span class="hljs-keyword">and</span>         <span class="hljs-keyword">equals</span>      <span class="hljs-keyword">init</span>          <span class="hljs-keyword">on</span>          <span class="hljs-keyword">select</span>      <span class="hljs-keyword">when</span>
<span class="hljs-keyword">ascending</span>   <span class="hljs-keyword">file</span>        <span class="hljs-keyword">into</span>          <span class="hljs-keyword">or</span>          <span class="hljs-keyword">set</span>         <span class="hljs-keyword">where</span>
<span class="hljs-keyword">async</span>       <span class="hljs-keyword">from</span>        <span class="hljs-keyword">join</span>          <span class="hljs-keyword">orderby</span>     <span class="hljs-keyword">unmanaged</span>   <span class="hljs-keyword">yield</span>
<span class="hljs-keyword">await</span>       <span class="hljs-keyword">get</span>         <span class="hljs-keyword">let</span>           <span class="hljs-keyword">partial</span>     <span class="hljs-keyword">value</span>
<span class="hljs-keyword">by</span>          managed     <span class="hljs-keyword">nameof</span>
</code></pre>
<p>با کلمات کلیدی متنی، ابهام نمی‌تواند در متنی که در آن استفاده می‌شوند، ایجاد شود.</p>
<h3>ثابت‌ها (Literals)، نشانه‌گذارها (Punctuators)، و عملگرها (Operators)</h3>
<p>ثابت‌ها، داده‌های اولیه‌ای هستند که به صورت مستقیم و نوشتاری درون برنامه قرار می‌گیرند.<br>
برای مثال، در برنامه نمونه ما، 12 و 30 نمونه‌هایی از ثابت‌ها هستند.</p>
<p>نشانه‌گذارها به ساختاربندی و جدا کردن بخش‌های مختلف برنامه کمک می‌کنند.<br>
یک مثال، سمی‌کالن (;) است که یک دستور را خاتمه می‌دهد.<br>
دستورات می‌توانند در چند خط نوشته شوند:</p>
<pre class="hljs"><code>Console.WriteLine
    (<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + <span class="hljs-number">7</span> + <span class="hljs-number">8</span> + <span class="hljs-number">9</span> + <span class="hljs-number">10</span>);
</code></pre>
<p>عملگرها عبارت‌ها را تغییر داده یا با هم ترکیب می‌کنند. بیشتر عملگرها در C# با یک نماد مشخص می‌شوند؛<br>
مثلاً عملگر ضرب *.</p>
<p>ما عملگرها را در ادامه این فصل به‌طور کامل بررسی خواهیم کرد.<br>
در برنامه نمونه‌مان، عملگرهای زیر را استفاده کردیم:</p>
<pre class="hljs"><code>=   *   .   ()
</code></pre>
<p>🔹 نقطه (.) یک عضو از چیزی را مشخص می‌کند (یا در اعداد اعشاری، نقش ممیز را دارد).</p>
<p>🔹 پرانتزها (()) هنگام تعریف یا فراخوانی یک متد استفاده می‌شوند؛ پرانتز خالی یعنی متد هیچ آرگومانی نمی‌گیرد. (پرانتزها کاربردهای دیگری هم دارند که در ادامه این فصل خواهید دید.)</p>
<p>🔹 علامت مساوی (=) برای انتساب مقدار به کار می‌رود.</p>
<p>🔹 علامت مساوی دوتایی (==) برای مقایسه برابری استفاده می‌شود.</p>
<h3>توضیحات (Comments)</h3>
<p>زبان C# دو روش برای نوشتن توضیحات در کد ارائه می‌دهد:</p>
<ol>
<li>توضیحات تک‌خطی (Single-line)<br>
با دو خط مورب (//) شروع می‌شوند و تا پایان همان خط ادامه دارند:</li>
</ol>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">3</span>;   <span class="hljs-comment">// توضیحی درباره مقداردهی 3 به x</span>
</code></pre>
<ol start="2">
<li>توضیحات چندخطی (Multiline)<br>
با /<em>آغاز و با</em>/ پایان می‌یابند:</li>
</ol>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">3</span>;   <span class="hljs-comment">/* این یک توضیح است
                که در دو خط نوشته شده */</span>
</code></pre>
<p>همچنین، توضیحات می‌توانند شامل برچسب‌های مستندسازی XML باشند که در بخش «XML Documentation» در صفحه ۲۷۲ توضیح داده خواهد شد. 📝</p>
<h2>اصول اولیه نوع داده 🧩 Types</h2>
<p>یک نوع داده (Type) در واقع نقشه یا قالبی است که برای یک مقدار تعریف می‌شود.</p>
<p>در این مثال، ما دو لیترال (literal) از نوع int با مقادیر 12 و 30 داریم. همچنین یک متغیر از نوع int به نام x تعریف می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">12</span> * <span class="hljs-number">30</span>;
Console.WriteLine(x);
</code></pre>
<p>🟡 از آنجا که بیشتر نمونه‌کدهای این کتاب به نوع‌هایی از فضای نام (namespace) System نیاز دارند، از این به بعد عبارت using System را نمی‌آوریم، مگر این‌که بخواهیم مفهومی مرتبط با فضای نام‌ها را توضیح دهیم.</p>
<p>🔹 متغیر (Variable) به یک محل ذخیره‌سازی اشاره دارد که می‌تواند در طول زمان مقادیر متفاوتی بگیرد.<br>
در مقابل، ثابت (Constant) همیشه یک مقدار ثابت و تغییر‌ناپذیر دارد (در ادامه مفصل توضیح می‌دهیم):</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> y = <span class="hljs-number">360</span>;
</code></pre>
<p>📌 در زبان سی شارپ، تمام مقادیر، نمونه‌ای از یک نوع داده هستند.<br>
نوع داده تعیین می‌کند که:</p>
<p>🔹 مقدار چه معنایی دارد 📝</p>
<p>🔹 و یک متغیر چه مقادیر ممکنی می‌تواند داشته باشد 🎯</p>
<h3>📌 نمونه‌هایی از انواع از پیش تعریف‌شده (Predefined Type Examples)</h3>
<p>انواع از پیش تعریف‌شده، نوع‌هایی هستند که به شکل ویژه توسط کامپایلر پشتیبانی می‌شوند.<br>
به‌عنوان مثال، نوع int یک نوع از پیش تعریف‌شده برای نمایش مجموعه‌ای از اعداد صحیح است که در ۳۲ بیت حافظه جای می‌گیرند؛ این محدوده از  2³¹ تا 2³¹- را پوشش می‌دهد. همچنین، برای مقادیر عددی که در این بازه هستند، نوع پیش‌فرض int استفاده می‌شود.<br>
شما می‌توانید روی متغیرهایی از نوع int عمل‌هایی مانند محاسبات ریاضی انجام دهید، به شکل زیر:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">12</span> * <span class="hljs-number">30</span>;
</code></pre>
<p>نوع از پیش تعریف‌شده دیگر در C#، نوع string است. این نوع نشان‌دهنده‌ی یک دنباله از کاراکترهاست، مثل &quot;.NET&quot; یا &quot;<a href="http://oreilly.com">http://oreilly.com</a>&quot;. شما می‌توانید با استفاده از متدهای این نوع، روی رشته‌ها کار کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> message = <span class="hljs-string">&quot;Hello world&quot;</span>;
<span class="hljs-built_in">string</span> upperMessage = message.ToUpper();
Console.WriteLine(upperMessage); <span class="hljs-comment">// HELLO WORLD</span>

<span class="hljs-built_in">int</span> x = <span class="hljs-number">2022</span>;
message = message + x.ToString();
Console.WriteLine(message); <span class="hljs-comment">// Hello world2022</span>
</code></pre>
<p>در این مثال، ما از x.ToString() استفاده کردیم تا یک نمایش رشته‌ای از عدد صحیح x به دست آوریم.<br>
جالب است بدانید که شما می‌توانید روی تقریباً هر نوع داده‌ای متد ToString() را فراخوانی کنید.</p>
<p><strong>✅ نوع بولی (bool)</strong></p>
<p>نوع از پیش تعریف‌شده bool فقط دو مقدار ممکن دارد: true و false.<br>
این نوع معمولاً همراه با دستور if برای اجرای شرطی کد استفاده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">bool</span> simpleVar = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">if</span> (simpleVar)
    Console.WriteLine(<span class="hljs-string">&quot;This will not print&quot;</span>);

<span class="hljs-built_in">int</span> x = <span class="hljs-number">5000</span>;
<span class="hljs-built_in">bool</span> lessThanAMile = x &lt; <span class="hljs-number">5280</span>;
<span class="hljs-keyword">if</span> (lessThanAMile)
    Console.WriteLine(<span class="hljs-string">&quot;This will print&quot;</span>);
</code></pre>
<p><strong>🛠 انواع سفارشی (Custom Types)</strong></p>
<p>در C#، انواع از پیش تعریف‌شده (که به آن‌ها Built-in Types هم گفته می‌شود) با یک کلیدواژه‌ی C# شناخته می‌شوند.<br>
فضای نام System در .NET شامل بسیاری از انواع مهم است که در C# از پیش تعریف نشده‌اند (مثلاً DateTime).</p>
<p>همان‌طور که می‌توانیم متدهای خودمان را بنویسیم، می‌توانیم انواع (کلاس‌ها) را هم بسازیم.<br>
در مثال زیر، ما یک نوع سفارشی به نام UnitConverter تعریف کرده‌ایم؛ یک کلاس که به عنوان الگو برای تبدیل واحدها عمل می‌کند:</p>
<pre class="hljs"><code>UnitConverter feetToInchesConverter = <span class="hljs-keyword">new</span> UnitConverter(<span class="hljs-number">12</span>);
UnitConverter milesToFeetConverter  = <span class="hljs-keyword">new</span> UnitConverter(<span class="hljs-number">5280</span>);

Console.WriteLine(feetToInchesConverter.Convert(<span class="hljs-number">30</span>));    <span class="hljs-comment">// 360</span>
Console.WriteLine(feetToInchesConverter.Convert(<span class="hljs-number">100</span>));   <span class="hljs-comment">// 1200</span>
Console.WriteLine(feetToInchesConverter.Convert(
                  milesToFeetConverter.Convert(<span class="hljs-number">1</span>)));     <span class="hljs-comment">// 63360</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnitConverter</span>
{
    <span class="hljs-built_in">int</span> ratio; <span class="hljs-comment">// فیلد (Field)</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnitConverter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> unitRatio</span>) <span class="hljs-comment">// سازنده (Constructor)</span></span>
    {
        ratio = unitRatio;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Convert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> unit</span>) <span class="hljs-comment">// متد (Method)</span></span>
    {
        <span class="hljs-keyword">return</span> unit * ratio;
    }
}
</code></pre>
<p>در این مثال، تعریف کلاس ما در همان فایلی قرار دارد که دستورات سطح بالا (Top-level statements) نوشته شده‌اند.<br>
این کار قانونی است—به شرطی که دستورات سطح بالا قبل از تعریف کلاس بیایند—و در برنامه‌های کوچک آزمایشی، کاملاً پذیرفته‌شده است.<br>
اما در برنامه‌های بزرگ‌تر، رویکرد استاندارد این است که تعریف کلاس را در یک فایل جداگانه قرار دهیم؛ مثلاً در UnitConverter.cs.</p>
<h4>اعضای یک نوع (Members of a Type) 🧩</h4>
<p>یک نوع (Type) شامل دو دسته عضو است:</p>
<p>1️⃣ اعضای داده‌ای (Data Members) → داده‌ها را نگهداری می‌کنند.</p>
<p>2️⃣ اعضای تابعی (Function Members) → عملیات و رفتار مرتبط با داده‌ها را انجام می‌دهند.</p>
<p>در مثال UnitConverter:</p>
<p>🔹 عضو داده‌ای → فیلدی به نام ratio که نسبت تبدیل را ذخیره می‌کند.</p>
<p>🔹 اعضای تابعی → متد Convert و سازنده‌ی (Constructor) کلاس UnitConverter.</p>
<h4>تقارن بین انواع از پیش تعریف‌شده و انواع سفارشی ⚖️</h4>
<p>یکی از ویژگی‌های زیبا در C# این است که انواع از پیش تعریف‌شده (مثل int) و انواع سفارشی (مثل UnitConverter) از نظر ساختار، تفاوت کمی دارند:</p>
<p>🔹 نوع int → یک نقشه (Blueprint) برای اعداد صحیح است. داده ذخیره می‌کند (۳۲ بیت) و توابعی مثل ToString برای کار با آن دارد.</p>
<p>🔹 نوع UnitConverter → یک نقشه برای تبدیل واحدها است. داده‌ای (نسبت تبدیل) را نگهداری می‌کند و توابعی برای استفاده از آن دارد.</p>
<h4>سازنده‌ها و نمونه‌سازی (Constructors &amp; Instantiation) 🏗️</h4>
<p>🔹 ایجاد داده‌ها با نمونه‌سازی (Instantiation) انجام می‌شود.</p>
<p>🔹 انواع از پیش تعریف‌شده را می‌توان با یک لیترال ایجاد کرد، مثل:</p>
<pre class="hljs"><code><span class="hljs-string">&quot;Hello world&quot;</span>
</code></pre>
<p>🔹 برای ایجاد نمونه از یک نوع سفارشی باید از عملگر new استفاده کنیم:</p>
<pre class="hljs"><code>UnitConverter feetToInchesConverter = <span class="hljs-keyword">new</span> UnitConverter(<span class="hljs-number">12</span>);
</code></pre>
<p>🔹 بعد از اجرای new، سازنده‌ی آن نوع فراخوانی می‌شود تا داده‌ها مقداردهی اولیه شوند.</p>
<p><strong>تعریف یک سازنده 🛠️</strong></p>
<p>یک سازنده درست مثل یک متد نوشته می‌شود، با این تفاوت که:</p>
<p>🔹 نام آن دقیقا همان نام نوع است.</p>
<p>🔹 نوع بازگشتی ندارد.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnitConverter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> unitRatio</span>)</span> 
{
    ratio = unitRatio;
}
</code></pre>
<h3>🆚 اعضای نمونه (Instance) در برابر اعضای ایستا (Static)</h3>
<p>اعضای داده‌ای و اعضای تابعی که روی نمونه‌ای از یک نوع (Type) عمل می‌کنند، «اعضای نمونه» (Instance Members) نام دارند.<br>
مثلاً متد Convert در کلاس UnitConverter و متد ToString در نوع int نمونه‌هایی از اعضای نمونه هستند.<br>
به‌طور پیش‌فرض، اعضا در سی‌شارپ «نمونه‌ای» هستند.</p>
<p>در مقابل، اعضای داده‌ای و تابعی که روی نمونه خاصی از نوع عمل نمی‌کنند، می‌توانند با کلمه کلیدی static علامت‌گذاری شوند.<br>
برای دسترسی به یک عضو ایستا از بیرونِ نوع، به جای یک نمونه، نام خودِ نوع را مشخص می‌کنیم.<br>
مثلاً متد WriteLine در کلاس Console یک عضو ایستا است، بنابراین آن را این‌طور فراخوانی می‌کنیم:</p>
<pre class="hljs"><code>Console.WriteLine();
</code></pre>
<p>و نه این‌طور:</p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> Console().WriteLine();
</code></pre>
<p>📌 کلاس Console در واقع به‌عنوان یک کلاس ایستا (Static Class) تعریف شده است. این یعنی تمام اعضای آن ایستا هستند و شما هرگز نمی‌توانید نمونه‌ای از Console بسازید.</p>
<p><strong>📍 مثال — تفاوت عضو نمونه و ایستا</strong></p>
<p>در کد زیر، فیلد نمونه‌ای Name به یک نمونه خاص از کلاس Panda مربوط می‌شود،<br>
در حالی که فیلد ایستای Population به مجموع همه نمونه‌های Panda ارتباط دارد:</p>
<pre class="hljs"><code>Panda p1 = <span class="hljs-keyword">new</span> Panda(<span class="hljs-string">&quot;Pan Dee&quot;</span>);
Panda p2 = <span class="hljs-keyword">new</span> Panda(<span class="hljs-string">&quot;Pan Dah&quot;</span>);

Console.WriteLine(p1.Name);      <span class="hljs-comment">// Pan Dee</span>
Console.WriteLine(p2.Name);      <span class="hljs-comment">// Pan Dah</span>
Console.WriteLine(Panda.Population); <span class="hljs-comment">// 2</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Panda</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;             <span class="hljs-comment">// 🐼 فیلد نمونه‌ای</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Population;   <span class="hljs-comment">// 🌍 فیلد ایستا</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Panda</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> n</span>)          <span class="hljs-comment">// 🔹 سازنده (Constructor)</span></span>
    {
        Name = n;                   <span class="hljs-comment">// مقداردهی فیلد نمونه‌ای</span>
        Population = Population + <span class="hljs-number">1</span>; <span class="hljs-comment">// افزایش فیلد ایستا</span>
    }
}
</code></pre>
<p>📌 اگر بخواهید p1.Population یا <a href="http://Panda.Name">Panda.Name</a> را ارزیابی کنید،<br>
کامپایلر یک خطای زمان کامپایل (Compile-time Error) تولید خواهد کرد.</p>
<h4>🔑 کلیدواژه public</h4>
<p>کلیدواژه public اعضای یک کلاس را برای دسترسی توسط سایر کلاس‌ها قابل مشاهده می‌کند.<br>
در این مثال، اگر فیلد Name در کلاس Panda با public علامت‌گذاری نشده بود، به‌صورت خصوصی (private) در نظر گرفته می‌شد و امکان دسترسی به آن از خارج کلاس وجود نداشت.</p>
<p>علامت‌گذاری یک عضو به‌صورت public، روشی است که یک نوع (type) این پیام را منتقل می‌کند:</p>
<p>«اینجا چیزهایی است که می‌خواهم بقیه‌ی انواع ببینند — بقیه‌اش جزئیات داخلی و شخصی خودم است.»</p>
<p>در اصطلاحات برنامه‌نویسی شیءگرا (OOP)، می‌گوییم اعضای عمومی (public members)، اعضای خصوصی (private members) کلاس را کپسوله‌سازی (encapsulate) می‌کنند.</p>
<h4>📦 تعریف فضای نام (Namespace)</h4>
<p>به‌خصوص در برنامه‌های بزرگ، منطقی است که انواع (Types) را در قالب فضای نام (namespace)‌ها سازمان‌دهی کنیم.<br>
مثال: تعریف کلاس Panda درون فضای نامی به نام Animals 👇</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> Animals;

Panda p = <span class="hljs-keyword">new</span> Panda(<span class="hljs-string">&quot;Pan Dee&quot;</span>);
Console.WriteLine(p.Name);

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Animals</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Panda</span>
    {
        ...
    }
}
</code></pre>
<p>در این مثال، ما فضای نام Animals را وارد (import) کردیم تا بتوانیم در کدهای سطح بالا (Top-level statements) به انواع داخل آن بدون پیشوند کامل دسترسی داشته باشیم.</p>
<p>بدون این وارد کردن، مجبور بودیم به این شکل بنویسیم:</p>
<pre class="hljs"><code>Animals.Panda p = <span class="hljs-keyword">new</span> Animals.Panda(<span class="hljs-string">&quot;Pan Dee&quot;</span>);
</code></pre>
<p>📖 یادداشت: ما مبحث فضای نام‌ها را به‌طور کامل در انتهای این فصل بررسی می‌کنیم (بخش Namespaces در صفحه ۹۵).</p>
<h4>📌 تعریف متد Main</h4>
<p>تا اینجای کار، تمام مثال‌های ما از دستورات سطح بالا (Top-Level Statements) استفاده کرده‌اند؛ این قابلیت از نسخه C# 9 معرفی شد.</p>
<p>🔹 بدون استفاده از دستورات سطح بالا، یک برنامه‌ی ساده‌ی کنسول یا ویندوز به این شکل نوشته می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()   <span class="hljs-comment">// نقطه شروع برنامه</span></span>
    {
        <span class="hljs-built_in">int</span> x = <span class="hljs-number">12</span> * <span class="hljs-number">30</span>;
        Console.WriteLine(x);
    }
}
</code></pre>
<p>💡 در نبود دستورات سطح بالا، زبان C# به دنبال یک متد ایستا (static) به نام Main می‌گردد که نقطه‌ی شروع برنامه محسوب می‌شود.</p>
<p>🔹 متد Main می‌تواند در هر کلاسی تعریف شود (اما فقط یک متد Main می‌تواند وجود داشته باشد).</p>
<p>🔹 این متد می‌تواند به‌صورت اختیاری به جای void یک عدد صحیح (int) برگرداند تا نتیجه‌ای به محیط اجرای برنامه (Execution Environment) ارسال کند. معمولاً یک مقدار غیر صفر نشان‌دهنده‌ی وقوع خطاست.</p>
<p>🔹 همچنین متد Main می‌تواند به صورت اختیاری یک آرایه از رشته‌ها (string[]) به‌عنوان پارامتر بگیرد که شامل آرگومان‌هایی است که به فایل اجرایی پاس داده شده‌اند.</p>
<p>📌 مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Main</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span> { ... }
</code></pre>
<p><strong>📚 نکته: آرایه‌ها در C#</strong></p>
<p>آرایه (مثل string[]) مجموعه‌ای ثابت از عناصر یک نوع خاص را نشان می‌دهد.<br>
برای تعریف آرایه، براکت مربع ([]) را بعد از نوع داده قرار می‌دهیم.<br>
(آرایه‌ها به طور کامل در بخش &quot;آرایه‌ها&quot; در صفحه 61 توضیح داده می‌شوند.)</p>
<p>💡 همچنین متد Main می‌تواند با کلمه‌ی کلیدی async تعریف شود و مقدار Task یا Task<int> برگرداند تا از برنامه‌نویسی غیرهمزمان (Asynchronous Programming) پشتیبانی کند. این موضوع را در فصل 14 بررسی می‌کنیم.</p>
<h3>🏷 دستورات سطح بالا (Top-Level Statements)</h3>
<p>دستورات سطح بالا که در C# 9 معرفی شدند، به شما اجازه می‌دهند بدون نیاز به نوشتن متد Main استاتیک و یک کلاس حاوی آن، برنامه را شروع کنید.<br>
یک فایل شامل دستورات سطح بالا از سه بخش تشکیل می‌شود که به همین ترتیب می‌آیند:</p>
<p>1️⃣ (اختیاری) — دستورهای using</p>
<p>2️⃣ یک‌سری دستورات که می‌توانند با تعریف متدها مخلوط شوند (اختیاری)</p>
<p>3️⃣ (اختیاری) — اعلان نوع‌ها و فضای‌نام‌ها (Types &amp; Namespaces)</p>
<p>📌 مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;                           <span class="hljs-comment">// بخش ۱</span>
Console.WriteLine(<span class="hljs-string">&quot;Hello, world&quot;</span>);      <span class="hljs-comment">// بخش ۲</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SomeMethod1</span>()</span> { ... }              <span class="hljs-comment">// بخش ۲</span>
Console.WriteLine(<span class="hljs-string">&quot;Hello again!&quot;</span>);      <span class="hljs-comment">// بخش ۲</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SomeMethod2</span>()</span> { ... }              <span class="hljs-comment">// بخش ۲</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> { ... }                 <span class="hljs-comment">// بخش ۳</span>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">SomeNamespace</span> { ... }         <span class="hljs-comment">// بخش ۳</span>
</code></pre>
<p>💡 چون CLR (ماشین مجازی دات‌نت) به طور مستقیم از دستورات سطح بالا پشتیبانی نمی‌کند، کامپایلر کد شما را به شکلی مشابه زیر ترجمه می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;                           <span class="hljs-comment">// بخش ۱</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>$   <span class="hljs-comment">// نام خاص تولیدشده توسط کامپایلر</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Main$(<span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span>)    <span class="hljs-comment">// نام خاص تولیدشده توسط کامپایلر</span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;Hello, world&quot;</span>);  <span class="hljs-comment">// بخش ۲</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SomeMethod1</span>()</span> { ... }          <span class="hljs-comment">// بخش ۲</span>
        Console.WriteLine(<span class="hljs-string">&quot;Hello again!&quot;</span>);  <span class="hljs-comment">// بخش ۲</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SomeMethod2</span>()</span> { ... }          <span class="hljs-comment">// بخش ۲</span>
    }
}
<span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> { ... }                     <span class="hljs-comment">// بخش ۳</span>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">SomeNamespace</span> { ... }             <span class="hljs-comment">// بخش ۳</span>
</code></pre>
<p>🔍 نکته مهم این است که تمام بخش ۲ درون متد Main قرار می‌گیرد.<br>
به این معنا که SomeMethod1 و SomeMethod2 در عمل متدهای محلی هستند.<br>
ما اثرات کامل این موضوع را در بخش متدهای محلی (صفحه ۱۰۶) بررسی می‌کنیم. مهم‌ترین نکته این است که متدهای محلی (مگر اینکه به صورت static تعریف شوند) می‌توانند به متغیرهای تعریف‌شده در همان متد دسترسی داشته باشند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">3</span>;
LocalMethod();
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LocalMethod</span>()</span> { Console.WriteLine(x); }  <span class="hljs-comment">// می‌توانیم به x دسترسی داشته باشیم</span>
</code></pre>
<p>⚠️ نتیجه دیگر این است که متدهای سطح بالا را نمی‌توان از کلاس‌ها یا نوع‌های دیگر فراخوانی کرد.</p>
<p>📌 ویژگی‌های دیگر:</p>
<p>🔹 متد سطح بالا می‌تواند به صورت اختیاری یک مقدار عدد صحیح (int) به فراخواننده برگرداند.</p>
<p>🔹 همچنین می‌تواند به یک متغیر جادویی به نام args (از نوع string[]) دسترسی داشته باشد که شامل آرگومان‌های خط فرمانی است که توسط فراخواننده ارسال شده‌اند.</p>
<p>❗ از آنجایی که یک برنامه فقط می‌تواند یک نقطه ورود (Entry Point) داشته باشد، در هر پروژه C# حداکثر می‌توان یک فایل با دستورات سطح بالا داشت.</p>
<h3>انواع و تبدیل‌ها (Types and Conversions)</h3>
<p>زبان C# می‌تواند بین نمونه‌های انواع (Types) سازگار، تبدیل انجام دهد. هر تبدیل همیشه یک مقدار جدید را از یک مقدار موجود ایجاد می‌کند.</p>
<p>تبدیل‌ها می‌توانند ضمنی (Implicit) یا صریح (Explicit) باشند:</p>
<p>🔹 تبدیل ضمنی به‌طور خودکار انجام می‌شود.</p>
<p>🔹 تبدیل صریح نیاز به عملیات Cast دارد.</p>
<p>در مثال زیر:</p>
<p>🔹 یک int به‌صورت ضمنی به long (که دو برابر ظرفیت بیتی int را دارد) تبدیل می‌شود.</p>
<p>🔹 یک int به‌صورت صریح به short (که نصف ظرفیت بیتی int را دارد) Cast می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">12345</span>;       <span class="hljs-comment">// int یک عدد صحیح ۳۲ بیتی است</span>
<span class="hljs-built_in">long</span> y = x;          <span class="hljs-comment">// تبدیل ضمنی به عدد صحیح ۶۴ بیتی</span>
<span class="hljs-built_in">short</span> z = (<span class="hljs-built_in">short</span>)x;  <span class="hljs-comment">// تبدیل صریح به عدد صحیح ۱۶ بیتی</span>
</code></pre>
<p>✅ تبدیل ضمنی زمانی مجاز است که هر دو شرط زیر برقرار باشند:</p>
<p>1️⃣ کامپایلر بتواند تضمین کند که تبدیل همیشه موفق خواهد شد.</p>
<p>2️⃣ هیچ اطلاعاتی در فرآیند تبدیل از دست نرود.</p>
<p>⚠ تبدیل صریح زمانی لازم است که یکی از شرایط زیر برقرار باشد:</p>
<p>1️⃣ کامپایلر نتواند تضمین کند که تبدیل همیشه موفق خواهد شد.</p>
<p>2️⃣ ممکن است اطلاعات در فرآیند تبدیل از دست برود.</p>
<p>📌 اگر کامپایلر تشخیص دهد که یک تبدیل همیشه شکست خواهد خورد، هر دو نوع تبدیل (ضمنی و صریح) ممنوع می‌شوند.<br>
همچنین، تبدیل‌های مربوط به جنریک‌ها (Generics) هم ممکن است در شرایط خاص شکست بخورند (بخش Type Parameters and Conversions در صفحه 166 توضیح داده شده است).</p>
<p>🔹 تبدیل‌های عددی که در بالا دیدیم، در خود زبان به‌صورت داخلی پشتیبانی می‌شوند.</p>
<p>🔹 سی شارپ همچنین از موارد زیر پشتیبانی می‌کند:</p>
<p>🔹 تبدیل‌های ارجاعی (Reference Conversions)</p>
<p>🔹 تبدیل‌های Boxing (در فصل ۳ توضیح داده شده)</p>
<p>🔹 تبدیل‌های سفارشی (Custom Conversions) (بخش Operator Overloading در صفحه 256)</p>
<p>⚠ در تبدیل‌های سفارشی، کامپایلر قوانین بالا را اجرا نمی‌کند، بنابراین اگر نوع‌ها به‌درستی طراحی نشده باشند، می‌توانند رفتار غیرمنتظره داشته باشند.</p>
<h3>انواع مقدار (Value Types) در مقابل انواع مرجع (Reference Types)</h3>
<p>تمام انواع (Type)‌های C# در یکی از دسته‌بندی‌های زیر قرار می‌گیرند:</p>
<p>🔹 انواع مقدار (Value Types)</p>
<p>🔹 انواع مرجع (Reference Types)</p>
<p>🔹 پارامترهای نوع کلی (Generic Type Parameters)</p>
<p>🔹 انواع اشاره‌گر (Pointer Types)</p>
<p>در این بخش، ما فقط به انواع مقدار و انواع مرجع می‌پردازیم.<br>
پارامترهای نوع کلی را در بخش &quot;Generics&quot; (صفحه 159) و انواع اشاره‌گر را در بخش &quot;Unsafe Code and Pointers&quot; (صفحه 263) بررسی خواهیم کرد.</p>
<h4>انواع مقدار</h4>
<p>محتوای یک متغیر یا ثابت از نوع مقدار، فقط خودِ مقدار است.<br>
به‌عنوان مثال، محتوای یک متغیر int (که نوع مقداری از پیش تعریف‌شده است) صرفاً ۳۲ بیت داده می‌باشد.</p>
<p>شما می‌توانید یک نوع مقدار سفارشی را با کلیدواژه‌ی struct تعریف کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Point { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X; <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y; }
</code></pre>
<p>یا به شکل خلاصه‌تر:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Point { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X, Y; }
</code></pre>
<p>📌 شکل ۲-۱. نمونه‌ای از یک نوع مقداری در حافظه</p>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-1.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>وقتی یک نمونه از نوع مقداری را به متغیری دیگر انتساب می‌دهید، کل داده کپی می‌شود، نه فقط یک اشاره‌گر. مثال:</p>
<pre class="hljs"><code>Point p1 = <span class="hljs-keyword">new</span> Point();
p1.X = <span class="hljs-number">7</span>;

Point p2 = p1;             <span class="hljs-comment">// 📄 انتساب باعث ایجاد یک کپی از p1 می‌شود</span>

Console.WriteLine(p1.X);   <span class="hljs-comment">// 🔢 خروجی: 7</span>
Console.WriteLine(p2.X);   <span class="hljs-comment">// 🔢 خروجی: 7</span>

p1.X = <span class="hljs-number">9</span>;                  <span class="hljs-comment">// ✏️ تغییر مقدار X در p1</span>

Console.WriteLine(p1.X);   <span class="hljs-comment">// 🔢 خروجی: 9</span>
Console.WriteLine(p2.X);   <span class="hljs-comment">// 🔢 خروجی: 7</span>
</code></pre>
<p>💡 همانطور که می‌بینید، تغییر در متغیر p1 بعد از کپی شدن، هیچ تاثیری روی p2 ندارد. این ویژگی، تفاوت اصلی انواع مقداری با انواع ارجاعی است.</p>
<p>📌 شکل ۲-۲ نشان می‌دهد که <code>p1</code> و <code>p2</code> فضای ذخیره‌سازی مستقلی دارند.</p>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-2.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>📌 یعنی هر کدام در حافظه جداگانه نگهداری می‌شوند و تغییر یکی روی دیگری اثری ندارد.</p>
<h3>انواع ارجاعی (Reference Types) 🧭</h3>
<p>یک نوع ارجاعی از یک نوع مقداری پیچیده‌تر است، زیرا از دو بخش تشکیل شده است: یک شیء (Object) و ارجاع (Reference) به آن شیء.<br>
محتوای یک متغیر یا ثابت از نوع ارجاعی، در واقع یک ارجاع به شیئی است که مقدار را در خود نگه می‌دارد.</p>
<p>در اینجا همان نوع Point که در مثال قبلی داشتیم، این بار به جای ساختار (struct) به صورت کلاس (class) نوشته شده است (مطابق شکل 2-3):</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X, Y; }
</code></pre>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-3.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>📌 نکته مهم: وقتی یک متغیر از نوع ارجاعی را مقداردهی می‌کنیم، ارجاع (آدرس شیء) کپی می‌شود، نه خود شیء.<br>
این موضوع باعث می‌شود چندین متغیر بتوانند به یک شیء واحد اشاره کنند — چیزی که در انواع مقداری به طور معمول امکان‌پذیر نیست.</p>
<p>اگر همان مثال قبلی را تکرار کنیم اما این بار Point یک کلاس باشد، تغییر در p1 روی p2 نیز اثر می‌گذارد:</p>
<pre class="hljs"><code>Point p1 = <span class="hljs-keyword">new</span> Point();
p1.X = <span class="hljs-number">7</span>;

Point p2 = p1;             <span class="hljs-comment">// کپی شدن ارجاع p1</span>
Console.WriteLine(p1.X);   <span class="hljs-comment">// خروجی: 7</span>
Console.WriteLine(p2.X);   <span class="hljs-comment">// خروجی: 7</span>

p1.X = <span class="hljs-number">9</span>;                  <span class="hljs-comment">// تغییر مقدار p1.X</span>
Console.WriteLine(p1.X);   <span class="hljs-comment">// خروجی: 9</span>
Console.WriteLine(p2.X);   <span class="hljs-comment">// خروجی: 9</span>

</code></pre>
<p>💡 نتیجه: در انواع ارجاعی، همه متغیرهایی که به یک شیء اشاره می‌کنند، در واقع یک نسخه مشترک از داده‌ها را می‌بینند.</p>
<p>📌 شکل ۲-۴ نشان می‌دهد که <code>p1</code> و <code>p2</code> دو ارجاع هستند که به یک شیء مشترک اشاره می‌کنند.</p>
<div align="center">
<p><img src="../../../assets/image/02/Figure-2-4.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>📌 در نتیجه تغییر یکی، روی دیگری هم تأثیر دارد.</p>
<h3>Null</h3>
<p>یک مرجع (reference) می‌تواند به مقدار ثابت (literal) null نسبت داده شود، که نشان می‌دهد این مرجع به هیچ شیءی اشاره نمی‌کند:</p>
<pre class="hljs"><code>Point p = <span class="hljs-literal">null</span>;
Console.WriteLine(p == <span class="hljs-literal">null</span>);   <span class="hljs-comment">// True</span>

<span class="hljs-comment">// خط زیر باعث ایجاد خطای زمان اجرا می‌شود</span>
<span class="hljs-comment">// (یک استثنای NullReferenceException پرتاب می‌شود):</span>
Console.WriteLine(p.X);

<span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> { ... }
</code></pre>
<p>در بخش &quot;نوع‌های مرجع قابل تهی&quot; (صفحه 215)، یک قابلیت در C# توضیح داده شده است که به کاهش خطاهای اتفاقی NullReferenceException کمک می‌کند.</p>
<p>در مقابل، یک نوع مقداری (value type) معمولاً نمی‌تواند مقدار null داشته باشد:</p>
<pre class="hljs"><code>Point p = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// خطای زمان کامپایل</span>
<span class="hljs-built_in">int</span> x = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// خطای زمان کامپایل</span>

<span class="hljs-keyword">struct</span> Point { ... }
</code></pre>
<p>C# یک ساختار به نام نوع‌های مقداری قابل تهی (nullable value types) نیز دارد که برای نمایش مقدار null در نوع‌های مقداری استفاده می‌شود. برای اطلاعات بیشتر به بخش &quot;نوع‌های مقداری قابل تهی&quot; (صفحه 210) مراجعه کنید.</p>
<h4>سربار حافظه (Storage overhead)</h4>
<p>نمونه‌های نوع مقداری دقیقاً به اندازه‌ای از حافظه اشغال می‌کنند که برای ذخیره فیلدهایشان لازم است. در این مثال، ساختار Point دقیقاً 8 بایت حافظه می‌گیرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> Point
{
    <span class="hljs-built_in">int</span> x;  <span class="hljs-comment">// 4 بایت</span>
    <span class="hljs-built_in">int</span> y;  <span class="hljs-comment">// 4 بایت</span>
}
</code></pre>
<p>از نظر فنی، CLR فیلدها را در آدرسی قرار می‌دهد که مضربی از اندازه فیلد باشد (حداکثر تا 8 بایت).<br>
به همین دلیل، ساختار زیر در واقع 16 بایت حافظه مصرف می‌کند (7 بایت بعد از فیلد اول «هدر» می‌رود):</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> A
{
    <span class="hljs-built_in">byte</span> b;
    <span class="hljs-built_in">long</span> l;
}
</code></pre>
<p>می‌توان این رفتار را با اعمال ویژگی StructLayout تغییر داد (به بخش &quot;نگاشت یک struct به حافظه unmanaged&quot; در صفحه 997 مراجعه کنید).</p>
<p>نوع‌های مرجعی نیاز به تخصیص جداگانه حافظه برای مرجع و شیء دارند.<br>
شیء به اندازه فیلدهایش حافظه مصرف می‌کند به اضافه سربار مدیریتی اضافی.<br>
میزان دقیق این سربار وابسته به پیاده‌سازی داخلی زمان‌اجرای .NET است، اما حداقل 8 بایت است که برای ذخیره کلیدی به نوع شیء، و همچنین اطلاعات موقتی مانند وضعیت قفل برای چندنخی و یک فلگ برای مشخص کردن اینکه آیا شیء توسط garbage collector از جابجایی قفل شده یا خیر، استفاده می‌شود.</p>
<p>هر مرجع به یک شیء، بسته به اینکه .NET روی پلتفرم 32بیتی یا 64بیتی اجرا شود، به ترتیب 4 یا 8 بایت اضافی نیاز دارد.</p>
<h3>Predefined Type Taxonomy</h3>
<p>Predefined Types در C# به شرح زیر هستند:</p>
<ul>
<li>
<p>Value Types</p>
<ul>
<li>
<p>Numeric</p>
<p>Signed integer (sbyte, short, int, long)</p>
<p>Unsigned integer (byte, ushort, uint, ulong)</p>
<p>Real number (float, double, decimal)</p>
</li>
<li>
<p>Logical (bool)</p>
</li>
<li>
<p>Character (char)</p>
</li>
</ul>
</li>
<li>
<p>Reference Types</p>
<ul>
<li>
<p>String (string)</p>
</li>
<li>
<p>Object (object)</p>
</li>
</ul>
</li>
</ul>
<p>Predefined Types در C# در واقع Alias برای .NET Types در Namespace System هستند. تنها یک تفاوت Syntactic بین این دو دستور وجود دارد:</p>
<pre class="hljs"><code>
<span class="hljs-built_in">int</span> i = <span class="hljs-number">5</span>;
System.Int32 i = <span class="hljs-number">5</span>;
</code></pre>
<p>در دات‌نت، مجموعه‌ای از انواع مقداری (Value Types) که به‌جز decimal هستند، به‌عنوان انواع اولیه (Primitive Types) شناخته می‌شوند. 🧩</p>
<p>به آن‌ها «اولیه» گفته می‌شود چون به‌طور مستقیم از طریق دستورالعمل‌های موجود در کد کامپایل‌شده پشتیبانی می‌شوند، و این معمولاً به معنی پشتیبانی مستقیم در پردازنده‌ی سخت‌افزاری است. 💻⚡</p>
<p>برای مثال:</p>
<pre class="hljs"><code><span class="hljs-comment">// نمایش زیرساختی (نمایش هگزادسیمال)</span>
<span class="hljs-built_in">int</span> i = <span class="hljs-number">7</span>;        <span class="hljs-comment">// 0x7</span>
<span class="hljs-built_in">bool</span> b = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 0x1</span>
<span class="hljs-built_in">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>;     <span class="hljs-comment">// 0x41</span>
<span class="hljs-built_in">float</span> f = <span class="hljs-number">0.5f</span>;   <span class="hljs-comment">// استفاده از کدگذاری IEEE برای اعداد اعشاری شناور</span>
</code></pre>
<p>همچنین، انواع System.IntPtr و System.UIntPtr نیز جزو انواع اولیه محسوب می‌شوند. (به فصل ۲۴ مراجعه کنید) 📖</p>
<p>Numeric Types</p>
<p>C# دارای Predefined Numeric Types است که در Table 2-1 نشان داده شده‌اند.</p>
<p>Table 2-1. Predefined numeric types in C#</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-1.png" alt="Conventions-UsedThis-Book"></p>
</div>
از بین انواع عدد صحیح (Integral Types)، نوع‌های int و long در زبان C# و در زمان اجرای برنامه (Runtime) جایگاه ویژه‌ای دارند و بیشترین استفاده را دارند. سایر انواع عدد صحیح معمولاً زمانی استفاده می‌شوند که یا نیاز به سازگاری و تعامل با سیستم‌ها و کتابخانه‌های دیگر (Interoperability) وجود دارد یا بهینه‌سازی در مصرف حافظه اهمیت دارد.
نوع‌های عدد صحیح با اندازه بومی سیستم یعنی nint و nuint بیشتر هنگام کار با اشاره‌گرها (Pointers) مفید هستند که توضیح آن‌ها در فصل بعدی خواهد آمد (بخش «اعداد صحیح با اندازه بومی» در صفحه 266).
<p>از بین انواع اعداد حقیقی (Real Number Types)، دو نوع float و double که به آن‌ها انواع شناور (Floating-Point Types) گفته می‌شود، معمولاً در محاسبات علمی و گرافیکی استفاده می‌شوند.<br>
نوع decimal بیشتر در محاسبات مالی و اقتصادی به کار می‌رود، چون محاسبات آن دقیق بر پایه مبنای ۱۰ بوده و دقت بالایی دارد.</p>
<p>علاوه بر این، ‌**.NET** چند نوع عددی تخصصی نیز ارائه می‌دهد، از جمله:</p>
<ul>
<li>
<p>Int128 و UInt128 برای اعداد صحیح علامت‌دار و بدون علامت ۱۲۸ بیتی</p>
</li>
<li>
<p>BigInteger برای اعداد صحیح بسیار بزرگ (بدون محدودیت اندازه)</p>
</li>
<li>
<p>Half برای اعداد اعشاری ۱۶ بیتی (نقطه شناور)</p>
</li>
</ul>
<p>نوع Half عمدتاً برای تعامل با پردازنده‌های کارت گرافیک استفاده می‌شود و اغلب پشتیبانی سخت‌افزاری مستقیم در CPUها ندارد، به همین دلیل float و double برای استفاده عمومی انتخاب‌های بهتری هستند.</p>
<h3>اعداد ثابت (Numeric Literals)</h3>
<p>اعداد ثابت از نوع صحیح (Integral-type literals) می‌توانند از نمادگذاری ده‌دهی (decimal) یا شانزده‌شانزدهی (hexadecimal) استفاده کنند؛ حالت شانزده‌شانزدهی با پیشوند 0x مشخص می‌شود.<br>
برای مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">127</span>;
<span class="hljs-built_in">long</span> y = <span class="hljs-number">0x7F</span>;
</code></pre>
<p>شما می‌توانید برای خواناتر کردن یک عدد ثابت، در هرجای آن یک خط زیرین (underscore) قرار دهید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> million = <span class="hljs-number">1</span>_000_000;
</code></pre>
<p>همچنین می‌توانید اعداد را به صورت دودویی (binary) با پیشوند 0b بنویسید:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> b = <span class="hljs-number">0b1010</span>_1011_1100_1101_1110_1111;
</code></pre>
<p>اعداد ثابت اعشاری (Real literals) می‌توانند از نمادگذاری ده‌دهی و/یا نمادگذاری نمایی (exponential notation) استفاده کنند:</p>
<pre class="hljs"><code><span class="hljs-built_in">double</span> d = <span class="hljs-number">1.5</span>;
<span class="hljs-built_in">double</span> million = <span class="hljs-number">1E06</span>;
</code></pre>
<h4>نتیجه‌گیری نوع عدد ثابت (Numeric literal type inference)</h4>
<p>به طور پیش‌فرض، کامپایلر نوع یک عدد ثابت را یا double یا یکی از انواع صحیح در نظر می‌گیرد:</p>
<ul>
<li>
<p>اگر عدد شامل نقطه اعشار یا نماد نمایی E باشد، نوع آن double خواهد بود.</p>
</li>
<li>
<p>در غیر این صورت، نوع عدد اولین نوع در لیست زیر خواهد بود که بتواند مقدار آن را در خود جای دهد:<br>
int → uint → long → ulong</p>
</li>
</ul>
<p>برای مثال:</p>
<pre class="hljs"><code>Console.WriteLine(       <span class="hljs-number">1.0</span>.GetType());   <span class="hljs-comment">// Double  (double)</span>
Console.WriteLine(      <span class="hljs-number">1E06</span>.GetType());   <span class="hljs-comment">// Double  (double)</span>
Console.WriteLine(         <span class="hljs-number">1.</span>GetType());   <span class="hljs-comment">// Int32   (int)</span>
Console.WriteLine(<span class="hljs-number">0xF0000000</span>.GetType());   <span class="hljs-comment">// UInt32  (uint)</span>
Console.WriteLine(<span class="hljs-number">0x100000000</span>.GetType());  <span class="hljs-comment">// Int64   (long)</span>
</code></pre>
<p>نکته: از نظر فنی، decimal نیز یک نوع اعشاری (floating-point type) محسوب می‌شود، اما در مشخصات زبان C# به این صورت معرفی نشده است.</p>
<h3>پسوندهای عددی (Numeric Suffixes) 🔤</h3>
<p>پسوندهای عددی به‌طور صریح نوع یک مقدار ثابت (literal) را مشخص می‌کنند. این پسوندها می‌توانند با حروف کوچک یا بزرگ نوشته شوند.</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-2.png" alt="Conventions-UsedThis-Book"></p>
</div>
📌 نکته:
پسوندهای U و L به ندرت لازم می‌شوند، چون نوع‌های uint، long و ulong معمولاً یا به‌طور خودکار حدس زده می‌شوند (inferred) یا می‌توانند به‌طور ضمنی (implicitly) از int تبدیل شوند:
<pre class="hljs"><code><span class="hljs-built_in">long</span> i = <span class="hljs-number">5</span>; <span class="hljs-comment">// تبدیل ضمنی بدون از دست دادن داده از int به long</span>
</code></pre>
<p>💡 پسوند D از نظر فنی اضافی است، چون هر عددی که یک نقطه اعشار داشته باشد به‌طور پیش‌فرض به عنوان double در نظر گرفته می‌شود. حتی می‌توانید با افزودن یک نقطه اعشار این کار را انجام دهید:</p>
<pre class="hljs"><code><span class="hljs-built_in">double</span> x = <span class="hljs-number">4.0</span>;
</code></pre>
<p><strong>⭐ پسوندهای F و M</strong> بیشترین کاربرد را دارند و باید همیشه وقتی نوع float یا decimal را مشخص می‌کنید، استفاده شوند.</p>
<p>🔹 بدون پسوند F، کد زیر کامپایل نمی‌شود، چون 4.5 به‌طور پیش‌فرض از نوع double است و تبدیل ضمنی به float وجود ندارد:</p>
<pre class="hljs"><code><span class="hljs-built_in">float</span> f = <span class="hljs-number">4.5F</span>;
</code></pre>
<p>🔹 همین اصل برای decimal هم صدق می‌کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">decimal</span> d = <span class="hljs-number">-1.23</span>M; <span class="hljs-comment">// بدون M کامپایل نمی‌شود</span>
</code></pre>
<p>📖 در بخش بعدی، به‌طور کامل مفهوم تبدیل‌های عددی (numeric conversions) را توضیح خواهیم داد.</p>
<h3>تبدیل‌های عددی (Numeric Conversions)</h3>
<h4>تبدیل بین نوع‌های صحیح (Integral Types)</h4>
<p>تبدیل نوع‌های صحیح به‌صورت ضمنی (implicit) انجام می‌شود، زمانی که نوع مقصد بتواند تمام مقادیر ممکن نوع مبدأ را نمایش دهد. در غیر این صورت، یک تبدیل صریح (explicit) لازم است؛ برای مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">12345</span>;       <span class="hljs-comment">// int یک عدد صحیح 32 بیتی است</span>
<span class="hljs-built_in">long</span> y = x;          <span class="hljs-comment">// تبدیل ضمنی به نوع صحیح 64 بیتی</span>
<span class="hljs-built_in">short</span> z = (<span class="hljs-built_in">short</span>)x;  <span class="hljs-comment">// تبدیل صریح به نوع صحیح 16 بیتی</span>
</code></pre>
<h4>تبدیل بین نوع‌های اعشاری شناور (Floating-Point Types)</h4>
<p>یک مقدار float می‌تواند به‌صورت ضمنی به یک double تبدیل شود، چون double قادر است همه مقادیر ممکن یک float را نمایش دهد.<br>
برعکس این تبدیل باید به‌صورت صریح انجام شود.</p>
<h4>تبدیل بین نوع‌های اعشاری شناور و صحیح (Floating-Point ↔ Integral Types)</h4>
<p>همه نوع‌های صحیح می‌توانند به‌صورت ضمنی به همه نوع‌های اعشاری شناور تبدیل شوند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;
<span class="hljs-built_in">float</span> f = i;
</code></pre>
<p>اما برعکس این تبدیل باید صریح باشد:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i2 = (<span class="hljs-built_in">int</span>)f;
</code></pre>
<p>هنگامی که یک عدد اعشاری شناور را به یک نوع صحیح تبدیل می‌کنید، هر بخش کسری (fractional portion) حذف می‌شود و هیچ گرد شدنی (rounding) انجام نمی‌شود.<br>
کلاس ایستای System.Convert متدهایی فراهم می‌کند که هنگام تبدیل بین نوع‌های عددی مختلف، عملیات گرد کردن را انجام می‌دهند (به فصل ۶ مراجعه کنید).</p>
<h4>دقت (Precision) در تبدیل اعداد بزرگ</h4>
<p>تبدیل ضمنی یک نوع صحیح بزرگ به یک نوع اعشاری شناور، مقدار کلی (magnitude) را حفظ می‌کند اما گاهی ممکن است دقت (precision) از دست برود.<br>
این به این دلیل است که نوع‌های اعشاری شناور همیشه بازه عددی (magnitude) بیشتری نسبت به نوع‌های صحیح دارند، اما ممکن است دقت کمتری داشته باشند.</p>
<p>بازنویسی مثال با یک عدد بزرگ:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i1 = <span class="hljs-number">100000001</span>;
<span class="hljs-built_in">float</span> f = i1;          <span class="hljs-comment">// مقدار کلی حفظ شده، اما دقت از دست رفته</span>
<span class="hljs-built_in">int</span> i2 = (<span class="hljs-built_in">int</span>)f;       <span class="hljs-comment">// خروجی: 100000000</span>
</code></pre>
<h4>تبدیل‌های Decimal</h4>
<p>همه نوع‌های صحیح را می‌توان به‌صورت ضمنی به نوع decimal تبدیل کرد، زیرا decimal می‌تواند همه مقادیر ممکن نوع‌های صحیح C# را نمایش دهد.<br>
تمام تبدیل‌های عددی دیگر به/از نوع decimal باید به‌صورت صریح انجام شوند، زیرا این تبدیل‌ها می‌توانند باعث شوند مقدار خارج از محدوده (out of range) شود یا دقت آن از دست برود.</p>
<h3>عملگرهای حسابی (Arithmetic Operators) 🔢</h3>
<p>عملگرهای حسابی در C# برای همه نوع‌های عددی به جز نوع‌های صحیح 8 و 16 بیتی تعریف شده‌اند:</p>
<p>عملگر توضیح</p>
<ul>
<li>
<p>➕ جمع (Addition)</p>
</li>
<li>
<p>➖ تفریق (Subtraction)</p>
</li>
<li>
<p>✖️ ضرب (Multiplication)<br>
/ ➗ تقسیم (Division)<br>
% باقیمانده بعد از تقسیم (Remainder)</p>
</li>
</ul>
<h3>عملگرهای افزایش و کاهش (Increment &amp; Decrement Operators) ⬆️⬇️</h3>
<p>عملگر ++ مقدار متغیر را ۱ واحد افزایش و عملگر -- مقدار را ۱ واحد کاهش می‌دهد.<br>
این عملگرها می‌توانند قبل یا بعد از متغیر بیایند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;
Console.WriteLine(x++); <span class="hljs-comment">// خروجی: 0  → سپس x می‌شود 1</span>
Console.WriteLine(++y); <span class="hljs-comment">// خروجی: 1  → y قبل از چاپ افزایش می‌یابد</span>
</code></pre>
<p>📌 نکته: قبل گذاشتن (++y) یعنی اول تغییر، بعد استفاده.<br>
بعد گذاشتن (y++) یعنی اول استفاده، بعد تغییر.</p>
<h3>عملیات ویژه روی نوع‌های صحیح (Specialized Operations on Integral Types) 🧮</h3>
<p>نوع‌های صحیح شامل:<br>
int, uint, long, ulong, short, ushort, byte, sbyte</p>
<h4>تقسیم (Division) ➗</h4>
<ul>
<li>
<p>در نوع‌های صحیح، نتیجه تقسیم همیشه بخش اعشاری را حذف می‌کند (گرد کردن به صفر).</p>
</li>
<li>
<p>تقسیم بر ۰ در زمان اجرا (runtime) باعث خطا (DivideByZeroException) می‌شود.</p>
</li>
<li>
<p>تقسیم بر ثابت یا مقدار صفر در زمان کامپایل (compile-time) خطا می‌دهد.</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">int</span> a = <span class="hljs-number">2</span> / <span class="hljs-number">3</span>; <span class="hljs-comment">// خروجی: 0</span>
<span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>;
<span class="hljs-built_in">int</span> c = <span class="hljs-number">5</span> / b; <span class="hljs-comment">// خطای DivideByZeroException</span>
</code></pre>
<h4>سرریز (Overflow) ⚠️</h4>
<p>در عملیات عددی روی نوع‌های صحیح، اگر مقدار از محدوده نوع داده فراتر برود، به‌طور پیش‌فرض خطایی رخ نمی‌دهد، بلکه مقدار دور می‌زند (wraparound).</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> a = <span class="hljs-built_in">int</span>.MinValue;
a--;
Console.WriteLine(a == <span class="hljs-built_in">int</span>.MaxValue); <span class="hljs-comment">// True</span>
</code></pre>
<h4>بررسی سرریز با checked ✅</h4>
<p>اگر بخواهید در صورت سرریز خطا (OverflowException) دریافت کنید، از checked استفاده کنید. این دستور روی عملگرهای:<br>
++, --, +, -, *, / و تبدیل‌های صریح بین نوع‌های صحیح اثر دارد.</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> a = <span class="hljs-number">1000000</span>;
<span class="hljs-built_in">int</span> b = <span class="hljs-number">1000000</span>;
<span class="hljs-built_in">int</span> c = checked(a * b); <span class="hljs-comment">// بررسی فقط همین عبارت</span>
</code></pre>
<p>یا می‌توانید یک بلوک کامل را بررسی کنید:</p>
<pre class="hljs"><code>checked
{
    c = a * b; <span class="hljs-comment">// همه عبارات این بلوک بررسی می‌شوند</span>
}
</code></pre>
<p>📌 نکات مهم:</p>
<ul>
<li>
<p>روی double و float بی‌اثر است (این نوع‌ها در سرریز مقدار &quot;بی‌نهایت&quot; می‌گیرند).</p>
</li>
<li>
<p>روی decimal همیشه بررسی انجام می‌شود.</p>
</li>
<li>
<p>می‌توانید در تنظیمات پروژه (Advanced Build Settings) حالت checked را به‌طور پیش‌فرض فعال کنید.</p>
</li>
<li>
<p>اگر checked پیش‌فرض فعال باشد، با unchecked می‌توان بررسی را غیرفعال کرد:</p>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-built_in">int</span>.MaxValue;
<span class="hljs-built_in">int</span> y = <span class="hljs-keyword">unchecked</span>(x + <span class="hljs-number">1</span>); <span class="hljs-comment">// خطا نمی‌دهد</span>
</code></pre>
<h3>بررسی سرریز (Overflow) برای عبارت‌های ثابت 📏💥</h3>
<p>فارغ از این‌که تنظیم «checked» در پروژه فعال باشد یا نه، تمام عبارت‌هایی که در زمان کامپایل ارزیابی می‌شوند، همیشه از نظر سرریز بررسی می‌شوند—مگر این‌که از عملگر unchecked استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-built_in">int</span>.MaxValue + <span class="hljs-number">1</span>;               <span class="hljs-comment">// ❌ خطای زمان کامپایل</span>
<span class="hljs-built_in">int</span> y = <span class="hljs-keyword">unchecked</span>(<span class="hljs-built_in">int</span>.MaxValue + <span class="hljs-number">1</span>);    <span class="hljs-comment">// ✅ بدون خطا</span>
</code></pre>
<p>🔍 نکته:<br>
در حالت اول، چون محاسبه در زمان کامپایل انجام می‌شود و مقدار فراتر از int.MaxValue می‌رود، کامپایلر جلوی اجرای آن را می‌گیرد. اما با unchecked به کامپایلر می‌گویید که بررسی سرریز را انجام ندهد و اجازه دهد عملیات بدون خطا انجام شود—even اگر نتیجه wrap-around شود.</p>
<h3>Bitwise Operators</h3>
<p>C# از Bitwise Operators زیر پشتیبانی می‌کند:</p>
<p><img src="../../../assets/image/02/Table-2-3.png" alt="Conventions-UsedThis-Book"></p>
<p>عملگر شیفت به راست &gt;&gt; و تفاوتش با &gt;&gt;&gt; ⚙️</p>
<p>وقتی عملگر شیفت به راست (&gt;&gt;) روی اعداد صحیح علامت‌دار (signed integers) اعمال می‌شود، بیت پرارزش (بیت علامت) را تکرار می‌کند.<br>
اما عملگر شیفت به راست بدون علامت (&gt;&gt;&gt;) این کار را انجام نمی‌دهد و همیشه بیت‌های خالی را با صفر پر می‌کند.</p>
<p>📌 مثال ساده:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> a = <span class="hljs-number">-8</span>;     <span class="hljs-comment">// در باینری: 11111111 11111111 11111111 11111000</span>
<span class="hljs-built_in">int</span> b = a &gt;&gt; <span class="hljs-number">2</span>; <span class="hljs-comment">// تکرار بیت علامت: 11111111 11111111 11111111 11111110</span>
<span class="hljs-built_in">int</span> c = a &gt;&gt;&gt; <span class="hljs-number">2</span>;<span class="hljs-comment">// بدون تکرار بیت علامت: 00111111 11111111 11111111 11111110</span>
</code></pre>
<p>علاوه بر این عملگرها، عملیات بیتی پیشرفته‌تری از طریق کلاس BitOperations در فضای نام System.Numerics ارائه شده است<br>
(نگاه کنید به بخش “BitOperations” در صفحه 340 📖).</p>
<h3>🔢 انواع عدد صحیح ۸ و ۱۶ بیتی</h3>
<p>انواع عدد صحیح ۸ و ۱۶ بیتی شامل byte، sbyte، short و ushort هستند.<br>
این نوع‌ها عملگرهای حسابی مخصوص به خود را ندارند، بنابراین #C به‌طور ضمنی آن‌ها را در صورت نیاز به انواع بزرگ‌تر تبدیل می‌کند.</p>
<p>این موضوع می‌تواند باعث خطای زمان کامپایل شود وقتی بخواهید نتیجه عملیات را دوباره به یک نوع کوچک اختصاص دهید:</p>
<pre class="hljs"><code><span class="hljs-built_in">short</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;
<span class="hljs-built_in">short</span> z = x + y;   <span class="hljs-comment">// ❌ خطای زمان کامپایل</span>
</code></pre>
<p>در این مثال، x و y به‌طور ضمنی به نوع int تبدیل می‌شوند تا عمل جمع انجام شود.<br>
این یعنی نتیجه نیز یک int خواهد بود که نمی‌تواند به‌طور ضمنی به short تبدیل شود (چون احتمال از دست رفتن داده وجود دارد).</p>
<p>برای رفع خطا باید تبدیل (Cast) صریح انجام دهید:</p>
<pre class="hljs"><code><span class="hljs-built_in">short</span> z = (<span class="hljs-built_in">short</span>)(x + y);  <span class="hljs-comment">// ✅ صحیح</span>
</code></pre>
<h3>🌊 مقادیر خاص float و double</h3>
<p>برخلاف انواع عدد صحیح، انواع اعشاری (float و double) مقادیری دارند که برخی عملیات‌ها آن‌ها را به‌طور ویژه پردازش می‌کنند. این مقادیر خاص عبارتند از:</p>
<ul>
<li>
<p>NaN (عدد نامعتبر یا Not a Number) 🌀</p>
</li>
<li>
<p>+∞ (مثبت بی‌نهایت) ♾️</p>
</li>
<li>
<p>−∞ (منفی بی‌نهایت) ♾️</p>
</li>
<li>
<p>−0 (منفی صفر)</p>
</li>
</ul>
<p>کلاس‌های float و double ثابت‌هایی برای NaN، +∞ و −∞ دارند، همچنین مقادیر دیگری مثل MaxValue، MinValue و Epsilon نیز موجود است.</p>
<p>مثال:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-built_in">double</span>.NegativeInfinity); <span class="hljs-comment">// -Infinity</span>
</code></pre>
<p>Constants که special values را برای double و float نشان می‌دهند، به شرح زیر هستند:</p>
<p><img src="../../../assets/image/02/Table-2-4.png" alt="Conventions-UsedThis-Book"></p>
<p>تقسیم یک عدد ناصفر بر صفر منجر به یک مقدار بی‌نهایت می‌شود:</p>
<pre class="hljs"><code>Console.WriteLine ( <span class="hljs-number">1.0</span> /  <span class="hljs-number">0.0</span>);                  <span class="hljs-comment">//  Infinity</span>
Console.WriteLine (−<span class="hljs-number">1.0</span> /  <span class="hljs-number">0.0</span>);                  <span class="hljs-comment">// -Infinity</span>
Console.WriteLine ( <span class="hljs-number">1.0</span> / −<span class="hljs-number">0.0</span>);                  <span class="hljs-comment">// -Infinity</span>
Console.WriteLine (−<span class="hljs-number">1.0</span> / −<span class="hljs-number">0.0</span>);                  <span class="hljs-comment">//  Infinity</span>
</code></pre>
<p>تقسیم صفر بر صفر، یا کم کردن بی‌نهایت از بی‌نهایت، منجر به یک مقدار NaN می‌شود:</p>
<pre class="hljs"><code>Console.WriteLine ( <span class="hljs-number">0.0</span> /  <span class="hljs-number">0.0</span>);                  <span class="hljs-comment">//  NaN</span>
Console.WriteLine ((<span class="hljs-number">1.0</span> /  <span class="hljs-number">0.0</span>) − (<span class="hljs-number">1.0</span> / <span class="hljs-number">0.0</span>));   <span class="hljs-comment">//  NaN</span>
</code></pre>
<p>وقتی از عملگر == استفاده می‌کنید، یک مقدار NaN هرگز برابر با مقدار دیگری نیست، حتی اگر آن مقدار NaN دیگری باشد:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-number">0.0</span> / <span class="hljs-number">0.0</span> == <span class="hljs-built_in">double</span>.NaN);    <span class="hljs-comment">// False</span>
</code></pre>
<p>برای بررسی اینکه آیا یک مقدار NaN است، باید از متد float.IsNaN یا double.IsNaN استفاده کنید:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-built_in">double</span>.IsNaN (<span class="hljs-number">0.0</span> / <span class="hljs-number">0.0</span>));   <span class="hljs-comment">// True</span>
</code></pre>
<p>با این حال، هنگام استفاده از object.Equals، دو مقدار NaN برابر در نظر گرفته می‌شوند:</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-built_in">object</span>.Equals (<span class="hljs-number">0.0</span> / <span class="hljs-number">0.0</span>, <span class="hljs-built_in">double</span>.NaN));   <span class="hljs-comment">// True</span>
</code></pre>
<p>مقادیر NaN گاهی برای نمایش مقادیر خاص مفید هستند.<br>
در Windows Presentation Foundation (WPF)، مقدار double.NaN نمایانگر یک اندازه‌گیری با مقدار «خودکار» (Automatic) است.<br>
راه دیگر برای نمایش چنین مقداری، استفاده از یک نوع تهی‌پذیر (nullable type) است (فصل ۴)؛<br>
و یا استفاده از یک ساختار سفارشی (custom struct) که یک نوع عددی را در خود نگه داشته و یک فیلد اضافی به آن اضافه می‌کند (فصل ۳).</p>
<p>نوع‌های float و double از مشخصات قالب IEEE 754 پیروی می‌کنند که تقریباً توسط تمام پردازنده‌ها به صورت بومی پشتیبانی می‌شود.<br>
می‌توانید اطلاعات دقیق‌تر درباره رفتار این نوع‌ها را در <a href="http://www.ieee.org">http://www.ieee.org</a> پیدا کنید.</p>
<h3>🔍 مقایسه‌ی double و decimal</h3>
<p>🔹 double برای محاسبات علمی مفید است (مانند محاسبه‌ی مختصات فضایی 🛰️).<br>
🔹 decimal برای محاسبات مالی 💰 و مقادیری که ساخته‌شده‌اند و نه نتیجه‌ی اندازه‌گیری‌های دنیای واقعی، مناسب است.</p>
<p>📌 در اینجا خلاصه‌ای از تفاوت‌ها آورده شده است.</p>
<p><img src="../../../assets/image/02/Table-2-5.png" alt="Conventions-UsedThis-Book"></p>
<h3>خطاهای گرد کردن اعداد حقیقی 🧮</h3>
<p>نوع داده‌های float و double به‌صورت داخلی اعداد را در مبنای ۲ ذخیره می‌کنند.<br>
به همین دلیل، فقط اعدادی که در مبنای ۲ قابل بیان باشند، دقیق نمایش داده می‌شوند.</p>
<p>در عمل، این یعنی بیشتر عددهای اعشاری که ما به‌صورت مبنای ۱۰ می‌نویسیم، دقیق ذخیره نمی‌شوند.<br>
مثلاً:</p>
<pre class="hljs"><code><span class="hljs-built_in">float</span> x = <span class="hljs-number">0.1f</span>;  <span class="hljs-comment">// دقیقاً 0.1 نیست</span>
Console.WriteLine (x + x + x + x + x + x + x + x + x + x);
<span class="hljs-comment">// خروجی: 1.0000001</span>
</code></pre>
<p>به همین دلیل، float و double برای محاسبات مالی انتخاب خوبی نیستند.<br>
در مقابل، نوع داده‌ی decimal در مبنای ۱۰ کار می‌کند و می‌تواند اعدادی را که در مبنای ۱۰ قابل بیان هستند، دقیق ذخیره کند (همچنین مقسوم‌علیه‌های آن یعنی مبنای ۲ و ۵ را هم).</p>
<p>چون عددهای اعشاری که ما می‌نویسیم در مبنای ۱۰ هستند، decimal می‌تواند عددهایی مثل 0.1 را دقیق نمایش دهد.</p>
<p>با این حال، حتی double و decimal هم نمی‌توانند عددهای کسری‌ای را که در مبنای ۱۰ نمایش دوره‌ای دارند، دقیق ذخیره کنند:</p>
<pre class="hljs"><code><span class="hljs-built_in">decimal</span> m = <span class="hljs-number">1</span>M / <span class="hljs-number">6</span>M;     <span class="hljs-comment">// 0.1666666666666666666666666667M</span>
<span class="hljs-built_in">double</span>  d = <span class="hljs-number">1.0</span> / <span class="hljs-number">6.0</span>;   <span class="hljs-comment">// 0.16666666666666666</span>
</code></pre>
<p>این موضوع باعث ایجاد خطاهای تجمعی در گرد کردن می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">decimal</span> notQuiteWholeM = m+m+m+m+m+m;  <span class="hljs-comment">// 1.0000000000000000000000000002M</span>
<span class="hljs-built_in">double</span>  notQuiteWholeD = d+d+d+d+d+d;  <span class="hljs-comment">// 0.99999999999999989</span>
</code></pre>
<p>که می‌تواند باعث شکست در عملیات مقایسه و برابری شود:</p>
<pre class="hljs"><code>Console.WriteLine (notQuiteWholeM == <span class="hljs-number">1</span>M);   <span class="hljs-comment">// False</span>
Console.WriteLine (notQuiteWholeD &lt; <span class="hljs-number">1.0</span>);   <span class="hljs-comment">// True</span>
</code></pre>
<h3>نوع بولی و عملگرها (Boolean Type and Operators)</h3>
<p>نوع bool در زبان C# (که نام مستعار نوع System.Boolean است) یک مقدار منطقی را نشان می‌دهد که می‌تواند مقدار ثابت true یا false داشته باشد.</p>
<p>اگرچه یک مقدار بولی از نظر تئوری فقط به یک بیت حافظه نیاز دارد، اما در زمان اجرا (runtime) یک بایت کامل حافظه استفاده می‌شود، چون این کوچک‌ترین واحدی است که پردازنده و زمان اجرا می‌توانند به شکل کارآمد با آن کار کنند.</p>
<p>برای جلوگیری از هدر رفت حافظه در مواقعی مثل آرایه‌های بزرگ از مقادیر بولی، دات‌نت کلاسی به نام BitArray در فضای نام System.Collections ارائه می‌دهد که طوری طراحی شده است که برای هر مقدار بولی فقط یک بیت استفاده کند.</p>
<h4>تبدیل‌های نوع بولی (bool Conversions)</h4>
<p>هیچ نوع تبدیلی (casting) بین bool و انواع عددی (numeric types) وجود ندارد؛ یعنی شما نمی‌توانید یک عدد را مستقیم به bool تبدیل کنید یا برعکس.</p>
<h4>عملگرهای برابری و مقایسه (Equality and Comparison Operators)</h4>
<p>عملگرهای == و != برای بررسی برابری و نابرابری همه نوع‌ها به کار می‌روند و همیشه یک مقدار بولی برمی‌گردانند.</p>
<p>برای انواع مقداری (Value Types) مثل int، مفهوم برابری معمولاً ساده است:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>;
<span class="hljs-built_in">int</span> y = <span class="hljs-number">2</span>;
<span class="hljs-built_in">int</span> z = <span class="hljs-number">1</span>;

Console.WriteLine(x == y); <span class="hljs-comment">// False</span>
Console.WriteLine(x == z); <span class="hljs-comment">// True</span>
</code></pre>
<p>📌 نکته: در تئوری می‌توان این عملگرها را overload کرد تا نوعی غیر از bool برگردانند (فصل 4)، ولی در عمل تقریباً هرگز این کار انجام نمی‌شود.</p>
<h4>برابری در انواع ارجاعی (Reference Types)</h4>
<p>برای انواع ارجاعی، برابری به طور پیش‌فرض بر اساس آدرس مرجع بررسی می‌شود، نه مقدار واقعی شیء:</p>
<pre class="hljs"><code>Dude d1 = <span class="hljs-keyword">new</span> Dude(<span class="hljs-string">&quot;John&quot;</span>);
Dude d2 = <span class="hljs-keyword">new</span> Dude(<span class="hljs-string">&quot;John&quot;</span>);
Console.WriteLine(d1 == d2); <span class="hljs-comment">// False</span>

Dude d3 = d1;
Console.WriteLine(d1 == d3); <span class="hljs-comment">// True</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dude</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dude</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> n</span>)</span> { Name = n; }
}
</code></pre>
<p><strong>نکات تکمیلی</strong></p>
<ul>
<li>
<p>عملگرهای ==، !=، &lt;، &gt;، &gt;= و &lt;= روی همه انواع عددی کار می‌کنند.</p>
</li>
<li>
<p>ولی باید هنگام استفاده با اعداد اعشاری (real numbers) دقت کنید، چون خطاهای گرد کردن (rounding errors) می‌تواند نتایج مقایسه را تحت تأثیر قرار دهد (همان‌طور که در بخش «خطاهای گرد کردن اعداد حقیقی» صفحه 54 دیدیم).</p>
</li>
<li>
<p>این عملگرها همچنین روی مقادیر enum هم کار می‌کنند، چون مقادیر آن‌ها بر اساس نوع عددی زیرین‌شان مقایسه می‌شود (توضیح کامل در بخش «Enums» صفحه 154).</p>
</li>
<li>
<p>جزئیات بیشتر در مورد این عملگرها در فصل‌های «Operator Overloading» صفحه 256، «Equality Comparison» صفحه 344 و «Order Comparison» صفحه 355 آمده است.</p>
</li>
</ul>
<h4>عملگرهای شرطی (Conditional Operators)</h4>
<p>عملگرهای &amp;&amp; و || برای بررسی شرایط و (and) و یا (or) استفاده می‌شوند. این عملگرها معمولاً همراه با عملگر ! که بیانگر not (نقیض) است، به کار می‌روند.</p>
<p>در مثال زیر، متد UseUmbrella مقدار true برمی‌گرداند اگر هوا بارانی یا آفتابی باشد (برای محافظت از باران یا آفتاب)، البته به شرطی که هم‌زمان باد هم نوزد (چون چتر در باد بی‌فایده است):</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">UseUmbrella</span> (<span class="hljs-params"><span class="hljs-built_in">bool</span> rainy, <span class="hljs-built_in">bool</span> sunny, <span class="hljs-built_in">bool</span> windy</span>)</span>
{
    <span class="hljs-keyword">return</span> !windy &amp;&amp; (rainy || sunny);
}
</code></pre>
<p>عملگرهای &amp;&amp; و || ارزیابی کوتاه‌مدت (short-circuit evaluation) انجام می‌دهند؛ یعنی وقتی ممکن باشد، از ادامه ارزیابی جلوگیری می‌کنند.</p>
<p>در مثال بالا، اگر windy برابر true باشد، عبارت (rainy || sunny) حتی ارزیابی هم نمی‌شود.</p>
<p>این ویژگی بسیار مهم است، چون اجازه می‌دهد کدهایی مانند نمونه زیر بدون ایجاد NullReferenceException اجرا شوند:</p>
<p>csharp<br>
Copy<br>
Edit<br>
if (sb != null &amp;&amp; sb.Length &gt; 0) ...<br>
<strong>عملگرهای &amp; و |</strong></p>
<p>عملگرهای &amp; و | هم برای بررسی شرایط و و یا به کار می‌روند:</p>
<pre class="hljs"><code><span class="hljs-keyword">return</span> !windy &amp; (rainy | sunny);
</code></pre>
<p>تفاوتشان با &amp;&amp; و || این است که ارزیابی کوتاه‌مدت انجام نمی‌دهند. به همین دلیل، به‌ندرت به جای عملگرهای شرطی اصلی استفاده می‌شوند.</p>
<p>برخلاف زبان‌های C و ++C، وقتی عملگرهای &amp; و | روی عبارت‌های bool به کار می‌روند، مقایسه‌های منطقی (Boolean comparisons) انجام می‌دهند و عملیات بیتی (bitwise) تنها زمانی اتفاق می‌افتد که روی اعداد اعمال شوند.</p>
<h5>عملگر شرطی سه‌تایی (Ternary Operator)</h5>
<p>عملگر شرطی (که معمولاً به آن عملگر سه‌تایی می‌گویند، چون تنها عملگری است که سه عملوند می‌گیرد) به شکل زیر است:</p>
<pre class="hljs"><code><span class="hljs-selector-tag">q</span> ? <span class="hljs-selector-tag">a</span> : <span class="hljs-selector-tag">b</span>
</code></pre>
<p>اگر شرط q برابر true باشد، عبارت a ارزیابی می‌شود؛ در غیر این صورت، عبارت b ارزیابی می‌شود:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Max</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>
{
    <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;
}
</code></pre>
<p>این عملگر در عبارات LINQ (فصل ۸) به‌خصوص کاربرد زیادی دارد. ✅</p>
<h3>رشته‌ها و کاراکترها 📝</h3>
<p>نوع داده char در #C (که نام مستعار System.Char است) یک کاراکتر یونیکد را نمایش می‌دهد و ۲ بایت (با استاندارد UTF-16) فضا اشغال می‌کند.<br>
یک مقدار کاراکتر به‌صورت تک‌نقل‌قول نوشته می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>;       <span class="hljs-comment">// کاراکتر ساده</span>
</code></pre>
<p>کاراکترهای ویژه یا همان Escape Sequences کاراکترهایی هستند که نمی‌توان آن‌ها را به‌طور مستقیم نوشت یا تفسیر کرد.<br>
برای نوشتن این کاراکترها، یک بک‌اسلش () به‌علاوه‌ی یک حرف با معنی خاص استفاده می‌شود.<br>
مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span> newLine = <span class="hljs-string">&#x27;\n&#x27;</span>;   <span class="hljs-comment">// خط جدید</span>
<span class="hljs-built_in">char</span> backSlash = <span class="hljs-string">&#x27;\\&#x27;</span>; <span class="hljs-comment">// بک‌اسلش</span>
</code></pre>
<p>📌 جدول ۲-۲ کاراکترهای Escape Sequence را نشان می‌دهد.<br>
Table 2-2 escape sequence characters را نشان می‌دهد.</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-6.png" alt="Conventions-UsedThis-Book"> <br><br>
<img src="../../../assets/image/02/Table-2-6-1.png" alt="Conventions-UsedThis-Book"></p>
</div>
<p>دستورات \u یا \x این امکان را می‌دهند که هر کاراکتر یونیکد را با استفاده از کد هگزادسیمال چهاررقمی مشخص کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span> copyrightSymbol = <span class="hljs-string">&#x27;\u00A9&#x27;</span>;
<span class="hljs-built_in">char</span> omegaSymbol     = <span class="hljs-string">&#x27;\u03A9&#x27;</span>;
<span class="hljs-built_in">char</span> newLine         = <span class="hljs-string">&#x27;\u000A&#x27;</span>;
</code></pre>
<h4>تبدیل‌های کاراکتر 🔄</h4>
<p>یک تبدیل ضمنی (Implicit Conversion) از نوع char به یک نوع عددی، در صورتی انجام می‌شود که نوع عددی بتواند یک مقدار unsigned short را در خود جای دهد.<br>
برای سایر انواع عددی، یک تبدیل صریح (Explicit Conversion) لازم است.</p>
<h4>📝 رشته‌ها (Strings) و نوع string</h4>
<p>در C#، نوع داده‌ی string (که در واقع نام مستعار System.String است و به‌طور کامل در فصل ۶ توضیح داده می‌شود) نمایانگر یک دنباله‌ی غیرقابل تغییر (Immutable) از کاراکترهای یونیکد است.</p>
<ol>
<li>ایجاد رشته<br>
برای تعریف یک رشته، از دابل کوتیشن (&quot; &quot;) استفاده می‌کنیم:</li>
</ol>
<pre class="hljs"><code><span class="hljs-built_in">string</span> a = <span class="hljs-string">&quot;Heat&quot;</span>;
</code></pre>
<ol start="2">
<li>نوع مرجع (Reference Type) با رفتار مقایسه‌ی مقداری<br>
نوع string از نوع مرجع است، اما عملگرهای مقایسه (== و !=) مثل نوع‌های مقداری رفتار می‌کنند:</li>
</ol>
<pre class="hljs"><code><span class="hljs-built_in">string</span> a = <span class="hljs-string">&quot;test&quot;</span>;
<span class="hljs-built_in">string</span> b = <span class="hljs-string">&quot;test&quot;</span>;
Console.Write(a == b);  <span class="hljs-comment">// خروجی: True</span>
</code></pre>
<p>این یعنی مقایسه، مقدار رشته را بررسی می‌کند نه محل ذخیره‌سازی در حافظه.</p>
<ol start="3">
<li>استفاده از سکانس‌های فرار (Escape Sequences)<br>
همان سکانس‌های فرار که برای char معتبر بودند، در string هم کار می‌کنند:</li>
</ol>
<pre class="hljs"><code><span class="hljs-built_in">string</span> a = <span class="hljs-string">&quot;Here&#x27;s a tab:\t&quot;</span>;
</code></pre>
<ol start="4">
<li>مشکل بک‌اسلش و راه‌حل آن<br>
به‌دلیل استفاده از بک‌اسلش \ در سکانس‌های فرار، برای نوشتن یک بک‌اسلش واقعی باید آن را دو بار بنویسید:</li>
</ol>
<pre class="hljs"><code><span class="hljs-built_in">string</span> a1 = <span class="hljs-string">&quot;\\\\server\\fileshare\\helloworld.cs&quot;</span>;
</code></pre>
<ol start="5">
<li>رشته‌های حرف‌به‌حرف (Verbatim Strings)<br>
برای راحت‌تر نوشتن رشته‌ها، می‌توانیم از پیشوند @ استفاده کنیم که:</li>
</ol>
<p>سکانس‌های فرار را نادیده می‌گیرد</p>
<p>امکان نوشتن رشته‌ها در چند خط را می‌دهد</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> a2 = <span class="hljs-string">@&quot;\\server\fileshare\helloworld.cs&quot;</span>;
</code></pre>
<p>همچنین:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> escaped  = <span class="hljs-string">&quot;First Line\r\nSecond Line&quot;</span>;
<span class="hljs-built_in">string</span> verbatim = <span class="hljs-string">@&quot;First Line
Second Line&quot;</span>;

Console.WriteLine(escaped == verbatim); <span class="hljs-comment">// True (اگر ویرایشگر از CR-LF استفاده کند)</span>
</code></pre>
<ol start="6">
<li>قرار دادن کوتیشن دوتایی داخل رشته‌ی حرف‌به‌حرف<br>
برای گذاشتن &quot; داخل یک رشته‌ی verbatim، باید آن را دو بار بنویسید:</li>
</ol>
<pre class="hljs"><code><span class="hljs-built_in">string</span> xml = <span class="hljs-string">@&quot;&lt;customer id=&quot;&quot;123&quot;&quot;&gt;&lt;/customer&gt;&quot;</span>;
</code></pre>
<h4>🔹 لیترال‌های رشته‌ای خام (Raw String Literals) در #C 11</h4>
<p>اگر یک رشته را در سه یا بیشتر علامت نقل‌قول دوتایی (&quot;&quot;&quot;) قرار دهید، یک رشته‌ی خام ایجاد می‌شود. رشته‌های خام می‌توانند تقریباً هر دنباله‌ای از کاراکترها را شامل شوند، بدون نیاز به فرار دادن (escaping) یا دوبل‌کردن کاراکترها:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> raw = <span class="hljs-string">&quot;&quot;&quot;&lt;file path=&quot;c:\temp\test.txt&quot;&gt;&lt;/file&gt;&quot;&quot;&quot;</span>;
</code></pre>
<p>رشته‌های خام نوشتن متن‌هایی مثل JSON، XML و HTML را بسیار راحت می‌کنند، همچنین برای عبارات منظم (Regex) و کد منبع هم مفید هستند.</p>
<p>اگر لازم باشد که سه یا بیشتر علامت نقل‌قول دوتایی در خود رشته داشته باشید، کافیست رشته را با چهار یا بیشتر علامت نقل‌قول دوتایی بپیچید:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> raw = <span class="hljs-string">&quot;&quot;&quot;&quot;The &quot;&quot;&quot; sequence denotes raw string literals.&quot;&quot;&quot;&quot;</span>;
</code></pre>
<p><strong>📜 رشته‌های خام چندخطی</strong></p>
<p>رشته‌های خام چندخطی قوانین خاصی دارند. برای مثال، می‌توان رشته‌ی &quot;Line 1\r\nLine 2&quot; را اینگونه نوشت:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> multiLineRaw = <span class="hljs-string">&quot;&quot;&quot;
  Line 1
  Line 2
&quot;&quot;&quot;</span>;
</code></pre>
<p>🔹 توجه کنید: علامت‌های شروع (&quot;&quot;&quot;) و پایان (&quot;&quot;&quot;) باید در خطوط جداگانه از محتوای رشته باشند.</p>
<p>همچنین:</p>
<ul>
<li>
<p>فضای خالی (Whitespace) بعد از علامت شروع &quot;&quot;&quot; (در همان خط) نادیده گرفته می‌شود.</p>
</li>
<li>
<p>فضای خالی قبل از علامت پایان &quot;&quot;&quot; (در همان خط) به‌عنوان تورفتگی مشترک (common indentation) در نظر گرفته شده و از همه‌ی خطوط رشته حذف می‌شود. این کار باعث می‌شود تورفتگی کد منبع برای خوانایی حفظ شود، اما بخشی از رشته نشود.</p>
</li>
</ul>
<p>📌 نمونه‌ی دیگر</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>)
    Console.WriteLine(<span class="hljs-string">&quot;&quot;&quot;
        {
          &quot;Name&quot; : &quot;Joe&quot;
        }
    &quot;&quot;&quot;</span>);
</code></pre>
<p>📤 خروجی:</p>
<pre class="hljs"><code><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;Name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Joe&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>⚠️ اگر در یک رشته‌ی خام چندخطی، هر خط تورفتگی مشترک مشخص‌شده در علامت پایان را نداشته باشد، کامپایلر خطا می‌دهد.</p>
<p>💡 رشته‌های خام می‌توانند قابل درون‌گذاری (Interpolated) هم باشند، البته با قوانین خاصی که در بخش «درون‌گذاری رشته» توضیح داده شده است.</p>
<h4>الحاق رشته‌ها (String Concatenation)</h4>
<p>عملگر + می‌تواند دو رشته را به هم متصل کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;
</code></pre>
<p>اگر یکی از عملوندها رشته نباشد، متد ToString روی آن فراخوانی می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-number">5</span>;  <span class="hljs-comment">// خروجی: a5</span>
</code></pre>
<p>استفاده مکرر از + برای ساخت یک رشته طولانی غیر بهینه است. راه‌حل بهتر استفاده از کلاس System.Text.StringBuilder است (که در فصل ۶ توضیح داده می‌شود).</p>
<h4>درون‌گذاری رشته‌ها (String Interpolation)</h4>
<p>اگر یک رشته با علامت $ شروع شود، به آن رشته درون‌گذاری‌شده می‌گویند. این رشته‌ها می‌توانند شامل عبارات C# درون {} باشند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">4</span>;
Console.Write (<span class="hljs-string">$&quot;A square has <span class="hljs-subst">{x}</span> sides&quot;</span>);

<span class="hljs-comment">// خروجی: A square has 4 sides</span>
</code></pre>
<p>هر عبارت معتبر C# از هر نوع داده‌ای می‌تواند درون {} قرار گیرد و C# آن را با استفاده از ToString یا معادل آن به رشته تبدیل می‌کند.</p>
<p>قالب‌دهی درون رشته<br>
می‌توان بعد از عبارت، یک علامت : و رشته قالب (Format String) نوشت:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">$&quot;255 in hex is <span class="hljs-subst">{<span class="hljs-built_in">byte</span>.MaxValue:X2}</span>&quot;</span>;  
<span class="hljs-comment">// X2 = نمایش هگزادسیمال دو رقمی</span>
<span class="hljs-comment">// خروجی: 255 in hex is FF</span>
</code></pre>
<p>اگر لازم باشد از : در جای دیگری استفاده کنید (مثل عملگر شرطی سه‌تایی ?:)، باید کل عبارت را داخل پرانتز بگذارید:</p>
<pre class="hljs"><code><span class="hljs-built_in">bool</span> b = <span class="hljs-literal">true</span>;
Console.WriteLine (<span class="hljs-string">$&quot;The answer in binary is <span class="hljs-subst">{(b ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>)}</span>&quot;</span>);
</code></pre>
<p><strong>قابلیت‌های جدید C# در رشته‌های درون‌گذاری‌شده</strong></p>
<ul>
<li>از C# 10: رشته‌های درون‌گذاری‌شده می‌توانند const باشند، به شرطی که تمام مقادیر درون‌گذاری نیز ثابت باشند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> greeting = <span class="hljs-string">&quot;Hello&quot;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> message = <span class="hljs-string">$&quot;<span class="hljs-subst">{greeting}</span>, world&quot;</span>;
</code></pre>
<ul>
<li>از C# 11: رشته‌های درون‌گذاری‌شده می‌توانند چندخطی باشند (چه معمولی، چه verbatim):</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">$&quot;this interpolation spans <span class="hljs-subst">{<span class="hljs-number">1</span> + <span class="hljs-number">1</span>}</span> lines&quot;</span>;
</code></pre>
<ul>
<li>رشته‌های خام (Raw String Literals) نیز می‌توانند درون‌گذاری شوند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">$&quot;&quot;</span><span class="hljs-string">&quot;The date and time is {DateTime.Now}&quot;</span><span class="hljs-string">&quot;&quot;</span>;
</code></pre>
<p><strong>قرار دادن آکولاد به‌صورت ثابت در رشته درون‌گذاری‌شده</strong></p>
<ul>
<li>
<p>در رشته‌های معمولی و verbatim: کاراکتر آکولاد ({ یا }) را دوبار بنویسید.</p>
</li>
<li>
<p>در رشته‌های خام: با تکرار علامت $ در ابتدای رشته، طول توالی آکولاد تغییر می‌کند.</p>
</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code>Console.WriteLine ($<span class="hljs-string">$&quot;&quot;</span><span class="hljs-string">&quot;{ &quot;</span>TimeStamp<span class="hljs-string">&quot;: &quot;</span><span class="hljs-string">&quot; }&quot;</span><span class="hljs-string">&quot;&quot;</span>);
<span class="hljs-comment">// خروجی: { &quot;TimeStamp&quot;: &quot;01/01/2024 12:13:25 PM&quot; }</span>
</code></pre>
<p>این روش باعث می‌شود بتوانید متن را مستقیماً کپی و در رشته خام قرار دهید، بدون نیاز به تغییر آکولادها.</p>
<h4>مقایسه‌ی رشته‌ها (String comparisons)</h4>
<p>برای انجام مقایسه برابری رشته‌ها، می‌توانید از عملگر == (یا یکی از متدهای Equals کلاس string) استفاده کنید.<br>
برای مقایسه‌ی ترتیب، باید از متد CompareTo رشته استفاده کنید؛ عملگرهای &lt; و &gt; در این زمینه پشتیبانی نمی‌شوند. ما جزئیات مربوط به برابری و مقایسه‌ی ترتیب را در بخش «Comparing Strings» در صفحه ۲۹۷ توضیح داده‌ایم.</p>
<h3>رشته‌های UTF-8</h3>
<p>از نسخه‌ی C# 11، می‌توانید با استفاده از پسوند u8 رشته‌هایی ایجاد کنید که به جای UTF-16 در UTF-8 رمزگذاری شده‌اند.<br>
این ویژگی برای سناریوهای پیشرفته، مانند مدیریت سطح پایین متن JSON در بخش‌هایی که عملکرد (Performance) بسیار مهم است، طراحی شده است:</p>
<pre class="hljs"><code>ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; utf8 = <span class="hljs-string">&quot;ab→cd&quot;</span>u8;  <span class="hljs-comment">// علامت فلش ۳ بایت مصرف می‌کند</span>
Console.WriteLine(utf8.Length);       <span class="hljs-comment">// خروجی: 7</span>
</code></pre>
<p>نوع زیرین آن ReadOnlySpan<byte> است که در فصل ۲۳ بررسی خواهیم کرد.<br>
برای تبدیل آن به آرایه، می‌توانید متد ToArray() را فراخوانی کنید.</p>
<h3>آرایه‌ها (Arrays)</h3>
<p>آرایه یک تعداد ثابت از متغیرها (که به آن‌ها عنصر یا element گفته می‌شود) از یک نوع مشخص را نشان می‌دهد. عناصر یک آرایه همیشه به صورت پشت‌سرهم در یک بلوک پیوسته از حافظه ذخیره می‌شوند، که این باعث دسترسی بسیار کارآمد به آن‌ها می‌شود.</p>
<p>آرایه با قرار دادن کروشه ([]) بعد از نوع عنصر تعریف می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span>[] vowels = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[<span class="hljs-number">5</span>];    <span class="hljs-comment">// تعریف یک آرایه ۵ کاراکتری</span>
</code></pre>
<p>کروشه‌ها همچنین برای اندیس‌دهی (indexing) استفاده می‌شوند تا به یک عنصر مشخص بر اساس موقعیتش دسترسی پیدا کنیم:</p>
<pre class="hljs"><code>vowels[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;
vowels[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;
vowels[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;i&#x27;</span>;
vowels[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;o&#x27;</span>;
vowels[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;u&#x27;</span>;

Console.WriteLine(vowels[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// e</span>
</code></pre>
<p>در اینجا خروجی e چاپ می‌شود، چون اندیس‌های آرایه از ۰ شروع می‌شوند.</p>
<p>می‌توانید از حلقه for برای پیمایش (iterate) تمام عناصر یک آرایه استفاده کنید. کد زیر متغیر i را از ۰ تا ۴ پیمایش می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; vowels.Length; i++)
    Console.Write(vowels[i]);   <span class="hljs-comment">// خروجی: aeiou</span>
</code></pre>
<p>ویژگی (property)‌ Length در یک آرایه، تعداد عناصر آن را برمی‌گرداند. بعد از ایجاد یک آرایه، طول آن قابل تغییر نیست.<br>
فضای نام (namespace) System.Collections و زیرمجموعه‌های آن، ساختارهای داده پیشرفته‌تری مانند آرایه‌های با اندازه پویا (dynamic arrays) و دیکشنری‌ها را ارائه می‌کنند.</p>
<p>یک عبارت مقداردهی اولیه (initialization expression) به شما این امکان را می‌دهد که آرایه را در یک مرحله تعریف و پر کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span>[] vowels = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] { <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span> };
</code></pre>
<p>یا به شکل کوتاه‌تر:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span>[] vowels = { <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span> };
</code></pre>
<p>از C# 12 می‌توانید به جای آکولاد {} از کروشه [] استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span>[] vowels = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>];
</code></pre>
<p>به این روش عبارت مجموعه‌ای (Collection Expression) گفته می‌شود و مزیت آن این است که هنگام ارسال آرایه به متدها نیز کاربرد دارد:</p>
<pre class="hljs"><code>Foo([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">char</span>[] letters</span>)</span> { ... }
</code></pre>
<p>عبارت‌های مجموعه‌ای همچنین با سایر نوع‌های مجموعه‌ای مثل لیست‌ها (lists) و مجموعه‌ها (sets) نیز کار می‌کنند — بخش &quot;Collection Initializers and Collection Expressions&quot; در صفحه 205 را ببینید.</p>
<p>تمام آرایه‌ها از کلاس System.Array ارث‌بری می‌کنند که سرویس‌های مشترکی برای تمام آرایه‌ها ارائه می‌دهد. این قابلیت‌ها شامل متدهایی برای گرفتن یا تنظیم عناصر صرف‌نظر از نوع آرایه هستند. توضیحات کامل‌تر در بخش &quot;The Array Class&quot; در صفحه 377 آمده است.</p>
<h4>مقداردهی پیش‌فرض به عناصر (Default Element Initialization)</h4>
<p>هنگام ایجاد یک آرایه، همیشه تمام عناصر آن به مقادیر پیش‌فرض (default values) مقداردهی اولیه می‌شوند. مقدار پیش‌فرض یک نوع، حاصل صفر کردن بیتی (bitwise zeroing) حافظه است.</p>
<p>به عنوان مثال، در نظر بگیرید که یک آرایه از اعداد صحیح (int) ایجاد می‌کنیم. از آنجایی که int یک نوع مقداری (value type) است، این کار باعث تخصیص ۱۰۰۰ عدد صحیح در یک بلوک پیوسته از حافظه می‌شود. مقدار پیش‌فرض برای هر عنصر صفر خواهد بود:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">1000</span>];
Console.Write(a[<span class="hljs-number">123</span>]); <span class="hljs-comment">// خروجی: 0</span>
</code></pre>
<h5>انواع مقداری در برابر انواع ارجاعی (Value Types vs Reference Types)</h5>
<p>اینکه نوع عنصر یک آرایه مقداری باشد یا ارجاعی، تأثیر مهمی بر عملکرد برنامه دارد.</p>
<p>اگر نوع عنصر یک نوع مقداری باشد، هر مقدار مستقیماً به عنوان بخشی از آرایه تخصیص داده می‌شود، مانند مثال زیر:</p>
<pre class="hljs"><code>Point[] a = <span class="hljs-keyword">new</span> Point[<span class="hljs-number">1000</span>];
<span class="hljs-built_in">int</span> x = a[<span class="hljs-number">500</span>].X; <span class="hljs-comment">// خروجی: 0</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Point { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X, Y; }
</code></pre>
<p>اما اگر Point یک کلاس بود، ایجاد آرایه تنها باعث ایجاد ۱۰۰۰ ارجاع null می‌شد:</p>
<pre class="hljs"><code>Point[] a = <span class="hljs-keyword">new</span> Point[<span class="hljs-number">1000</span>];
<span class="hljs-built_in">int</span> x = a[<span class="hljs-number">500</span>].X; <span class="hljs-comment">// خطای زمان اجرا: NullReferenceException</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X, Y; }
</code></pre>
<p>برای جلوگیری از این خطا، باید بعد از ایجاد آرایه، به‌طور صریح ۱۰۰۰ شیء Point ایجاد و به عناصر نسبت دهیم:</p>
<pre class="hljs"><code>Point[] a = <span class="hljs-keyword">new</span> Point[<span class="hljs-number">1000</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; a.Length; i++) <span class="hljs-comment">// تکرار از 0 تا 999</span>
    a[i] = <span class="hljs-keyword">new</span> Point(); <span class="hljs-comment">// مقداردهی عنصر i با یک Point جدید</span>
</code></pre>
<p>توجه: خود آرایه، همیشه یک شیء از نوع ارجاعی است، صرف‌نظر از اینکه نوع عناصر آن مقداری باشد یا ارجاعی.<br>
به عنوان مثال، دستور زیر معتبر است:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] a = <span class="hljs-literal">null</span>;
</code></pre>
<h3>ایندکس‌ها (Indices) و بازه‌ها (Ranges) 🔢📏</h3>
<p>ایندکس‌ها و بازه‌ها (که در نسخه‌ی C# 8 معرفی شدند) کار با عناصر یا بخش‌هایی از یک آرایه را ساده‌تر می‌کنند.</p>
<p>ایندکس‌ها و بازه‌ها همچنین با انواع CLR مانند Span<T> و ReadOnlySpan<T> نیز کار می‌کنند (به فصل ۲۳ مراجعه کنید 📖).<br>
شما حتی می‌توانید انواع دلخواه خودتان را هم طوری طراحی کنید که با ایندکس‌ها و بازه‌ها کار کنند؛ برای این کار باید یک ایندکسر (Indexer) از نوع Index یا Range تعریف کنید (بخش &quot;Indexers&quot; در صفحه ۱۱۸ را ببینید).</p>
<h4>ایندکس‌ها (Indices)</h4>
<p>ایندکس‌ها این امکان را می‌دهند که به عناصر یک آرایه نسبت به انتهای آن ارجاع دهید، با استفاده از عملگر ^.</p>
<ul>
<li>
<p>^1 به آخرین عنصر اشاره می‌کند.</p>
</li>
<li>
<p>^2 به عنصر ماقبل آخر اشاره می‌کند.</p>
</li>
<li>
<p>و همین‌طور ادامه پیدا می‌کند.</p>
</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span>[] vowels = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] {<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>};
<span class="hljs-built_in">char</span> lastElement  = vowels[^<span class="hljs-number">1</span>];   <span class="hljs-comment">// &#x27;u&#x27;</span>
<span class="hljs-built_in">char</span> secondToLast = vowels[^<span class="hljs-number">2</span>];   <span class="hljs-comment">// &#x27;o&#x27;</span>
</code></pre>
<p>نکته: مقدار ^0 برابر با طول آرایه است، بنابراین vowels[^0] باعث ایجاد خطا می‌شود. ⚠️</p>
<p>زبان C# ایندکس‌ها را با کمک نوع Index پیاده‌سازی می‌کند، بنابراین می‌توانید کد زیر را هم بنویسید:</p>
<pre class="hljs"><code>Index first = <span class="hljs-number">0</span>;
Index last = ^<span class="hljs-number">1</span>;
<span class="hljs-built_in">char</span> firstElement = vowels[first];   <span class="hljs-comment">// &#x27;a&#x27;</span>
<span class="hljs-built_in">char</span> lastElement  = vowels[last];    <span class="hljs-comment">// &#x27;u&#x27;</span>
</code></pre>
<h4>بازه‌ها (Ranges)</h4>
<p>بازه‌ها به شما امکان می‌دهند با استفاده از عملگر .. یک آرایه را برش بزنید:</p>
<pre class="hljs"><code>char[] firstTwo  = vowels[..2];   // 'a', 'e'
char[] lastThree = vowels[2..];   // 'i', 'o', 'u'
char[] middleOne = vowels[2..3];  // 'i'
</code></pre>
<p>عدد دوم در بازه انحصاری است، یعنی ..2 عناصری را برمی‌گرداند که قبل از vowels[2] قرار دارند.</p>
<p>همچنین می‌توانید در بازه‌ها از نماد ^ استفاده کنید. مثال زیر دو کاراکتر آخر را برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span>[] lastTwo = vowels[^<span class="hljs-number">2.</span>.];   <span class="hljs-comment">// &#x27;o&#x27;, &#x27;u&#x27;</span>
</code></pre>
<p>زبان C# بازه‌ها را با کمک نوع Range پیاده‌سازی می‌کند، بنابراین کد زیر هم ممکن است:</p>
<pre class="hljs"><code>Range firstTwoRange = <span class="hljs-number">0.</span><span class="hljs-number">.2</span>;
<span class="hljs-built_in">char</span>[] firstTwo = vowels[firstTwoRange];   <span class="hljs-comment">// &#x27;a&#x27;, &#x27;e&#x27;</span>
</code></pre>
<h3>آرایه‌های چندبعدی Multidimensional Arrays 🧮</h3>
<p>آرایه‌های چندبعدی در زبان #C به دو نوع اصلی تقسیم می‌شوند: آرایه‌های مستطیلی و آرایه‌های دندانه‌دار (Jagged).</p>
<p>آرایه‌های مستطیلی یک بلوک n-بعدی از حافظه را نمایش می‌دهند.</p>
<p>آرایه‌های دندانه‌دار در واقع آرایه‌ای از آرایه‌ها هستند.</p>
<h4>📏 آرایه‌های مستطیلی (Rectangular Arrays)</h4>
<p>آرایه‌های مستطیلی با استفاده از ویرگول ( , ) بین هر بُعد تعریف می‌شوند. مثال زیر یک آرایه دو‌بعدی 3×3 ایجاد می‌کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[,] matrix = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>];
</code></pre>
<p>متد GetLength طول یک بُعد خاص از آرایه را برمی‌گرداند (شماره‌گذاری از 0 شروع می‌شود):</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.GetLength(<span class="hljs-number">0</span>); i++)
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix.GetLength(<span class="hljs-number">1</span>); j++)
        matrix[i,j] = i * <span class="hljs-number">3</span> + j;
</code></pre>
<p>همچنین می‌توان آرایه مستطیلی را به‌طور مستقیم با مقادیر مشخص مقداردهی اولیه کرد:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[,] matrix = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[,]
{
    {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},
    {<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>},
    {<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>}
};
</code></pre>
<h4>🪢 آرایه‌های دندانه‌دار (Jagged Arrays)</h4>
<p>آرایه‌های دندانه‌دار با استفاده از براکت‌های متوالی [ ] برای نمایش هر بُعد تعریف می‌شوند. مثال زیر یک آرایه دو‌بعدی دندانه‌دار با بُعد بیرونی 3 ایجاد می‌کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>][];
</code></pre>
<p>نکته: این تعریف new int[3][] است، نه new int[][3].<br>
اریک لیپرت (Eric Lippert) مقاله بسیار خوبی درباره دلیل این موضوع نوشته است.</p>
<p>در این نوع آرایه، اندازه بُعد داخلی در زمان تعریف مشخص نمی‌شود، زیرا هر آرایه داخلی می‌تواند طول متفاوتی داشته باشد. در ابتدا هر آرایه داخلی به‌طور پیش‌فرض مقدار null می‌گیرد (نه یک آرایه خالی). بنابراین باید به صورت دستی آرایه داخلی را ایجاد کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.Length; i++)
{
    matrix[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>];   <span class="hljs-comment">// ایجاد آرایه داخلی</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix[i].Length; j++)
        matrix[i][j] = i * <span class="hljs-number">3</span> + j;
}
</code></pre>
<p>همچنین می‌توان یک آرایه دندانه‌دار را به‌طور مستقیم مقداردهی اولیه کرد:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[][]
{
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] {<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>},
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] {<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>}
};
</code></pre>
<h3>📝 مقداردهی ساده‌شده به آرایه‌ها (Simplified Array Initialization Expressions)</h3>
<p>در #C دو روش برای کوتاه‌کردن عبارات مقداردهی اولیه به آرایه‌ها وجود دارد.</p>
<p><strong>1️⃣ حذف new و نوع داده</strong></p>
<p>در این روش، می‌توانیم عملگر new و مشخصه نوع داده را حذف کنیم:</p>
<pre class="hljs"><code><span class="hljs-built_in">char</span>[] vowels = {<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>};

<span class="hljs-built_in">int</span>[,] rectangularMatrix =
{
    {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},
    {<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>},
    {<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>}
};

<span class="hljs-built_in">int</span>[][] jaggedMatrix =
{
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] {<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>},
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] {<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>}
};
</code></pre>
<p>💡 نکته: از نسخه C# 12 به بعد، برای آرایه‌های یک‌بعدی می‌توانید از براکت مربع [] به‌جای آکولاد {} استفاده کنید.</p>
<p><strong>2️⃣ استفاده از کلیدواژه var</strong></p>
<p>کلمه کلیدی var به کامپایلر می‌گوید که نوع متغیر را به صورت ضمنی تشخیص دهد:</p>
<pre class="hljs"><code>var i = 3;         // i به‌صورت ضمنی int است
var s = &quot;sausage&quot;; // s به‌صورت ضمنی string است
</code></pre>
<p>برای آرایه‌ها هم می‌توانیم از این قابلیت استفاده کنیم و حتی یک گام جلوتر برویم: با حذف نوع داده بعد از new، کامپایلر نوع آرایه را تشخیص می‌دهد:</p>
<pre class="hljs"><code>var vowels = new[] {'a','e','i','o','u'}; // نوع char[] است
</code></pre>
<p><strong>🧮 اعمال در آرایه‌های چندبعدی</strong></p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> rectMatrix = <span class="hljs-keyword">new</span>[,]
{
    {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},
    {<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>},
    {<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>}
}; <span class="hljs-comment">// نوع int[,]</span>

<span class="hljs-keyword">var</span> jaggedMat = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[][]
{
    <span class="hljs-keyword">new</span>[] {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},
    <span class="hljs-keyword">new</span>[] {<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>},
    <span class="hljs-keyword">new</span>[] {<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>}
}; <span class="hljs-comment">// نوع int[][]</span>
</code></pre>
<p><strong>⚠️ محدودیت‌ها</strong></p>
<p>برای این که این روش کار کند:</p>
<ul>
<li>
<p>تمام عناصر باید به‌طور ضمنی قابل تبدیل به یک نوع داده واحد باشند.</p>
</li>
<li>
<p>حداقل یک عنصر باید دقیقاً از آن نوع باشد.</p>
</li>
<li>
<p>باید تنها یک نوع بهترین انتخاب وجود داشته باشد.</p>
</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span>[] {<span class="hljs-number">1</span>, <span class="hljs-number">10000000000</span>}; <span class="hljs-comment">// همه به long قابل تبدیل‌اند</span>
</code></pre>
<h3>🛡 بررسی محدوده آرایه‌ها (Bounds Checking)</h3>
<p>در #C، تمام دسترسی‌ها به عناصر آرایه‌ها توسط زمان اجرا (runtime) بررسی می‌شود.<br>
اگر از یک ایندکس نامعتبر استفاده کنید، استثنای IndexOutOfRangeException پرتاب می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>];
arr[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// IndexOutOfRangeException رخ می‌دهد</span>
</code></pre>
<p>🔍 بررسی محدوده آرایه‌ها برای ایمنی نوع داده (type safety) ضروری است و همچنین کار اشکال‌زدایی (debugging) را ساده‌تر می‌کند.</p>
<p><strong>⚡ تأثیر بر کارایی</strong></p>
<p>به‌طور کلی، کاهش کارایی ناشی از این بررسی‌ها بسیار جزئی است.<br>
کامپایلر JIT (Just-In-Time) می‌تواند بهینه‌سازی‌هایی انجام دهد؛ مثلاً قبل از ورود به یک حلقه، تشخیص دهد که تمام ایندکس‌ها ایمن هستند و به این ترتیب، نیاز به بررسی در هر تکرار حلقه را حذف کند.</p>
<p><strong>🚫 کد Unsafe</strong></p>
<p>همچنین، زبان #C قابلیت کد ناایمن (unsafe code) را فراهم کرده که می‌تواند این بررسی‌ها را به‌طور صریح دور بزند.<br>
(برای جزئیات بیشتر، بخش &quot;Unsafe Code and Pointers&quot; در صفحه 263 را ببینید.)</p>
<h3>🗃 متغیرها و پارامترها (Variables and Parameters)</h3>
<p>یک متغیر (variable) نمایانگر یک مکان ذخیره‌سازی است که مقدار آن قابل تغییر است.<br>
متغیر می‌تواند یکی از انواع زیر باشد:</p>
<ul>
<li>
<p>متغیر محلی (local variable)</p>
</li>
<li>
<p>پارامتر (parameter) — که می‌تواند به شکل value، یا با کلیدواژه‌های ref، out، یا in باشد</p>
</li>
<li>
<p>فیلد (field) — چه نمونه‌ای (instance) و چه ایستا (static)</p>
</li>
<li>
<p>عنصر آرایه (array element)</p>
</li>
</ul>
<h4>🏛 پشته و هیپ (The Stack and the Heap)</h4>
<p>در #C، متغیرها در یکی از دو مکان اصلی حافظه ذخیره می‌شوند:</p>
<ol>
<li>
<p>پشته (stack)</p>
</li>
<li>
<p>هیپ (heap)</p>
</li>
</ol>
<p>هرکدام از این مکان‌ها قوانین و چرخه عمر (lifetime) متفاوتی دارند.</p>
<h5>📦 پشته (Stack)</h5>
<p>پشته یک بخش از حافظه است که برای ذخیره متغیرهای محلی و پارامترها استفاده می‌شود.<br>
پشته به‌صورت منطقی رشد و کوچک می‌شود؛ یعنی وقتی یک متد یا تابع وارد می‌شود، فضا اضافه می‌شود و وقتی از آن خارج می‌شویم، آن فضا آزاد می‌گردد.</p>
<p>🔹 به مثال زیر توجه کنید:<br>
(برای جلوگیری از حواس‌پرتی، بررسی ورودی‌ها را نادیده گرفته‌ایم)</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Factorial</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>
{
    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> x * Factorial(x - <span class="hljs-number">1</span>);
}
</code></pre>
<p>این متد بازگشتی (recursive) است، یعنی خودش را صدا می‌زند.</p>
<p>هر بار که این متد اجرا می‌شود:</p>
<ul>
<li>
<p>یک مقدار int جدید روی پشته اختصاص داده می‌شود.</p>
</li>
<li>
<p>و هر بار که متد پایان می‌یابد، آن مقدار از پشته آزاد می‌شود.</p>
</li>
</ul>
<h5>🗄 هیپ (Heap)</h5>
<p>هیپ بخشی از حافظه است که در آن اشیاء (objects) یا همان نمونه‌های نوع مرجع (reference-type instances) ذخیره می‌شوند.</p>
<p>هر زمان که یک شیء جدید ایجاد می‌شود:</p>
<ol>
<li>
<p>فضای آن روی هیپ اختصاص داده می‌شود.</p>
</li>
<li>
<p>یک مرجع (reference) به آن شیء برگردانده می‌شود.</p>
</li>
</ol>
<p><strong>♻ جمع‌آوری زباله (Garbage Collection)</strong></p>
<p>در طول اجرای برنامه، هیپ کم‌کم با ایجاد اشیاء جدید پر می‌شود.<br>
زمان اجرا (runtime) یک مکانیزم به نام جمع‌آورندهٔ زباله (garbage collector - GC) دارد که به‌طور دوره‌ای اشیاء بلااستفاده را از هیپ آزاد می‌کند تا برنامه با مشکل کمبود حافظه مواجه نشود.</p>
<p>یک شیء زمانی واجد شرایط پاک شدن است که دیگر هیچ مرجعی از سوی داده‌های زنده (alive) به آن وجود نداشته باشد.</p>
<p>🔍 مثال</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Text;

StringBuilder ref1 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;object1&quot;</span>);
Console.WriteLine(ref1);
<span class="hljs-comment">// شیء StringBuilder که توسط ref1 ارجاع داده شده، اکنون واجد شرایط GC است.</span>

StringBuilder ref2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;object2&quot;</span>);
StringBuilder ref3 = ref2;
<span class="hljs-comment">// شیء StringBuilder که توسط ref2 ارجاع داده شده، هنوز واجد شرایط GC نیست</span>
<span class="hljs-comment">// چون ref3 همچنان به آن اشاره می‌کند.</span>

Console.WriteLine(ref3); <span class="hljs-comment">// خروجی: object2</span>
</code></pre>
<p>در این مثال:</p>
<ul>
<li>
<p>ابتدا یک شیء از نوع StringBuilder ایجاد می‌کنیم که توسط متغیر ref1 ارجاع داده شده است.<br>
بعد از خط Console.WriteLine(ref1)، دیگر چیزی به آن شیء ارجاع نمی‌دهد، پس می‌تواند توسط GC جمع‌آوری شود.</p>
</li>
<li>
<p>سپس یک شیء دیگر به نام ref2 ایجاد کرده و مرجع آن را در ref3 ذخیره می‌کنیم.<br>
حتی اگر ref2 دیگر استفاده نشود، وجود ref3 باعث می‌شود شیء همچنان زنده بماند.</p>
</li>
</ul>
<p><strong>📌 نکات مهم دربارهٔ هیپ:</strong></p>
<ul>
<li>
<p>نمونه‌های نوع مقداری (value-type instances) و مراجع اشیاء در همان جایی ذخیره می‌شوند که متغیرشان تعریف شده است.<br>
اگر نمونهٔ نوع مقداری به‌عنوان یک فیلد درون یک نوع کلاس یا به‌عنوان یک عنصر آرایه تعریف شود، روی هیپ ذخیره می‌شود.</p>
</li>
<li>
<p>در C#، برخلاف C++، شما نمی‌توانید یک شیء را به‌صورت دستی حذف کنید.<br>
شیء بدون مرجع در نهایت توسط جمع‌آورندهٔ زباله پاک می‌شود.</p>
</li>
<li>
<p>هیپ همچنین فیلدهای ایستا (static fields) را ذخیره می‌کند.<br>
برخلاف اشیاء معمولی روی هیپ که می‌توانند جمع‌آوری شوند، این فیلدها تا پایان اجرای فرآیند زنده می‌مانند.</p>
</li>
</ul>
<h3>✅ انتساب قطعی (Definite Assignment)</h3>
<p>در زبان C# یک قانون به نام انتساب قطعی وجود دارد.<br>
به زبان ساده، این قانون تضمین می‌کند که (خارج از حالت‌های unsafe یا interop) شما نمی‌توانید به‌طور تصادفی به حافظهٔ مقداردهی‌نشده دسترسی پیدا کنید.</p>
<p><strong>📌 سه نتیجهٔ اصلی این قانون:</strong></p>
<ol>
<li>
<p>متغیرهای محلی (Local Variables) باید قبل از خواندن یک مقدار به آن‌ها اختصاص داده شود.</p>
</li>
<li>
<p>پارامترهای متد (Function Arguments) باید هنگام فراخوانی متد ارسال شوند (مگر این که به‌عنوان اختیاری مشخص شده باشند – بخش Optional Parameters صفحه 74).</p>
</li>
<li>
<p>تمام متغیرهای دیگر (مثل فیلدها و عناصر آرایه) به‌طور خودکار توسط زمان اجرا (runtime) مقداردهی اولیه می‌شوند.</p>
</li>
</ol>
<p><strong>🛑 مثال خطای زمان کامپایل</strong></p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x;
Console.WriteLine(x); <span class="hljs-comment">// خطا در زمان کامپایل: متغیر مقداردهی نشده</span>
</code></pre>
<p>اینجا x یک متغیر محلی است و چون قبل از استفاده مقداری به آن نداده‌ایم، کامپایلر خطا می‌دهد.</p>
<p><strong>🗄 مقداردهی پیش‌فرض برای آرایه‌ها</strong></p>
<p>عناصر آرایه‌ها به‌صورت پیش‌فرض با مقدار پیش‌فرض نوعشان (default value) مقداردهی می‌شوند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>];
Console.WriteLine(ints[<span class="hljs-number">0</span>]); <span class="hljs-comment">// خروجی: 0</span>
</code></pre>
<p>در اینجا، نوع int پیش‌فرضش 0 است، پس تمام خانه‌های آرایه به این مقدار مقداردهی می‌شوند.</p>
<p><strong>🏷 مقداردهی پیش‌فرض برای فیلدها</strong></p>
<p>فیلدها (چه ایستا و چه نمونه‌ای) به‌طور خودکار با مقدار پیش‌فرضشان مقداردهی می‌شوند:</p>
<pre class="hljs"><code>Console.WriteLine(Test.X); <span class="hljs-comment">// خروجی: 0</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> X; <span class="hljs-comment">// به‌طور پیش‌فرض 0</span>
}
</code></pre>
<h3>🎯 مقادیر پیش‌فرض (Default Values)</h3>
<p>تمام نمونه‌های نوع داده‌ها یک مقدار پیش‌فرض دارند.<br>
برای نوع‌های از پیش تعریف‌شده (predefined types)، مقدار پیش‌فرض نتیجهٔ صفر شدن بیت به بیت حافظه است:</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-7.png" alt="Conventions-UsedThis-Book"> <br></p>
</div>
می‌توانی مقدار پیش‌فرض هر نوع داده‌ای را با استفاده از کلیدواژه‌ی default به دست بیاوری:
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-literal">default</span>(<span class="hljs-built_in">decimal</span>));   <span class="hljs-comment">// 0</span>
</code></pre>
<p>در صورتی که نوع داده قابل استنباط باشد، می‌توانی نوع را هم نیاوری:</p>
<pre class="hljs"><code><span class="hljs-built_in">decimal</span> d = <span class="hljs-literal">default</span>;
</code></pre>
<p>مقدار پیش‌فرض در نوع‌های سفارشی از نوع value (یعنی struct) همان مقدار پیش‌فرض هر فیلد تعریف‌شده در آن نوع است. ✅</p>
<h3>Parameters پارامترها</h3>
<p>یک متد می‌تواند یک دنباله از پارامترها داشته باشد. پارامترها مجموعه‌ای از آرگومان‌ها را تعریف می‌کنند که باید برای آن متد فراهم شوند.</p>
<p>در مثال زیر، متد Foo یک پارامتر به نام p از نوع int دارد:</p>
<pre class="hljs"><code>Foo(<span class="hljs-number">8</span>);                        <span class="hljs-comment">// 8 یک آرگومان است</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p</span>)</span> {...}   <span class="hljs-comment">// p یک پارامتر است</span>
</code></pre>
<p>می‌توانی نحوه‌ی ارسال پارامترها را با استفاده از مقداردهنده‌های ref، in و out کنترل کنی. 🔄</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-8.png" alt="Conventions-UsedThis-Book"> <br></p>
</div>
<h5>عبور آرگومان‌ها به صورت مقدار (Passing arguments by value)</h5>
<p>به طور پیش‌فرض، در C# آرگومان‌ها به صورت مقدار (by value) ارسال می‌شوند، که رایج‌ترین حالت است. ✨</p>
<p>این یعنی وقتی مقداری به متد داده می‌شود، یک کپی از آن مقدار ساخته شده و به متد داده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">8</span>;
Foo(x);                    <span class="hljs-comment">// یک کپی از x ساخته می‌شود</span>
Console.WriteLine(x);      <span class="hljs-comment">// x همچنان 8 خواهد بود</span>

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p</span>)</span>
{
    p = p + <span class="hljs-number">1</span>;             <span class="hljs-comment">// مقدار p یک واحد افزایش می‌یابد</span>
    Console.WriteLine(p);  <span class="hljs-comment">// مقدار p نمایش داده می‌شود</span>
}
</code></pre>
<p>اینجا تغییر مقدار p هیچ اثری روی x ندارد، چون p و x در مکان‌های متفاوتی از حافظه ذخیره شده‌اند. 🧩</p>
<p>🔹 حالا اگر آرگومان از نوع مرجع (reference type) باشد، ماجرا کمی فرق می‌کند:<br>
در این حالت، هنگام ارسال آرگومان، خود شیء کپی نمی‌شود، بلکه مرجع (آدرس حافظه) شیء کپی می‌شود.</p>
<pre class="hljs"><code>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
Foo(sb);
Console.WriteLine(sb.ToString());    <span class="hljs-comment">// خروجی: test</span>

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">StringBuilder fooSB</span>)</span>
{
    fooSB.Append(<span class="hljs-string">&quot;test&quot;</span>);
    fooSB = <span class="hljs-literal">null</span>;
}
</code></pre>
<p>اینجا هم sb و هم fooSB هر دو به یک شیء مشترک از نوع StringBuilder اشاره می‌کنند.<br>
به همین دلیل، وقتی در متد Foo عبارت &quot;test&quot; اضافه می‌کنیم، تغییر روی شیء اصلی (sb) هم اعمال می‌شود.</p>
<p>اما زمانی که در Foo مقدار fooSB = null; انجام می‌دهیم، فقط کپی مرجع را تغییر می‌دهیم و شیء اصلی (sb) همچنان به همان StringBuilder اشاره می‌کند.</p>
<p>(البته اگر fooSB با کلیدواژه‌ی ref تعریف و فراخوانی شده بود، تغییر آن به null باعث می‌شد که sb هم null شود.) ⚡</p>
<h5>کلیدواژه‌ی ref</h5>
<p>برای اینکه یک آرگومان به‌صورت مرجع (by reference) به متد داده شود، در C# از کلیدواژه‌ی ref استفاده می‌کنیم. 🔗</p>
<p>در این حالت، پارامتر متد و متغیر اصلی، هر دو به یک مکان حافظه اشاره می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">8</span>;
Foo(<span class="hljs-keyword">ref</span> x);               <span class="hljs-comment">// از Foo می‌خواهیم مستقیماً روی x کار کند</span>
Console.WriteLine(x);     <span class="hljs-comment">// خروجی: 9</span>

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> p</span>)</span>
{
    p = p + <span class="hljs-number">1</span>;            <span class="hljs-comment">// مقدار p یک واحد زیاد می‌شود</span>
    Console.WriteLine(p); <span class="hljs-comment">// نمایش مقدار p</span>
}
</code></pre>
<p>✅ در اینجا وقتی p تغییر می‌کند، مقدار x هم تغییر می‌کند.<br>
توجه کن که کلیدواژه‌ی ref هم در تعریف متد و هم در هنگام فراخوانی باید ذکر شود؛ این کار باعث می‌شود خیلی واضح باشد که آرگومان با مرجعش ارسال شده است.</p>
<p>📌 استفاده‌ی مهم ref در پیاده‌سازی متدهایی مثل جابجایی (Swap) است:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> x = <span class="hljs-string">&quot;Penn&quot;</span>;
<span class="hljs-built_in">string</span> y = <span class="hljs-string">&quot;Teller&quot;</span>;

Swap(<span class="hljs-keyword">ref</span> x, <span class="hljs-keyword">ref</span> y);

Console.WriteLine(x);   <span class="hljs-comment">// خروجی: Teller</span>
Console.WriteLine(y);   <span class="hljs-comment">// خروجی: Penn</span>

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">string</span> a, <span class="hljs-keyword">ref</span> <span class="hljs-built_in">string</span> b</span>)</span>
{
    <span class="hljs-built_in">string</span> temp = a;
    a = b;
    b = temp;
}
</code></pre>
<h5>کلیدواژه‌ی out</h5>
<p>پارامترها می‌توانند چه به‌صورت مقدار (by value) و چه به‌صورت مرجع (by reference) ارسال شوند،<br>
اما کلیدواژه‌ی out یک تفاوت ظریف با ref دارد: ✨</p>
<ol>
<li>
<p>✅ مقدار متغیر قبل از ورود به متد لازم نیست مقداردهی شود.</p>
</li>
<li>
<p>✅ اما قبل از خروج از متد حتماً باید مقداردهی شود.</p>
</li>
</ol>
<p>📌 این ویژگی معمولاً برای برگرداندن چند مقدار از یک متد استفاده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> a, b;
Split(<span class="hljs-string">&quot;Stevie Ray Vaughn&quot;</span>, <span class="hljs-keyword">out</span> a, <span class="hljs-keyword">out</span> b);

Console.WriteLine(a);   <span class="hljs-comment">// خروجی: Stevie Ray</span>
Console.WriteLine(b);   <span class="hljs-comment">// خروجی: Vaughn</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Split</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> firstNames, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> lastName</span>)</span>
{
    <span class="hljs-built_in">int</span> i = name.LastIndexOf(<span class="hljs-string">&#x27; &#x27;</span>);
    firstNames = name.Substring(<span class="hljs-number">0</span>, i);
    lastName = name.Substring(i + <span class="hljs-number">1</span>);
}
</code></pre>
<p>اینجا پارامترهای firstNames و lastName با کلیدواژه‌ی out ارسال شده‌اند.<br>
این یعنی متد Split باید حتماً قبل از پایان اجرا به هر دو مقدار اختصاص دهد.</p>
<p>📍 نکته‌ی مهم: درست مثل ref، یک پارامتر out هم به‌صورت مرجع (by reference) ارسال می‌شود.<br>
پس تغییرش درون متد، روی متغیر اصلی بیرون از متد هم اثر می‌گذارد.</p>
<h5>متغیرهای out و Discards</h5>
<p>گاهی اوقات وقتی متدی پارامترهای out دارد، می‌توانیم متغیرها را همان لحظه (on the fly) در زمان فراخوانی متد تعریف کنیم. 🎯</p>
<p>به جای این:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> a, b;
Split(<span class="hljs-string">&quot;Stevie Ray Vaughan&quot;</span>, <span class="hljs-keyword">out</span> a, <span class="hljs-keyword">out</span> b);
</code></pre>
<p>می‌توانیم مستقیم بنویسیم:</p>
<pre class="hljs"><code>Split(<span class="hljs-string">&quot;Stevie Ray Vaughan&quot;</span>, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> a, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> b);
</code></pre>
<p><strong>Discards (نادیده گرفتن مقادیر)</strong></p>
<p>اگر متدی چندین پارامتر out داشته باشد، ولی به همه‌ی خروجی‌ها نیاز نداشته باشیم، می‌توانیم بعضی را نادیده بگیریم.<br>
این کار با علامت _ انجام می‌شود:</p>
<pre class="hljs"><code>Split(<span class="hljs-string">&quot;Stevie Ray Vaughan&quot;</span>, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> a, <span class="hljs-keyword">out</span> _); <span class="hljs-comment">// پارامتر دوم نادیده گرفته می‌شود</span>
Console.WriteLine(a);   <span class="hljs-comment">// خروجی: Stevie Ray</span>
</code></pre>
<p>✅ علامت _ در اینجا نقش یک متغیر خاص به نام discard را دارد.<br>
می‌توان چندین بار از آن در یک فراخوانی استفاده کرد:</p>
<pre class="hljs"><code>SomeBigMethod(<span class="hljs-keyword">out</span> _, <span class="hljs-keyword">out</span> _, <span class="hljs-keyword">out</span> _, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> x, <span class="hljs-keyword">out</span> _, <span class="hljs-keyword">out</span> _, <span class="hljs-keyword">out</span> _);
</code></pre>
<p>اینجا فقط پارامتر چهارم (x) را نگه داشته‌ایم و بقیه را نادیده گرفته‌ایم.</p>
<p><strong>⚠️ یک نکته‌ی مهم:</strong></p>
<p>به‌خاطر سازگاری با نسخه‌های قدیمی‌تر C#، اگر در همان محدوده‌ی کد واقعاً متغیری با نام _ تعریف کرده باشید، آن دیگر discard محسوب نمی‌شود.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> _;
Split(<span class="hljs-string">&quot;Stevie Ray Vaughan&quot;</span>, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> a, <span class="hljs-keyword">out</span> _);
Console.WriteLine(_);   <span class="hljs-comment">// خروجی: Vaughan</span>
</code></pre>
<p>اینجا چون _ به عنوان متغیر واقعی تعریف شده، مقدار پارامتر دوم (Vaughan) در آن ریخته می‌شود.</p>
<h5>پیامدهای ارسال پارامتر به‌صورت مرجع (by reference)</h5>
<p>وقتی آرگومانی را با ref یا out ارسال می‌کنیم، در واقع یک آدرس (مرجع) به متد داده می‌شود،<br>
نه یک کپی جداگانه. یعنی پارامتر متد و متغیر اصلی، هردو به یک مکان حافظه اشاره دارند.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> x;

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span> 
    { 
        Foo(<span class="hljs-keyword">out</span> x); 
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> y</span>)</span>
    {
        Console.WriteLine(x);  <span class="hljs-comment">// خروجی: 0</span>
        y = <span class="hljs-number">1</span>;                 <span class="hljs-comment">// مقدار y تغییر داده می‌شود</span>
        Console.WriteLine(x);  <span class="hljs-comment">// خروجی: 1</span>
    }
}
</code></pre>
<p>اینجا x و y در واقع به همان مکان حافظه اشاره می‌کنند.<br>
وقتی y = 1 می‌شود، مقدار x هم همزمان تغییر می‌کند.</p>
<h5>🔹 پارامترهای in</h5>
<p>پارامتر in شبیه به پارامتر ref است، با این تفاوت مهم که:<br>
👉 متد نمی‌تواند مقدار آن پارامتر را تغییر دهد.<br>
اگر سعی کنیم داخل متد مقدارش را تغییر دهیم، ❌ خطای کامپایل خواهیم گرفت.</p>
<p><strong>📌 کاربرد اصلی in</strong></p>
<p>وقتی یک ساختار بزرگ (struct) را به متدی پاس می‌دهیم، به‌طور پیش‌فرض یک کپی کامل از آن ساخته می‌شود.<br>
این کار می‌تواند هزینه‌ی زیادی برای حافظه و کارایی داشته باشد.</p>
<p>✅ استفاده از in باعث می‌شود:</p>
<ul>
<li>
<p>مقدار by reference پاس داده شود (بدون کپی اضافه).</p>
</li>
<li>
<p>ولی همچنان محافظت شود تا متد نتواند مقدار اصلی را تغییر دهد.</p>
</li>
</ul>
<p><strong>📍 اورلودینگ بر اساس in</strong></p>
<p>می‌توان یک متد را فقط بر اساس وجود in اورلود کرد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">SomeBigStruct a</span>)</span> { ... }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">in</span> SomeBigStruct a</span>)</span> { ... }
</code></pre>
<p>حالا برای فراخوانی:</p>
<pre class="hljs"><code>SomeBigStruct x = ...;

Foo(x);     <span class="hljs-comment">// فراخوانی متد اول (بدون in)</span>
Foo(<span class="hljs-keyword">in</span> x);  <span class="hljs-comment">// فراخوانی متد دوم (با in)</span>
</code></pre>
<p><strong>📍 زمانی که ابهامی وجود ندارد</strong></p>
<p>اگر فقط یک متد داشته باشیم که in استفاده می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"><span class="hljs-keyword">in</span> SomeBigStruct a</span>)</span> { ... }
</code></pre>
<p>در این صورت، هنگام فراخوانی نوشتن in اختیاری است:</p>
<pre class="hljs"><code>Bar(x);     <span class="hljs-comment">// اوکی ✔ (همان متد با in صدا زده می‌شود)</span>
Bar(<span class="hljs-keyword">in</span> x);  <span class="hljs-comment">// اوکی ✔</span>
</code></pre>
<p><strong>📌 نکته مهم</strong></p>
<p>این ویژگی بیشتر برای زمانی معنا دارد که SomeBigStruct یک struct بزرگ باشد (مثل یک struct با چندین فیلد یا داده‌ی حجیم).<br>
چون در غیر این صورت استفاده از in خیلی تفاوتی ایجاد نمی‌کند.</p>
<h5>🔹 پارامترهای params</h5>
<p>کلمه کلیدی params به ما اجازه می‌دهد که یک متد را طوری تعریف کنیم که تعداد نامحدودی آرگومان از یک نوع خاص بپذیرد.</p>
<p>📌 شرایط:</p>
<ul>
<li>
<p>باید فقط روی آخرین پارامتر متد اعمال شود.</p>
</li>
<li>
<p>نوع آن باید آرایه تک‌بعدی باشد.</p>
</li>
</ul>
<p>📍 مثال</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> total = Sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
Console.WriteLine(total);   <span class="hljs-comment">// خروجی: 10</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Sum</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] ints</span>)</span>
{
    <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; ints.Length; i++)
        sum += ints[i];
    <span class="hljs-keyword">return</span> sum;
}
</code></pre>
<p>🔸 در اینجا متد Sum هر تعداد عدد صحیح را می‌پذیرد و جمع آن‌ها را برمی‌گرداند.</p>
<p><strong>📌 معادل بدون params</strong></p>
<p>فراخوانی بالا در واقع معادل است با:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> total = Sum(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> });
</code></pre>
<p>یعنی کامپایلر به صورت خودکار یک آرایه می‌سازد.</p>
<p><strong>📍 حالت بدون آرگومان</strong></p>
<p>اگر هیچ آرگومانی داده نشود، یک آرایه خالی ساخته می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> total = Sum();   <span class="hljs-comment">// آرایه‌ای با Length = 0</span>
</code></pre>
<p><strong>🔹 پارامترهای اختیاری (Optional Parameters)</strong></p>
<p>در C#، متدها، سازنده‌ها و ایندکسرها می‌توانند پارامتر اختیاری داشته باشند.<br>
یعنی در تعریف متد برای آن پارامتر یک مقدار پیش‌فرض مشخص می‌کنیم.</p>
<p>📍 مثال ساده</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x = <span class="hljs-number">23</span></span>)</span> 
{ 
    Console.WriteLine(x); 
}

Foo();    <span class="hljs-comment">// 23</span>
</code></pre>
<p>✅ وقتی آرگومان را حذف کنیم، مقدار پیش‌فرض 23 پاس داده می‌شود.<br>
در حقیقت، کامپایلر مقدار 23 را در کد کامپایل‌شده جایگزین می‌کند.</p>
<p>پس این دو فراخوانی معادل هستند:</p>
<pre class="hljs"><code>Foo();    <span class="hljs-comment">// 23</span>
Foo(<span class="hljs-number">23</span>);  <span class="hljs-comment">// 23</span>
</code></pre>
<p><strong>📌 قوانین پارامترهای اختیاری</strong></p>
<ol>
<li>مقدار پیش‌فرض باید یک عبارت ثابت (constant expression)، سازنده بدون پارامتر یک نوع مقداری (مثل new DateTime())، یا یک عبارت default باشد.</li>
</ol>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>, <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;Hello&quot;</span>, DateTime d = <span class="hljs-literal">default</span></span>)</span> { }
</code></pre>
<ol start="2">
<li>
<p>پارامترهای اختیاری نمی‌توانند با ref یا out علامت‌گذاری شوند. ❌</p>
</li>
<li>
<p>پارامترهای اجباری باید همیشه قبل از پارامترهای اختیاری بیایند.</p>
</li>
<li>
<p>استثنا: اگر params داشته باشیم، همیشه باید در آخر قرار بگیرد.</p>
</li>
</ol>
<p><strong>📍 مثال ترکیب پارامتر اجباری و اختیاری</strong></p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-built_in">int</span> y = <span class="hljs-number">0</span></span>)</span> 
{ 
    Console.WriteLine(x + <span class="hljs-string">&quot;, &quot;</span> + y); 
}

Foo(<span class="hljs-number">1</span>);    <span class="hljs-comment">// خروجی: 1, 0</span>
Foo();     <span class="hljs-comment">// خروجی: 0, 0</span>
</code></pre>
<p><strong>📌 ترکیب با Named Arguments</strong></p>
<p>اگر بخواهیم مقدار پیش‌فرض x را نگه داریم ولی برای y مقدار مشخصی بفرستیم، می‌توانیم از named arguments استفاده کنیم:</p>
<pre class="hljs"><code>Foo(y: <span class="hljs-number">5</span>);   <span class="hljs-comment">// خروجی: 0, 5</span>
</code></pre>
<h5>آرگومان‌های نام‌گذاری‌شده (Named Arguments) 🎯</h5>
<p>به‌جای اینکه یک آرگومان را بر اساس موقعیتش مشخص کنید، می‌توانید آن را بر اساس نام پارامتر صدا بزنید:</p>
<pre class="hljs"><code>Foo (x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span>);  <span class="hljs-comment">// خروجی: 1, 2</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span> { Console.WriteLine (x + <span class="hljs-string">&quot;, &quot;</span> + y); }
</code></pre>
<p>✅ آرگومان‌های نام‌گذاری‌شده می‌توانند به هر ترتیبی بیایند. فراخوانی‌های زیر کاملاً معادل هستند:</p>
<pre class="hljs"><code>Foo (x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span>);
Foo (y: <span class="hljs-number">2</span>, x: <span class="hljs-number">1</span>);
</code></pre>
<p><strong>ترتیب ارزیابی (Evaluation Order) ⚡</strong></p>
<p>یک نکته‌ی ظریف این است که عبارت‌های آرگومان‌ها به ترتیبی که در محل فراخوانی نوشته شده‌اند، ارزیابی می‌شوند.</p>
<p>مثلاً کد زیر 0, 1 چاپ می‌کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>;
Foo (y: ++a, x: --a);  <span class="hljs-comment">// اول ++a اجرا می‌شود، بعد --a</span>
</code></pre>
<p>البته نوشتن چنین کدی در عمل به‌هیچ‌وجه توصیه نمی‌شود! 🚫</p>
<p><strong>ترکیب آرگومان‌های نامی و موقعیتی 📝</strong></p>
<p>شما می‌توانید آرگومان‌های موقعیتی و نام‌گذاری‌شده را ترکیب کنید:</p>
<pre class="hljs"><code>Foo (<span class="hljs-number">1</span>, y: <span class="hljs-number">2</span>);   <span class="hljs-comment">// مجاز ✅</span>
</code></pre>
<p>اما یک محدودیت وجود دارد:</p>
<ul>
<li>آرگومان‌های موقعیتی باید قبل از آرگومان‌های نامی بیایند، مگر اینکه دقیقاً در موقعیت درست قرار گیرند.</li>
</ul>
<p>مثلاً:</p>
<pre class="hljs"><code>Foo (x: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// مجاز ✅ (هر کدام در جای درستشان هستند)</span>
Foo (y: <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">// خطای کامپایل ❌ (y در جای اول نیست)</span>
</code></pre>
<p><strong>کاربرد عملی 💡</strong></p>
<p>آرگومان‌های نامی به‌ویژه زمانی مفید هستند که همراه با پارامترهای اختیاری (optional parameters) استفاده شوند.</p>
<p>مثلاً اگر متدی این‌طور تعریف شده باشد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>, <span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>, <span class="hljs-built_in">int</span> c = <span class="hljs-number">0</span>, <span class="hljs-built_in">int</span> d = <span class="hljs-number">0</span></span>)</span> { ... }
</code></pre>
<p>می‌توانید فقط مقدار d را مشخص کنید:</p>
<pre class="hljs"><code>Bar (d: <span class="hljs-number">3</span>);
</code></pre>
<p>این ویژگی مخصوصاً هنگام کار با COM APIs (که در فصل ۲۴ توضیح داده می‌شوند) بسیار کاربردی است.</p>
<h3>🟢 Ref Locals</h3>
<p>یکی از ویژگی‌های کمتر شناخته‌شده‌ی #C (اضافه شده از نسخه‌ی 7) امکان استفاده از متغیرهای محلی ارجاعی (ref locals) و بازگشت ارجاعی (ref returns) است. این قابلیت‌ها بیشتر برای بهینه‌سازی‌های خاص (micro-optimizations) استفاده می‌شوند.</p>
<p>یک ref local متغیری است که به یک عنصر آرایه، فیلد یا متغیر محلی دیگر اشاره می‌کند.</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] numbers = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> };

<span class="hljs-comment">// numRef یک اشاره‌گر به عنصر سوم آرایه است</span>
<span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> numRef = <span class="hljs-keyword">ref</span> numbers[<span class="hljs-number">2</span>];

numRef *= <span class="hljs-number">10</span>;

Console.WriteLine(numRef);      <span class="hljs-comment">// 20</span>
Console.WriteLine(numbers[<span class="hljs-number">2</span>]);  <span class="hljs-comment">// 20</span>
</code></pre>
<p>✔ تغییر numRef باعث تغییر مستقیم روی numbers[2] شد.<br>
❌ توجه: هدف یک ref local نمی‌تواند یک property باشد (به خاطر اینکه property در واقع یک متد است، نه یک متغیر ذخیره‌شده).</p>
<h3>🟢 Ref Returns</h3>
<p>گاهی می‌خواهیم متدی یک ارجاع به یک متغیر یا فیلد برگرداند، نه یک کپی از مقدار آن. این کار با ref return انجام می‌شود.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> x = <span class="hljs-string">&quot;Old Value&quot;</span>;

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetX</span>()</span> =&gt; <span class="hljs-keyword">ref</span> x;   <span class="hljs-comment">// متد یک ارجاع برمی‌گرداند</span>

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        <span class="hljs-keyword">ref</span> <span class="hljs-built_in">string</span> xRef = <span class="hljs-function"><span class="hljs-keyword">ref</span> <span class="hljs-title">GetX</span>()</span>;    <span class="hljs-comment">// نتیجه را در یک ref local می‌گیریم</span>
        xRef = <span class="hljs-string">&quot;New Value&quot;</span>;
        
        Console.WriteLine(x);  <span class="hljs-comment">// خروجی: New Value</span>
    }
}
</code></pre>
<p>🔹 اگر ref در سمت گیرنده استفاده نشود، یک کپی معمولی از مقدار برگردانده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> localX = GetX();  <span class="hljs-comment">// localX فقط یک مقدار معمولی است</span>
</code></pre>
<p><strong>🟢 Ref Properties و Ref Indexers</strong></p>
<p>می‌توانیم یک property یا indexer را به‌صورت ref تعریف کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> <span class="hljs-built_in">string</span> Prop =&gt; <span class="hljs-keyword">ref</span> x;

Prop = <span class="hljs-string">&quot;New Value&quot;</span>;   <span class="hljs-comment">// مجاز است، حتی بدون set accessor!</span>
</code></pre>
<p>اما اگر بخواهیم تغییر مقدار جلوگیری شود، می‌توانیم از ref readonly استفاده کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> Prop =&gt; <span class="hljs-keyword">ref</span> x;
</code></pre>
<p>✔ این کار اجازه‌ی خواندن مستقیم بدون کپی‌برداری می‌دهد، اما جلوی تغییر مقدار را می‌گیرد.</p>
<p><strong>⚡ نکته‌ی مهم درباره‌ی Performance</strong></p>
<ul>
<li>
<p>در نوع‌های مرجع (مثل string)، سود زیادی از ref returns به‌دست نمی‌آید، چون فقط یک آدرس (۳۲ یا ۶۴ بیتی) کپی می‌شود.</p>
</li>
<li>
<p>اما در نوع‌های مقداری (structs)، به‌ویژه اگر بزرگ باشند و به‌صورت readonly struct تعریف شوند، استفاده از ref می‌تواند جلوی کپی‌های پرهزینه را بگیرد.</p>
</li>
</ul>
<p>❌ تعریف یک set accessor صریح روی property یا indexer که ref return دارد، غیرقانونی است.</p>
<h4>متغیرهای ضمنی (Implicitly Typed Locals) با var</h4>
<p>اغلب پیش می‌آید که متغیری را همزمان با تعریف، مقداردهی اولیه کنیم. اگر کامپایلر بتواند نوع متغیر را از روی عبارت مقداردهی تشخیص دهد، می‌توانیم به‌جای نام نوع، از کلمه کلیدی var استفاده کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;hello&quot;</span>;
<span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> System.Text.StringBuilder();
<span class="hljs-keyword">var</span> z = (<span class="hljs-built_in">float</span>)Math.PI;
</code></pre>
<p>این دقیقاً معادل کد زیر است:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> x = <span class="hljs-string">&quot;hello&quot;</span>;
System.Text.StringBuilder y = <span class="hljs-keyword">new</span> System.Text.StringBuilder();
<span class="hljs-built_in">float</span> z = (<span class="hljs-built_in">float</span>)Math.PI;
</code></pre>
<p>✅ به همین دلیل، متغیرهای ضمنی همچنان استاتیک تایپ (دارای نوع مشخص در زمان کامپایل) هستند.</p>
<p>مثال خطا:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;       <span class="hljs-comment">// نوع x، int است</span>
x = <span class="hljs-string">&quot;hello&quot;</span>;     <span class="hljs-comment">// ❌ خطا در زمان کامپایل</span>
</code></pre>
<p><strong>⚠️ نکته درباره‌ی خوانایی کد</strong></p>
<p>استفاده از var گاهی باعث می‌شود خوانایی کد پایین بیاید، به‌خصوص وقتی نوع متغیر از روی عبارت مقداردهی مشخص نیست:</p>
<pre class="hljs"><code>Random r = <span class="hljs-keyword">new</span> Random();
<span class="hljs-keyword">var</span> x = r.Next();   <span class="hljs-comment">// 🤔 نوع x چیست؟ (int)</span>
</code></pre>
<p>📌 در بعضی موارد مثل Anonymous Types (صفحه 220 کتاب)، استفاده از var اجباری است.</p>
<h4>عبارات new با نوع هدف (Target-Typed new Expressions) در #C 9</h4>
<p>ویژگی دیگری که برای کم کردن تکرار نوع معرفی شد، Target-Typed new Expressions است.</p>
<pre class="hljs"><code>System.Text.StringBuilder sb1 = <span class="hljs-keyword">new</span>();
System.Text.StringBuilder sb2 = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;Test&quot;</span>);
</code></pre>
<p>این دقیقاً معادل است با:</p>
<pre class="hljs"><code>System.Text.StringBuilder sb1 = <span class="hljs-keyword">new</span> System.Text.StringBuilder();
System.Text.StringBuilder sb2 = <span class="hljs-keyword">new</span> System.Text.StringBuilder(<span class="hljs-string">&quot;Test&quot;</span>);
</code></pre>
<p>اصل موضوع این است که اگر کامپایلر بتواند نوع شیء را بدون ابهام از روی زمینه (context) تشخیص دهد، دیگر نیاز نیست نوع را دوباره در سمت راست بنویسیم.</p>
<p><strong>📌 کاربردهای مهم Target-Typed new</strong></p>
<ol>
<li>مقداردهی فیلدها در سازنده‌ها</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{
    System.Text.StringBuilder sb;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> initialValue</span>)</span>
    {
        sb = <span class="hljs-keyword">new</span>(initialValue);   <span class="hljs-comment">// نوع از روی فیلد sb مشخص است</span>
    }
}
</code></pre>
<ol start="2">
<li>ارسال مستقیم مقدار به متدها</li>
</ol>
<pre class="hljs"><code>MyMethod(<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;test&quot;</span>));

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params">System.Text.StringBuilder sb</span>)</span> { ... }
</code></pre>
<p>👉 به‌طور خلاصه:</p>
<ul>
<li>
<p>var → وقتی نوع از روی مقداردهی مشخص است، دیگر نیازی به نوشتن نام نوع ندارید.</p>
</li>
<li>
<p>target-typed new → وقتی کامپایلر نوع را از روی سمت چپ یا پارامتر متد می‌فهمد، دیگر نیاز نیست سمت راست بنویسید.</p>
</li>
</ul>
<h3>عبارت‌ها و عملگرها (Expressions and Operators)</h3>
<p>یک عبارت (expression) در اصل نشان‌دهنده‌ی یک مقدار است. ساده‌ترین نوع عبارت‌ها شامل ثابت‌ها (constants) و متغیرها (variables) هستند.<br>
عبارت‌ها می‌توانند با استفاده از عملگرها (operators) تغییر داده شده یا ترکیب شوند.</p>
<p>🔹 یک عملگر (operator) یک یا چند عملوند (operand) را گرفته و یک عبارت جدید خروجی می‌دهد.</p>
<p>برای نمونه، این یک عبارت ثابت (constant expression) است:</p>
<pre class="hljs"><code>12
</code></pre>
<p>می‌توانیم از عملگر * برای ترکیب دو عملوند (یعنی دو مقدار ثابت 12 و 30) استفاده کنیم:</p>
<pre class="hljs"><code>12 * 30
</code></pre>
<p>همچنین می‌توانیم عبارت‌های پیچیده‌تر بسازیم؛ چون یک عملوند خودش می‌تواند یک عبارت باشد، مثل (12 * 30) در مثال زیر:</p>
<pre class="hljs"><code>1 + (12 * 30)
</code></pre>
<p>عملگرها در C# بر اساس تعداد عملوندها دسته‌بندی می‌شوند:</p>
<ul>
<li>
<p>یکانی (unary) → روی یک عملوند کار می‌کنند.</p>
</li>
<li>
<p>دوتایی (binary) → روی دو عملوند کار می‌کنند.</p>
</li>
<li>
<p>سه‌تایی (ternary) → روی سه عملوند کار می‌کنند.</p>
</li>
</ul>
<p>عملگرهای دوتایی همیشه از نشانه‌گذاری میانی (infix notation) استفاده می‌کنند؛ یعنی عملگر بین دو عملوند قرار می‌گیرد.</p>
<h4>عبارت‌های اصلی (Primary Expressions)</h4>
<p>عبارت‌های اصلی شامل عملگرهایی می‌شوند که جزو بخش‌های پایه‌ای زبان هستند.<br>
مثال:</p>
<pre class="hljs"><code>Math.Log(1)
</code></pre>
<p>این عبارت شامل دو عبارت اصلی است:</p>
<p>عملگر . که یک جستجوی عضو (member lookup) انجام می‌دهد.</p>
<p>عملگر () که یک فراخوانی متد (method call) انجام می‌دهد.</p>
<h4>عبارت‌های void</h4>
<p>یک عبارت void عبارتی است که هیچ مقداری ندارد؛ مثلاً:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-number">1</span>)
</code></pre>
<p>چون مقداری ندارد، نمی‌توان از آن به‌عنوان عملوند در عبارات پیچیده‌تر استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-number">1</span> + Console.WriteLine(<span class="hljs-number">1</span>)   <span class="hljs-comment">// خطای کامپایل</span>
</code></pre>
<h4>عبارت‌های انتسابی (Assignment Expressions)</h4>
<p>یک عبارت انتسابی با عملگر = نتیجه‌ی یک عبارت را به یک متغیر اختصاص می‌دهد. مثال:</p>
<pre class="hljs"><code>x = x * 5
</code></pre>
<p>🔹 عبارت انتسابی یک عبارت void نیست؛ بلکه مقدار آن همان چیزی است که اختصاص داده شده.<br>
پس می‌توان آن را درون یک عبارت دیگر به کار برد:</p>
<pre class="hljs"><code>y = 5 * (x = 2)   // مقداردهی همزمان به x و y
</code></pre>
<p>می‌توانید این سبک را برای مقداردهی همزمان چند متغیر استفاده کنید:</p>
<pre class="hljs"><code>a = b = c = d = 0
</code></pre>
<p>عملگرهای ترکیبی (Compound Assignment Operators)</p>
<p>این عملگرها میانبرهایی هستند که انتساب را با عملگر دیگری ترکیب می‌کنند:</p>
<pre class="hljs"><code>x *= <span class="hljs-number">2</span>    <span class="hljs-comment">// معادل x = x * 2</span>
x &lt;&lt;= <span class="hljs-number">1</span>   <span class="hljs-comment">// معادل x = x &lt;&lt; 1</span>
</code></pre>
<p>⚠️ یک استثنای ظریف اینجاست: برای eventها در C# عملگرهای += و -= رفتار خاصی دارند و در واقع به متدهای add و remove آن event نگاشت می‌شوند (فصل ۴ توضیح داده شده).</p>
<h4>تقدم و وابستگی عملگرها (Operator Precedence and Associativity)</h4>
<p>وقتی یک عبارت شامل چند عملگر باشد، ترتیب اجرای آن‌ها با دو قانون مشخص می‌شود:</p>
<p>تقدم (Precedence) → عملگرهایی با تقدم بالاتر زودتر اجرا می‌شوند.</p>
<p>وابستگی (Associativity) → اگر دو عملگر تقدم یکسانی داشته باشند، وابستگی تعیین می‌کند که از چپ به راست اجرا می‌شوند یا برعکس.</p>
<h5>تقدم (Precedence)</h5>
<p>مثال:</p>
<pre class="hljs"><code>1 + 2 * 3
</code></pre>
<p>اینجا عملگر * تقدم بیشتری دارد، پس ابتدا ضرب انجام می‌شود:</p>
<pre class="hljs"><code>1 + (2 * 3)
</code></pre>
<h4>وابستگی به چپ (Left-associative)</h4>
<p>بیشتر عملگرهای دوتایی (به‌جز =, =&gt;, و ??) چپ‌گرا هستند؛ یعنی از چپ به راست ارزیابی می‌شوند.</p>
<p>مثال:</p>
<pre class="hljs"><code>8 / 4 / 2
</code></pre>
<p>به این صورت اجرا می‌شود:</p>
<pre class="hljs"><code>(8 / 4) / 2   // نتیجه: 1
</code></pre>
<p>اما با پرانتز می‌توانید ترتیب واقعی اجرا را تغییر دهید:</p>
<pre class="hljs"><code>8 / (4 / 2)   // نتیجه: 4
</code></pre>
<h4>اپراتورهای راست‌همبند (Right-associative operators) ⚡</h4>
<p>در زبان #C، بعضی از اپراتورها به‌جای چپ‌همبندی، راست‌همبند هستند. یعنی وقتی چند بار پشت سر هم بیایند، از راست به چپ ارزیابی می‌شوند.</p>
<p>📌 این اپراتورها عبارت‌اند از:</p>
<ul>
<li>
<p>اپراتورهای انتساب (=, +=, -=, *=, …)</p>
</li>
<li>
<p>اپراتور lambda (=&gt;)</p>
</li>
<li>
<p>اپراتور null-coalescing (??)</p>
</li>
<li>
<p>اپراتور شرطی (?:)</p>
</li>
</ul>
<p>مثال: چندین انتساب</p>
<pre class="hljs"><code>x = y = 3;
</code></pre>
<p>✔️ ابتدا مقدار 3 به y نسبت داده می‌شود.<br>
✔️ سپس نتیجه‌ی همان عبارت (که 3 است) به x نسبت داده می‌شود.</p>
<p>به همین دلیل، این نوع کد به‌درستی کامپایل می‌شود.</p>
<p>جدول اپراتورها  🧮</p>
<p>کتاب در ادامه یک جدول (Table 2-3) ارائه می‌دهد که تمام اپراتورهای C# را به‌ترتیب اولویت (precedence) نشان می‌دهد.</p>
<ul>
<li>
<p>اپراتورهایی که در یک دسته قرار می‌گیرند، اولویت یکسان دارند.</p>
</li>
<li>
<p>ترتیب دسته‌ها مشخص می‌کند کدام عملگرها زودتر اجرا می‌شوند.</p>
</li>
</ul>
<p>📖 نکته: در فصل “Operator Overloading” (صفحه 256) توضیح داده شده که کدام اپراتورها را می‌توان برای کلاس‌ها و ساختارهای خودتان بازتعریف (overload) کنید.</p>
<p>Table 2-3. C# operators (categories in order of precedence)</p>
<div align="center">
<p><img src="../../../assets/image/02/Table-2-9.jpeg" alt="Conventions-UsedThis-Book"> <br></p>
</div>
<h3>اپراتورهای null  🟰</h3>
<p>زبان #C سه اپراتور پرکاربرد برای راحت‌تر کار کردن با مقادیر null دارد:</p>
<ol>
<li>
<p>اپراتور ادغام با null (??)</p>
</li>
<li>
<p>اپراتور انتساب ادغام با null (??=)</p>
</li>
<li>
<p>اپراتور شرطی null (Elvis) (?.)</p>
</li>
</ol>
<h4>اپراتور Null-Coalescing (??)</h4>
<p>این اپراتور می‌گوید:<br>
👉 «اگر مقدار سمت چپ null نبود، همان را بده؛ در غیر این صورت مقدار سمت راست را بده.»</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s1 = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">string</span> s2 = s1 ?? <span class="hljs-string">&quot;nothing&quot;</span>;   <span class="hljs-comment">// s2 برابر می‌شود با &quot;nothing&quot;</span>
</code></pre>
<p>📌 نکته: اگر سمت چپ غیر null باشد، سمت راست اصلاً اجرا نمی‌شود.</p>
<p>این اپراتور همچنین با انواع Nullable هم کار می‌کند (توضیح کامل در فصل &quot;Nullable Value Types&quot;).</p>
<h4>اپراتور Null-Coalescing Assignment (??=)</h4>
<p>(اضافه شده در C# 8)</p>
<p>این اپراتور می‌گوید:<br>
👉 «اگر مقدار سمت چپ null بود، مقدار سمت راست را به آن انتساب بده.»</p>
<p>مثال:</p>
<pre class="hljs"><code>myVariable ??= someDefault;
</code></pre>
<p>معادل است با:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (myVariable == <span class="hljs-literal">null</span>) 
    myVariable = someDefault;
</code></pre>
<p>📌 این اپراتور مخصوصاً در پیاده‌سازی ویژگی‌های محاسبه‌ای تنبل (lazy evaluation) خیلی کاربردی است.</p>
<h4>اپراتور Null-Conditional (Elvis) (?.)</h4>
<p>این اپراتور (به خاطر شباهت به شکلک Elvis ?.) به شما اجازه می‌دهد مثل اپراتور نقطه (.) به اعضای یک شیء دسترسی پیدا کنید،<br>
اما اگر شیء سمت چپ null باشد، به جای پرتاب خطای NullReferenceException، مقدار کل عبارت null می‌شود.</p>
<p>مثال:</p>
<pre class="hljs"><code>System.Text.StringBuilder sb = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">string</span> s = sb?.ToString();   <span class="hljs-comment">// خطایی نمی‌دهد، s برابر null می‌شود</span>
</code></pre>
<p>این معادل است با:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = (sb == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : sb.ToString());
</code></pre>
<p>📌 استفاده با ایندکسرها:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span>[] words = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">string</span> word = words?[<span class="hljs-number">1</span>];   <span class="hljs-comment">// word برابر null می‌شود</span>
</code></pre>
<p>📌 کوتاه‌سازی (short-circuiting):</p>
<pre class="hljs"><code>System.Text.StringBuilder sb = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">string</span> s = sb?.ToString().ToUpper();   <span class="hljs-comment">// باز هم s برابر null می‌شود، بدون خطا</span>
</code></pre>
<p>🔹 تکرار Elvis فقط زمانی لازم است که هر بخش ممکن است null باشد:</p>
<pre class="hljs"><code>x?.y?.z
</code></pre>
<p>معادل است با:</p>
<pre class="hljs"><code>x == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> 
          : (x.y == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : x.y.z)
</code></pre>
<p><strong>⚠️ خطا در استفاده با نوع غیرnullable</strong></p>
<pre class="hljs"><code>System.Text.StringBuilder sb = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">int</span> length = sb?.ToString().Length;   <span class="hljs-comment">// ❌ خطا: int نمی‌تواند null باشد</span>
</code></pre>
<p>✅ راه‌حل: استفاده از Nullable</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>? length = sb?.ToString().Length;  <span class="hljs-comment">// درست: int? می‌تواند null باشد</span>
</code></pre>
<p>📌 استفاده برای متدهای void</p>
<pre class="hljs"><code>someObject?.SomeVoidMethod();
</code></pre>
<p>اگر someObject مقدار null داشته باشد، این دستور هیچ کاری نمی‌کند (no-op).</p>
<p><strong>🌀 ترکیب با اپراتور Null-Coalescing</strong></p>
<p>خیلی وقت‌ها ترکیب این دو اپراتور کاربردی است:</p>
<pre class="hljs"><code>System.Text.StringBuilder sb = <span class="hljs-literal">null</span>;
<span class="hljs-built_in">string</span> s = sb?.ToString() ?? <span class="hljs-string">&quot;nothing&quot;</span>;   <span class="hljs-comment">// s می‌شود &quot;nothing&quot;</span>
</code></pre>
<h3>جملات (Statements)</h3>
<p>توابع (Functions) از جملات (statements) تشکیل می‌شوند که به ترتیب متنی که ظاهر شده‌اند، اجرا می‌شوند.<br>
یک بلوک جمله (statement block) مجموعه‌ای از جملات است که بین آکولادها ({}) نوشته می‌شوند.</p>
<h4>جملات اعلان (Declaration Statements)</h4>
<p>یک اعلان متغیر (variable declaration) یک متغیر جدید معرفی می‌کند و در صورت نیاز می‌تواند آن را با یک عبارت مقداردهی اولیه کند.<br>
شما می‌توانید چند متغیر از یک نوع را در یک لیست جداشده با ویرگول اعلان کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> someWord = <span class="hljs-string">&quot;rosebud&quot;</span>;
<span class="hljs-built_in">int</span> someNumber = <span class="hljs-number">42</span>;
<span class="hljs-built_in">bool</span> rich = <span class="hljs-literal">true</span>, famous = <span class="hljs-literal">false</span>;
</code></pre>
<p>یک اعلان ثابت (constant declaration) شبیه به اعلان متغیر است، با این تفاوت که پس از تعریف دیگر قابل تغییر نیست و مقداردهی اولیه باید همان موقع اعلام صورت بگیرد (به بخش «ثابت‌ها (Constants)» در صفحه 104 مراجعه کنید):</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> c = <span class="hljs-number">2.99792458E08</span>;
c += <span class="hljs-number">10</span>;   <span class="hljs-comment">// خطای زمان کامپایل</span>
</code></pre>
<h5>متغیرهای محلی (Local variables)</h5>
<p>دامنه (scope) یک متغیر یا ثابت محلی در کل بلوک جاری برقرار است.<br>
شما نمی‌توانید متغیر دیگری با همان نام در همان بلوک یا بلوک‌های تو در تو اعلان کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x;
{
    <span class="hljs-built_in">int</span> y;
    <span class="hljs-built_in">int</span> x;   <span class="hljs-comment">// خطا - x قبلاً تعریف شده</span>
}
{
    <span class="hljs-built_in">int</span> y;   <span class="hljs-comment">// مجاز - y در اینجا در دامنه نیست</span>
}
Console.Write(y);  <span class="hljs-comment">// خطا - y خارج از دامنه است</span>
</code></pre>
<p>دامنه‌ی یک متغیر در هر دو جهت در سراسر بلوک کدی‌اش گسترش دارد.<br>
این یعنی اگر در مثال بالا اعلان x را به پایین متد منتقل کنیم، باز همان خطا را خواهیم گرفت.<br>
این موضوع در تضاد با زبان ++C است و کمی عجیب به نظر می‌رسد، چون شما نمی‌توانید قبل از تعریف یک متغیر یا ثابت به آن ارجاع دهید.</p>
<h4>جملات عبارت (Expression Statements)</h4>
<p>جملات عبارت، عبارت‌هایی هستند که به‌عنوان جمله نیز معتبر هستند.<br>
یک جمله‌ی عبارت باید یا وضعیت (state) را تغییر دهد یا چیزی را فراخوانی کند که ممکن است وضعیت را تغییر دهد.</p>
<p>منظور از تغییر وضعیت همان تغییر دادن مقدار یک متغیر است.</p>
<p>انواع جملات عبارت عبارت‌اند از:</p>
<ul>
<li>
<p>عبارت‌های انتساب (assignment expressions) → شامل افزایش (++) و کاهش (--)</p>
</li>
<li>
<p>عبارت‌های فراخوانی متد (method call expressions) → چه متدهای void و چه غیر void</p>
</li>
<li>
<p>عبارت‌های نمونه‌سازی شیء (object instantiation expressions)</p>
</li>
</ul>
<p>مثال‌ها</p>
<pre class="hljs"><code><span class="hljs-comment">// جملات اعلان:</span>
<span class="hljs-built_in">string</span> s;
<span class="hljs-built_in">int</span> x, y;
System.Text.StringBuilder sb;

<span class="hljs-comment">// جملات عبارت:</span>
x = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;                 <span class="hljs-comment">// عبارت انتساب</span>
x++;                       <span class="hljs-comment">// عبارت افزایش</span>
y = Math.Max(x, <span class="hljs-number">5</span>);        <span class="hljs-comment">// عبارت انتساب</span>
Console.WriteLine(y);      <span class="hljs-comment">// عبارت فراخوانی متد</span>
sb = <span class="hljs-keyword">new</span> StringBuilder();  <span class="hljs-comment">// عبارت انتساب</span>
<span class="hljs-keyword">new</span> StringBuilder();       <span class="hljs-comment">// عبارت نمونه‌سازی شیء</span>
</code></pre>
<p>وقتی یک سازنده (constructor) یا متدی که مقداری برمی‌گرداند را فراخوانی می‌کنید، الزامی نیست از نتیجه‌ی آن استفاده کنید.<br>
اما اگر سازنده یا متد هیچ تغییری در وضعیت ایجاد نکند، جمله‌ی حاصل کاملاً بی‌فایده خواهد بود:</p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> StringBuilder();     <span class="hljs-comment">// مجاز، اما بی‌فایده</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>);      <span class="hljs-comment">// مجاز، اما بی‌فایده</span>
x.Equals(y);             <span class="hljs-comment">// مجاز، اما بی‌فایده</span>
</code></pre>
<h4>جملات انتخابی (Selection Statements)</h4>
<p>زبان C# مکانیزم‌های مختلفی برای کنترل شرطی جریان اجرای برنامه دارد:</p>
<ul>
<li>
<p>جملات انتخابی (if, switch)</p>
</li>
<li>
<p>عملگر شرطی (?:)</p>
</li>
<li>
<p>جملات حلقه (while, do-while, for, foreach)</p>
</li>
</ul>
<p>در این بخش، دو ساختار ساده‌تر یعنی دستور if و دستور switch توضیح داده می‌شوند.</p>
<p><strong>دستور if</strong></p>
<p>یک دستور if یک جمله را فقط در صورتی اجرا می‌کند که یک عبارت بولی (bool) مقدار true داشته باشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> &lt; <span class="hljs-number">2</span> * <span class="hljs-number">3</span>)
    Console.WriteLine(<span class="hljs-string">&quot;true&quot;</span>);   <span class="hljs-comment">// true</span>
</code></pre>
<p>جمله می‌تواند یک بلوک کدی هم باشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> &lt; <span class="hljs-number">2</span> * <span class="hljs-number">3</span>)
{
    Console.WriteLine(<span class="hljs-string">&quot;true&quot;</span>);
    Console.WriteLine(<span class="hljs-string">&quot;Let’s move on!&quot;</span>);
}
</code></pre>
<p><strong>بخش else</strong></p>
<p>یک دستور if می‌تواند به صورت اختیاری دارای بخش else هم باشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">5</span>)
    Console.WriteLine(<span class="hljs-string">&quot;Does not compute&quot;</span>);
<span class="hljs-keyword">else</span>
    Console.WriteLine(<span class="hljs-string">&quot;False&quot;</span>);   <span class="hljs-comment">// False</span>
</code></pre>
<p>داخل بخش else می‌توان یک دستور if دیگر قرار داد:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">5</span>)
    Console.WriteLine(<span class="hljs-string">&quot;Does not compute&quot;</span>);
<span class="hljs-keyword">else</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">4</span>)
        Console.WriteLine(<span class="hljs-string">&quot;Computes&quot;</span>);   <span class="hljs-comment">// Computes</span>
</code></pre>
<h4>تغییر جریان اجرا با آکولادها (Braces)</h4>
<p>بخش else همیشه به نزدیک‌ترین دستور if قبل از خودش تعلق دارد:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>)
        Console.WriteLine();
    <span class="hljs-keyword">else</span>
        Console.WriteLine(<span class="hljs-string">&quot;executes&quot;</span>);
</code></pre>
<p>این دقیقاً معادل است با:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>)
        Console.WriteLine();
    <span class="hljs-keyword">else</span>
        Console.WriteLine(<span class="hljs-string">&quot;executes&quot;</span>);
}
</code></pre>
<p>اما اگر جای آکولادها را تغییر دهیم، جریان اجرا عوض می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>)
{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>)
        Console.WriteLine();
}
<span class="hljs-keyword">else</span>
    Console.WriteLine(<span class="hljs-string">&quot;does not execute&quot;</span>);
</code></pre>
<p><strong>چرا آکولادها مهم هستند؟</strong></p>
<p>استفاده از آکولادها باعث می‌شود قصد شما شفاف‌تر شود و خوانایی کد در ساختارهای تو در تو بهتر گردد—even اگر کامپایلر به آنها نیازی نداشته باشد.</p>
<p>یک استثنای مهم الگوی زیر است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TellMeWhatICanDo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age</span>)</span>
{
    <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">35</span>)
        Console.WriteLine(<span class="hljs-string">&quot;You can be president!&quot;</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">21</span>)
        Console.WriteLine(<span class="hljs-string">&quot;You can drink!&quot;</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>)
        Console.WriteLine(<span class="hljs-string">&quot;You can vote!&quot;</span>);
    <span class="hljs-keyword">else</span>
        Console.WriteLine(<span class="hljs-string">&quot;You can wait!&quot;</span>);
}
</code></pre>
<p>اینجا دستورهای if و else طوری پشت سر هم قرار گرفته‌اند که شبیه به دستور elseif در زبان‌های دیگر باشد (یا مثل دستور پیش‌پردازنده #elif در C#).<br>
ویژوال استودیو این الگو را تشخیص می‌دهد و فرمت‌بندی خودکارش را مطابق همین حالت حفظ می‌کند.<br>
با این حال، از نظر معنایی هر دستور if بعد از یک else در واقع داخل بخش else قبلی تو در تو است.</p>
<h4>دستور switch</h4>
<p>دستورهای switch به شما اجازه می‌دهند جریان اجرای برنامه را بر اساس مجموعه‌ای از مقادیر ممکن که یک متغیر می‌تواند داشته باشد، شاخه‌بندی کنید.<br>
کدهایی که از switch استفاده می‌کنند معمولاً خواناتر و تمیزتر از استفاده از چندین دستور if پشت سر هم هستند، چون عبارت فقط یک بار ارزیابی می‌شود.</p>
<p>مثال ساده</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowCard</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> cardNumber</span>)</span>
{
    <span class="hljs-keyword">switch</span> (cardNumber)
    {
        <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:
            Console.WriteLine(<span class="hljs-string">&quot;King&quot;</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:
            Console.WriteLine(<span class="hljs-string">&quot;Queen&quot;</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:
            Console.WriteLine(<span class="hljs-string">&quot;Jack&quot;</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:                       <span class="hljs-comment">// کارت Joker معادل -1</span>
            <span class="hljs-keyword">goto</span> <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>;              <span class="hljs-comment">// در این بازی Joker معادل Queen حساب می‌شود</span>
        <span class="hljs-literal">default</span>:                       <span class="hljs-comment">// اجرا می‌شود برای هر مقدار دیگری</span>
            Console.WriteLine(cardNumber);
            <span class="hljs-keyword">break</span>;
    }
}
</code></pre>
<p>🔹 در این مثال، از رایج‌ترین حالت استفاده شده است: سوئیچ روی مقادیر ثابت.<br>
وقتی یک مقدار ثابت (constant) مشخص می‌کنید، نوع آن باید یکی از موارد زیر باشد:</p>
<ul>
<li>
<p>انواع عددی داخلی (int, byte, long, …)</p>
</li>
<li>
<p>bool</p>
</li>
<li>
<p>char</p>
</li>
<li>
<p>string</p>
</li>
<li>
<p>enum</p>
</li>
</ul>
<p><strong>پایان هر case</strong></p>
<p>در انتهای هر بخش case باید صراحتاً مشخص کنید که اجرای برنامه به کجا برود (مگر اینکه کد شما به حلقه بی‌نهایت ختم شود).<br>
گزینه‌ها عبارت‌اند از:</p>
<ul>
<li>
<p>break → پرش به انتهای دستور switch</p>
</li>
<li>
<p>goto case x → پرش به بخش یک case دیگر</p>
</li>
<li>
<p>goto default → پرش به بخش default</p>
</li>
<li>
<p>سایر دستورات پرش مثل: return، throw، continue یا goto label</p>
</li>
</ul>
<p><strong>اجرای یک کد مشترک برای چند مقدار</strong></p>
<p>اگر بیش از یک مقدار باید همان کد را اجرا کند، می‌توانید آنها را پشت سر هم بنویسید:</p>
<pre class="hljs"><code><span class="hljs-keyword">switch</span> (cardNumber)
{
    <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:
        Console.WriteLine(<span class="hljs-string">&quot;Face card&quot;</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-literal">default</span>:
        Console.WriteLine(<span class="hljs-string">&quot;Plain card&quot;</span>);
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>در اینجا برای مقادیر 13، 12 و 11 همان کد مشترک اجرا می‌شود.</p>
<p>✅ این قابلیت یکی از ویژگی‌های مهم دستور switch است که باعث می‌شود کد شما خیلی خواناتر و تمیزتر از چندین if-else پشت سر هم باشد.</p>
<h4>سوئیچ روی نوع داده (Switching on Types)</h4>
<p>سوئیچ روی نوع داده یک حالت خاص از سوئیچ روی الگو (pattern matching) است.<br>
از نسخه‌های جدیدتر C#، الگوهای بیشتری معرفی شده‌اند (برای توضیح کامل به بخش Patterns در صفحه 238 مراجعه کنید).</p>
<p>مثال: سوئیچ روی نوع داده</p>
<pre class="hljs"><code>TellMeTheType(<span class="hljs-number">12</span>);
TellMeTheType(<span class="hljs-string">&quot;hello&quot;</span>);
TellMeTheType(<span class="hljs-literal">true</span>);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TellMeTheType</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> x</span>)   <span class="hljs-comment">// object می‌تواند هر نوع داده‌ای را بپذیرد</span></span>
{
    <span class="hljs-keyword">switch</span> (x)
    {
        <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i:
            Console.WriteLine(<span class="hljs-string">&quot;It&#x27;s an int!&quot;</span>);
            Console.WriteLine(<span class="hljs-string">$&quot;The square of <span class="hljs-subst">{i}</span> is <span class="hljs-subst">{i * i}</span>&quot;</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-built_in">string</span> s:
            Console.WriteLine(<span class="hljs-string">&quot;It&#x27;s a string&quot;</span>);
            Console.WriteLine(<span class="hljs-string">$&quot;The length of <span class="hljs-subst">{s}</span> is <span class="hljs-subst">{s.Length}</span>&quot;</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> DateTime:
            Console.WriteLine(<span class="hljs-string">&quot;It&#x27;s a DateTime&quot;</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-literal">default</span>:
            Console.WriteLine(<span class="hljs-string">&quot;I don&#x27;t know what x is&quot;</span>);
            <span class="hljs-keyword">break</span>;
    }
}
</code></pre>
<p>🔹 نوع object این امکان را می‌دهد که پارامتر هر نوع داده‌ای را بپذیرد.<br>
(این موضوع در بخش‌های Inheritance صفحه 126 و The object Type صفحه 138 توضیح داده می‌شود.)</p>
<p>در هر بخش case:</p>
<ul>
<li>
<p>یک نوع داده مشخص می‌کنید.</p>
</li>
<li>
<p>اگر تطبیق برقرار شود، مقدار متغیر به یک متغیر الگو (pattern variable) اختصاص داده می‌شود.</p>
</li>
</ul>
<p>برخلاف مقادیر ثابت، اینجا هیچ محدودیتی برای نوع داده وجود ندارد.</p>
<p><strong>شرط‌گذاری روی case با when</strong></p>
<p>می‌توانید یک شرط اضافه کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">switch</span> (x)
{
    <span class="hljs-keyword">case</span> <span class="hljs-built_in">bool</span> b <span class="hljs-keyword">when</span> b == <span class="hljs-literal">true</span>:
        Console.WriteLine(<span class="hljs-string">&quot;True!&quot;</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-built_in">bool</span> b:
        Console.WriteLine(<span class="hljs-string">&quot;False!&quot;</span>);
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>🔸 توجه: ترتیب caseها در سوئیچ روی نوع اهمیت دارد (برخلاف ثابت‌ها).<br>
اگر ترتیب را برعکس کنید، کد حتی کامپایل نمی‌شود چون بخش دوم غیرقابل دسترسی (unreachable) خواهد شد.<br>
استثنا: بخش default که همیشه در آخر اجرا می‌شود (مهم نیست کجا نوشته شده باشد).</p>
<p><strong>چندین case روی هم (Stacking Cases)</strong></p>
<p>می‌توانید چند نوع داده را پشت سر هم قرار دهید تا یک کد مشترک اجرا شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">switch</span> (x)
{
    <span class="hljs-keyword">case</span> <span class="hljs-built_in">float</span> f <span class="hljs-keyword">when</span> f &gt; <span class="hljs-number">1000</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-built_in">double</span> d <span class="hljs-keyword">when</span> d &gt; <span class="hljs-number">1000</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-built_in">decimal</span> m <span class="hljs-keyword">when</span> m &gt; <span class="hljs-number">1000</span>:
        Console.WriteLine(<span class="hljs-string">&quot;We can refer to x here but not f or d or m&quot;</span>);
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>🔹 در اینجا متغیرهای f، d و m فقط داخل شرط‌های when در دسترس هستند.<br>
وقتی به Console.WriteLine می‌رسیم، چون معلوم نیست کدام یک از این متغیرها مقدار گرفته، همه آنها خارج از محدوده (out of scope) محسوب می‌شوند.</p>
<p><strong>ترکیب ثابت‌ها و الگوها</strong></p>
<p>شما می‌توانید مقادیر ثابت و الگوها (patterns) را در یک دستور switch ترکیب کنید.<br>
همچنین می‌توانید روی مقدار null هم سوئیچ کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">case</span> <span class="hljs-literal">null</span>:
    Console.WriteLine(<span class="hljs-string">&quot;Nothing here&quot;</span>);
    <span class="hljs-keyword">break</span>;
</code></pre>
<p>✅ پس در نسخه‌های جدید C#، switch فقط محدود به مقادیر ثابت نیست،<br>
بلکه می‌تواند بر اساس نوع داده، مقدار null، یا حتی الگوهای پیچیده‌تر تصمیم بگیرد.</p>
<h4>عبارت‌های Switch (Switch Expressions)</h4>
<p>از C# 8 به بعد، می‌توان از switch در قالب یک عبارت (expression) هم استفاده کرد.<br>
برخلاف حالت عادی که switch یک بلوک دستور (statement block) است، اینجا مقدار بازمی‌گرداند و می‌تواند مستقیماً در انتساب‌ها یا پرس‌وجوهای LINQ به‌کار برود.</p>
<p><strong>مثال ساده</strong></p>
<p>فرض کنید متغیر cardNumber از نوع int است:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> cardName = cardNumber <span class="hljs-keyword">switch</span>
{
    <span class="hljs-number">13</span> =&gt; <span class="hljs-string">&quot;King&quot;</span>,
    <span class="hljs-number">12</span> =&gt; <span class="hljs-string">&quot;Queen&quot;</span>,
    <span class="hljs-number">11</span> =&gt; <span class="hljs-string">&quot;Jack&quot;</span>,
    _  =&gt; <span class="hljs-string">&quot;Pip card&quot;</span>   <span class="hljs-comment">// معادل &#x27;default&#x27;</span>
};
</code></pre>
<p>🔹 نکات مهم:</p>
<ul>
<li>
<p>کلمه کلیدی switch بعد از نام متغیر می‌آید.</p>
</li>
<li>
<p>هر بخش case در قالب یک عبارت نوشته می‌شود و با کاما جدا می‌شود (نه break;).</p>
</li>
<li>
<p>بخش _ نقش default را دارد.</p>
</li>
<li>
<p>اگر _ (یا هر حالت پیش‌فرض دیگری) حذف شود و تطبیق انجام نشود → یک استثنا (exception) پرتاب می‌شود.</p>
</li>
</ul>
<p><strong>مزایا</strong></p>
<ul>
<li>
<p>کوتاه‌تر و خواناتر از switch معمولی.</p>
</li>
<li>
<p>قابل استفاده در عبارت‌های LINQ و جاهایی که نیاز به یک مقدار بازگشتی دارید.</p>
</li>
</ul>
<p><strong>سوئیچ روی چند مقدار (Tuple Pattern)</strong></p>
<p>می‌توانید روی بیش از یک مقدار همزمان سوئیچ کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> cardNumber = <span class="hljs-number">12</span>;
<span class="hljs-built_in">string</span> suite = <span class="hljs-string">&quot;spades&quot;</span>;

<span class="hljs-built_in">string</span> cardName = (cardNumber, suite) <span class="hljs-keyword">switch</span>
{
    (<span class="hljs-number">13</span>, <span class="hljs-string">&quot;spades&quot;</span>) =&gt; <span class="hljs-string">&quot;King of spades&quot;</span>,
    (<span class="hljs-number">13</span>, <span class="hljs-string">&quot;clubs&quot;</span>)  =&gt; <span class="hljs-string">&quot;King of clubs&quot;</span>,
    (<span class="hljs-number">12</span>, <span class="hljs-string">&quot;spades&quot;</span>) =&gt; <span class="hljs-string">&quot;Queen of spades&quot;</span>,
    _              =&gt; <span class="hljs-string">&quot;Some other card&quot;</span>
};
</code></pre>
<p>🔹 در اینجا (cardNumber, suite) یک تاپل (tuple) است و هر case هم یک الگوی تاپل مشخص می‌کند.</p>
<p><strong>جمع‌بندی</strong></p>
<p>✅ Switch Expressions یک نسخه ساده‌تر و قدرتمندتر از switch هستند که:</p>
<ul>
<li>
<p>از C# 8 معرفی شدند.</p>
</li>
<li>
<p>می‌توانند روی یک مقدار یا چند مقدار (تاپل) عمل کنند.</p>
</li>
<li>
<p>به‌طور مستقیم مقدار بازمی‌گردانند.</p>
</li>
<li>
<p>از الگوها (patterns) پشتیبانی می‌کنند.</p>
</li>
</ul>
<h4>دستورهای تکرار (Iteration Statements)</h4>
<p>در زبان C#، می‌توان یک بلوک از دستورات را به‌طور تکراری اجرا کرد.<br>
این کار با استفاده از چهار نوع حلقه (loop) امکان‌پذیر است:</p>
<ul>
<li>
<p>while</p>
</li>
<li>
<p>do-while</p>
</li>
<li>
<p>for</p>
</li>
<li>
<p>foreach</p>
</li>
</ul>
<p><strong>🔹 حلقه while</strong></p>
<p>حلقه while یک بلوک کد را تا زمانی که شرط بولی برقرار باشد تکرار می‌کند.<br>
در این حالت، شرط قبل از اجرای بدنه بررسی می‌شود.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">3</span>)
{
    Console.Write(i);
    i++;
}
</code></pre>
<p>🔸 خروجی:</p>
<pre class="hljs"><code>012
</code></pre>
<p>✅ توضیح:</p>
<p>ابتدا مقدار i بررسی می‌شود.</p>
<p>تا زمانی که i &lt; 3 باشد، بدنه حلقه اجرا می‌شود.</p>
<p>در هر بار اجرا، i++ مقدار را یکی افزایش می‌دهد.</p>
<h5>حلقه do-while</h5>
<p>حلقه do-while تقریباً شبیه به while است، اما با یک تفاوت مهم:</p>
<p>شرط بعد از اجرای بدنه بررسی می‌شود.</p>
<p>بنابراین بدنه حداقل یک بار اجرا خواهد شد، حتی اگر شرط در ابتدا نادرست باشد.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">do</span>
{
    Console.WriteLine(i);
    i++;
}
<span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">3</span>);
</code></pre>
<p>🔸 خروجی:</p>
<pre class="hljs"><code>0
1
2
</code></pre>
<p>✅ تفاوت کلیدی:</p>
<ul>
<li>
<p>در while، اگر شرط از همان ابتدا نادرست باشد، هیچ‌وقت بدنه اجرا نمی‌شود.</p>
</li>
<li>
<p>در do-while، بدنه حداقل یک بار اجرا می‌شود، حتی اگر شرط از ابتدا نادرست باشد.</p>
</li>
</ul>
<h6>🔹 حلقه for</h6>
<p>حلقه for شبیه به while است، با این تفاوت که بخش‌های مقداردهی اولیه، شرط و به‌روزرسانی متغیر در یک خط قرار می‌گیرند.</p>
<p>ساختار کلی:</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (initialization-clause; condition-clause; iteration-clause)
    statement-<span class="hljs-keyword">or</span>-statement-block;
</code></pre>
<ul>
<li>
<p>initialization-clause → قبل از شروع حلقه اجرا می‌شود؛ معمولاً برای مقداردهی متغیر شمارنده.</p>
</li>
<li>
<p>condition-clause → یک عبارت بولی است که شرط ادامه‌ی حلقه را مشخص می‌کند.</p>
</li>
<li>
<p>iteration-clause → بعد از هر بار اجرای بدنه حلقه اجرا می‌شود؛ معمولاً برای به‌روزرسانی شمارنده.</p>
</li>
</ul>
<p>مثال ساده:</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
    Console.WriteLine(i);
</code></pre>
<p>🔸 خروجی:</p>
<p>0<br>
1<br>
2</p>
<p><strong>مثال محاسبه‌ی دنباله فیبوناچی (۱۰ عدد اول):</strong></p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, prevFib = <span class="hljs-number">1</span>, curFib = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++)
{
    Console.WriteLine(prevFib);
    <span class="hljs-built_in">int</span> newFib = prevFib + curFib;
    prevFib = curFib; 
    curFib = newFib;
}
</code></pre>
<p>🔸 خروجی:</p>
<pre class="hljs"><code>1
1
2
3
5
8
13
21
34
55
</code></pre>
<p><strong>حلقه‌ی بی‌نهایت با for</strong></p>
<p>در حلقه‌ی for، هر سه بخش (init, condition, iteration) می‌توانند حذف شوند.<br>
این باعث می‌شود یک حلقه بی‌نهایت ساخته شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (;;)
    Console.WriteLine(<span class="hljs-string">&quot;interrupt me&quot;</span>);
</code></pre>
<p>(مشابه با while (true))</p>
<h6>حلقه foreach</h6>
<p>حلقه‌ی foreach برای پیمایش روی عناصر یک شیء قابل شمارش (Enumerable) استفاده می‌شود.<br>
بسیاری از مجموعه‌ها در .NET مثل آرایه‌ها، لیست‌ها و حتی رشته‌ها (string) قابل شمارش هستند.</p>
<p>مثال پیمایش روی کاراکترهای یک رشته:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;beer&quot;</span>)   <span class="hljs-comment">// c متغیر تکرار است</span>
    Console.WriteLine(c);
</code></pre>
<p>🔸 خروجی:</p>
<pre class="hljs"><code>b
e
e
r
</code></pre>
<p>✅ نکته: foreach به شما کمک می‌کند بدون نیاز به شمارنده (i) روی عناصر مجموعه حرکت کنید.</p>
<h4>🚀 دستورات پرش (Jump Statements)</h4>
<p>در زبان C# چند دستور وجود دارد که باعث تغییر ناگهانی جریان اجرای برنامه می‌شوند. این‌ها به نام jump statements شناخته می‌شوند و شامل موارد زیر هستند:</p>
<ul>
<li>
<p>break</p>
</li>
<li>
<p>continue</p>
</li>
<li>
<p>goto</p>
</li>
<li>
<p>return</p>
</li>
<li>
<p>throw</p>
</li>
</ul>
<p><strong>⚖️ قوانین مهم پرش‌ها در کنار بلوک‌های try/finally</strong></p>
<p>اگر از داخل یک بلوک try پرش (jump) انجام شود، قبل از رسیدن به مقصد، بلوک finally همیشه اجرا می‌شود.</p>
<p>پرش از داخل finally به بیرون ممنوع است (مگر با استفاده از throw).</p>
<h5>دستور break</h5>
<p>🔸 break اجرای بدنه‌ی یک حلقه (for, while, do-while, foreach) یا یک switch را متوقف کرده و جریان برنامه را به اولین خط بعد از آن منتقل می‌کند.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
{
    <span class="hljs-keyword">if</span> (x++ &gt; <span class="hljs-number">5</span>)
        <span class="hljs-keyword">break</span>;   <span class="hljs-comment">// خروج از حلقه</span>
}
Console.WriteLine(<span class="hljs-string">&quot;بعد از break&quot;</span>);
</code></pre>
<p>📌 وقتی شرط برقرار شود، حلقه متوقف شده و اجرای برنامه از خط بعد از حلقه ادامه پیدا می‌کند.</p>
<h5>دستور continue</h5>
<p>🔸 continue باعث می‌شود اجرای باقی‌مانده‌ی کد در همان تکرار جاری از حلقه متوقف شود و بلافاصله به سراغ تکرار بعدی حلقه برود.</p>
<p>مثال: پرش از روی اعداد زوج</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
{
    <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>)   <span class="hljs-comment">// اگر عدد زوج بود</span>
        <span class="hljs-keyword">continue</span>;       <span class="hljs-comment">// برو سراغ تکرار بعدی</span>

    Console.Write(i + <span class="hljs-string">&quot; &quot;</span>);
}
</code></pre>
<p>🔸 خروجی:</p>
<pre class="hljs"><code>1 3 5 7 9
</code></pre>
<p>📌 اینجا همه‌ی اعداد زوج نادیده گرفته می‌شوند و فقط اعداد فرد چاپ می‌شوند.</p>
<h5>دستور goto</h5>
<p>🔸 دستور goto باعث می‌شود اجرای برنامه به یک برچسب (label) منتقل شود.</p>
<p>📌 فرمت کلی:</p>
<pre class="hljs"><code><span class="hljs-keyword">goto</span> statement-label;
</code></pre>
<p>یا در switch‎:</p>
<pre class="hljs"><code><span class="hljs-keyword">goto</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">case</span>-constant;   <span class="hljs-comment">// فقط برای مقادیر ثابت</span>
</code></pre>
<p>🔸 برچسب یک نام در بلوک کد است که با علامت : تعریف می‌شود.</p>
<p>مثال: شبیه‌سازی یک حلقه با goto</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;
startLoop:
<span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">5</span>)
{
    Console.Write(i + <span class="hljs-string">&quot; &quot;</span>);
    i++;
    <span class="hljs-keyword">goto</span> startLoop;   <span class="hljs-comment">// پرش به برچسب</span>
}
</code></pre>
<p>🔸 خروجی:</p>
<pre class="hljs"><code>1 2 3 4 5
</code></pre>
<p>📌 اینجا عملاً رفتاری مثل یک for ساخته‌ایم، ولی به روش قدیمی و کمتر خوانا.</p>
<p>⚠️ نکته: استفاده از goto معمولاً توصیه نمی‌شود چون باعث سخت‌خوانی کد می‌شود، مگر در شرایط خاص (مثل خروج از چند حلقه تو در تو یا پرش در switch).</p>
<h5>دستور return</h5>
<p>🔸 دستور return باعث می‌شود اجرای متد متوقف شده و کنترل به متدی که آن را صدا زده بازگردد.</p>
<p>اگر متد مقداری برنگرداند (void)، فقط return; کافی است.</p>
<p>اگر متد مقدار برمی‌گرداند (مثل int یا decimal)، باید مقدار مناسب برگردانده شود.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">decimal</span> <span class="hljs-title">AsPercentage</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> d</span>)</span>
{
    <span class="hljs-built_in">decimal</span> p = d * <span class="hljs-number">100</span>m;
    <span class="hljs-keyword">return</span> p;   <span class="hljs-comment">// بازگشت همراه با مقدار</span>
}
</code></pre>
<p>📌 این متد یک عدد را گرفته و درصد آن را برمی‌گرداند.</p>
<p>⚠️ return می‌تواند در هر جای متد نوشته شود (به‌جز داخل finally).</p>
<h5>دستور throw</h5>
<p>🔸 دستور throw برای پرتاب یک Exception (استثنا/خطا) استفاده می‌شود. این کار اجرای عادی برنامه را متوقف کرده و کنترل را به مکان مدیریت خطا (معمولاً یک بلوک try/catch) منتقل می‌کند.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (w == <span class="hljs-literal">null</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-string">&quot;w cannot be null&quot;</span>);
</code></pre>
<p>📌 اگر متغیر w مقدار null داشته باشد، یک استثنا پرتاب می‌شود تا به برنامه‌نویس یا کاربر اعلام کند خطایی رخ داده است.</p>
<h4>دستورات متفرقه ✨</h4>
<p>دستور using یک نحو (syntax) شیک و ساده برای فراخوانی متد Dispose روی اشیائی که رابط IDisposable را پیاده‌سازی کرده‌اند، درون یک بلوک finally فراهم می‌کند (بخش “try Statements and Exceptions” در صفحه 195 و “IDisposable, Dispose, and Close” در صفحه 581 را ببینید).</p>
<p>در زبان C#، کلمه‌ی کلیدی using بیش‌بارگذاری (overload) شده تا در زمینه‌های مختلف، معانی مستقلی داشته باشد. به طور مشخص، using directive با using statement متفاوت است.</p>
<p>دستور lock یک میان‌بر (shortcut) برای فراخوانی متدهای Enter و Exit از کلاس Monitor است (به فصل‌های 14 و 23 مراجعه کنید). 🔒</p>
<h3>فضای نام‌ها (Namespaces) 🗂️</h3>
<p>یک فضای نام (namespace) در واقع یک دامنه برای نام انواع (types) است. انواع معمولاً در قالب فضای نام‌های سلسله‌مراتبی (hierarchical) سازمان‌دهی می‌شوند تا پیدا کردن آن‌ها آسان‌تر باشد و از بروز تداخل جلوگیری شود.</p>
<p>برای نمونه، نوع (type) RSA که وظیفه‌ی مدیریت رمزنگاری کلید عمومی را بر عهده دارد، در فضای نام زیر تعریف شده است:</p>
<pre class="hljs"><code>System.Security.Cryptography
</code></pre>
<p>فضای نام، بخش جدایی‌ناپذیری از نام یک نوع به‌شمار می‌رود. کد زیر متد Create از نوع RSA را فراخوانی می‌کند:</p>
<pre class="hljs"><code>System.Security.Cryptography.RSA rsa =
    System.Security.Cryptography.RSA.Create();
</code></pre>
<p>فضاهای نام (namespaces) مستقل از assemblies هستند. اسمبلی‌ها همان فایل‌های .dll‌ای هستند که به عنوان واحدهای استقرار (deployment units) عمل می‌کنند (در فصل 17 توضیح داده شده است).<br>
همچنین، فضاهای نام هیچ تأثیری بر روی سطح دسترسی اعضا (مانند public، internal، private و غیره) ندارند.</p>
<p>کلمه‌ی کلیدی namespace یک فضای نام برای انواع درون یک بلوک تعریف می‌کند؛ برای مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">Outer.Middle.Inner</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> {}
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> {}
}
</code></pre>
<p>نقطه‌ها (.) در نام فضای نام نشان‌دهنده‌ی سلسله‌مراتبی از فضاهای نام تو‌در‌تو هستند. کدی که در ادامه می‌آید، از نظر معنایی دقیقاً معادل نمونه‌ی قبلی است:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">Outer</span>
{
    <span class="hljs-keyword">namespace</span> <span class="hljs-title">Middle</span>
    {
        <span class="hljs-keyword">namespace</span> <span class="hljs-title">Inner</span>
        {
            <span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> {}
            <span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> {}
        }
    }
}
</code></pre>
<p>شما می‌توانید به یک نوع با نام کاملش (fully qualified name) اشاره کنید؛ نامی که شامل همه‌ی فضاهای نام از بیرونی‌ترین تا درونی‌ترین است. به عنوان مثال، می‌توانیم به Class1 در نمونه‌ی قبلی به صورت زیر ارجاع دهیم:</p>
<pre class="hljs"><code>Outer.Middle.Inner.Class1
</code></pre>
<p>انواعی که در هیچ فضای نامی تعریف نشده‌اند، در فضای نام global قرار می‌گیرند. فضای نام global همچنین شامل فضای نام‌های سطح بالا (top-level namespaces) مانند Outer در مثال ما هم می‌شود. 🌍</p>
<h4>فضای نام با محدوده فایل (File-Scoped Namespaces) 📄</h4>
<p>اغلب اوقات، می‌خواهید همه‌ی انواع (types) در یک فایل، در یک فضای نام تعریف شوند:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyNamespace</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> {}
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> {}
}
</code></pre>
<p>از C# 10 به بعد، می‌توانید این کار را با استفاده از فضای نام با محدوده فایل (file-scoped namespace) انجام دهید:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyNamespace</span>;  <span class="hljs-comment">// برای همه چیز در ادامه فایل اعمال می‌شود</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> {}         <span class="hljs-comment">// داخل MyNamespace</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> {}         <span class="hljs-comment">// داخل MyNamespace</span>
</code></pre>
<p>استفاده از فضای نام با محدوده فایل باعث کاهش شلوغی کد و حذف یک سطح اضافی از تورفتگی (indentation) می‌شود. ✨</p>
<h4>دستور using 🧩</h4>
<p>دستور using یک فضای نام را وارد (import) می‌کند و به شما اجازه می‌دهد بدون استفاده از نام کامل (fully qualified name) به انواع آن فضای نام دسترسی داشته باشید.</p>
<p>مثال زیر فضای نام Outer.Middle.Inner که قبلاً تعریف شده بود را وارد می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> Outer.Middle.Inner;

Class1 c;  <span class="hljs-comment">// نیازی به نام کامل نیست</span>
</code></pre>
<p>قانوناً (و اغلب به صورت مطلوب) می‌توانید نام یک نوع را در فضای نام‌های مختلف دوباره تعریف کنید. اما معمولاً این کار تنها زمانی انجام می‌شود که احتمال کمی وجود داشته باشد که کسی بخواهد هر دو فضای نام را همزمان وارد کند.<br>
یک مثال خوب کلاس TextBox است که هم در System.Windows.Controls (WPF) و هم در System.Windows.Forms (Windows Forms) تعریف شده است.</p>
<p>همچنین، یک دستور using می‌تواند درون یک فضای نام دیگر قرار گیرد تا محدوده‌ی دسترسی آن محدود شود. 🛡️</p>
<h4>دستور global using 🌐</h4>
<p>از C# 10 به بعد، اگر یک دستور using را با کلمه‌ی کلیدی global پیشوند کنید، این دستور برای تمام فایل‌های پروژه یا واحد کامپایل اعمال می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">global</span> <span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">global</span> <span class="hljs-keyword">using</span> System.Collections.Generic;
</code></pre>
<p>این کار به شما اجازه می‌دهد تا واردات رایج (common imports) را متمرکز کنید و از تکرار همان دستورات در هر فایل جلوگیری کنید.<br>
توجه داشته باشید که دستورهای global using باید قبل از دستورهای معمولی (nonglobal) قرار بگیرند و نمی‌توانند داخل تعریف یک namespace بیایند. همچنین، می‌توان از global همراه با using static نیز استفاده کرد. ⚡</p>
<h5>واردات ضمنی global (Implicit global usings) 🔄</h5>
<p>از .NET 6، فایل‌های پروژه اجازه می‌دهند تا دستورهای global using به صورت ضمنی تعریف شوند. اگر عنصر ImplicitUsings در فایل پروژه روی true تنظیم شود (که برای پروژه‌های جدید پیش‌فرض است)، فضای نام‌های زیر به طور خودکار وارد می‌شوند:</p>
<pre class="hljs"><code>System

System.Collections.Generic

System.IO

System.Linq

System.Net.Http

System.Threading

System.Threading.Tasks
</code></pre>
<p>همچنین، بسته به نوع SDK پروژه (Web، Windows Forms، WPF و غیره)، فضای نام‌های اضافی نیز به طور خودکار وارد می‌شوند.</p>
<h4>دستور using static ⚙️</h4>
<p>دستور using static یک نوع (type) را وارد می‌کند، نه یک namespace. پس از آن، تمام اعضای static آن نوع بدون نیاز به نوشتن نام نوع، قابل استفاده هستند.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;

WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// نیازی به Console.WriteLine نیست</span>
</code></pre>
<p>دستور using static همه‌ی اعضای static قابل دسترسی نوع، شامل فیلدها، ویژگی‌ها (properties) و انواع تو در تو (nested types) را وارد می‌کند (فصل 3).<br>
همچنین می‌توان این دستور را روی enumها نیز اعمال کرد، که در این صورت اعضای آن‌ها وارد می‌شوند.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Windows.Visibility;

<span class="hljs-keyword">var</span> textBox = <span class="hljs-keyword">new</span> TextBox { Visibility = Hidden };  <span class="hljs-comment">// به جای Visibility.Hidden</span>
</code></pre>
<p>اگر بین چندین واردات static ابهام ایجاد شود، کامپایلر C# به اندازه کافی هوشمند نیست تا نوع صحیح را از زمینه استنتاج کند و خطا ایجاد می‌کند. ⚠️</p>
<h3>قواعد درون یک فضای نام (Rules Within a Namespace) 📚</h3>
<h4>محدوده‌ی نام‌ها (Name Scoping) 🏷️</h4>
<p>نام‌هایی که در فضای نام‌های بیرونی تعریف شده‌اند، می‌توانند بدون نیاز به نام کامل در فضای نام‌های درونی استفاده شوند.<br>
در مثال زیر، Class1 نیازی به نام کامل ندارد و می‌توان مستقیماً در Inner استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">Outer</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> {}

    <span class="hljs-keyword">namespace</span> <span class="hljs-title">Inner</span>
    {
        <span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> : <span class="hljs-title">Class1</span> {}  <span class="hljs-comment">// Class1 از Outer استفاده می‌شود</span>
    }
}
</code></pre>
<p>اگر بخواهید به نوعی در شاخه‌ی دیگری از سلسله‌مراتب فضای نام خود ارجاع دهید، می‌توانید از نام نیمه‌کامل (partially qualified name) استفاده کنید.<br>
مثال زیر، SalesReport را بر اساس Common.ReportBase تعریف می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyTradingCompany</span>
{
    <span class="hljs-keyword">namespace</span> <span class="hljs-title">Common</span>
    {
        <span class="hljs-keyword">class</span> <span class="hljs-title">ReportBase</span> {}
    }

    <span class="hljs-keyword">namespace</span> <span class="hljs-title">ManagementReporting</span>
    {
        <span class="hljs-keyword">class</span> <span class="hljs-title">SalesReport</span> : <span class="hljs-title">Common.ReportBase</span> {}
    }
}
</code></pre>
<h5>مخفی شدن نام‌ها (Name Hiding) 🕵️‍♂️</h5>
<p>اگر نام یک نوع در هر دو فضای نام درونی و بیرونی ظاهر شود، نام درونی برنده است و استفاده می‌شود.<br>
برای ارجاع به نوع در فضای نام بیرونی، باید نام کامل آن را مشخص کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">Outer</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> { }

    <span class="hljs-keyword">namespace</span> <span class="hljs-title">Inner</span>
    {
        <span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> { }

        <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
        {
            Foo f1;         <span class="hljs-comment">// = Outer.Inner.Foo</span>
            Outer.Foo f2;   <span class="hljs-comment">// = Outer.Foo</span>
        }
    }
}
</code></pre>
<p>تمام نام‌های انواع در زمان کامپایل به نام کامل (fully qualified name) تبدیل می‌شوند.<br>
کد Intermediate Language (IL) هیچ نام ناکامل یا نیمه‌کامل ندارد و همه چیز به صورت کامل مشخص است. ⚡</p>
<h4>تکرار فضای نام‌ها (Repeated Namespaces) 🔁</h4>
<p>می‌توانید یک اعلامیه‌ی فضای نام را تکرار کنید، تا زمانی که نام‌های انواع (types) داخل آن‌ها با هم تداخل نداشته باشند:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">Outer.Middle.Inner</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> {}
}

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Outer.Middle.Inner</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> {}
}
</code></pre>
<p>حتی می‌توان مثال بالا را به دو فایل جداگانه تقسیم کرد، به طوری که هر کلاس بتواند در یک assembly متفاوت کامپایل شود.</p>
<p>فایل منبع 1:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">Outer.Middle.Inner</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> {}
}
</code></pre>
<p>فایل منبع 2:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">Outer.Middle.Inner</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> {}
}
</code></pre>
<h4>دستور using تو در تو (Nested Using Directives) 📦</h4>
<p>می‌توانید یک دستور using را درون یک فضای نام قرار دهید. این کار به شما اجازه می‌دهد تا دامنه‌ی استفاده از دستور using را محدود به همان فضای نام کنید.<br>
در مثال زیر، Class1 در یک محدوده قابل مشاهده است ولی در محدوده‌ی دیگر نه:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">N1</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> {}
}

<span class="hljs-keyword">namespace</span> <span class="hljs-title">N2</span>
{
    <span class="hljs-keyword">using</span> N1;
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> : <span class="hljs-title">Class1</span> {}  <span class="hljs-comment">// قابل مشاهده</span>
}

<span class="hljs-keyword">namespace</span> <span class="hljs-title">N2</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">Class3</span> : <span class="hljs-title">Class1</span> {}  <span class="hljs-comment">// خطای زمان کامپایل</span>
}
</code></pre>
<p>⚠️ نکته: اگر دستور using داخل یک فضای نام تعریف نشود، اعضای آن به همه‌ی فضای نام‌های بعدی در همان فایل قابل دسترسی خواهند بود، اما با تو در تو کردن آن، می‌توان کنترل دقیقی روی دامنه‌ی دید (scope) داشت.</p>
<h4>ایجاد نام مستعار برای انواع و فضای نام‌ها (Aliasing Types and Namespaces) 🎭</h4>
<p>گاهی اوقات وارد کردن یک فضای نام کامل می‌تواند باعث تداخل نام‌ها (type-name collision) شود.<br>
به جای وارد کردن کل فضای نام، می‌توانید فقط انواع خاص مورد نیاز خود را وارد کرده و برای هر نوع یک نام مستعار (alias) تعریف کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> PropertyInfo2 = System.Reflection.PropertyInfo;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    PropertyInfo2 p;
}
</code></pre>
<p>همچنین می‌توان کل یک فضای نام را به یک نام مستعار تبدیل کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> R = System.Reflection;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    R.PropertyInfo p;
}
</code></pre>
<h5>نام مستعار برای هر نوع (C# 12) ✨</h5>
<p>از C# 12 به بعد، دستور using می‌تواند برای هر نوعی نام مستعار تعریف کند، حتی برای آرایه‌ها:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> NumberList = <span class="hljs-built_in">double</span>[];

NumberList numbers = { <span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span> };
</code></pre>
<p>همچنین می‌توان tupleها را نیز نام مستعار داد که در بخش “Aliasing Tuples (C# 12)” در صفحه 225 توضیح داده شده است.</p>
<h4>ویژگی‌های پیشرفته فضای نام (Advanced Namespace Features) 🛠️</h4>
<h5>Extern</h5>
<p>نام‌های مستعار extern به برنامه اجازه می‌دهند تا به دو نوع با نام کامل یکسان ارجاع دهد (یعنی هم نام فضای نام و هم نام نوع یکسان باشد). این سناریو نادر است و تنها زمانی رخ می‌دهد که دو نوع از اسمبلی‌های مختلف آمده باشند.</p>
<p>مثال:</p>
<p>Library 1، کامپایل شده به Widgets1.dll:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">Widgets</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> {}
}
</code></pre>
<p>Library 2، کامپایل شده به Widgets2.dll:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">Widgets</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> {}
}
</code></pre>
<p>برنامه‌ای که به هر دو اسمبلی ارجاع دارد:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> Widgets;

Widget w = <span class="hljs-keyword">new</span> Widget();  <span class="hljs-comment">// خطا: نام Widget مبهم است</span>
</code></pre>
<p>برای حل این ابهام، ابتدا فایل پروژه (.csproj) را تغییر داده و برای هر ارجاع یک نام مستعار منحصر به فرد اختصاص می‌دهیم:</p>
<pre class="hljs"><code>&lt;ItemGroup&gt;
    &lt;Reference Include=<span class="hljs-string">&quot;Widgets1&quot;</span>&gt;
        &lt;Aliases&gt;W1&lt;/Aliases&gt;
    &lt;/Reference&gt;
    &lt;Reference Include=<span class="hljs-string">&quot;Widgets2&quot;</span>&gt;
        &lt;Aliases&gt;W2&lt;/Aliases&gt;
    &lt;/Reference&gt;
&lt;/ItemGroup&gt;
</code></pre>
<p>سپس از دستور extern alias استفاده می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">extern</span> <span class="hljs-keyword">alias</span> W1;
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">alias</span> W2;

W1.Widgets.Widget w1 = <span class="hljs-keyword">new</span> W1.Widgets.Widget();
W2.Widgets.Widget w2 = <span class="hljs-keyword">new</span> W2.Widgets.Widget();
</code></pre>
<h5>مشخص کردن نام فضاها با نام مستعار (Namespace Alias Qualifiers) 🏷️</h5>
<p>همانطور که قبلاً گفتیم، نام‌ها در فضای نام‌های درونی، نام‌های فضای نام بیرونی را پنهان می‌کنند.<br>
با این حال، گاهی حتی استفاده از نام کامل نوع هم مشکل را حل نمی‌کند.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">N</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">A</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span> =&gt; <span class="hljs-keyword">new</span> A.B();  <span class="hljs-comment">// کدام B؟</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> {}                  <span class="hljs-comment">// نوع تو در تو</span>
    }
}

<span class="hljs-keyword">namespace</span> <span class="hljs-title">A</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> {}
}
</code></pre>
<p>در این مثال، کامپایلر همیشه اولویت بالاتر را به نوع موجود در فضای نام جاری می‌دهد (در اینجا B تو در تو).</p>
<p>برای رفع این ابهام، می‌توان نام فضای نام را با یک مرجع مشخص تعیین کرد:</p>
<ul>
<li>
<p>فضای نام global — ریشه همه فضاهای نام (با کلیدواژه‌ی global)</p>
</li>
<li>
<p>مجموعه‌ی نام‌های مستعار extern</p>
</li>
</ul>
<p>نماد :: برای تعیین نام مستعار فضای نام (namespace alias qualification) استفاده می‌شود.</p>
<p>مثال با فضای نام global:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">N</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">A</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
        {
            System.Console.WriteLine(<span class="hljs-keyword">new</span> A.B());        <span class="hljs-comment">// B تو در تو</span>
            System.Console.WriteLine(<span class="hljs-keyword">new</span> <span class="hljs-keyword">global</span>::A.B()); <span class="hljs-comment">// B در فضای نام A</span>
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> {}
    }
}

<span class="hljs-keyword">namespace</span> <span class="hljs-title">A</span>
{
    <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> {}
}
</code></pre>
<p>مثال با نام مستعار extern (از بخش Extern در صفحه 100):</p>
<pre class="hljs"><code><span class="hljs-keyword">extern</span> <span class="hljs-keyword">alias</span> W1;
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">alias</span> W2;

W1::Widgets.Widget w1 = <span class="hljs-keyword">new</span> W1::Widgets.Widget();
W2::Widgets.Widget w2 = <span class="hljs-keyword">new</span> W2::Widgets.Widget();
</code></pre>
<p>⚠️ استفاده از نام مستعار و :: کمک می‌کند ابهام بین انواع مشابه در فضاهای نام مختلف برطرف شود.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
