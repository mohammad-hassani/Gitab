

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Threading پیشرفته</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/Gitab/" aria-current="page">خانه</a>
        <a href="/Gitab/books/list-books">کتاب‌ها</a>
       <a href="/Gitab/translator.html">مترجمین</a>
        <a href="/Gitab/giter.html">گیتر</a>
      </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل بیست و یکم:  Threading پیشرفته</h1>
<p>ما در <strong>فصل ۱۴</strong> با مبانی اولیه‌ی <strong>Threading</strong> شروع کردیم تا مقدمه‌ای برای <strong>Tasks</strong> و <strong>Asynchrony</strong> باشد. به طور مشخص، نشان دادیم چطور می‌توان یک <strong>Thread</strong> را شروع و پیکربندی کرد و مفاهیم اساسی مثل <strong>Thread Pooling</strong>، <strong>Blocking</strong>، <strong>Spinning</strong> و <strong>Synchronization Contexts</strong> را پوشش دادیم. همچنین به <strong>Locking</strong> و <strong>Thread Safety</strong> پرداختیم و ساده‌ترین سازه‌ی سیگنال‌دهی، یعنی <strong>ManualResetEvent</strong> را معرفی کردیم.</p>
<p>این فصل دقیقاً از همان‌جایی ادامه پیدا می‌کند که فصل ۱۴ در موضوع <strong>Threading</strong> متوقف شد. در سه بخش اول، به‌طور عمیق‌تر به <strong>Synchronization</strong>، <strong>Locking</strong> و <strong>Thread Safety</strong> می‌پردازیم. سپس موارد زیر را پوشش می‌دهیم:</p>
<ul>
<li>🔓 <strong>Nonexclusive locking</strong> (مانند <strong>Semaphore</strong> و <strong>Reader/Writer Locks</strong>)</li>
<li>🔔 همه‌ی سازه‌های سیگنال‌دهی (<strong>AutoResetEvent</strong>، <strong>ManualResetEvent</strong>، <strong>CountdownEvent</strong> و <strong>Barrier</strong>)</li>
<li>🐢 <strong>Lazy Initialization</strong> (با استفاده از <strong>Lazy<T></strong> و <strong>LazyInitializer</strong>)</li>
<li>🧩 <strong>Thread-local storage</strong> (مانند <strong>ThreadStaticAttribute</strong>، <strong>ThreadLocal<T></strong> و <strong>GetData/SetData</strong>)</li>
<li>⏱ <strong>Timers</strong></li>
</ul>
<p>موضوع <strong>Threading</strong> آن‌قدر وسیع است که ما بخش‌های تکمیلی را به‌صورت آنلاین قرار داده‌ایم تا تصویر کامل‌تری ارائه شود. برای مطالعه‌ی موضوعات پیشرفته‌تر، به وب‌سایت زیر مراجعه کنید:</p>
<p>🔗 <a href="http://albahari.com/threading">http://albahari.com/threading</a></p>
<p>در آن‌جا مباحث زیر را خواهید یافت:</p>
<ul>
<li>⚙️ <strong>Monitor.Wait</strong> و <strong>Monitor.Pulse</strong> برای سناریوهای خاص سیگنال‌دهی</li>
<li>🚀 تکنیک‌های <strong>Nonblocking Synchronization</strong> برای <strong>Micro-Optimization</strong> (مانند <strong>Interlocked</strong>، <strong>Memory Barriers</strong>، <strong>volatile</strong>)</li>
<li>🔄 <strong>SpinLock</strong> و <strong>SpinWait</strong> برای سناریوهای با <strong>Concurrency</strong> بالا</li>
</ul>
<hr>
<h2>🔑 Synchronization Overview (مرور Synchronization)</h2>
<p><strong>Synchronization</strong> یعنی هماهنگ‌سازی عملیات همزمان برای دستیابی به یک نتیجه‌ی قابل پیش‌بینی. این موضوع به‌ویژه وقتی اهمیت پیدا می‌کند که چندین <strong>Thread</strong> به داده‌ی مشترک دسترسی دارند؛ در این شرایط، خیلی راحت می‌توان دچار مشکل شد.</p>
<p>ساده‌ترین و کاربردی‌ترین ابزارهای <strong>Synchronization</strong> احتمالاً همان <strong>Continuations</strong> و <strong>Task Combinators</strong> هستند که در فصل ۱۴ توضیح دادیم. با فرموله کردن برنامه‌های همزمان در قالب عملیات <strong>Asynchronous</strong> که با <strong>Continuations</strong> و <strong>Combinators</strong> به هم متصل می‌شوند، نیاز به <strong>Locking</strong> و <strong>Signaling</strong> کمتر می‌شود. با این حال، هنوز مواقعی وجود دارد که سازه‌های سطح پایین‌تر وارد عمل می‌شوند.</p>
<p>سازه‌های <strong>Synchronization</strong> را می‌توان به سه دسته تقسیم کرد:</p>
<ol>
<li>
<p>🔒 <strong>Exclusive Locking</strong><br>
این سازه‌ها اجازه می‌دهند فقط یک <strong>Thread</strong> در هر لحظه فعالیت خاصی انجام دهد یا بخشی از کد را اجرا کند. هدف اصلی آن‌ها این است که <strong>Threads</strong> بتوانند به وضعیت مشترک در حال نوشتن دسترسی داشته باشند بدون این‌که مزاحم هم شوند. سازه‌های <strong>Exclusive Locking</strong> عبارت‌اند از:<br>
<strong>lock</strong>، <strong>Mutex</strong> و <strong>SpinLock</strong>.</p>
</li>
<li>
<p>🔓 <strong>Nonexclusive Locking</strong><br>
این نوع <strong>Locking</strong> به شما اجازه می‌دهد میزان <strong>Concurrency</strong> را محدود کنید. سازه‌های آن عبارت‌اند از:<br>
<strong>Semaphore(Slim)</strong> و <strong>ReaderWriterLock(Slim)</strong>.</p>
</li>
<li>
<p>📢 <strong>Signaling</strong><br>
این سازه‌ها به یک <strong>Thread</strong> اجازه می‌دهند تا زمانی که از یک یا چند <strong>Thread</strong> دیگر اطلاع (Notification) دریافت نکرده، در حالت <strong>Block</strong> باقی بماند. سازه‌های <strong>Signaling</strong> شامل <strong>ManualResetEvent(Slim)</strong>، <strong>AutoResetEvent</strong>، <strong>CountdownEvent</strong> و <strong>Barrier</strong> هستند. سه مورد اول معمولاً با عنوان <strong>Event Wait Handles</strong> شناخته می‌شوند.</p>
</li>
</ol>
<p>همچنین امکان (و البته دشواری) انجام برخی عملیات همزمان روی داده‌ی مشترک بدون استفاده از <strong>Locking</strong> وجود دارد، با کمک سازه‌های <strong>Nonblocking Synchronization</strong>. این سازه‌ها عبارت‌اند از:<br>
<strong>Thread.MemoryBarrier</strong>، <strong>Thread.VolatileRead</strong>، <strong>Thread.VolatileWrite</strong>، کلیدواژه‌ی <strong>volatile</strong> و کلاس <strong>Interlocked</strong>.</p>
<p>ما این موضوع را به همراه متدهای <strong>Monitor.Wait/Pulse</strong> که برای نوشتن منطق سفارشی سیگنال‌دهی کاربرد دارند، به‌صورت آنلاین پوشش داده‌ایم.</p>
<hr>
<h2>🔐 Exclusive Locking (قفل‌گذاری انحصاری)</h2>
<p>سه سازه‌ی اصلی برای <strong>Exclusive Locking</strong> وجود دارد: دستور <strong>lock</strong>، <strong>Mutex</strong> و <strong>SpinLock</strong>.</p>
<ul>
<li>دستور <strong>lock</strong> راحت‌ترین و پرکاربردترین گزینه است.</li>
<li><strong>Mutex</strong> زمانی استفاده می‌شود که بخواهید قفل را بین چندین <strong>Process</strong> گسترش دهید (قفل‌های سطح کامپیوتر).</li>
<li><strong>SpinLock</strong> یک <strong>Micro-Optimization</strong> است که می‌تواند در سناریوهای با <strong>Concurrency</strong> بالا باعث کاهش <strong>Context Switches</strong> شود. 🔄</li>
</ul>
<h3>🔒 The <code>lock</code> Statement (دستور lock)</h3>
<p>برای نشان دادن نیاز به <strong>Locking</strong>، کلاس زیر را در نظر بگیرید:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span>
{
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _val1 = <span class="hljs-number">1</span>, _val2 = <span class="hljs-number">1</span>;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Go</span>()</span>
  {
    <span class="hljs-keyword">if</span> (_val2 != <span class="hljs-number">0</span>) Console.WriteLine (_val1 / _val2);
    _val2 = <span class="hljs-number">0</span>;
  }
}
</code></pre>
<p>این کلاس <strong>Thread-Safe</strong> نیست: اگر متد <code>Go</code> به‌طور همزمان توسط دو <strong>Thread</strong> فراخوانی شود، امکان رخ دادن خطای <strong>Division by Zero</strong> وجود دارد. چرا؟ چون ممکن است در همان لحظه‌ای که یک <strong>Thread</strong> بین اجرای دستور <code>if</code> و <code>Console.WriteLine</code> است، <strong>Thread</strong> دیگر مقدار <code>_val2</code> را برابر صفر قرار دهد.</p>
<p>اینجاست که دستور <strong>lock</strong> مشکل را حل می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span>
{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> _locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _val1 = <span class="hljs-number">1</span>, _val2 = <span class="hljs-number">1</span>;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Go</span>()</span>
  {
    <span class="hljs-keyword">lock</span> (_locker)
    {
      <span class="hljs-keyword">if</span> (_val2 != <span class="hljs-number">0</span>) Console.WriteLine (_val1 / _val2);
      _val2 = <span class="hljs-number">0</span>;
    }
  }
}
</code></pre>
<p>فقط یک <strong>Thread</strong> در هر لحظه می‌تواند شیء همگام‌ساز (در اینجا <code>_locker</code>) را قفل کند. هر <strong>Thread</strong> دیگری که برای قفل رقابت کند، <strong>Blocked</strong> می‌شود تا زمانی که قفل آزاد شود.</p>
<p>اگر بیش از یک <strong>Thread</strong> برای قفل رقابت کند، آن‌ها در یک <strong>Ready Queue</strong> قرار می‌گیرند و به ترتیب ورود، قفل به آن‌ها داده می‌شود (البته ✍️ در بعضی شرایط سیستم‌عامل <strong>Windows</strong> و <strong>CLR</strong> ممکن است این عدالت نقض شود).</p>
<p>به همین دلیل، قفل‌های انحصاری را گاهی اوقات طوری توصیف می‌کنند که <strong>دسترسی سریالی</strong> را به چیزی که توسط قفل محافظت می‌شود، اعمال می‌کنند؛ زیرا دسترسی یک <strong>Thread</strong> نمی‌تواند با دیگری همپوشانی داشته باشد. در این مثال، ما هم منطق داخل متد <code>Go</code> و هم فیلدهای <code>_val1</code> و <code>_val2</code> را محافظت کرده‌ایم.</p>
<hr>
<h3>⚙️ Monitor.Enter و Monitor.Exit</h3>
<p>دستور <code>lock</code> در C# در حقیقت یک <strong>میان‌بر نحوی (Syntactic Shortcut)</strong> برای فراخوانی متدهای <code>Monitor.Enter</code> و <code>Monitor.Exit</code> به همراه یک بلوک <code>try/finally</code> است.</p>
<p>به‌طور ساده، کدی که در متد <code>Go</code> اتفاق می‌افتد، معادل زیر است:</p>
<pre class="hljs"><code>Monitor.Enter (_locker);
<span class="hljs-keyword">try</span>
{
  <span class="hljs-keyword">if</span> (_val2 != <span class="hljs-number">0</span>) Console.WriteLine (_val1 / _val2);
  _val2 = <span class="hljs-number">0</span>;
}
<span class="hljs-keyword">finally</span> { Monitor.Exit (_locker); }
</code></pre>
<p>⚠️ اگر متد <code>Monitor.Exit</code> بدون این‌که قبلاً <code>Monitor.Enter</code> روی همان شیء صدا زده شده باشد، فراخوانی شود، یک <strong>Exception</strong> پرتاب می‌شود.</p>
<hr>
<h3>🛡 overloadهای lockTaken</h3>
<p>کدی که در بالا دیدیم یک آسیب‌پذیری ظریف دارد. فرض کنید (هرچند بعید) یک <strong>Exception</strong> بین فراخوانی <code>Monitor.Enter</code> و شروع بلوک <code>try</code> رخ دهد (مثلاً یک <strong>OutOfMemoryException</strong> یا در <strong>.NET Framework</strong> اگر <strong>Thread</strong> متوقف شود).</p>
<p>در این شرایط:</p>
<ul>
<li>اگر قفل گرفته نشده باشد، خطری وجود ندارد.</li>
<li>اما اگر قفل گرفته شده باشد، چون هیچ‌وقت وارد بلوک <code>try/finally</code> نمی‌شویم، قفل آزاد نخواهد شد. این یعنی <strong>Leak شدن قفل</strong>.</li>
</ul>
<p>برای جلوگیری از این مشکل، متد زیر در <strong>Monitor.Enter</strong> تعریف شده است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enter</span> (<span class="hljs-params"><span class="hljs-built_in">object</span> obj, <span class="hljs-keyword">ref</span> <span class="hljs-built_in">bool</span> lockTaken</span>)</span>;
</code></pre>
<p>🔎 اگر و فقط اگر متد <code>Enter</code> یک <strong>Exception</strong> پرتاب کند و قفل گرفته نشده باشد، مقدار <code>lockTaken</code> برابر <strong>false</strong> خواهد بود.</p>
<p>الگوی درست استفاده از آن (و همان چیزی که کامپایلر C# در پشت‌صحنه برای دستور <code>lock</code> تولید می‌کند) به شکل زیر است:</p>
<pre class="hljs"><code><span class="hljs-built_in">bool</span> lockTaken = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">try</span>
{
  Monitor.Enter (_locker, <span class="hljs-keyword">ref</span> lockTaken);
  <span class="hljs-comment">// Do your stuff...</span>
}
<span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (lockTaken) Monitor.Exit (_locker); }
</code></pre>
<hr>
<h3>⏱ TryEnter</h3>
<p>کلاس <strong>Monitor</strong> همچنین متدی به نام <strong>TryEnter</strong> ارائه می‌دهد که به شما اجازه می‌دهد یک <strong>Timeout</strong> مشخص کنید (بر حسب <strong>Milliseconds</strong> یا یک <strong>TimeSpan</strong>).</p>
<ul>
<li>اگر قفل گرفته شود، مقدار <strong>true</strong> برمی‌گرداند.</li>
<li>اگر قفل به‌دلیل <strong>Timeout</strong> گرفته نشود، مقدار <strong>false</strong> برمی‌گرداند.</li>
</ul>
<p>علاوه بر این، متد <strong>TryEnter</strong> می‌تواند بدون هیچ آرگومانی فراخوانی شود. در این حالت، فقط <strong>قفل را تست می‌کند</strong> و اگر بلافاصله نتواند قفل را بگیرد، بدون معطلی <strong>false</strong> برمی‌گرداند.</p>
<p>📌 درست مثل متد <code>Enter</code>، متد <strong>TryEnter</strong> هم یک نسخه‌ی overload دارد که از آرگومان <strong>lockTaken</strong> پشتیبانی می‌کند.</p>
<h3>🔑 Choosing the Synchronization Object (انتخاب شیء همگام‌ساز)</h3>
<p>شما می‌توانید از هر شیئی که برای <strong>Thread</strong>‌های شرکت‌کننده قابل مشاهده باشد، به‌عنوان شیء همگام‌ساز استفاده کنید؛ با این شرط مهم که آن شیء باید یک <strong>Reference Type</strong> باشد.</p>
<p>شیء همگام‌ساز معمولاً <strong>private</strong> است (چون این کار باعث می‌شود منطق قفل‌گذاری بهتر <strong>Encapsulate</strong> شود) و معمولاً یک <strong>Instance Field</strong> یا یک <strong>Static Field</strong> است.</p>
<p>گاهی اوقات شیء همگام‌ساز همان شیء محافظت‌شده است. مانند فیلد <code>_list</code> در مثال زیر:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span>
{
  List&lt;<span class="hljs-built_in">string</span>&gt; _list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span>
  {
    <span class="hljs-keyword">lock</span> (_list)
    {
      _list.Add(<span class="hljs-string">&quot;Item 1&quot;</span>);
      ...
    }
  }
}
</code></pre>
<p>البته داشتن یک فیلد اختصاصی برای قفل‌گذاری (مثل <code>_locker</code> در مثال قبلی) کنترل دقیق‌تری روی <strong>Scope</strong> و <strong>Granularity</strong> قفل فراهم می‌کند.</p>
<p>همچنین می‌توانید از شیء حاوی (یعنی <code>this</code>) به‌عنوان شیء همگام‌ساز استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">lock</span> (<span class="hljs-keyword">this</span>) { ... }
</code></pre>
<p>یا حتی از نوع کلاس استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">lock</span> (<span class="hljs-keyword">typeof</span>(Widget)) { ... }   <span class="hljs-comment">// برای محافظت از فیلدهای static</span>
</code></pre>
<p>❌ عیب این روش‌ها این است که منطق قفل‌گذاری <strong>Encapsulate</strong> نمی‌شود و همین می‌تواند مدیریت <strong>Deadlock</strong> و <strong>Blocking</strong> بیش از حد را سخت‌تر کند.</p>
<p>شما حتی می‌توانید روی متغیرهای محلی که توسط <strong>Lambda Expressions</strong> یا <strong>Anonymous Methods</strong> گرفته شده‌اند نیز قفل بگذارید.</p>
<hr>
<h3>⏰ When to Lock (چه زمانی باید قفل کنیم)</h3>
<p>قفل کردن دسترسی به خود شیء همگام‌ساز را محدود نمی‌کند. به عبارت دیگر، اگر متدی مثل <code>x.ToString()</code> فراخوانی شود، <strong>Blocked</strong> نخواهد شد فقط به این دلیل که یک <strong>Thread</strong> دیگر روی <code>lock(x)</code> قفل کرده است.<br>
فقط زمانی <strong>Blocking</strong> اتفاق می‌افتد که هر دو <strong>Thread</strong> از <code>lock(x)</code> استفاده کنند.</p>
<p>قاعده‌ی پایه‌ای این است:<br>
🔒 شما باید همیشه هنگام دسترسی به هر <strong>Shared Writable Field</strong> از قفل استفاده کنید.</p>
<p>حتی در ساده‌ترین حالت—مثلاً یک عمل <strong>Assignment</strong> روی یک فیلد—باید <strong>Synchronization</strong> را در نظر بگیرید.</p>
<p>به مثال زیر توجه کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafe</span>
{
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _x;
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Increment</span>()</span> { _x++; }
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Assign</span>()</span>    { _x = <span class="hljs-number">123</span>; }
}
</code></pre>
<p>این کلاس <strong>Thread-Safe</strong> نیست. نسخه‌ی ایمن‌تر آن به شکل زیر است:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> _locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();
<span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _x;

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Increment</span>()</span> { <span class="hljs-keyword">lock</span> (_locker) _x++; }
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Assign</span>()</span>    { <span class="hljs-keyword">lock</span> (_locker) _x = <span class="hljs-number">123</span>; }
</code></pre>
<hr>
<h3>⚠️ مشکلات بدون Lock</h3>
<p>اگر قفل وجود نداشته باشد، دو مشکل رخ می‌دهد:</p>
<ol>
<li>➕ عملیات‌هایی مثل افزایش مقدار یک متغیر (یا حتی خواندن/نوشتن آن در شرایط خاص) <strong>Atomic</strong> نیستند.</li>
<li>⚡ <strong>Compiler</strong>، <strong>CLR</strong> و <strong>Processor</strong> مجاز هستند برای بهبود کارایی، دستورات را <strong>Reorder</strong> کنند یا متغیرها را در <strong>CPU Registers</strong> کش کنند—تا زمانی که این بهینه‌سازی‌ها رفتار یک برنامه‌ی تک‌ریسمانی (یا چندریسمانی که از قفل استفاده می‌کند) را تغییر ندهد.</li>
</ol>
<p>قفل‌ها مشکل دوم را با ایجاد یک <strong>Memory Barrier</strong> قبل و بعد از قفل کاهش می‌دهند.</p>
<p>🧱 <strong>Memory Barrier</strong> مانند یک حصار است که مانع عبور اثرات <strong>Reordering</strong> و <strong>Caching</strong> می‌شود.</p>
<p>این قاعده فقط مخصوص قفل‌ها نیست؛ بلکه برای همه‌ی سازه‌های <strong>Synchronization</strong> صدق می‌کند.</p>
<p>مثال: اگر یک سازه‌ی سیگنال‌دهی تضمین کند که فقط یک <strong>Thread</strong> در هر لحظه متغیری را بخواند/بنویسد، دیگر نیازی به قفل ندارید:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> signal = <span class="hljs-keyword">new</span> ManualResetEvent(<span class="hljs-literal">false</span>);
<span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>;
<span class="hljs-keyword">new</span> Thread(() =&gt; { x++; signal.Set(); }).Start();
signal.WaitOne();
Console.WriteLine(x);   <span class="hljs-comment">// همیشه 1</span>
</code></pre>
<p>در بخش «<strong>Nonblocking Synchronization</strong>» توضیح داده‌ایم که چرا چنین نیازی پیش می‌آید و چگونه <strong>Memory Barriers</strong> و کلاس <strong>Interlocked</strong> می‌توانند جایگزین قفل در این سناریوها باشند.</p>
<hr>
<h3>🔗 Locking and Atomicity (قفل‌گذاری و اتمیک بودن)</h3>
<p>اگر گروهی از متغیرها همیشه درون یک قفل خوانده یا نوشته شوند، می‌توان گفت این متغیرها به شکل <strong>Atomic</strong> دسترسی دارند.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">lock</span> (locker) { <span class="hljs-keyword">if</span> (x != <span class="hljs-number">0</span>) y /= x; }
</code></pre>
<p>در این حالت، متغیرهای <code>x</code> و <code>y</code> به‌صورت <strong>Atomic</strong> دسترسی داده می‌شوند؛ یعنی هیچ <strong>Thread</strong> دیگری نمی‌تواند در میانه‌ی این عملیات آن‌ها را تغییر دهد و نتیجه را بی‌اعتبار کند. بنابراین، شما هرگز خطای <strong>Division by Zero</strong> دریافت نمی‌کنید، مشروط بر این‌که <code>x</code> و <code>y</code> همیشه در همین قفل انحصاری دسترسی داده شوند.</p>
<hr>
<h3>🚨 استثناها و Atomicity</h3>
<p>اتمیک بودن قفل نقض می‌شود اگر داخل بلوک قفل یک <strong>Exception</strong> رخ دهد (چه برنامه چندریسمانی باشد چه نباشد).</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">decimal</span> _savingsBalance, _checkBalance;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Transfer</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> amount</span>)</span>
{
  <span class="hljs-keyword">lock</span> (_locker)
  {
    _savingsBalance += amount;
    _checkBalance -= amount + GetBankFee();
  }
}
</code></pre>
<p>اگر متد <code>GetBankFee()</code> یک <strong>Exception</strong> پرتاب کند، بانک پول از دست می‌دهد! 🏦💸</p>
<p>در این شرایط می‌توان مشکل را با فراخوانی <code>GetBankFee</code> پیش از ورود به بلوک قفل برطرف کرد.</p>
<p>🔄 برای موارد پیچیده‌تر، یک راه‌حل این است که منطق <strong>Rollback</strong> را داخل یک بلوک <code>catch</code> یا <code>finally</code> پیاده‌سازی کنیم.</p>
<hr>
<h3>⚡ Instruction Atomicity</h3>
<p>مفهوم <strong>Instruction Atomicity</strong> متفاوت اما مشابه است: یک دستور <strong>Atomic</strong> است اگر روی پردازنده‌ی زیرین به‌طور غیرقابل تقسیم اجرا شود.</p>
<h3>🔐 قفل‌های تو در تو (Nested Locking)</h3>
<p>یک <strong>Thread</strong> می‌تواند بارها یک شیء را به‌صورت تو در تو (یا <strong>Reentrant</strong>) قفل کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">lock</span> (locker)
  <span class="hljs-keyword">lock</span> (locker)
    <span class="hljs-keyword">lock</span> (locker)
    {
       <span class="hljs-comment">// Do something...</span>
    }
</code></pre>
<p>یا به روش دیگر:</p>
<pre class="hljs"><code>Monitor.Enter (locker); 
Monitor.Enter (locker);  
Monitor.Enter (locker); 

<span class="hljs-comment">// Do something...</span>

Monitor.Exit (locker);  
Monitor.Exit (locker);   
Monitor.Exit (locker);
</code></pre>
<p>در این حالت‌ها، شیء تنها زمانی <strong>آزاد (unlock)</strong> می‌شود که یا خارجی‌ترین دستور <code>lock</code> پایان یافته باشد، یا تعداد متناظری از <code>Monitor.Exit</code> اجرا شده باشد.</p>
<p>🔁 <strong>قفل تو در تو</strong> زمانی مفید است که یک متد از داخل یک قفل، متد دیگری را صدا بزند:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span> locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();

<span class="hljs-keyword">lock</span> (locker)
{
    AnotherMethod();
    <span class="hljs-comment">// هنوز قفل داریم - چون قفل‌ها Reentrant هستند</span>
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AnotherMethod</span>()</span>
{
    <span class="hljs-keyword">lock</span> (locker) { Console.WriteLine (<span class="hljs-string">&quot;Another method&quot;</span>); }
}
</code></pre>
<p>✅ در اینجا Thread تنها روی اولین (خارجی‌ترین) قفل مسدود می‌شود.</p>
<hr>
<h3>⚠️ بن‌بست‌ها (Deadlocks)</h3>
<p><strong>Deadlock</strong> زمانی اتفاق می‌افتد که دو Thread هرکدام منتظر یک منبع باشند که توسط دیگری قفل شده است؛ در نتیجه هیچ‌کدام قادر به ادامه کار نخواهند بود.</p>
<p>مثال ساده با دو قفل:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span> locker1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();
<span class="hljs-built_in">object</span> locker2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();

<span class="hljs-keyword">new</span> Thread (() =&gt; {
    <span class="hljs-keyword">lock</span> (locker1)
    {
        Thread.Sleep (<span class="hljs-number">1000</span>);
        <span class="hljs-keyword">lock</span> (locker2);   <span class="hljs-comment">// Deadlock</span>
    }
}).Start();

<span class="hljs-keyword">lock</span> (locker2)
{
    Thread.Sleep (<span class="hljs-number">1000</span>);
    <span class="hljs-keyword">lock</span> (locker1);       <span class="hljs-comment">// Deadlock</span>
}
</code></pre>
<p>📌 در این حالت، هر Thread یکی از قفل‌ها را گرفته و منتظر دیگری است → <strong>بن‌بست دائمی</strong>.</p>
<ul>
<li>در محیط عادی CLR، بر خلاف SQL Server، <strong>بن‌بست‌ها به‌صورت خودکار تشخیص و رفع نمی‌شوند</strong>.</li>
<li>اگر بن‌بست رخ دهد، Threadها به‌طور نامحدود مسدود می‌شوند (مگر این‌که زمان‌انتظار یا Timeout تعریف کرده باشید).</li>
<li>در هاست SQL CLR (ادغام SQL Server با CLR)، بن‌بست‌ها شناسایی می‌شوند و یک استثنای قابل‌مدیریت روی یکی از Threadها پرتاب می‌شود.</li>
</ul>
<hr>
<h3>🔎 چرا Deadlock سخت است؟</h3>
<ul>
<li>هنگام طراحی شی‌ءگرا، ممکن است قفل‌ها در زنجیره‌ای از متدهای تو در تو گرفته شوند که ترتیب آن‌ها در زمان اجرا مشخص می‌شود.</li>
<li>ممکن است شما روی فیلد <code>a</code> در کلاس <code>x</code> قفل بزنید، در حالی که فراخواننده‌ی شما قبلاً روی فیلد <code>b</code> در کلاس <code>y</code> قفل زده باشد. هم‌زمان Thread دیگری برعکس همین کار را انجام دهد → Deadlock.</li>
<li>الگوهای خوب طراحی شی‌ءگرا (OOP) این مشکل را تشدید می‌کنند چون فراخوانی‌ها در زمان اجرا تعیین می‌شوند.</li>
</ul>
<hr>
<h3>✅ راهکارها برای کاهش Deadlock</h3>
<ol>
<li>
<p><strong>قفل‌ها را به ترتیب ثابت بگیرید</strong> (روش کلاسیک، ولی همیشه عملی نیست).</p>
</li>
<li>
<p>هنگام قفل کردن اطراف فراخوانی متدهای دیگر احتیاط کنید.</p>
</li>
<li>
<p>بررسی کنید آیا واقعاً لازم است هنگام فراخوانی متدهای دیگر قفل بگیرید یا خیر.</p>
</li>
<li>
<p>استفاده بیشتر از <strong>سینکرون‌سازی سطح بالاتر</strong> مثل:</p>
<ul>
<li>Task continuations/combinators</li>
<li>Data parallelism</li>
<li>Immutable types</li>
</ul>
</li>
</ol>
<p>💡 نکته: زمانی که در حین داشتن یک قفل، کدی بیرونی را صدا می‌زنید، <strong>کپسوله‌سازی قفل نشت می‌کند</strong>. این یک محدودیت ذاتی مکانیزم قفل‌گذاری است، نه یک ضعف CLR.</p>
<hr>
<h3>⚡️ سناریوی خاص Deadlock در UI</h3>
<ul>
<li>در اپلیکیشن‌های WPF: <code>Dispatcher.Invoke</code></li>
<li>در Windows Forms: <code>Control.Invoke</code></li>
</ul>
<p>اگر این‌ها را هنگام داشتن یک قفل صدا بزنید و Thread UI منتظر همان قفل باشد → Deadlock.</p>
<p>راه‌حل‌ها:</p>
<ul>
<li>استفاده از <code>BeginInvoke</code> به‌جای <code>Invoke</code>.</li>
<li>یا آزاد کردن قفل قبل از صدا زدن <code>Invoke</code> (البته اگر قفل توسط Caller گرفته شده باشد، جواب نمی‌دهد).</li>
</ul>
<hr>
<h3>🚀 کارایی (Performance)</h3>
<ul>
<li>گرفتن و آزاد کردن قفل در حالت <strong>بدون رقابت (uncontended)</strong> روی سیستم‌های 2020 کمتر از <strong>۲۰ نانوثانیه</strong> طول می‌کشد.</li>
<li>در حالت <strong>رقابتی (contended)</strong>، هزینه به حدود <strong>میکروثانیه</strong> می‌رسد (به‌خاطر Context Switch).</li>
<li>زمان واقعی باززمان‌بندی Thread ممکن است حتی بیشتر طول بکشد.</li>
</ul>
<h3>🔒 <strong>Mutex (موتکس)</strong></h3>
<p>یک <strong>Mutex</strong> شبیه به دستور <code>lock</code> در C# است، با این تفاوت که می‌تواند در <strong>چند پردازه (multi-process)</strong> هم کار کند. یعنی:</p>
<ul>
<li><code>lock</code> فقط داخل یک پردازه کاربرد دارد.</li>
<li><code>Mutex</code> هم <strong>سراسری در سطح کامپیوتر (computer-wide)</strong> و هم <strong>سطح برنامه (application-wide)</strong> قابل استفاده است.</li>
</ul>
<p>⏱ گرفتن و آزاد کردن یک Mutex (در حالت بدون رقابت) حدود <strong>۰.۵ میکروثانیه</strong> طول می‌کشد؛ یعنی بیش از <strong>۲۰ برابر کندتر از lock</strong>.</p>
<hr>
<h3>📌 استفاده از Mutex</h3>
<ul>
<li>برای گرفتن قفل: <code>WaitOne()</code></li>
<li>برای آزاد کردن: <code>ReleaseMutex()</code></li>
<li>دقیقاً مثل <code>lock</code>، فقط همان <strong>Thread</strong> که Mutex را گرفته، می‌تواند آن را آزاد کند.</li>
</ul>
<p>⚠️ اگر <code>ReleaseMutex</code> را فراموش کنید و فقط <code>Close</code> یا <code>Dispose</code> صدا بزنید،<br>
اولین Thread دیگری که روی آن منتظر مانده باشد، با <strong>AbandonedMutexException</strong> مواجه می‌شود.</p>
<hr>
<h3>🎯 کاربرد متداول: محدود کردن اجرای چندین نسخه از یک برنامه</h3>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-comment">// با نام‌گذاری Mutex، آن را در سطح کل کامپیوتر قابل‌دسترس می‌کنیم.</span>
<span class="hljs-comment">// بهتر است نام، یکتا باشد (مثلاً شامل نام شرکت یا URL).</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> mutex = <span class="hljs-keyword">new</span> Mutex (<span class="hljs-literal">true</span>, <span class="hljs-string">@&quot;Global\oreilly.com OneAtATimeDemo&quot;</span>);

<span class="hljs-comment">// اگر قفل اشغال بود، چند ثانیه صبر کنیم</span>
<span class="hljs-comment">// شاید نسخه قبلی برنامه در حال بستن باشد.</span>
<span class="hljs-keyword">if</span> (!mutex.WaitOne (TimeSpan.FromSeconds (<span class="hljs-number">3</span>), <span class="hljs-literal">false</span>))
{
    Console.WriteLine (<span class="hljs-string">&quot;Another instance of the app is running. Bye!&quot;</span>);
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-keyword">try</span> { RunProgram(); }
<span class="hljs-keyword">finally</span> { mutex.ReleaseMutex(); }

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RunProgram</span>()</span>
{
    Console.WriteLine (<span class="hljs-string">&quot;Running. Press Enter to exit&quot;</span>);
    Console.ReadLine();
}
</code></pre>
<p>📌 نکته:</p>
<ul>
<li>در <strong>Terminal Services</strong> یا <strong>کنسول‌های یونیکس جداگانه</strong>، Mutex سراسری معمولاً فقط برای برنامه‌هایی در همان <strong>Session</strong> قابل‌دسترسی است.</li>
<li>اگر بخواهید برای همه‌ی Sessionها در دسترس باشد، باید نام Mutex را با <code>&quot;Global\&quot;</code> شروع کنید (مثل نمونه کد).</li>
</ul>
<hr>
<h3>🧩 Thread Safety (ایمنی در چندنخی)</h3>
<p>یک برنامه یا متد زمانی <strong>Thread-Safe</strong> است که در هر سناریوی چندنخی درست کار کند.<br>
این کار عمدتاً با <strong>قفل‌گذاری (locking)</strong> و <strong>کاهش تعامل Threadها</strong> به دست می‌آید.</p>
<h4>چرا همه‌چیز همیشه Thread-Safe نیست؟</h4>
<ol>
<li>سربار توسعه زیاد است (اگر یک نوع تعداد زیادی فیلد داشته باشد، هر فیلد می‌تواند منبع تداخل باشد).</li>
<li>Thread-Safety هزینه‌ی کارایی دارد (حتی اگر فقط یک Thread استفاده کند).</li>
<li>حتی اگر یک کلاس Thread-Safe باشد، <strong>برنامه‌ای که از آن استفاده می‌کند، لزوماً Thread-Safe نخواهد بود</strong>.</li>
</ol>
<p>➡️ بنابراین، معمولاً <strong>فقط همان‌جایی Thread-Safe پیاده‌سازی می‌شود که لازم است</strong>.</p>
<hr>
<h3>⚙️ راه‌های &quot;میان‌بر&quot; برای Thread-Safety</h3>
<ol>
<li>
<p><strong>قفل‌گذاری کلی (Coarse-Grained Locking)</strong></p>
<ul>
<li>کل دسترسی به یک شیء را داخل یک قفل انحصاری قرار دهید.</li>
<li>این روش به‌خصوص برای استفاده از <strong>کدهای ناامن در چندنخی</strong> (مثل بیشتر انواع .NET یا کدهای شخص ثالث) ضروری است.</li>
<li>اگر متدهای شیء سریع باشند، این روش جواب می‌دهد. (وگرنه قفل زیاد باعث بلوکه شدن خواهد شد).</li>
</ul>
</li>
<li>
<p><strong>کاهش تعامل Threadها با کاهش داده‌های مشترک</strong></p>
<ul>
<li>این استراتژی در اپلیکیشن‌های Stateless (مثل وب‌سرورها یا سرویس‌های میانی) استفاده می‌شود.</li>
<li>چون داده بین درخواست‌ها ذخیره نمی‌شود، تعامل Threadها کم می‌شود.</li>
<li>تنها نقاط مشترک می‌توانند فیلدهای <code>static</code> باشند (مثلاً برای کش کردن داده یا سرویس‌های زیرساختی مثل Authentication و Auditing).</li>
</ul>
</li>
<li>
<p><strong>اجرای کد دسترسی به داده‌های مشترک روی Thread رابط کاربری (UI Thread)</strong></p>
<ul>
<li>در اپلیکیشن‌های کلاینت غنی (Rich Client).</li>
<li>با استفاده از <strong>توابع Asynchronous</strong> (که در فصل 14 دیدیم) این کار راحت‌تر می‌شود.</li>
</ul>
</li>
</ol>
<hr>
<p>📖 جمع‌بندی:</p>
<ul>
<li>از <strong>Mutex</strong> وقتی استفاده کنید که نیاز به هماهنگی بین چند پردازه دارید (مثل اطمینان از اجرای تنها یک نسخه‌ی برنامه).</li>
<li>برای <strong>Thread-Safety</strong>، یا باید با قفل‌ها دسترسی را کنترل کنید، یا با طراحی صحیح (مثل Stateless یا Immutable) تعامل Threadها را به حداقل برسانید.</li>
</ul>
<h3>ایمنی نخ‌ها و انواع .NET 🧵🛡️</h3>
<p>شما می‌توانید با استفاده از <strong>locking</strong> کدی که thread-unsafe است را به کدی thread-safe تبدیل کنید. یکی از کاربردهای خوب این کار در <strong>.NET</strong> است: تقریباً همه‌ی انواع <strong>nonprimitive</strong> (غیرابتدایی) در .NET زمانی که ساخته می‌شوند، thread-safe نیستند (برای چیزی بیشتر از دسترسی فقط‌خواندنی). با این حال، شما می‌توانید آن‌ها را در کد چندنخی (multithreaded) استفاده کنید، به شرطی که همه‌ی دسترسی‌ها به یک شیء مشخص با استفاده از یک <strong>lock</strong> محافظت شوند.</p>
<p>در اینجا مثالی داریم که در آن دو نخ به‌طور همزمان یک آیتم را به همان <strong>List collection</strong> اضافه می‌کنند و سپس آن لیست را پیمایش می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span>
{
  <span class="hljs-keyword">static</span> List&lt;<span class="hljs-built_in">string</span>&gt; _list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
  {
    <span class="hljs-keyword">new</span> Thread (AddItem).Start();
    <span class="hljs-keyword">new</span> Thread (AddItem).Start();
  }
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddItem</span>()</span>
  {
    <span class="hljs-keyword">lock</span> (_list) _list.Add (<span class="hljs-string">&quot;Item &quot;</span> + _list.Count);
    <span class="hljs-built_in">string</span>[] items;
    <span class="hljs-keyword">lock</span> (_list) items = _list.ToArray();
    <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> s <span class="hljs-keyword">in</span> items) Console.WriteLine (s);
  }
}
</code></pre>
<hr>
<h3>قفل‌گذاری و ایمنی نخ‌ها 🔐</h3>
<p>در این حالت، ما روی خود شیء <strong>_list</strong> قفل می‌کنیم. اگر دو لیست مرتبط داشتیم، باید یک شیء مشترک را برای قفل انتخاب می‌کردیم (می‌توانستیم یکی از لیست‌ها را انتخاب کنیم یا بهتر: از یک فیلد مستقل استفاده کنیم).</p>
<p>پیمایش (enumerating) مجموعه‌های .NET نیز thread-unsafe است، به این معنا که اگر لیست هنگام پیمایش تغییر کند، یک <strong>exception</strong> رخ می‌دهد. به جای قفل‌گذاری در کل مدت پیمایش، در این مثال ابتدا آیتم‌ها را در یک <strong>آرایه</strong> کپی می‌کنیم. این کار باعث می‌شود قفل برای مدت طولانی نگه داشته نشود، مخصوصاً اگر کاری که هنگام پیمایش انجام می‌دهیم زمان‌بر باشد. (راه‌حل دیگر استفاده از یک <strong>reader/writer lock</strong> است؛ به بخش «Reader/Writer Locks» در صفحه ۹۰۷ مراجعه کنید.)</p>
<hr>
<h3>قفل‌گذاری روی اشیاء thread-safe ⚡</h3>
<p>گاهی لازم است حتی هنگام دسترسی به اشیاء <strong>thread-safe</strong> نیز از قفل استفاده کنید. برای توضیح، فرض کنید که کلاس <strong>List</strong> در .NET واقعاً thread-safe بود و ما می‌خواستیم یک آیتم به لیست اضافه کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (!_list.Contains (newItem)) _list.Add (newItem);
</code></pre>
<p>صرف‌نظر از اینکه لیست thread-safe باشد یا نه، این دستور قطعاً thread-safe نیست! کل عبارت <strong>if</strong> باید درون یک قفل قرار گیرد تا از پیش‌دستی (preemption) بین بررسی عضویت و اضافه کردن آیتم جلوگیری شود. این قفل باید در همه‌ی جاهایی که لیست را تغییر می‌دهیم استفاده شود. برای مثال، دستور زیر نیز باید در همان قفل پیچیده شود تا از پیش‌دستی نسبت به عبارت قبلی جلوگیری کند:</p>
<pre class="hljs"><code>_list.Clear();
</code></pre>
<p>به عبارت دیگر، باید دقیقاً همانند کلاس‌های مجموعه‌ی thread-unsafe قفل‌گذاری کنیم (که این موضوع ایمنی نخِ فرضیِ کلاس <strong>List</strong> را بی‌اثر می‌سازد).</p>
<hr>
<h3>اعضای ایستا (Static Members) ⚙️</h3>
<p>قفل‌گذاری هنگام دسترسی به یک مجموعه می‌تواند در محیط‌های با همروندی بالا (<strong>highly concurrent environments</strong>) باعث <strong>blocking</strong> بیش‌ازحد شود. برای همین، .NET یک <strong>queue</strong>، <strong>stack</strong> و <strong>dictionary</strong> thread-safe فراهم کرده است که در فصل ۲۲ بررسی خواهیم کرد.</p>
<p>پیچیدن دسترسی به یک شیء در یک قفل سفارشی فقط وقتی کار می‌کند که همه‌ی نخ‌های همروند از آن قفل آگاه باشند و از آن استفاده کنند. این ممکن است وقتی شیء در سطح وسیعی استفاده می‌شود برقرار نباشد. بدترین حالت در مورد <strong>static members</strong> در یک نوع عمومی (public type) رخ می‌دهد.</p>
<p>برای مثال، تصور کنید که ویژگی ایستای <strong>DateTime.Now</strong> در ساختار <strong>DateTime</strong> thread-safe نبود و دو فراخوانی همزمان می‌توانست خروجی درهم یا یک <strong>exception</strong> ایجاد کند. تنها راه‌حل با قفل‌گذاری خارجی این بود که قبل از فراخوانی DateTime.Now نوع را قفل کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">lock</span>(<span class="hljs-keyword">typeof</span>(DateTime))
</code></pre>
<p>این فقط زمانی جواب می‌دهد که همه‌ی برنامه‌نویسان با این کار موافق باشند (که بعید است). علاوه بر این، قفل‌گذاری روی یک نوع مشکلات خودش را ایجاد می‌کند.</p>
<p>به همین دلیل، اعضای ایستای <strong>DateTime struct</strong> به‌طور دقیق thread-safe پیاده‌سازی شده‌اند. این یک الگوی رایج در .NET است:</p>
<ul>
<li>اعضای ایستا (static members) → <strong>thread-safe</strong> ✅</li>
<li>اعضای نمونه (instance members) → <strong>thread-unsafe</strong> ❌</li>
</ul>
<p>دنبال کردن این الگو هنگام نوشتن انواع برای استفاده عمومی منطقی است تا از ایجاد معماهای غیرممکنِ ایمنی نخ جلوگیری شود. به عبارت دیگر، با thread-safe کردن متدهای ایستا، شما طوری کدنویسی می‌کنید که مانع ایمنی نخ برای مصرف‌کنندگان آن نوع نشوید.</p>
<p>⚠️ <strong>ایمنی نخ در متدهای ایستا چیزی است که باید به‌طور صریح پیاده‌سازی شود؛ این ویژگی به‌طور خودکار فقط به دلیل ایستا بودن متد اتفاق نمی‌افتد!</strong></p>
<hr>
<h3>ایمنی نخ در حالت فقط‌خواندنی 📖</h3>
<p>ایمن کردن انواع برای دسترسی همزمان فقط‌خواندنی (در صورت امکان) سودمند است زیرا به این معناست که مصرف‌کنندگان می‌توانند از قفل‌گذاری بیش‌ازحد جلوگیری کنند. بسیاری از انواع .NET این اصل را دنبال می‌کنند: برای مثال، مجموعه‌ها برای خوانندگان همزمان thread-safe هستند.</p>
<p>دنبال کردن این اصل برای خودتان ساده است: اگر نوعی را به‌عنوان thread-safe برای دسترسی همزمان فقط‌خواندنی مستند می‌کنید، در متدهایی که مصرف‌کننده انتظار دارد فقط‌خواندنی باشند به فیلدها ننویسید (یا در صورت نیاز قفل‌گذاری کنید).</p>
<p>برای نمونه، در پیاده‌سازی یک متد <strong>ToArray()</strong> در یک مجموعه، ممکن است بخواهید ابتدا ساختار داخلی مجموعه را فشرده‌سازی کنید. با این حال، این کار آن را برای مصرف‌کنندگانی که انتظار داشتند فقط‌خواندنی باشد، thread-unsafe می‌کند.</p>
<p>ایمنی نخ در حالت فقط‌خواندنی یکی از دلایلی است که <strong>enumerator</strong> ها از <strong>enumerable</strong> ها جدا هستند: دو نخ می‌توانند به‌طور همزمان روی یک مجموعه پیمایش کنند چون هرکدام یک شیء enumerator جدا دریافت می‌کنند.</p>
<p>در نبود مستندات، بهتر است محتاط باشید و فرض نکنید که یک متد ذاتاً فقط‌خواندنی است. یک مثال خوب کلاس <strong>Random</strong> است: وقتی <strong>Random.Next()</strong> را فراخوانی می‌کنید، پیاده‌سازی داخلی آن نیاز دارد که مقادیر بذر خصوصی (private seed values) را به‌روزرسانی کند. بنابراین، شما باید یا هنگام استفاده از کلاس Random قفل‌گذاری کنید یا یک نمونه جداگانه برای هر نخ نگه دارید.</p>
<h3>ایمنی نخ در سرورهای برنامه 🖥️🧵</h3>
<p>سرورهای برنامه (Application servers) باید <strong>چندنخی (multithreaded)</strong> باشند تا بتوانند درخواست‌های همزمان کلاینت‌ها را مدیریت کنند. برنامه‌های <strong><a href="http://ASP.NET">ASP.NET</a> Core</strong> و <strong>Web API</strong> به‌صورت ضمنی چندنخی هستند. این یعنی هنگام نوشتن کد در سمت سرور، اگر احتمال تعامل میان نخ‌هایی که درخواست‌های کلاینت را پردازش می‌کنند وجود داشته باشد، باید <strong>ایمنی نخ (thread safety)</strong> را در نظر بگیرید. خوشبختانه، چنین احتمالی نادر است؛ یک کلاس معمولی در سرور یا <strong>stateless</strong> است (هیچ فیلدی ندارد) یا یک مدل فعال‌سازی دارد که برای هر کلاینت یا هر درخواست یک نمونه‌ی جدا از شیء می‌سازد. تعامل معمولاً فقط از طریق <strong>static fields</strong> رخ می‌دهد، که گاهی برای کش کردن بخش‌هایی از دیتابیس در حافظه جهت بهبود کارایی استفاده می‌شوند.</p>
<p>برای مثال، فرض کنید متدی به نام <strong>RetrieveUser</strong> دارید که یک دیتابیس را کوئری می‌گیرد:</p>
<pre class="hljs"><code><span class="hljs-comment">// User is a custom class with fields for user data</span>
<span class="hljs-function"><span class="hljs-keyword">internal</span> User <span class="hljs-title">RetrieveUser</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span> { ... }
</code></pre>
<p>اگر این متد به دفعات فراخوانی شود، می‌توان عملکرد را با کش کردن نتایج در یک <strong>Dictionary</strong> ایستا بهبود داد. در اینجا یک راه‌حل ساده‌ی مفهومی آورده شده است که ایمنی نخ را نیز در نظر می‌گیرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UserCache</span>
{
  <span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">int</span>, User&gt; _users = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>, User&gt;();
  <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">GetUser</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span>
  {
    User u = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">lock</span> (_users)
      <span class="hljs-keyword">if</span> (_users.TryGetValue (id, <span class="hljs-keyword">out</span> u))
        <span class="hljs-keyword">return</span> u;
    u = RetrieveUser (id);           <span class="hljs-comment">// Method to retrieve from database;</span>
    <span class="hljs-keyword">lock</span> (_users) _users[id] = u;
    <span class="hljs-keyword">return</span> u;
  }
}
</code></pre>
<p>در اینجا باید حداقل هنگام خواندن و به‌روزرسانی دیکشنری قفل‌گذاری کنیم تا ایمنی نخ تضمین شود. این طراحی یک مصالحه‌ی عملی میان سادگی و کارایی در قفل‌گذاری است. اما یک مشکل کوچک ایجاد می‌شود: اگر دو نخ به‌طور همزمان این متد را با یک شناسه‌ی یکسان (که قبلاً واکشی نشده) فراخوانی کنند، متد <strong>RetrieveUser</strong> دوبار اجرا می‌شود و دیکشنری بی‌دلیل به‌روزرسانی خواهد شد.</p>
<p>قفل کردن کل متد جلوی این مشکل را می‌گیرد، اما ناکارآمدی بیشتری ایجاد می‌کند: کل کش برای مدت فراخوانی <strong>RetrieveUser</strong> قفل می‌شود و در این مدت سایر نخ‌ها برای واکشی کاربران دیگر بلاک خواهند شد.</p>
<hr>
<h3>راه‌حل ایده‌آل با Task<User> ⚡</h3>
<p>برای یک راه‌حل ایده‌آل، باید استراتژی‌ای که در بخش «Completing synchronously» صفحه ۶۷۷ توضیح داده شد را به‌کار بگیریم. به جای کش کردن <strong>User</strong>، ما <strong>Task<User></strong> را کش می‌کنیم و فراخواننده آن را <strong>await</strong> می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UserCache</span>
{
  <span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">int</span>, Task&lt;User&gt;&gt; _userTasks = 
     <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>, Task&lt;User&gt;&gt;();
  <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> Task&lt;User&gt; <span class="hljs-title">GetUserAsync</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span>
  {
    <span class="hljs-keyword">lock</span> (_userTasks)
      <span class="hljs-keyword">if</span> (_userTasks.TryGetValue (id, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> userTask))
        <span class="hljs-keyword">return</span> userTask;
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> _userTasks[id] = Task.Run(() =&gt; RetrieveUser(id));
  }
}
</code></pre>
<p>در این نسخه، یک قفل واحد کل منطق متد را پوشش می‌دهد. این کار به همروندی (concurrency) آسیبی نمی‌زند زیرا تنها کاری که داخل قفل انجام می‌دهیم، دسترسی به دیکشنری و (احتمالاً) شروع یک عملیات <strong>asynchronous</strong> با فراخوانی <strong>Task.Run</strong> است.</p>
<p>اگر دو نخ به‌طور همزمان این متد را با همان شناسه (ID) صدا بزنند، هر دو منتظر همان <strong>Task</strong> خواهند ماند؛ که دقیقاً همان چیزی است که می‌خواهیم. ✅</p>
<hr>
<h3>اشیاء تغییرناپذیر (Immutable Objects) 🔒</h3>
<p>یک <strong>immutable object</strong> شیئی است که وضعیتش (state) چه به‌صورت خارجی و چه داخلی، قابل تغییر نباشد. فیلدهای یک شیء immutable معمولاً <strong>read-only</strong> تعریف می‌شوند و در طول سازنده (constructor) مقداردهی کامل می‌شوند.</p>
<p>تغییرناپذیری (immutability) یکی از ویژگی‌های اصلی <strong>برنامه‌نویسی تابعی (functional programming)</strong> است—جایی که به‌جای تغییر دادن یک شیء، یک شیء جدید با ویژگی‌های متفاوت می‌سازید. <strong>LINQ</strong> از این پارادایم پیروی می‌کند.</p>
<p>تغییرناپذیری در برنامه‌های چندنخی نیز ارزشمند است زیرا مشکل <strong>shared writable state</strong> (اشتراک‌گذاری وضعیت قابل‌نوشتن) را از بین می‌برد یا به حداقل می‌رساند.</p>
<p>یک الگوی رایج این است که از اشیاء immutable برای کپسوله کردن گروهی از فیلدهای مرتبط استفاده کنید تا مدت زمان قفل‌گذاری کاهش یابد.</p>
<hr>
<h3>یک مثال ساده 📊</h3>
<p>فرض کنید دو فیلد زیر داریم:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> _percentComplete;
<span class="hljs-built_in">string</span> _statusMessage;
</code></pre>
<p>حالا اگر بخواهیم آن‌ها را به‌طور اتمی (atomic) بخوانیم و بنویسیم، به جای قفل‌گذاری مستقیم روی این فیلدها، می‌توانیم یک کلاس immutable تعریف کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">ProgressStatus</span>    <span class="hljs-comment">// Represents progress of some activity</span>
{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> PercentComplete;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> StatusMessage;
  <span class="hljs-comment">// This class might have many more fields...</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProgressStatus</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> percentComplete, <span class="hljs-built_in">string</span> statusMessage</span>)</span>
  {
    PercentComplete = percentComplete;
    StatusMessage = statusMessage;
  }
}
</code></pre>
<p>سپس می‌توانیم یک فیلد از این نوع به همراه یک شیء قفل تعریف کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> _statusLocker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();
ProgressStatus _status;
</code></pre>
<p>اکنون می‌توانیم مقادیر این نوع را بدون نگه داشتن قفل برای مدت طولانی بخوانیم و بنویسیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> status = <span class="hljs-keyword">new</span> ProgressStatus (<span class="hljs-number">50</span>, <span class="hljs-string">&quot;Working on it&quot;</span>);
<span class="hljs-comment">// Imagine we were assigning many more fields...</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">lock</span> (_statusLocker) _status = status;    <span class="hljs-comment">// Very brief lock</span>
</code></pre>
<p>برای خواندن شیء، ابتدا یک کپی از مرجع شیء را (داخل قفل) می‌گیریم. سپس می‌توانیم مقادیرش را بدون نیاز به نگه داشتن قفل بخوانیم:</p>
<pre class="hljs"><code>ProgressStatus status;
<span class="hljs-keyword">lock</span> (_statusLocker) status = _status;   <span class="hljs-comment">// Again, a brief lock</span>
<span class="hljs-built_in">int</span> pc = status.PercentComplete;
<span class="hljs-built_in">string</span> msg = status.StatusMessage;
...
</code></pre>
<h3>قفل غیرانحصاری (Nonexclusive Locking) 🔓</h3>
<p>ساختارهای قفل <strong>غیرانحصاری</strong> برای محدود کردن هم‌زمانی (concurrency) به‌کار می‌روند. در این بخش، به <strong>Semaphore</strong> و <strong>Read/Writer Locks</strong> می‌پردازیم و نشان می‌دهیم که چگونه کلاس <strong>SemaphoreSlim</strong> می‌تواند هم‌زمانی را در عملیات <strong>آسنکرون</strong> محدود کند.</p>
<hr>
<h3>Semaphore 🕺</h3>
<p>یک <strong>Semaphore</strong> شبیه یک <strong>کلاب شبانه</strong> با ظرفیت محدود است که توسط <strong>دربان (bouncer)</strong> مدیریت می‌شود.</p>
<ul>
<li>وقتی کلاب پر است، کسی نمی‌تواند وارد شود و صفی خارج از کلاب تشکیل می‌شود.</li>
<li>تعداد Semaphore برابر است با تعداد جایگاه‌ها در کلاب.</li>
<li><strong>Release</strong> کردن یک Semaphore تعداد را افزایش می‌دهد؛ معمولاً وقتی کسی کلاب را ترک می‌کند (مطابقت با آزاد شدن یک منبع)، یا وقتی Semaphore مقداردهی اولیه می‌شود.</li>
<li>می‌توان در هر زمان <strong>Release</strong> کرد تا ظرفیت افزایش یابد.</li>
</ul>
<p><strong>Wait کردن روی یک Semaphore</strong> تعداد آن را کاهش می‌دهد و معمولاً قبل از گرفتن یک منبع انجام می‌شود. اگر <strong>Wait</strong> روی Semaphore‌ای با مقدار فعلی بزرگ‌تر از صفر انجام شود، بلافاصله تکمیل می‌شود.</p>
<p>Semaphore می‌تواند حداکثر تعداد (maximum count) داشته باشد که یک محدودیت سخت محسوب می‌شود. افزایش مقدار بیش از این حد باعث پرتاب استثناء خواهد شد. هنگام ایجاد Semaphore، مقدار اولیه (initial count) و اختیاری حداکثر مقدار مشخص می‌شود.</p>
<hr>
<p>یک <strong>Semaphore</strong> با مقدار اولیه یک شبیه <strong>Mutex</strong> یا <strong>lock</strong> است، با این تفاوت که <strong>Semaphore</strong> مالک (owner) ندارد و مستقل از نخ است. هر نخ می‌تواند <strong>Release</strong> کند، در حالی که در Mutex و lock فقط نخ دریافت‌کننده‌ی قفل می‌تواند آن را آزاد کند.</p>
<p>دو نسخه‌ی عملکردی مشابه وجود دارد: <strong>Semaphore</strong> و <strong>SemaphoreSlim</strong>. نسخه‌ی دوم برای برنامه‌نویسی موازی با تأخیر پایین بهینه شده است و در <strong>multithreading</strong> سنتی نیز مفید است، زیرا اجازه می‌دهد <strong>CancellationToken</strong> هنگام <strong>Wait</strong> مشخص شود و یک متد <strong>WaitAsync</strong> برای برنامه‌نویسی آسنکرون ارائه می‌دهد. اما برای سیگنال‌دهی بین فرآیندها (interprocess) کاربرد ندارد.</p>
<ul>
<li><strong>Semaphore</strong> حدود ۱ میکروثانیه برای فراخوانی <strong>WaitOne</strong> و <strong>Release</strong> صرف می‌کند.</li>
<li><strong>SemaphoreSlim</strong> تقریباً یک‌دهم این زمان را مصرف می‌کند.</li>
</ul>
<hr>
<h3>کاربرد Semaphore برای محدود کردن هم‌زمانی ⚡</h3>
<p>Semaphore برای جلوگیری از اجرای بیش از حد نخ‌ها روی یک بخش خاص از کد مفید است.</p>
<p>مثالی داریم که پنج نخ تلاش می‌کنند وارد یک کلاب شوند که فقط سه نخ همزمان اجازه ورود دارند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">TheClub</span>
{
  <span class="hljs-keyword">static</span> SemaphoreSlim _sem = <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">3</span>);    <span class="hljs-comment">// ظرفیت ۳</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
  {
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) <span class="hljs-keyword">new</span> Thread(Enter).Start(i);
  }

  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enter</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> id</span>)</span>
  {
    Console.WriteLine(id + <span class="hljs-string">&quot; wants to enter&quot;</span>);
    _sem.Wait();
    Console.WriteLine(id + <span class="hljs-string">&quot; is in!&quot;</span>);           <span class="hljs-comment">// حداکثر سه نخ</span>
    Thread.Sleep(<span class="hljs-number">1000</span> * (<span class="hljs-built_in">int</span>)id);               <span class="hljs-comment">// می‌توانند همزمان</span>
    Console.WriteLine(id + <span class="hljs-string">&quot; is leaving&quot;</span>);      <span class="hljs-comment">// در کلاب باشند</span>
    _sem.Release();
  }
}
</code></pre>
<p>نمونه خروجی ممکن:</p>
<pre class="hljs"><code>1 wants to enter
1 is in!
2 wants to enter
2 is in!
3 wants to enter
3 is in!
4 wants to enter
5 wants to enter
1 is leaving
4 is in!
2 is leaving
5 is in!
</code></pre>
<hr>
<p>همچنین قانونی است که Semaphore را با <strong>مقدار اولیه صفر</strong> ایجاد کنید و سپس با <strong>Release</strong> تعداد آن را افزایش دهید. مثال زیر دو Semaphore معادل را نشان می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> semaphore1 = <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">3</span>);
<span class="hljs-keyword">var</span> semaphore2 = <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">0</span>); 
semaphore2.Release(<span class="hljs-number">3</span>);
</code></pre>
<p>اگر Semaphore نام‌گذاری شده باشد، می‌تواند مانند Mutex بین فرآیندها نیز مورد استفاده قرار گیرد. (Semaphore نام‌گذاری شده فقط در Windows موجود است، در حالی که Mutex نام‌گذاری شده روی Unix هم کار می‌کند.)</p>
<h3>Semaphoreها و قفل‌های آسنکرون (Asynchronous Semaphores and Locks) ⏳</h3>
<p>قفل کردن (lock) <strong>در یک عبارت await غیرمجاز است</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">lock</span> (_locker)
{
  <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);    <span class="hljs-comment">// خطای کامپایل</span>
  ...
}
</code></pre>
<p>دلیلش ساده است: قفل‌ها به یک <strong>نخ خاص</strong> تعلق دارند، و هنگام بازگشت از <code>await</code> معمولاً نخ تغییر می‌کند. علاوه بر این، <strong>lock بلوک‌کننده است</strong> و بلوک کردن برای یک بازه طولانی دقیقاً همان چیزی است که در برنامه‌های آسنکرون نمی‌خواهید.</p>
<hr>
<p>با این حال، گاهی اوقات می‌خواهیم عملیات آسنکرون <strong>به صورت متوالی اجرا شوند</strong> یا تعداد عملیات همزمان را محدود کنیم تا بیش از n عملیات همزمان رخ ندهد.</p>
<p>مثال: یک مرورگر وب ممکن است نیاز داشته باشد تا دانلودها را به‌صورت آسنکرون و همزمان انجام دهد، اما بخواهد محدودیت حداکثر ۱۰ دانلود همزمان را اعمال کند. این کار را می‌توان با <strong>SemaphoreSlim</strong> انجام داد:</p>
<pre class="hljs"><code>SemaphoreSlim _semaphore = <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">10</span>);

<span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">byte</span>[]&gt; DownloadWithSemaphoreAsync(<span class="hljs-built_in">string</span> uri)
{
    <span class="hljs-keyword">await</span> _semaphore.WaitAsync();
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> WebClient().DownloadDataTaskAsync(uri);
    }
    <span class="hljs-keyword">finally</span>
    {
        _semaphore.Release();
    }
}
</code></pre>
<ul>
<li>اگر <code>initialCount</code> Semaphore را به ۱ کاهش دهیم، حداکثر هم‌زمانی به ۱ محدود می‌شود و عملاً یک <strong>قفل آسنکرون</strong> ایجاد می‌کند.</li>
</ul>
<hr>
<h3>نوشتن یک متد extension به نام <code>EnterAsync</code></h3>
<p>متد extension زیر استفاده آسنکرون از <strong>SemaphoreSlim</strong> را ساده‌تر می‌کند، با استفاده از کلاس <strong>Disposable</strong> که در بخش “Anonymous Disposal” معرفی شد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task&lt;IDisposable&gt; <span class="hljs-title">EnterAsync</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> SemaphoreSlim ss</span>)</span>
{
    <span class="hljs-keyword">await</span> ss.WaitAsync().ConfigureAwait(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">return</span> Disposable.Create(() =&gt; ss.Release());
}
</code></pre>
<p>با این متد می‌توانیم روش قبلی دانلود را به شکل ساده‌تر بازنویسی کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">byte</span>[]&gt; DownloadWithSemaphoreAsync(<span class="hljs-built_in">string</span> uri)
{
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">await</span> _semaphore.EnterAsync())
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> WebClient().DownloadDataTaskAsync(uri);
}
</code></pre>
<hr>
<h3>Parallel.ForEachAsync</h3>
<p>از <strong>.NET 6</strong>، روش دیگری برای محدود کردن هم‌زمانی آسنکرون وجود دارد: <strong>Parallel.ForEachAsync</strong>.</p>
<p>فرض کنید آرایه‌ای از URIها داریم که می‌خواهیم دانلود کنیم. می‌توانیم آنها را به‌صورت همزمان دانلود کنیم و هم‌زمانی را به حداکثر ۱۰ عملیات محدود کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">await</span> Parallel.ForEachAsync(
    uris,
    <span class="hljs-keyword">new</span> ParallelOptions { MaxDegreeOfParallelism = <span class="hljs-number">10</span> },
    <span class="hljs-keyword">async</span> (uri, cancelToken) =&gt;
    {
        <span class="hljs-keyword">var</span> download = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> HttpClient().GetByteArrayAsync(uri);
        Console.WriteLine(<span class="hljs-string">$&quot;Downloaded <span class="hljs-subst">{download.Length}</span> bytes&quot;</span>);
    });
</code></pre>
<ul>
<li>سایر متدهای کلاس <strong>Parallel</strong> بیشتر برای سناریوهای برنامه‌نویسی موازی محاسباتی (<strong>compute-bound</strong>) استفاده می‌شوند، که در فصل ۲۲ بررسی شده‌اند.</li>
</ul>
<h3>قفل‌های خواندن/نوشتن (Reader/Writer Locks) 📖</h3>
<p>اغلب اوقات، نمونه‌های یک نوع داده <strong>برای خواندن همزمان ایمن هستند</strong>، اما <strong>برای به‌روزرسانی همزمان یا ترکیبی از خواندن و نوشتن ایمن نیستند</strong>.<br>
این موضوع می‌تواند در مورد منابعی مانند فایل‌ها هم صادق باشد.</p>
<ul>
<li>استفاده از یک <strong>قفل انحصاری ساده</strong> (exclusive lock) معمولاً مشکل را حل می‌کند،</li>
<li>اما اگر تعداد زیادی خواننده و فقط به‌روزرسانی‌های گاه‌به‌گاه داشته باشیم، این کار <strong>محدودیت زیادی روی همزمانی ایجاد می‌کند</strong>.</li>
</ul>
<p>مثالی از چنین سناریویی در <strong>سرورهای تجاری</strong> است که داده‌های پرکاربرد را در <strong>فیلدهای static</strong> برای دسترسی سریع کش می‌کنند.</p>
<hr>
<h3>کلاس <code>ReaderWriterLockSlim</code></h3>
<p>این کلاس برای <strong>حداکثر دسترسی همزمان</strong> در چنین شرایطی طراحی شده است و جایگزین کلاس قدیمی‌تر و “چاق” <strong>ReaderWriterLock</strong> است:</p>
<ul>
<li>کلاس قدیمی چندین بار کندتر بود و یک مشکل طراحی در ارتقای قفل داشت.</li>
<li>در مقایسه با یک قفل معمولی (<code>Monitor.Enter/Exit</code>) هنوز دو برابر کندتر است، اما <strong>مزیت آن کاهش رقابت (contention) هنگام خواندن زیاد و نوشتن کم است</strong>.</li>
</ul>
<hr>
<h3>انواع قفل</h3>
<p>دو نوع اصلی قفل داریم:</p>
<ul>
<li><strong>Write lock (قفل نوشتن)</strong>: کاملاً انحصاری است.</li>
<li><strong>Read lock (قفل خواندن)</strong>: با سایر read lockها سازگار است.</li>
</ul>
<blockquote>
<p>اگر یک نخ write lock داشته باشد، تمام نخ‌های دیگر که قصد read یا write دارند، مسدود می‌شوند. اما اگر هیچ write lockی وجود نداشته باشد، هر تعداد نخ می‌تواند همزمان read lock بگیرد.</p>
</blockquote>
<hr>
<h3>متدهای مهم <code>ReaderWriterLockSlim</code></h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EnterReadLock</span>()</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExitReadLock</span>()</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EnterWriteLock</span>()</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExitWriteLock</span>()</span>;
</code></pre>
<ul>
<li>نسخه‌های <strong>Try</strong> هم وجود دارد که timeout می‌پذیرند (مشابه <code>Monitor.TryEnter</code>)</li>
<li>کلاس قدیمی ReaderWriterLock روش‌های مشابهی به نام‌های <code>AcquireXXX</code> و <code>ReleaseXXX</code> دارد که در صورت timeout <strong>ApplicationException</strong> پرتاب می‌کند.</li>
</ul>
<hr>
<h3>مثال عملی</h3>
<p>سه نخ مرتباً یک لیست را می‌خوانند و دو نخ دیگر هر ۱۰۰ میلی‌ثانیه یک عدد تصادفی به لیست اضافه می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">SlimDemo</span>
{
    <span class="hljs-keyword">static</span> ReaderWriterLockSlim _rw = <span class="hljs-keyword">new</span> ReaderWriterLockSlim();
    <span class="hljs-keyword">static</span> List&lt;<span class="hljs-built_in">int</span>&gt; _items = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();
    <span class="hljs-keyword">static</span> Random _rand = <span class="hljs-keyword">new</span> Random();

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        <span class="hljs-keyword">new</span> Thread(Read).Start();
        <span class="hljs-keyword">new</span> Thread(Read).Start();
        <span class="hljs-keyword">new</span> Thread(Read).Start();
        <span class="hljs-keyword">new</span> Thread(Write).Start(<span class="hljs-string">&quot;A&quot;</span>);
        <span class="hljs-keyword">new</span> Thread(Write).Start(<span class="hljs-string">&quot;B&quot;</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Read</span>()</span>
    {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
        {
            _rw.EnterReadLock();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span> _items) Thread.Sleep(<span class="hljs-number">10</span>);
            _rw.ExitReadLock();
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Write</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> threadID</span>)</span>
    {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
        {
            <span class="hljs-built_in">int</span> newNumber = GetRandNum(<span class="hljs-number">100</span>);
            _rw.EnterWriteLock();
            _items.Add(newNumber);
            _rw.ExitWriteLock();
            Console.WriteLine(<span class="hljs-string">&quot;Thread &quot;</span> + threadID + <span class="hljs-string">&quot; added &quot;</span> + newNumber);
            Thread.Sleep(<span class="hljs-number">100</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetRandNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> max</span>)</span> { <span class="hljs-keyword">lock</span> (_rand) <span class="hljs-keyword">return</span> _rand.Next(max); }
}
</code></pre>
<ul>
<li>در کد تولیدی واقعی، معمولاً از <strong>try/finally</strong> برای اطمینان از آزاد شدن قفل‌ها در صورت بروز استثنا استفاده می‌کنیم.</li>
<li>خروجی نمونه:</li>
</ul>
<pre class="hljs"><code>Thread B added 61
Thread A added 83
Thread B added 55
Thread A added 33
...
</code></pre>
<hr>
<h3>مزیت اصلی</h3>
<p><code>ReaderWriterLockSlim</code> <strong>امکان خواندن همزمان بیشتری نسبت به قفل ساده فراهم می‌کند</strong>.</p>
<ul>
<li>برای مشاهده تعداد نخ‌های concurrent خواننده می‌توانیم در متد Write بنویسیم:</li>
</ul>
<pre class="hljs"><code>Console.WriteLine(_rw.CurrentReadCount + <span class="hljs-string">&quot; concurrent readers&quot;</span>);
</code></pre>
<ul>
<li>اغلب اوقات این مقدار ۳ concurrent readers خواهد بود، زیرا متدهای Read بیشتر زمان خود را در حلقه <code>foreach</code> می‌گذرانند.</li>
</ul>
<hr>
<h3>ویژگی‌ها و پروپرتی‌های مانیتورینگ</h3>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsReadLockHeld            { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsUpgradeableReadLockHeld { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsWriteLockHeld           { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  WaitingReadCount          { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  WaitingUpgradeCount       { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  WaitingWriteCount         { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  RecursiveReadCount        { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  RecursiveUpgradeCount     { <span class="hljs-keyword">get</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>  RecursiveWriteCount       { <span class="hljs-keyword">get</span>; }
</code></pre>
<p>این ویژگی‌ها به برنامه‌نویس امکان <strong>مانیتور کردن وضعیت قفل‌ها</strong> و بهینه‌سازی عملکرد را می‌دهد.</p>
<h3>قفل‌های قابل ارتقا (Upgradeable Locks) 🔄</h3>
<p>گاهی لازم است که <strong>یک read lock را به write lock تبدیل کنیم</strong> به صورت <strong>اتمی</strong> (atomic).<br>
مثلاً فرض کنید می‌خواهیم یک آیتم به لیست اضافه کنیم <strong>فقط در صورتی که قبلاً وجود نداشته باشد</strong>.</p>
<p>ایده این است که زمان نگه داشتن write lock را <strong>به حداقل برسانیم</strong>، و معمولاً مراحل زیر را دنبال می‌کنیم:</p>
<ol>
<li>گرفتن یک <strong>read lock</strong>.</li>
<li>بررسی اینکه آیا آیتم قبلاً در لیست هست یا نه؛ اگر هست، قفل را آزاد کرده و باز می‌گردیم.</li>
<li>آزاد کردن read lock.</li>
<li>گرفتن <strong>write lock</strong>.</li>
<li>اضافه کردن آیتم به لیست.</li>
</ol>
<p>💡 مشکل: بین مراحل ۳ و ۴، <strong>یک نخ دیگر ممکن است وارد شده و لیست را تغییر دهد</strong> (مثلاً همان آیتم را اضافه کند).</p>
<hr>
<h3>راه‌حل <code>ReaderWriterLockSlim</code></h3>
<p>کلاس <code>ReaderWriterLockSlim</code> برای این مشکل، <strong>نوع سومی از قفل</strong> ارائه می‌دهد: <strong>upgradeable lock</strong>.</p>
<ul>
<li>این قفل شبیه read lock است، اما می‌توان آن را <strong>بعداً به write lock ارتقا داد</strong> به صورت اتمی.</li>
</ul>
<p>مراحل استفاده از Upgradeable Lock:</p>
<ol>
<li>فراخوانی <code>EnterUpgradeableReadLock()</code></li>
<li>انجام عملیات مبتنی بر خواندن (مثلاً بررسی وجود آیتم)</li>
<li>فراخوانی <code>EnterWriteLock()</code> → این مرحله <strong>قفل قابل ارتقا را به write lock تبدیل می‌کند</strong></li>
<li>انجام عملیات نوشتن (مثلاً اضافه کردن آیتم به لیست)</li>
<li>فراخوانی <code>ExitWriteLock()</code> → write lock به upgradeable lock باز می‌گردد</li>
<li>انجام هر عملیات خواندنی دیگر</li>
<li>فراخوانی <code>ExitUpgradeableReadLock()</code></li>
</ol>
<blockquote>
<p>از دید برنامه‌نویس، این مانند <strong>قفل‌های تو در تو یا بازگشتی (nested/recursive)</strong> است.<br>
از نظر عملکرد، در مرحله ۳، <code>ReaderWriterLockSlim</code> <strong>read lock قبلی را آزاد کرده و write lock جدید می‌گیرد به صورت اتمی</strong>.</p>
</blockquote>
<hr>
<h3>تفاوت مهم با read lock</h3>
<ul>
<li>یک upgradeable lock می‌تواند <strong>همزمان با تعداد زیادی read lock</strong> وجود داشته باشد.</li>
<li>اما <strong>تنها یک upgradeable lock می‌تواند همزمان گرفته شود</strong>.</li>
<li>این محدودیت <strong>از deadlock هنگام تبدیل جلوگیری می‌کند</strong>، مشابه کاری که <strong>update lock در SQL Server</strong> انجام می‌دهد.</li>
</ul>
 <div align="center">
<p><img src="../../../assets/image/21/Table-21-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>مثال عملی از Upgradeable Lock و قفل بازگشتی 🔄</h3>
<p>می‌توانیم <strong>Upgradeable Lock</strong> را با تغییر متد <code>Write</code> در مثال قبلی نشان دهیم، به طوری که <strong>یک عدد به لیست اضافه شود فقط اگر قبلاً وجود نداشته باشد</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
{
    <span class="hljs-built_in">int</span> newNumber = GetRandNum(<span class="hljs-number">100</span>);
    _rw.EnterUpgradeableReadLock();

    <span class="hljs-keyword">if</span> (!_items.Contains(newNumber))
    {
        _rw.EnterWriteLock();
        _items.Add(newNumber);
        _rw.ExitWriteLock();
        Console.WriteLine(<span class="hljs-string">&quot;Thread &quot;</span> + threadID + <span class="hljs-string">&quot; added &quot;</span> + newNumber);
    }

    _rw.ExitUpgradeableReadLock();
    Thread.Sleep(<span class="hljs-number">100</span>);
}
</code></pre>
<hr>
<h3>قفل بازگشتی (Lock Recursion) 🔁</h3>
<ul>
<li><code>ReaderWriterLock</code> قدیمی می‌تواند تبدیل قفل‌ها را انجام دهد، اما <strong>غیرقابل اعتماد</strong> است و مفهوم <strong>upgradeable lock</strong> را ندارد.</li>
<li><code>ReaderWriterLockSlim</code> به طور پیش‌فرض <strong>قفل‌های بازگشتی یا تو در تو را مجاز نمی‌داند</strong>.</li>
</ul>
<p>مثال خطا‌دهنده:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> rw = <span class="hljs-keyword">new</span> ReaderWriterLockSlim();
rw.EnterReadLock();
rw.EnterReadLock();  <span class="hljs-comment">// Exception!</span>
rw.ExitReadLock();
rw.ExitReadLock();
</code></pre>
<p>برای پشتیبانی از قفل بازگشتی، باید هنگام ساخت کلاس مشخص کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> rw = <span class="hljs-keyword">new</span> ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);
</code></pre>
<p>💡 قانون اصلی برای قفل‌های بازگشتی: پس از گرفتن یک قفل، <strong>قفل‌های بعدی می‌توانند کمتر اما نه بیشتر از نوع اولیه باشند</strong>:</p>
<pre class="hljs"><code>Read Lock → Upgradeable Lock → Write Lock
</code></pre>
<ul>
<li>ارتقاء upgradeable lock به write lock همیشه مجاز است.</li>
</ul>
<p>مثال ترکیبی:</p>
<pre class="hljs"><code>rw.EnterWriteLock();
rw.EnterReadLock();
Console.WriteLine(rw.IsReadLockHeld);   <span class="hljs-comment">// True</span>
Console.WriteLine(rw.IsWriteLockHeld);  <span class="hljs-comment">// True</span>
rw.ExitReadLock();
rw.ExitWriteLock();
</code></pre>
<hr>
<h3>سیگنال‌دهی با Event Wait Handles 🔔</h3>
<p><strong>Event Wait Handle</strong> ساده‌ترین ابزار برای سیگنال‌دهی بین نخ‌ها است و <strong>مرتبط با C# events نیست</strong>.<br>
انواع اصلی:</p>
<ul>
<li><code>AutoResetEvent</code></li>
<li><code>ManualResetEvent</code> / <code>ManualResetEventSlim</code></li>
<li><code>CountdownEvent</code></li>
</ul>
<p>تمام این‌ها از کلاس پایه <code>EventWaitHandle</code> مشتق شده‌اند.</p>
<hr>
<h4>AutoResetEvent 🎟️</h4>
<ul>
<li>شبیه <strong>گذرگاه بلیت (turnstile)</strong> است: ورود بلیت فقط یک نفر را عبور می‌دهد.</li>
<li>پس از عبور، گذرگاه به طور خودکار <strong>reset</strong> می‌شود.</li>
<li>یک نخ با <code>WaitOne()</code> منتظر می‌ماند و یک نخ دیگر با <code>Set()</code> آن را آزاد می‌کند.</li>
</ul>
<p>ساخت AutoResetEvent:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> auto = <span class="hljs-keyword">new</span> AutoResetEvent(<span class="hljs-literal">false</span>);  
<span class="hljs-comment">// یا</span>
<span class="hljs-keyword">var</span> auto = <span class="hljs-keyword">new</span> EventWaitHandle(<span class="hljs-literal">false</span>, EventResetMode.AutoReset);
</code></pre>
<p>مثال ساده:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">BasicWaitHandle</span>
{
    <span class="hljs-keyword">static</span> EventWaitHandle _waitHandle = <span class="hljs-keyword">new</span> AutoResetEvent(<span class="hljs-literal">false</span>);

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        <span class="hljs-keyword">new</span> Thread(Waiter).Start();
        Thread.Sleep(<span class="hljs-number">1000</span>);       <span class="hljs-comment">// مکث یک ثانیه</span>
        _waitHandle.Set();        <span class="hljs-comment">// فعال کردن Waiter</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Waiter</span>()</span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;Waiting...&quot;</span>);
        _waitHandle.WaitOne();    <span class="hljs-comment">// انتظار برای سیگنال</span>
        Console.WriteLine(<span class="hljs-string">&quot;Notified&quot;</span>);
    }
}
</code></pre>
<p><strong>خروجی:</strong></p>
<pre class="hljs"><code>Waiting... (pause) Notified
</code></pre>
 <div align="center">
<p><img src="../../../assets/image/21/Table-21-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>رفتار <code>Set</code> وقتی هیچ نخی منتظر نیست ⚠️</h3>
<ul>
<li>اگر <code>Set()</code> فراخوانی شود و هیچ نخ منتظری وجود نداشته باشد، <strong>handle باز می‌ماند</strong> تا زمانی که یک نخ <code>WaitOne()</code> فراخوانی کند.</li>
<li>این رفتار از <strong>رقابت بین نخ‌ها جلوگیری می‌کند</strong>: نخ می‌خواهد وارد گذرگاه شود و نخ دیگر زودتر <code>Set()</code> زده باشد.</li>
<li>اما، <strong>فراخوانی مکرر <code>Set()</code> وقتی هیچ‌کس منتظر نیست، باعث عبور چند نفر نمی‌شود</strong>؛ فقط نفر بعدی عبور می‌کند و بلیت‌های اضافی «هدر می‌روند».</li>
</ul>
<hr>
<h3>آزادسازی Wait Handle ♻️</h3>
<ul>
<li>پس از پایان استفاده از wait handle، می‌توان <code>Close()</code> را صدا زد تا منبع سیستم عامل آزاد شود.</li>
<li>یا می‌توان تمام ارجاعات به آن را رها کرد و اجازه داد <strong>garbage collector</strong> بعداً آن را جمع‌آوری کند (wait handleها از الگوی disposal پیروی می‌کنند و finalizer آن‌ها <code>Close()</code> را فراخوانی می‌کند).</li>
<li>Wait handleها هنگام خروج process به طور خودکار آزاد می‌شوند.</li>
</ul>
<h4>نکات مهم</h4>
<ul>
<li><code>Reset()</code> روی AutoResetEvent، گذرگاه را می‌بندد (اگر باز باشد) بدون انتظار یا بلاک کردن.</li>
<li><code>WaitOne(timeout)</code> می‌تواند <strong>مدت انتظار را محدود</strong> کند و اگر timeout رخ دهد، <code>false</code> برمی‌گرداند.</li>
<li><code>WaitOne(0)</code> می‌تواند بررسی کند که آیا wait handle «باز» است بدون بلاک کردن نخ فراخواننده.</li>
</ul>
<blockquote>
<p>⚠️ توجه: این کار باعث <strong>reset شدن AutoResetEvent</strong> اگر باز باشد، می‌شود.</p>
</blockquote>
<hr>
<h3>سیگنال‌دهی دوطرفه ↔️</h3>
<p>اگر بخواهیم نخ اصلی (main thread) به یک نخ worker سه بار متوالی سیگنال بدهد:</p>
<ul>
<li>فراخوانی ساده <code>Set()</code> چند بار پشت سر هم ممکن است باعث <strong>از دست رفتن سیگنال‌ها</strong> شود، زیرا worker ممکن است زمان ببرد تا هر سیگنال را پردازش کند.</li>
<li>راه‌حل: نخ اصلی <strong>صبر کند تا worker آماده شود</strong> قبل از ارسال سیگنال. این کار با یک <code>AutoResetEvent</code> دیگر انجام می‌شود.</li>
</ul>
<p>مثال کامل:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">TwoWaySignaling</span>
{
    <span class="hljs-keyword">static</span> EventWaitHandle _ready = <span class="hljs-keyword">new</span> AutoResetEvent(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">static</span> EventWaitHandle _go = <span class="hljs-keyword">new</span> AutoResetEvent(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> _locker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> _message;

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        <span class="hljs-keyword">new</span> Thread(Work).Start();

        _ready.WaitOne();       <span class="hljs-comment">// منتظر می‌ماند تا worker آماده شود</span>
        <span class="hljs-keyword">lock</span> (_locker) _message = <span class="hljs-string">&quot;ooo&quot;</span>;
        _go.Set();              <span class="hljs-comment">// سیگنال به worker</span>

        _ready.WaitOne();       <span class="hljs-comment">// منتظر می‌ماند تا worker دوباره آماده شود</span>
        <span class="hljs-keyword">lock</span> (_locker) _message = <span class="hljs-string">&quot;ahhh&quot;</span>;
        _go.Set();

        _ready.WaitOne();
        <span class="hljs-keyword">lock</span> (_locker) _message = <span class="hljs-literal">null</span>; <span class="hljs-comment">// سیگنال پایان</span>
        _go.Set();
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Work</span>()</span>
    {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
        {
            _ready.Set();       <span class="hljs-comment">// اعلام آمادگی</span>
            _go.WaitOne();      <span class="hljs-comment">// منتظر سیگنال</span>

            <span class="hljs-keyword">lock</span> (_locker)
            {
                <span class="hljs-keyword">if</span> (_message == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// خروج کنترل‌شده</span>
                Console.WriteLine(_message);
            }
        }
    }
}
</code></pre>
<p><strong>خروجی:</strong></p>
<pre class="hljs"><code>ooo
ahhh
</code></pre>
<ul>
<li>در شکل 21-2 فرآیند آماده شدن و سیگنال‌دهی دوطرفه نشان داده شده است.</li>
</ul>
 <div align="center">
<p><img src="../../../assets/image/21/Table-21-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>استفاده از پیام null برای پایان دادن به worker 🛑</h3>
<ul>
<li>در مثال قبلی، از یک پیام <code>null</code> برای مشخص کردن پایان کار worker استفاده شد.</li>
<li>برای نخ‌هایی که <strong>به‌صورت نامحدود اجرا می‌شوند</strong>، داشتن یک استراتژی خروج ضروری است.</li>
</ul>
<hr>
<h3>ManualResetEvent 🏗️</h3>
<ul>
<li>
<p>همان‌طور که در فصل ۱۴ توضیح داده شد، <code>ManualResetEvent</code> مانند یک <strong>دروازه ساده</strong> عمل می‌کند:</p>
<ul>
<li>فراخوانی <code>Set()</code> دروازه را باز می‌کند و <strong>هر تعداد نخ</strong> که <code>WaitOne()</code> فراخوانی کرده‌اند، عبور می‌دهند.</li>
<li>فراخوانی <code>Reset()</code> دروازه را می‌بندد. نخ‌هایی که <code>WaitOne()</code> روی دروازه بسته صدا می‌زنند، <strong>بلاک می‌شوند</strong> تا دروازه باز شود.</li>
</ul>
</li>
<li>
<p>عملکرد کلی مشابه <code>AutoResetEvent</code> است.</p>
</li>
</ul>
<h4>ساخت ManualResetEvent</h4>
<pre class="hljs"><code><span class="hljs-keyword">var</span> manual1 = <span class="hljs-keyword">new</span> ManualResetEvent(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">var</span> manual2 = <span class="hljs-keyword">new</span> EventWaitHandle(<span class="hljs-literal">false</span>, EventResetMode.ManualReset);
</code></pre>
<ul>
<li>نسخه بهینه‌تری به نام <code>ManualResetEventSlim</code> وجود دارد که برای <strong>زمان انتظار کوتاه</strong> بهینه شده و امکان <strong>استفاده از CancellationToken</strong> را دارد.</li>
<li><code>ManualResetEventSlim</code> subclass از <code>WaitHandle</code> نیست اما دارای ویژگی <code>WaitHandle</code> است که یک <strong>object مبتنی بر WaitHandle</strong> برمی‌گرداند.</li>
</ul>
<hr>
<h3>عملکرد و کارایی ⏱️</h3>
<ul>
<li>انتظار یا سیگنال دادن با <code>AutoResetEvent</code> یا <code>ManualResetEvent</code> حدود <strong>یک میکروثانیه</strong> طول می‌کشد (اگر بلاک نشود).</li>
<li><code>ManualResetEventSlim</code> و <code>CountdownEvent</code> می‌توانند <strong>تا ۵۰ برابر سریع‌تر</strong> در زمان انتظار کوتاه عمل کنند، به دلیل عدم وابستگی به OS و استفاده از <strong>spinning constructs</strong>.</li>
<li>با این حال، در اکثر سناریوها، overhead این کلاس‌ها معمولاً <strong>گلوگاه ایجاد نمی‌کند</strong>.</li>
</ul>
<hr>
<h3>کاربرد ManualResetEvent و CountdownEvent</h3>
<ul>
<li><code>ManualResetEvent</code>: برای <strong>باز کردن یک نخ برای چند نخ دیگر</strong> مفید است.</li>
<li><code>CountdownEvent</code>: برای <strong>منتظر ماندن روی چند نخ</strong> استفاده می‌شود.</li>
</ul>
<h4>CountdownEvent</h4>
<pre class="hljs"><code><span class="hljs-keyword">var</span> countdown = <span class="hljs-keyword">new</span> CountdownEvent(<span class="hljs-number">3</span>); <span class="hljs-comment">// مقدار اولیه ۳ نخ</span>

<span class="hljs-keyword">new</span> Thread(SaySomething).Start(<span class="hljs-string">&quot;I am thread 1&quot;</span>);
<span class="hljs-keyword">new</span> Thread(SaySomething).Start(<span class="hljs-string">&quot;I am thread 2&quot;</span>);
<span class="hljs-keyword">new</span> Thread(SaySomething).Start(<span class="hljs-string">&quot;I am thread 3&quot;</span>);

countdown.Wait(); <span class="hljs-comment">// بلوک تا ۳ بار Signal فراخوانی شود</span>
Console.WriteLine(<span class="hljs-string">&quot;All threads have finished speaking!&quot;</span>);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaySomething</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> thing</span>)</span>
{
    Thread.Sleep(<span class="hljs-number">1000</span>);
    Console.WriteLine(thing);
    countdown.Signal(); <span class="hljs-comment">// کاهش count</span>
}
</code></pre>
<ul>
<li>می‌توان count را با <code>AddCount</code> افزایش داد، اما اگر شمارش به صفر رسیده باشد، <strong>استثنا ایجاد می‌کند</strong>.</li>
<li>برای جلوگیری از خطا، از <code>TryAddCount</code> استفاده می‌کنیم که <strong>false</strong> برمی‌گرداند اگر شمارش صفر باشد.</li>
<li>برای “unsignal” کردن یک CountdownEvent از <code>Reset()</code> استفاده می‌کنیم که <strong>count را به مقدار اولیه بازنشانی می‌کند</strong>.</li>
<li>مشابه <code>ManualResetEventSlim</code>، CountdownEvent دارای ویژگی <code>WaitHandle</code> برای تعامل با کلاس‌هایی که <strong>WaitHandle انتظار دارند</strong>، است.</li>
</ul>
<hr>
<h3>ایجاد EventWaitHandle میان پردازشی 🌐</h3>
<ul>
<li>می‌توان یک EventWaitHandle <strong>نام‌دار</strong> ایجاد کرد که بین چند پردازش کار کند.</li>
<li>نام تنها یک رشته است و باید <strong>منحصربه‌فرد باشد</strong> تا با سایر منابع تداخل نکند.</li>
</ul>
<pre class="hljs"><code>EventWaitHandle wh = <span class="hljs-keyword">new</span> EventWaitHandle(
    <span class="hljs-literal">false</span>,
    EventResetMode.AutoReset,
    <span class="hljs-string">@&quot;Global\MyCompany.MyApp.SomeName&quot;</span>
);
</code></pre>
<ul>
<li>اگر دو برنامه این کد را اجرا کنند، می‌توانند <strong>به هم سیگنال دهند</strong>: wait handle در همه نخ‌ها و پردازش‌ها کار می‌کند.</li>
<li>توجه: <strong>Named EventWaitHandle فقط در Windows موجود است</strong>.</li>
</ul>
<h3>Wait Handles و Continuations 🔄</h3>
<p>به جای <strong>منتظر ماندن روی یک wait handle</strong> و بلاک کردن نخ، می‌توان یک <strong>continuation</strong> به آن ضمیمه کرد با استفاده از <code>ThreadPool.RegisterWaitForSingleObject</code>.</p>
<h4>مثال</h4>
<pre class="hljs"><code><span class="hljs-keyword">var</span> starter = <span class="hljs-keyword">new</span> ManualResetEvent(<span class="hljs-literal">false</span>);

RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject(
    starter, Go, <span class="hljs-string">&quot;Some Data&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">true</span>);

Thread.Sleep(<span class="hljs-number">5000</span>);
Console.WriteLine(<span class="hljs-string">&quot;Signaling worker...&quot;</span>);
starter.Set();
Console.ReadLine();

reg.Unregister(starter); <span class="hljs-comment">// پاک‌سازی پس از اتمام</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Go</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> data, <span class="hljs-built_in">bool</span> timedOut</span>)</span>
{
    Console.WriteLine(<span class="hljs-string">&quot;Started - &quot;</span> + data);
    <span class="hljs-comment">// انجام کار...</span>
}
</code></pre>
<ul>
<li>زمانی که wait handle <strong>signaled</strong> می‌شود (یا timeout رخ می‌دهد)، delegate روی یک نخ از ThreadPool اجرا می‌شود.</li>
<li>پس از آن باید <code>Unregister</code> فراخوانی شود تا <strong>handle غیرمدیریت‌شده</strong> آزاد شود.</li>
<li>این متد همچنین یک <strong>object “black box”</strong> می‌گیرد که به delegate منتقل می‌شود، یک <strong>timeout</strong> (میلی‌ثانیه، <code>-1</code> یعنی بدون timeout) و یک <strong>Boolean</strong> که مشخص می‌کند آیا فراخوانی یک‌باره است یا مکرر.</li>
</ul>
<p>⚠️ نکته:</p>
<ul>
<li>می‌توان <code>RegisterWaitForSingleObject</code> را <strong>فقط یک بار برای هر wait handle</strong> فراخوانی کرد.</li>
<li>فراخوانی دوباره روی همان wait handle ممکن است باعث شود callback حتی وقتی handle signaled نشده، اجرا شود.</li>
<li>به همین دلیل، wait handles غیر-Slim برای برنامه‌نویسی asynchronous مناسب نیستند.</li>
</ul>
<hr>
<h3>WaitAny، WaitAll و SignalAndWait ⏳🔄</h3>
<p>علاوه بر متدهای <strong>Set</strong>، <strong>WaitOne</strong> و <strong>Reset</strong>، کلاس <strong>WaitHandle</strong> دارای متدهای استاتیک دیگری است که برای حل مسائل پیچیده‌تر همزمان‌سازی کاربرد دارند. متدهای <strong>WaitAny</strong>، <strong>WaitAll</strong> و <strong>SignalAndWait</strong> عملیات‌های سیگنال‌دهی و انتظار را روی چندین <strong>wait handle</strong> انجام می‌دهند. این <strong>wait handle</strong>ها می‌توانند از انواع مختلف باشند (از جمله <strong>Mutex</strong> و <strong>Semaphore</strong>، زیرا این‌ها نیز از کلاس انتزاعی <strong>WaitHandle</strong> مشتق شده‌اند).</p>
<p>همچنین، <strong>ManualResetEventSlim</strong> و <strong>CountdownEvent</strong> می‌توانند از طریق ویژگی‌های <strong>WaitHandle</strong> خود در این متدها شرکت کنند.</p>
<p>متدهای <strong>WaitAll</strong> و <strong>SignalAndWait</strong> ارتباط عجیبی با معماری قدیمی <strong>COM</strong> دارند: این متدها نیازمند آن هستند که فراخواننده در یک <strong>multithreaded apartment</strong> باشد، مدلی که برای تعامل با دیگر سیستم‌ها چندان مناسب نیست. به‌عنوان مثال، <strong>thread اصلی</strong> یک برنامه <strong>WPF</strong> یا <strong>Windows Forms</strong> در این حالت نمی‌تواند با <strong>clipboard</strong> تعامل کند. جایگزین‌ها را در ادامه بررسی خواهیم کرد.</p>
<ul>
<li><strong>WaitHandle.WaitAny</strong> منتظر می‌ماند تا هر یک از آرایه‌ای از <strong>wait handle</strong>ها سیگنال بگیرند.</li>
<li><strong>WaitHandle.WaitAll</strong> منتظر می‌ماند تا همه <strong>wait handle</strong>های داده‌شده به‌صورت <strong>اتمی</strong> سیگنال بگیرند.</li>
</ul>
<p>این بدان معناست که اگر روی دو <strong>AutoResetEvent</strong> منتظر باشید:</p>
<ul>
<li><strong>WaitAny</strong> هرگز باعث نمی‌شود که هر دو رویداد به‌طور همزمان &quot;قفل&quot; شوند.</li>
<li><strong>WaitAll</strong> هرگز باعث نمی‌شود که تنها یکی از رویدادها &quot;قفل&quot; شود.</li>
</ul>
<p><strong>SignalAndWait</strong> ابتدا <strong>Set</strong> را روی یک <strong>WaitHandle</strong> فراخوانی می‌کند و سپس <strong>WaitOne</strong> را روی <strong>WaitHandle</strong> دیگر صدا می‌زند. پس از سیگنال‌دهی به <strong>handle</strong> اول، به ابتدای صف انتظار برای <strong>handle</strong> دوم می‌رود؛ این کار کمک می‌کند تا عملیات موفق شود (هرچند که عملیات واقعاً اتمی نیست). می‌توان این متد را به‌عنوان «تبادل یک سیگنال با سیگنال دیگر» تصور کرد و آن را روی یک جفت <strong>EventWaitHandle</strong> استفاده کرد تا دو <strong>thread</strong> در یک نقطه زمانی با هم ملاقات یا <strong>rendezvous</strong> داشته باشند. هم <strong>AutoResetEvent</strong> و هم <strong>ManualResetEvent</strong> مناسب این کار هستند.</p>
<ul>
<li><strong>Thread اول</strong> اجرا می‌کند:</li>
</ul>
<pre class="hljs"><code>WaitHandle.SignalAndWait (wh1, wh2);
</code></pre>
<ul>
<li><strong>Thread دوم</strong> کار معکوس را انجام می‌دهد:</li>
</ul>
<pre class="hljs"><code>WaitHandle.SignalAndWait (wh2, wh1);
</code></pre>
<hr>
<h3>جایگزین‌ها برای WaitAll و SignalAndWait 🔁</h3>
<p>متدهای <strong>WaitAll</strong> و <strong>SignalAndWait</strong> در یک <strong>single-threaded apartment</strong> کار نمی‌کنند. خوشبختانه جایگزین‌هایی وجود دارند. در مورد <strong>SignalAndWait</strong>، به ندرت نیاز به ویژگی‌های <strong>queue-jumping</strong> آن است: برای مثال در مثال <strong>rendezvous</strong> ما، کافی است که ابتدا <strong>Set</strong> را روی <strong>wait handle</strong> اول صدا بزنید و سپس <strong>WaitOne</strong> را روی دیگری فراخوانی کنید، اگر از <strong>wait handle</strong>ها صرفاً برای همان ملاقات استفاده می‌کنید. در بخش بعد، یک گزینه دیگر برای پیاده‌سازی <strong>thread rendezvous</strong> بررسی می‌کنیم.</p>
<p>در مورد <strong>WaitAny</strong> و <strong>WaitAll</strong>، اگر به اتمی بودن نیاز ندارید، می‌توانید از کدی که در بخش قبل نوشتیم استفاده کنید تا <strong>wait handle</strong>ها را به <strong>Task</strong> تبدیل کرده و سپس از <strong>Task.WhenAny</strong> و <strong>Task.WhenAll</strong> استفاده کنید (فصل ۱۴).</p>
<p>اگر به اتمی بودن نیاز دارید، می‌توانید از سطح پایین‌تر شروع کنید و منطق سیگنال‌دهی را خودتان با متدهای <strong>Monitor.Wait</strong> و <strong>Monitor.Pulse</strong> بنویسید. ما <strong>Wait</strong> و <strong>Pulse</strong> را به‌صورت مفصل در <a href="http://albahari.com/threading">این لینک</a> توضیح داده‌ایم. ✅</p>
<h3>کلاس Barrier 🛑🧵</h3>
<p>کلاس <strong>Barrier</strong> یک <strong>مانع اجرای thread</strong> پیاده‌سازی می‌کند که اجازه می‌دهد چندین <strong>thread</strong> در یک نقطه زمانی با هم <strong>rendezvous</strong> داشته باشند (این با <strong>Thread.MemoryBarrier</strong> متفاوت است).</p>
<p>این کلاس بسیار سریع و کارآمد است و بر اساس متدهای <strong>Wait</strong>، <strong>Pulse</strong> و <strong>spinlock</strong> ساخته شده است.</p>
<h4>نحوه استفاده</h4>
<ol>
<li>یک نمونه از کلاس ایجاد کنید و مشخص کنید که چند <strong>thread</strong> باید در <strong>rendezvous</strong> شرکت کنند (می‌توانید بعداً با متدهای <strong>AddParticipants</strong> یا <strong>RemoveParticipants</strong> این تعداد را تغییر دهید).</li>
<li>هر <strong>thread</strong> زمانی که می‌خواهد در <strong>rendezvous</strong> شرکت کند، متد <strong>SignalAndWait</strong> را فراخوانی کند.</li>
</ol>
<p>اگر کلاس <strong>Barrier</strong> را با مقدار ۳ ایجاد کنید، فراخوانی <strong>SignalAndWait</strong> تا زمانی که این متد سه بار فراخوانی نشده باشد، <strong>بلوک</strong> می‌شود. سپس دوباره چرخه شروع می‌شود: فراخوانی بعدی <strong>SignalAndWait</strong> دوباره تا سه بار صدا زدن متد <strong>بلوک</strong> می‌شود. این کار باعث می‌شود هر <strong>thread</strong> همزمان با دیگر <strong>thread</strong>ها حرکت کند.</p>
<h4>مثال عملی</h4>
<p>در این مثال، هر یک از سه <strong>thread</strong> اعداد ۰ تا ۴ را چاپ می‌کنند و هم‌زمان با دیگر <strong>thread</strong>ها جلو می‌روند:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> barrier = <span class="hljs-keyword">new</span> Barrier(<span class="hljs-number">3</span>);
<span class="hljs-keyword">new</span> Thread(Speak).Start();
<span class="hljs-keyword">new</span> Thread(Speak).Start();
<span class="hljs-keyword">new</span> Thread(Speak).Start();

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span>
{
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)
    {
        Console.Write(i + <span class="hljs-string">&quot; &quot;</span>);
        barrier.SignalAndWait();
    }
}
</code></pre>
<p><strong>خروجی:</strong></p>
<pre class="hljs"><code>0 0 0 1 1 1 2 2 2 3 3 3 4 4 4
</code></pre>
<p>یک ویژگی بسیار مفید <strong>Barrier</strong> این است که می‌توانید <strong>post-phase action</strong> را هنگام ایجاد آن مشخص کنید. این یک <strong>delegate</strong> است که بعد از آنکه <strong>SignalAndWait</strong> به تعداد مشخص فراخوانی شد اجرا می‌شود، اما قبل از اینکه <strong>threads</strong> آزاد شوند.</p>
<p>در مثال ما، اگر <strong>Barrier</strong> را به این صورت ایجاد کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> Barrier _barrier = <span class="hljs-keyword">new</span> Barrier(<span class="hljs-number">3</span>, barrier =&gt; Console.WriteLine());
</code></pre>
<p>خروجی به صورت خط به خط خواهد بود:</p>
<pre class="hljs"><code>0 0 0 
1 1 1 
2 2 2 
3 3 3 
4 4 4
</code></pre>
<p>این ویژگی باعث می‌شود هماهنگی <strong>threads</strong> بسیار منظم و خوانا باشد. ✅</p>
 <div align="center">
<p><img src="../../../assets/image/21/Table-21-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>عملیات پس‌فاز (Post-Phase Action) و جمع‌آوری داده‌ها 📊</h3>
<p>یک <strong>Post-Phase Action</strong> می‌تواند برای <strong>ادغام داده‌ها از هر یک از worker thread‌ها</strong> مفید باشد. در این حالت، نگرانی‌ای از بابت <strong>preemption</strong> وجود ندارد، زیرا تمامی <strong>workerها</strong> در حین اجرای این عملیات <strong>مسدود</strong> هستند.</p>
<hr>
<h3>مقداردهی تنبل (Lazy Initialization) 🐢💡</h3>
<p>یکی از مشکلات رایج در <strong>threading</strong> این است که چگونه یک <strong>فیلد مشترک</strong> را به صورت <strong>تنبل و thread-safe</strong> مقداردهی کنیم. این نیاز زمانی ایجاد می‌شود که یک فیلد از نوعی داشته باشیم که <strong>ساخت آن هزینه‌بر باشد</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> Expensive Expensive = <span class="hljs-keyword">new</span> Expensive();
    ...
}
<span class="hljs-keyword">class</span> <span class="hljs-title">Expensive</span> { <span class="hljs-comment">/* فرض کنید ساخت این کلاس پرهزینه است */</span> }
</code></pre>
<p>مشکل این کد این است که <strong>ساخت Foo</strong> هزینه‌ی <strong>ساخت Expensive</strong> را نیز متحمل می‌شود، حتی اگر فیلد <strong>Expensive</strong> هیچ‌وقت دسترسی پیدا نکند.</p>
<p>راه حل واضح این است که <strong>نمونه را فقط در صورت نیاز ایجاد کنیم</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{
    Expensive _expensive;
    <span class="hljs-keyword">public</span> Expensive Expensive   <span class="hljs-comment">// مقداردهی تنبل Expensive</span>
    {
        <span class="hljs-keyword">get</span>
        {
            <span class="hljs-keyword">if</span> (_expensive == <span class="hljs-literal">null</span>) _expensive = <span class="hljs-keyword">new</span> Expensive();
            <span class="hljs-keyword">return</span> _expensive;
        }
    }
    ...
}
</code></pre>
<p>اما سوال اینجاست: آیا این <strong>thread-safe</strong> است؟<br>
اگر دو <strong>thread</strong> همزمان به این property دسترسی پیدا کنند، ممکن است هر دو شرط <strong>if</strong> را برآورده کنند و هر thread یک نمونه‌ی متفاوت از <strong>Expensive</strong> ایجاد کند. این می‌تواند منجر به خطاهای ظریف شود؛ بنابراین به طور کلی، این کد <strong>امن برای thread نیست</strong>.</p>
<p>راه حل <strong>امن برای thread</strong> این است که <strong>چک کردن و مقداردهی را داخل یک lock</strong> انجام دهیم:</p>
<pre class="hljs"><code>Expensive _expensive;
<span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> _expenseLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();

<span class="hljs-keyword">public</span> Expensive Expensive
{
    <span class="hljs-keyword">get</span>
    {
        <span class="hljs-keyword">lock</span> (_expenseLock)
        {
            <span class="hljs-keyword">if</span> (_expensive == <span class="hljs-literal">null</span>) _expensive = <span class="hljs-keyword">new</span> Expensive();
            <span class="hljs-keyword">return</span> _expensive;
        }
    }
}
</code></pre>
<hr>
<h3>کلاس Lazy<T> ⚡</h3>
<p>کلاس <strong>Lazy<T></strong> برای کمک به <strong>مقداردهی تنبل</strong> در دسترس است. اگر آن را با آرگومان <strong>true</strong> بسازید، <strong>الگوی مقداردهی thread-safe</strong> که بالاتر توضیح داده شد را پیاده‌سازی می‌کند.</p>
<p><strong>Lazy<T></strong> در واقع یک نسخه‌ی <strong>micro-optimized</strong> از این الگو، به نام <strong>double-checked locking</strong> را پیاده‌سازی می‌کند.<br>
این الگو یک <strong>خواندن volatile اضافی</strong> انجام می‌دهد تا اگر شیء از قبل مقداردهی شده بود، هزینه‌ی گرفتن lock را نداشته باشیم.</p>
<h4>نحوه استفاده از Lazy<T></h4>
<pre class="hljs"><code>Lazy&lt;Expensive&gt; _expensive = <span class="hljs-keyword">new</span> Lazy&lt;Expensive&gt;(
    () =&gt; <span class="hljs-keyword">new</span> Expensive(), <span class="hljs-literal">true</span>);

<span class="hljs-keyword">public</span> Expensive Expensive { <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _expensive.Value; } }
</code></pre>
<p>اگر <strong>false</strong> به سازنده‌ی <strong>Lazy<T></strong> بدهید، الگویی <strong>غیر امن برای thread</strong> ایجاد می‌کند، همانند الگویی که در ابتدای این بخش توضیح داده شد—که در محیط‌های <strong>single-threaded</strong> مناسب است. ✅</p>
<h3>کلاس LazyInitializer ⚡</h3>
<p>کلاس <strong>LazyInitializer</strong> یک کلاس <strong>static</strong> است که دقیقاً مانند <strong>Lazy<T></strong> عمل می‌کند، با این تفاوت‌ها:</p>
<ul>
<li>عملکرد آن از طریق یک <strong>متد static</strong> ارائه می‌شود که مستقیم روی <strong>فیلد خودتان</strong> عمل می‌کند. این باعث می‌شود یک سطح <strong>indirection</strong> حذف شود و در سناریوهایی که به <strong>بهینه‌سازی شدید</strong> نیاز دارید، عملکرد بهتر شود.</li>
<li>یک <strong>حالت مقداردهی دیگر</strong> ارائه می‌دهد که در آن <strong>چندین thread می‌توانند برای مقداردهی رقابت کنند</strong>.</li>
</ul>
<p>برای استفاده از <strong>LazyInitializer</strong>، قبل از دسترسی به فیلد، <strong>EnsureInitialized</strong> را فراخوانی کنید و <strong>ارجاع فیلد و delegate کارخانه</strong> را پاس دهید:</p>
<pre class="hljs"><code>Expensive _expensive;
<span class="hljs-keyword">public</span> Expensive Expensive
{ 
    <span class="hljs-keyword">get</span>          <span class="hljs-comment">// پیاده‌سازی double-checked locking</span>
    { 
        LazyInitializer.EnsureInitialized(<span class="hljs-keyword">ref</span> _expensive,
                                         () =&gt; <span class="hljs-keyword">new</span> Expensive());
        <span class="hljs-keyword">return</span> _expensive;
    }
}
</code></pre>
<p>همچنین می‌توانید یک آرگومان اضافی پاس دهید تا <strong>چند thread رقیب برای مقداردهی رقابت کنند</strong>. این شبیه مثال thread-unsafe اولیه ما است، اما <strong>اولین thread که تمام می‌شود همیشه برنده است</strong> و در نهایت تنها یک نمونه خواهید داشت.</p>
<p>مزیت این تکنیک این است که در سیستم‌های <strong>چند هسته‌ای</strong> حتی سریع‌تر از <strong>double-checked locking</strong> است، زیرا می‌تواند <strong>کاملاً بدون lock</strong> پیاده‌سازی شود، با استفاده از تکنیک‌های پیشرفته‌ای که در بخش‌های «Nonblocking Synchronization» و «Lazy Initialization» در <a href="http://albahari.com/threading">albahari.com/threading</a> توضیح داده شده است.</p>
<p>این یک بهینه‌سازی <strong>extreme و به ندرت مورد نیاز</strong> است که هزینه‌هایی دارد:</p>
<ul>
<li>وقتی تعداد threadهای رقابت‌کننده برای مقداردهی از تعداد هسته‌ها بیشتر باشد، <strong>کندتر است</strong>.</li>
<li>ممکن است منابع CPU صرف انجام <strong>مقداردهی تکراری</strong> شود.</li>
<li>منطق مقداردهی باید <strong>thread-safe</strong> باشد (مثلاً اگر constructor کلاس <strong>Expensive</strong> داده‌ای را به فیلدهای static می‌نوشت).</li>
<li>اگر initializer شیئی ایجاد کند که نیاز به <strong>disposal</strong> دارد، شیء «اضافی» بدون منطق اضافه <strong>dispose</strong> نمی‌شود.</li>
</ul>
<hr>
<h3>ذخیره‌سازی محلی برای Thread‌ها (Thread-Local Storage) 🧵</h3>
<p>بخش زیادی از این فصل روی <strong>سینکرونیزیشن و مشکلاتی که هنگام دسترسی همزمان threadها به یک داده ایجاد می‌شود</strong> تمرکز داشت.<br>
گاهی اوقات، می‌خواهید داده‌ها را <strong>ایزوله نگه دارید</strong> و مطمئن شوید که <strong>هر thread نسخه‌ی جداگانه‌ای دارد</strong>.</p>
<ul>
<li>متغیرهای محلی دقیقاً همین کار را انجام می‌دهند، اما فقط برای داده‌های <strong>موقت</strong> مفید هستند.</li>
<li><strong>راه حل:</strong> <strong>Thread-local storage</strong>.</li>
</ul>
<p>معمولاً داده‌هایی که می‌خواهید به یک thread اختصاص دهید <strong>به طور طبیعی موقت</strong> هستند. کاربرد اصلی آن‌ها <strong>ذخیره‌سازی داده‌های «خارج از مسیر اصلی»</strong> است—مثل <strong>messaging، transaction و security tokens</strong>.<br>
پاس دادن چنین داده‌هایی از طریق پارامترهای متد می‌تواند <strong>دست و پا گیر</strong> باشد و ذخیره آن‌ها در فیلدهای static معمولی باعث <strong>به اشتراک گذاشتن داده میان همه threadها</strong> می‌شود.</p>
<p><strong>Thread-local storage</strong> همچنین در <strong>بهینه‌سازی کد موازی</strong> مفید است، زیرا به هر thread اجازه می‌دهد <strong>نسخه‌ی خودش از یک شیء thread-unsafe</strong> را بدون lock و بدون نیاز به بازسازی بین فراخوانی‌های متد داشته باشد.</p>
<hr>
<h4>روش‌های پیاده‌سازی Thread-Local Storage</h4>
<p>۱. <strong>[ThreadStatic]</strong></p>
<p>ساده‌ترین روش، علامت‌گذاری یک <strong>فیلد static</strong> با <strong>ThreadStatic</strong> است:</p>
<pre class="hljs"><code>[<span class="hljs-meta">ThreadStatic</span>] <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _x;
</code></pre>
<p>هر thread نسخه‌ی جداگانه‌ای از <code>_x</code> خواهد دید.</p>
<p>⚠️ محدودیت‌ها:</p>
<ul>
<li>[ThreadStatic] با <strong>فیلدهای instance</strong> کار نمی‌کند.</li>
<li>با <strong>field initializers</strong> خوب کار نمی‌کند؛ آن‌ها تنها یک بار در thread‌ای که static constructor اجرا می‌شود، اجرا می‌شوند.</li>
</ul>
<p>اگر نیاز دارید با <strong>فیلدهای instance</strong> کار کنید یا <strong>مقدار غیر پیش‌فرض</strong> داشته باشید، <strong>ThreadLocal<T></strong> گزینه بهتری است.</p>
<hr>
<p>۲. <strong>ThreadLocal<T></strong></p>
<p>کلاس <strong>ThreadLocal<T></strong> امکان <strong>ذخیره‌سازی محلی برای thread</strong> را هم برای فیلدهای static و هم instance فراهم می‌کند و اجازه می‌دهد <strong>مقدار پیش‌فرض</strong> مشخص کنید.</p>
<p>مثال: ساخت یک <strong>ThreadLocal<int></strong> با مقدار پیش‌فرض ۳ برای هر thread:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> ThreadLocal&lt;<span class="hljs-built_in">int</span>&gt; _x = <span class="hljs-keyword">new</span> ThreadLocal&lt;<span class="hljs-built_in">int</span>&gt;(() =&gt; <span class="hljs-number">3</span>);
</code></pre>
<p>سپس از property <strong>Value</strong> برای دریافت یا تنظیم مقدار محلی هر thread استفاده می‌کنید.</p>
<p>✅ نکته: <strong>مقداردهی تنبل</strong> است—delegate کارخانه فقط <strong>در اولین دسترسی هر thread</strong> اجرا می‌شود.</p>
<h3>ThreadLocal<T> و فیلدهای Instance 🧵</h3>
<p>کلاس <strong>ThreadLocal<T></strong> همچنین برای <strong>فیلدهای instance</strong> و <strong>local variableهای capture شده</strong> مفید است.<br>
برای مثال، فرض کنید می‌خواهیم در محیط <strong>چند thread‌ای</strong> اعداد تصادفی تولید کنیم. کلاس <strong>Random</strong> <strong>thread-safe نیست</strong>، بنابراین دو راه داریم:</p>
<ol>
<li>استفاده از <strong>lock</strong> هنگام استفاده از Random (که <strong>Concurrency</strong> را محدود می‌کند).</li>
<li>تولید یک <strong>شیء Random جداگانه برای هر thread</strong>.</li>
</ol>
<p>با <strong>ThreadLocal<T></strong>، گزینه دوم خیلی آسان می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> localRandom = <span class="hljs-keyword">new</span> ThreadLocal&lt;Random&gt;(() =&gt; <span class="hljs-keyword">new</span> Random());
Console.WriteLine(localRandom.Value.Next());
</code></pre>
<p>🔹 نکته: تابع کارخانه ما برای ایجاد شیء <strong>Random</strong> کمی ساده است، چون سازنده بدون پارامتر Random از <strong>ساعت سیستم</strong> برای seed استفاده می‌کند. این ممکن است برای دو شیء Random که در حدود <strong>۱۰ میلی‌ثانیه</strong> از هم ایجاد شده‌اند، یکسان باشد.</p>
<p>یک روش برای رفع این مشکل:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> localRandom = <span class="hljs-keyword">new</span> ThreadLocal&lt;Random&gt;
(() =&gt; <span class="hljs-keyword">new</span> Random(Guid.NewGuid().GetHashCode()));
</code></pre>
<p>این روش در <strong>فصل ۲۲</strong> در مثال <strong>parallel spellchecking</strong> (در بخش PLINQ صفحه ۹۳۵) استفاده شده است.</p>
<hr>
<h3>GetData و SetData 📦</h3>
<p>روش سوم استفاده از دو متد در کلاس <strong>Thread</strong> است: <strong>GetData</strong> و <strong>SetData</strong>.</p>
<ul>
<li>این متدها داده‌ها را در <strong>slotهای مخصوص thread</strong> ذخیره می‌کنند.</li>
<li><strong>Thread.GetData</strong> داده را از <strong>ذخیره‌سازی ایزوله thread</strong> می‌خواند.</li>
<li><strong>Thread.SetData</strong> داده را در آن می‌نویسد.</li>
<li>هر دو متد نیاز به یک <strong>LocalDataStoreSlot</strong> برای شناسایی slot دارند.</li>
</ul>
<p>می‌توانید از همان slot برای همه threadها استفاده کنید و هر thread همچنان <strong>مقدار جداگانه‌ای</strong> دریافت می‌کند. مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    <span class="hljs-comment">// همان LocalDataStoreSlot می‌تواند برای همه threadها استفاده شود</span>
    LocalDataStoreSlot _secSlot = Thread.GetNamedDataSlot(<span class="hljs-string">&quot;securityLevel&quot;</span>);

    <span class="hljs-comment">// این property برای هر thread مقدار جداگانه دارد</span>
    <span class="hljs-built_in">int</span> SecurityLevel
    {
        <span class="hljs-keyword">get</span>
        {
            <span class="hljs-built_in">object</span> data = Thread.GetData(_secSlot);
            <span class="hljs-keyword">return</span> data == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : (<span class="hljs-built_in">int</span>)data; <span class="hljs-comment">// null == مقداردهی نشده</span>
        }
        <span class="hljs-keyword">set</span> { Thread.SetData(_secSlot, <span class="hljs-keyword">value</span>); }
    }
}
</code></pre>
<p>در این مثال، از <strong>Thread.GetNamedDataSlot</strong> استفاده کردیم که یک <strong>slot نام‌گذاری‌شده</strong> ایجاد می‌کند—این اجازه می‌دهد slot بین همه بخش‌های برنامه به اشتراک گذاشته شود.<br>
به طور جایگزین، می‌توانید با یک slot بدون نام، که با <strong>Thread.AllocateDataSlot</strong> ایجاد شده است، کنترل محدوده آن را خودتان داشته باشید:</p>
<pre class="hljs"><code>LocalDataStoreSlot _secSlot = Thread.AllocateDataSlot();
</code></pre>
<p>⚠️ نکته:</p>
<ul>
<li><strong>Thread.FreeNamedDataSlot</strong> یک slot نام‌گذاری‌شده را در همه threadها آزاد می‌کند، اما فقط وقتی که <strong>تمام ارجاعات به آن LocalDataStoreSlot از محدوده خارج شده و garbage collected شده باشند</strong>.</li>
<li>این تضمین می‌کند که threadها slotهای داده خود را از دست ندهند، تا زمانی که <strong>ارجاع مناسب به LocalDataStoreSlot</strong> را نگه داشته باشند.</li>
</ul>
<hr>
<h3>AsyncLocal<T> 🌐</h3>
<p>روش‌های پیشین <strong>Thread-local storage</strong> با <strong>async functions</strong> سازگار نیستند، چون بعد از <strong>await</strong>، اجرای کد می‌تواند روی یک thread دیگر ادامه پیدا کند.</p>
<p>کلاس <strong>AsyncLocal<T></strong> این مشکل را حل می‌کند و مقدار خود را <strong>بعد از await حفظ می‌کند</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> AsyncLocal&lt;<span class="hljs-built_in">string</span>&gt; _asyncLocalTest = <span class="hljs-keyword">new</span> AsyncLocal&lt;<span class="hljs-built_in">string</span>&gt;();

<span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
{
    _asyncLocalTest.Value = <span class="hljs-string">&quot;test&quot;</span>;  
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);  
    <span class="hljs-comment">// حتی اگر روی thread دیگری ادامه پیدا کنیم، درست کار می‌کند:</span>
    Console.WriteLine(_asyncLocalTest.Value);   <span class="hljs-comment">// test</span>
}
</code></pre>
<p><strong>AsyncLocal<T></strong> همچنین می‌تواند عملیات شروع‌شده روی <strong>threadهای جداگانه</strong> را از هم جدا نگه دارد، چه توسط <strong>Thread.Start</strong> و چه <strong>Task.Run</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> AsyncLocal&lt;<span class="hljs-built_in">string</span>&gt; _asyncLocalTest = <span class="hljs-keyword">new</span> AsyncLocal&lt;<span class="hljs-built_in">string</span>&gt;();

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
{
    <span class="hljs-comment">// Test را روی دو thread همزمان صدا بزن</span>
    <span class="hljs-keyword">new</span> Thread(() =&gt; Test(<span class="hljs-string">&quot;one&quot;</span>)).Start();
    <span class="hljs-keyword">new</span> Thread(() =&gt; Test(<span class="hljs-string">&quot;two&quot;</span>)).Start();
}

<span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span>
{
    _asyncLocalTest.Value = <span class="hljs-keyword">value</span>;
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);
    Console.WriteLine(<span class="hljs-keyword">value</span> + <span class="hljs-string">&quot; &quot;</span> + _asyncLocalTest.Value);
}
<span class="hljs-comment">// خروجی: </span>
<span class="hljs-comment">// one one</span>
<span class="hljs-comment">// two two</span>
</code></pre>
<p>یک نکته جالب درباره <strong>AsyncLocal<T></strong>:</p>
<ul>
<li>اگر یک شیء AsyncLocal<T> <strong>قبلاً مقداری داشته باشد</strong>، وقتی یک thread جدید شروع شود، thread جدید <strong>آن مقدار را به ارث می‌برد</strong>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">static</span> AsyncLocal&lt;<span class="hljs-built_in">string</span>&gt; _asyncLocalTest = <span class="hljs-keyword">new</span> AsyncLocal&lt;<span class="hljs-built_in">string</span>&gt;();

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
{
    _asyncLocalTest.Value = <span class="hljs-string">&quot;test&quot;</span>;
    <span class="hljs-keyword">new</span> Thread(AnotherMethod).Start();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AnotherMethod</span>()</span> =&gt; Console.WriteLine(_asyncLocalTest.Value);  <span class="hljs-comment">// test</span>
</code></pre>
<ul>
<li>با این حال، thread جدید <strong>یک کپی از مقدار دریافت می‌کند</strong>، بنابراین هر تغییری که روی آن انجام دهد، روی مقدار اصلی تأثیر نمی‌گذارد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">static</span> AsyncLocal&lt;<span class="hljs-built_in">string</span>&gt; _asyncLocalTest = <span class="hljs-keyword">new</span> AsyncLocal&lt;<span class="hljs-built_in">string</span>&gt;();

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
{
    _asyncLocalTest.Value = <span class="hljs-string">&quot;test&quot;</span>;
    <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">new</span> Thread(AnotherMethod);
    t.Start(); t.Join();
    Console.WriteLine(_asyncLocalTest.Value);   <span class="hljs-comment">// test</span>
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AnotherMethod</span>()</span> =&gt; _asyncLocalTest.Value = <span class="hljs-string">&quot;ha-ha!&quot;</span>;
</code></pre>
<p>⚠️ توجه: thread جدید <strong>یک کپی سطحی (shallow copy)</strong> از مقدار دریافت می‌کند.</p>
<ul>
<li>بنابراین اگر <strong>Async<string></strong> را با <strong>Async<StringBuilder></strong> یا <strong>Async&lt;List<string>&gt;</strong> جایگزین کنید، thread جدید می‌تواند <strong>StringBuilder را پاک کند یا آیتم‌ها را به List اضافه/حذف کند</strong> و این روی مقدار اصلی تأثیر خواهد گذاشت.</li>
</ul>
<h3>Timers ⏱️</h3>
<p>اگر نیاز دارید یک <strong>متد</strong> به صورت <strong>دوره‌ای و منظم</strong> اجرا شود، ساده‌ترین راه استفاده از <strong>timer</strong> است.</p>
<p><strong>Timerها</strong> هم راحت و هم بهینه از نظر حافظه و منابع هستند، مخصوصاً در مقایسه با تکنیک‌های زیر:</p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() {
    <span class="hljs-keyword">while</span> (enabled)
    {
        DoSomeAction();
        Thread.Sleep(TimeSpan.FromHours(<span class="hljs-number">24</span>));
    }
}).Start();
</code></pre>
<ul>
<li>این روش یک <strong>thread</strong> را دائماً مشغول نگه می‌دارد.</li>
<li>بدون کدنویسی اضافه، متد <strong>DoSomeAction</strong> هر روز در زمان متفاوتی اجرا می‌شود.</li>
<li><strong>Timers</strong> این مشکلات را حل می‌کنند.</li>
</ul>
<hr>
<p>.NET پنج نوع <strong>timer</strong> ارائه می‌دهد:</p>
<h4>۱. Timerهای چندthread‌ای عمومی</h4>
<ul>
<li><strong>System.Threading.Timer</strong></li>
<li><strong>System.Timers.Timer</strong></li>
</ul>
<h4>۲. Timerهای تک‌thread‌ای ویژه</h4>
<ul>
<li>
<p><strong>System.Windows.Forms.Timer</strong> (برای Windows Forms)</p>
</li>
<li>
<p><strong>System.Windows.Threading.DispatcherTimer</strong> (برای WPF)</p>
</li>
<li>
<p>Timerهای چندthread‌ای <strong>قدرتمندتر، دقیق‌تر و انعطاف‌پذیرتر</strong> هستند.</p>
</li>
<li>
<p>Timerهای تک‌thread‌ای برای <strong>اجرای ساده</strong> و به‌روزرسانی <strong>کنترل‌های Windows Forms یا عناصر WPF</strong> ایمن‌تر و راحت‌ترند.</p>
</li>
<li>
<p>از <strong>.NET 6</strong>، یک Timer جدید به نام <strong>PeriodicTimer</strong> اضافه شده که ابتدا به آن می‌پردازیم.</p>
</li>
</ul>
<hr>
<h3>PeriodicTimer 🔄</h3>
<p><strong>PeriodicTimer</strong> در واقع یک timer سنتی نیست؛ بلکه <strong>کلاسی برای ساده‌سازی حلقه‌های asynchronous</strong> است.</p>
<p>با ظهور <strong>async و await</strong>، معمولاً به timerهای سنتی نیاز نیست. به جای آن، الگوی زیر خوب کار می‌کند:</p>
<pre class="hljs"><code>StartPeriodicOperation();

<span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartPeriodicOperation</span>()</span>
{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
    {
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);
        Console.WriteLine(<span class="hljs-string">&quot;Tick&quot;</span>);   <span class="hljs-comment">// انجام یک عملیات</span>
    }
}
</code></pre>
<ul>
<li>اگر این کد را از <strong>UI thread</strong> فراخوانی کنید، مانند یک <strong>timer تک‌thread‌ای</strong> رفتار خواهد کرد، چون <strong>await</strong> همیشه روی همان <strong>synchronization context</strong> برمی‌گردد.</li>
<li>برای رفتار به صورت <strong>multi-threaded timer</strong> کافی است <strong>.ConfigureAwait(false)</strong> به await اضافه کنید.</li>
</ul>
<p><strong>PeriodicTimer</strong> این الگو را ساده می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> timer = <span class="hljs-keyword">new</span> PeriodicTimer(TimeSpan.FromSeconds(<span class="hljs-number">1</span>));
StartPeriodicOperation();

<span class="hljs-comment">// اختیاری: وقتی می‌خواهید حلقه را متوقف کنید، timer را dispose کنید.</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartPeriodicOperation</span>()</span>
{
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">await</span> timer.WaitForNextTickAsync())
        Console.WriteLine(<span class="hljs-string">&quot;Tick&quot;</span>);    <span class="hljs-comment">// انجام یک عملیات</span>
}
</code></pre>
<ul>
<li>همچنین می‌توان با <strong>dispose کردن</strong> نمونه <strong>PeriodicTimer</strong>، timer را متوقف کرد.</li>
<li>در این صورت <strong>WaitForNextTickAsync</strong> مقدار <strong>false</strong> برمی‌گرداند و حلقه پایان می‌یابد.</li>
</ul>
<h3>تایمرهای چند‌نخی ⏱️🧵</h3>
<p><strong>System.Threading.Timer</strong> ساده‌ترین <strong>timer چند‌نخی</strong> است: فقط یک <strong>constructor</strong> و دو <strong>method</strong> دارد (برای مینیمالیست‌ها و نویسندگان کتاب‌ها واقعاً لذت‌بخش!).</p>
<p>در مثال زیر، یک <strong>timer</strong> متد <strong>Tick</strong> را صدا می‌زند، که بعد از ۵ ثانیه <code>&quot;tick...&quot;</code> را چاپ می‌کند و سپس هر ثانیه یک‌بار این کار را تکرار می‌کند، تا زمانی که کاربر <strong>Enter</strong> را فشار دهد:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading;

<span class="hljs-comment">// اولین فاصله = 5000ms؛ فواصل بعدی = 1000ms</span>
Timer tmr = <span class="hljs-keyword">new</span> Timer(Tick, <span class="hljs-string">&quot;tick...&quot;</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">1000</span>);

Console.ReadLine();
tmr.Dispose();  <span class="hljs-comment">// هم timer را متوقف می‌کند و هم منابع را آزاد می‌کند.</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tick</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> data</span>)</span>
{
    <span class="hljs-comment">// این روی یک pooled thread اجرا می‌شود</span>
    Console.WriteLine(data);  <span class="hljs-comment">// چاپ &quot;tick...&quot;</span>
}
</code></pre>
<ul>
<li>برای تغییر فاصله‌ی اجرای timer بعد از ساخت آن، می‌توان از متد <strong>Change</strong> استفاده کرد.</li>
<li>اگر بخواهید timer فقط یک‌بار اجرا شود، از <strong>Timeout.Infinite</strong> در آرگومان آخر <strong>constructor</strong> استفاده کنید.</li>
</ul>
<hr>
<p>.NET یک کلاس <strong>timer</strong> دیگر با همان نام در فضای نام <strong>System.Timers</strong> دارد. این کلاس، <strong>System.Threading.Timer</strong> را wrap می‌کند و امکانات راحت‌تر و اضافی ارائه می‌دهد، در حالی که موتور اصلی همان است. ویژگی‌های اضافه شده عبارت‌اند از:</p>
<ul>
<li>پیاده‌سازی <strong>IComponent</strong> برای استفاده در <strong>Designer</strong> ویژوال استودیو</li>
<li><strong>Interval</strong> به جای متد <strong>Change</strong></li>
<li><strong>Elapsed event</strong> به جای <strong>callback delegate</strong></li>
<li><strong>Enabled property</strong> برای شروع و توقف timer (مقدار پیش‌فرض = false)</li>
<li>متدهای <strong>Start</strong> و <strong>Stop</strong></li>
<li><strong>AutoReset flag</strong> برای مشخص کردن اجرای دوره‌ای (مقدار پیش‌فرض = true)</li>
<li><strong>SynchronizingObject</strong> با متدهای <strong>Invoke</strong> و <strong>BeginInvoke</strong> برای فراخوانی ایمن متدها روی عناصر WPF و کنترل‌های Windows Forms</li>
</ul>
<p>مثالی از آن:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Timers;  <span class="hljs-comment">// فضای نام Timers</span>

<span class="hljs-keyword">var</span> tmr = <span class="hljs-keyword">new</span> Timer(); <span class="hljs-comment">// بدون نیاز به آرگومان</span>
tmr.Interval = <span class="hljs-number">500</span>;
tmr.Elapsed += tmr_Elapsed;  <span class="hljs-comment">// استفاده از event به جای delegate</span>
tmr.Start();                 <span class="hljs-comment">// شروع timer</span>
Console.ReadLine();
tmr.Stop();                  <span class="hljs-comment">// توقف timer</span>
Console.ReadLine();
tmr.Start();                 <span class="hljs-comment">// راه‌اندازی مجدد timer</span>
Console.ReadLine();
tmr.Dispose();               <span class="hljs-comment">// متوقف کردن دائم timer</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tmr_Elapsed</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span>
    =&gt; Console.WriteLine(<span class="hljs-string">&quot;Tick&quot;</span>);
</code></pre>
<ul>
<li>
<p><strong>Timerهای چند‌نخی</strong> از <strong>thread pool</strong> استفاده می‌کنند تا چند thread بتوانند به تعداد زیادی timer سرویس بدهند.</p>
</li>
<li>
<p>بنابراین، callback یا event handler ممکن است هر بار روی <strong>thread متفاوتی</strong> اجرا شود.</p>
</li>
<li>
<p>همچنین، <strong>Elapsed event</strong> تقریباً همیشه به موقع اجرا می‌شود، حتی اگر اجرای قبلی هنوز تمام نشده باشد.</p>
</li>
<li>
<p>پس callbackها و event handlerها باید <strong>thread-safe</strong> باشند.</p>
</li>
<li>
<p>دقت timerهای چند‌نخی به سیستم‌عامل وابسته است و معمولاً حدود <strong>۱۰ تا ۲۰ میلی‌ثانیه</strong> است.</p>
</li>
<li>
<p>برای دقت بالاتر، می‌توان از <strong>Windows multimedia timer</strong> استفاده کرد که دقت آن تا <strong>یک میلی‌ثانیه</strong> است و در <strong>winmm.dll</strong> تعریف شده.</p>
</li>
</ul>
<hr>
<h3>تایمرهای تک‌نخی 🧵🖥️</h3>
<p>.NET تایمرهایی ارائه می‌دهد که برای <strong>حذف مشکلات thread-safety</strong> در برنامه‌های <strong>WPF و Windows Forms</strong> طراحی شده‌اند:</p>
<ul>
<li>
<p><strong>System.Windows.Threading.DispatcherTimer</strong> (WPF)</p>
</li>
<li>
<p><strong>System.Windows.Forms.Timer</strong> (Windows Forms)</p>
</li>
<li>
<p>این تایمرها برای محیط‌های مربوطه طراحی شده‌اند و خارج از آن محیط‌ها کار نمی‌کنند.</p>
</li>
<li>
<p>به عنوان مثال، استفاده از Windows Forms Timer در یک <strong>Windows Service</strong> باعث می‌شود event تایمر اجرا نشود!</p>
</li>
<li>
<p>این تایمرها مشابه <strong>System.Timers.Timer</strong> عمل می‌کنند و <strong>Interval، Start، Stop</strong> و <strong>Tick</strong> دارند، اما در اجرای داخلی متفاوت هستند:</p>
<ul>
<li>به جای اجرای event روی <strong>pooled threads</strong>، event را به <strong>message loop</strong> محیط WPF یا Windows Forms ارسال می‌کنند.</li>
<li>بنابراین <strong>Tick</strong> همیشه روی همان thread که timer ساخته شده، اجرا می‌شود.</li>
<li>این thread معمولاً همان thread مدیریت تمام عناصر و کنترل‌های UI است.</li>
</ul>
</li>
</ul>
<p>مزایای این روش:</p>
<ul>
<li>
<p>دیگر نیازی به نگرانی درباره <strong>thread safety</strong> نیست.</p>
</li>
<li>
<p>اجرای بعدی Tick تا زمانی که Tick قبلی تمام نشده باشد، شروع نمی‌شود.</p>
</li>
<li>
<p>می‌توان عناصر و کنترل‌های UI را مستقیماً از Tick به‌روزرسانی کرد، بدون نیاز به <strong>Control.BeginInvoke</strong> یا <strong>Dispatcher.BeginInvoke</strong>.</p>
</li>
<li>
<p>برنامه‌هایی که از این تایمرها استفاده می‌کنند، واقعاً <strong>multithreaded</strong> نیستند؛ نوعی <strong>pseudo-concurrency</strong> شبیه فصل ۱۴ با asynchronous functions روی UI thread دارند.</p>
</li>
<li>
<p>این تایمرها برای <strong>کارهای کوچک</strong> و معمولاً به‌روزرسانی UI مناسب‌اند (مثلاً نمایش ساعت یا countdown).</p>
</li>
<li>
<p>از نظر دقت، تایمرهای تک‌نخی مشابه تایمرهای چند‌نخی هستند (ده‌ها میلی‌ثانیه)، اما معمولاً کمی کمتر دقیق‌اند چون ممکن است هنگام پردازش درخواست‌های دیگر UI یا eventهای تایمر تأخیر ایجاد شود.</p>
</li>
</ul>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
