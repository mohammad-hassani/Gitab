

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>بازتاب (Reflection) و متادیتا</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/Gitab/" aria-current="page">خانه</a>
        <a href="/Gitab/books/list-books">کتاب‌ها</a>
       <a href="/Gitab/translator.html">مترجمین</a>
        <a href="/Gitab/giter.html">گیتر</a>
      </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل هجدهم:  بازتاب (Reflection) و متادیتا</h1>
<p>همان‌طور که در فصل ۱۷ دیدیم، یک برنامه‌ی C# به یک <strong>Assembly</strong> کامپایل می‌شود که شامل <strong>متادیتا (Metadata)</strong>، کد کامپایل‌شده و منابع (Resources) است. بررسی متادیتا و کد کامپایل‌شده در زمان اجرا را <strong>Reflection (بازتاب)</strong> می‌نامند.</p>
<p>کد کامپایل‌شده در یک Assembly تقریباً تمام محتوای کد منبع اصلی را در بر دارد. با این حال، برخی اطلاعات مانند نام متغیرهای محلی، توضیحات (Comments) و دستورهای پیش‌پردازنده (Preprocessor Directives) از دست می‌روند. اما بازتاب به ما امکان دسترسی به تقریباً تمام موارد دیگر را می‌دهد—حتی تا حدی که می‌توان یک <strong>Decompiler</strong> (دی‌کامپایلر) نوشت. 🔎</p>
<p>بسیاری از سرویس‌های موجود در .NET و در دسترس از طریق C# (مانند <strong>Dynamic Binding</strong>، <strong>Serialization</strong> و <strong>Data Binding</strong>) به وجود متادیتا وابسته هستند. همچنین برنامه‌های شما نیز می‌توانند از این متادیتا استفاده کنند و حتی آن را با اطلاعات جدید از طریق <strong>Custom Attributes</strong> گسترش دهند. فضای نام <code>System.Reflection</code> شامل API مربوط به Reflection است. علاوه بر این، در زمان اجرا می‌توان متادیتا و دستورالعمل‌های اجرایی جدیدی در سطح <strong>Intermediate Language (IL)</strong> با استفاده از کلاس‌های موجود در فضای نام <code>System.Reflection.Emit</code> ایجاد کرد.</p>
<p>نمونه‌های این فصل فرض می‌کنند که شما فضای نام‌های <code>System</code> و <code>System.Reflection</code> و همچنین <code>System.Reflection.Emit</code> را وارد کرده‌اید.</p>
<p>وقتی در این فصل از اصطلاح <strong>«به‌صورت دینامیکی» (Dynamically)</strong> استفاده می‌کنیم، منظور این است که عملی را با Reflection انجام دهیم که <strong>ایمنی نوع (Type Safety)</strong> آن فقط در زمان اجرا کنترل می‌شود. این موضوع از نظر اصول مشابه <strong>Dynamic Binding</strong> در C# با کلیدواژه‌ی <code>dynamic</code> است، اما مکانیزم و عملکرد آن متفاوت است.</p>
<ul>
<li><strong>Dynamic Binding</strong> استفاده‌ی آسان‌تری دارد و از <strong>Dynamic Language Runtime (DLR)</strong> برای سازگاری با زبان‌های پویا استفاده می‌کند.</li>
<li><strong>Reflection</strong> نسبت به آن کمی دست‌وپاگیرتر است، اما انعطاف بیشتری در ارتباط با <strong>CLR</strong> ارائه می‌دهد.</li>
</ul>
<p>برای مثال، Reflection به شما اجازه می‌دهد:<br>
✔️ فهرستی از <strong>Types</strong> و <strong>Members</strong> دریافت کنید.<br>
✔️ یک شیء را با نامی که از یک رشته (String) می‌آید بسازید.<br>
✔️ در لحظه (On the fly) Assembly تولید کنید.</p>
<hr>
<h2>🔍 Reflecting and Activating Types</h2>
<p>در این بخش بررسی می‌کنیم که چگونه می‌توان یک <strong>Type</strong> را به دست آورد، متادیتای آن را بررسی کرد و از آن برای ایجاد دینامیکی یک شیء استفاده نمود.</p>
<h3>📌 Obtaining a Type</h3>
<p>یک نمونه از <code>System.Type</code> نمایانگر متادیتای یک Type است. از آن‌جا که <strong>Type</strong> بسیار پرکاربرد است، در فضای نام <code>System</code> قرار دارد، نه در <code>System.Reflection</code>.</p>
<p>روش‌های به‌دست‌آوردن یک نمونه‌ی <code>System.Type</code>:</p>
<p>۱. فراخوانی متد <code>GetType</code> روی هر شیء:</p>
<pre class="hljs"><code>Type t1 = DateTime.Now.GetType();     <span class="hljs-comment">// Type بدست‌آمده در زمان اجرا</span>
</code></pre>
<p>۲. استفاده از عملگر <code>typeof</code> در C#:</p>
<pre class="hljs"><code>Type t2 = <span class="hljs-keyword">typeof</span>(DateTime);          <span class="hljs-comment">// Type بدست‌آمده در زمان کامپایل</span>
</code></pre>
<p>با استفاده از <code>typeof</code> می‌توانید Type آرایه‌ها و Typeهای جنریک را نیز بگیرید:</p>
<pre class="hljs"><code>Type t3 = <span class="hljs-keyword">typeof</span>(DateTime[]);          <span class="hljs-comment">// آرایه یک‌بعدی</span>
Type t4 = <span class="hljs-keyword">typeof</span>(DateTime[,]);         <span class="hljs-comment">// آرایه دوبعدی</span>
Type t5 = <span class="hljs-keyword">typeof</span>(Dictionary&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;); <span class="hljs-comment">// جنریک بسته (Closed Generic Type)</span>
Type t6 = <span class="hljs-keyword">typeof</span>(Dictionary&lt;,&gt;);       <span class="hljs-comment">// جنریک باز (Unbound Generic Type)</span>
</code></pre>
<p>۳. دریافت Type از طریق نام (Name):<br>
اگر یک مرجع به Assembly داشته باشید:</p>
<pre class="hljs"><code>Type t = Assembly.GetExecutingAssembly().GetType(<span class="hljs-string">&quot;Demos.TestProgram&quot;</span>);
</code></pre>
<p>اگر Assembly را نداشته باشید، می‌توانید از <strong>Assembly Qualified Name</strong> استفاده کنید (نام کامل Type به‌همراه نام کامل یا جزئی Assembly). در این حالت Assembly به‌طور ضمنی بارگذاری می‌شود:</p>
<pre class="hljs"><code>Type t = Type.GetType(<span class="hljs-string">&quot;System.Int32, System.Private.CoreLib&quot;</span>);
</code></pre>
<p>پس از در اختیار داشتن یک شیء <code>System.Type</code>، می‌توانید با استفاده از ویژگی‌های آن به اطلاعاتی مانند نام، Assembly، Base Type، سطح دسترسی (Visibility) و ... دسترسی داشته باشید:</p>
<pre class="hljs"><code>Type stringType = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>);
<span class="hljs-built_in">string</span> name     = stringType.Name;          <span class="hljs-comment">// String</span>
Type baseType   = stringType.BaseType;      <span class="hljs-comment">// typeof(Object)</span>
Assembly assem  = stringType.Assembly;      <span class="hljs-comment">// System.Private.CoreLib</span>
<span class="hljs-built_in">bool</span> isPublic   = stringType.IsPublic;      <span class="hljs-comment">// true</span>
</code></pre>
<p>یک شیء از نوع <code>System.Type</code> در واقع پنجره‌ای به تمام متادیتای مربوط به آن Type و Assembly حاوی آن است.</p>
<blockquote>
<p><code>System.Type</code> یک کلاس <strong>Abstract</strong> است، بنابراین عملگر <code>typeof</code> در واقع یک زیرکلاس از Type را برمی‌گرداند. زیرکلاسی که CLR استفاده می‌کند داخلی (Internal) بوده و نام آن <strong>RuntimeType</strong> است.</p>
</blockquote>
<hr>
<h2>📘 TypeInfo</h2>
<p>اگر شما هدف‌گذاری روی <strong>.NET Core 1.x</strong> (یا پروفایل‌های قدیمی‌تر Windows Store) داشته باشید، بسیاری از اعضای <code>Type</code> در دسترس نیستند. این اعضا به جای آن در کلاسی به نام <code>TypeInfo</code> ارائه می‌شوند که از طریق فراخوانی <code>GetTypeInfo</code> به‌دست می‌آید.</p>
<p>برای اجرای مثال قبلی در چنین محیطی، کد شما این‌گونه خواهد بود:</p>
<pre class="hljs"><code>Type stringType = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>);
<span class="hljs-built_in">string</span> name = stringType.Name;
Type baseType = stringType.GetTypeInfo().BaseType;
Assembly assem = stringType.GetTypeInfo().Assembly;
<span class="hljs-built_in">bool</span> isPublic = stringType.GetTypeInfo().IsPublic;
</code></pre>
<p>کلاس <code>TypeInfo</code> در <strong>.NET Core 2 و 3</strong> و <strong>.NET 5+</strong> (و همچنین در <strong>.NET Framework 4.5+</strong> و تمامی نسخه‌های <strong>.NET Standard</strong>) نیز وجود دارد. بنابراین کد بالا تقریباً به‌طور جهانی (Universal) قابل اجراست.</p>
<p>همچنین <code>TypeInfo</code> ویژگی‌ها و متدهای اضافی برای بازتاب روی اعضا (Reflecting over Members) در اختیار قرار می‌دهد.</p>
<h2>📦 به‌دست‌آوردن انواع آرایه‌ها (Obtaining Array Types)</h2>
<p>همان‌طور که دیدیم، <code>typeof</code> و <code>GetType</code> با آرایه‌ها کار می‌کنند. علاوه بر این می‌توانید با فراخوانی <code>MakeArrayType</code> روی <strong>نوع المنت (Element Type)</strong>، یک نوع آرایه بسازید:</p>
<pre class="hljs"><code>Type simpleArrayType = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>).MakeArrayType();
Console.WriteLine(simpleArrayType == <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>[]));  <span class="hljs-comment">// True</span>
</code></pre>
<p>برای ایجاد آرایه‌های چندبعدی، کافی است یک آرگومان عدد صحیح به <code>MakeArrayType</code> بدهید:</p>
<pre class="hljs"><code>Type cubeType = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>).MakeArrayType(<span class="hljs-number">3</span>);   <span class="hljs-comment">// آرایه سه‌بعدی (شکل مکعب)</span>
Console.WriteLine(cubeType == <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>[,,])); <span class="hljs-comment">// True</span>
</code></pre>
<p>متد <code>GetElementType</code> عمل معکوس را انجام می‌دهد: نوع المنت یک آرایه را بازمی‌گرداند:</p>
<pre class="hljs"><code>Type e = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>[]).GetElementType();   <span class="hljs-comment">// e == typeof(int)</span>
</code></pre>
<p>متد <code>GetArrayRank</code> تعداد ابعاد یک آرایه مستطیلی را برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> rank = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>[,,]).GetArrayRank();  <span class="hljs-comment">// 3</span>
</code></pre>
<hr>
<h2>🧩 به‌دست‌آوردن نوع‌های تو در تو (Obtaining Nested Types)</h2>
<p>برای گرفتن نوع‌های تو در تو (Nested Types)، متد <code>GetNestedTypes</code> را روی نوع حاوی (Containing Type) فراخوانی کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-function">Type t <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span>(<span class="hljs-params">System.Environment</span>).<span class="hljs-title">GetNestedTypes</span>())
    Console.<span class="hljs-title">WriteLine</span>(<span class="hljs-params">t.FullName</span>)</span>;
</code></pre>
<p><strong>خروجی:</strong></p>
<pre class="hljs"><code>System.Environment+SpecialFolder
</code></pre>
<p>یا به روش دیگر:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-function">TypeInfo t <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span>(<span class="hljs-params">System.Environment</span>)
                        .<span class="hljs-title">GetTypeInfo</span>().DeclaredNestedTypes)
    Debug.<span class="hljs-title">WriteLine</span>(<span class="hljs-params">t.FullName</span>)</span>;
</code></pre>
<p>⚠️ تنها نکته این است که CLR یک نوع تو در تو را با سطوح دسترسی ویژه «Nested» در نظر می‌گیرد:</p>
<pre class="hljs"><code>Type t = <span class="hljs-keyword">typeof</span>(System.Environment.SpecialFolder);
Console.WriteLine(t.IsPublic);       <span class="hljs-comment">// False</span>
Console.WriteLine(t.IsNestedPublic); <span class="hljs-comment">// True</span>
</code></pre>
<hr>
<h2>🏷 نام انواع (Type Names)</h2>
<p>یک Type دارای ویژگی‌های <code>Namespace</code>، <code>Name</code> و <code>FullName</code> است. در بیشتر موارد، <code>FullName</code> ترکیبی از دو مورد اول است:</p>
<pre class="hljs"><code>Type t = <span class="hljs-keyword">typeof</span>(System.Text.StringBuilder);
Console.WriteLine(t.Namespace);  <span class="hljs-comment">// System.Text</span>
Console.WriteLine(t.Name);       <span class="hljs-comment">// StringBuilder</span>
Console.WriteLine(t.FullName);   <span class="hljs-comment">// System.Text.StringBuilder</span>
</code></pre>
<p>🔑 دو استثنا وجود دارد:</p>
<ol>
<li>نوع‌های تو در تو (Nested Types)</li>
<li>نوع‌های جنریک بسته (Closed Generic Types)</li>
</ol>
<p>همچنین ویژگی <code>AssemblyQualifiedName</code> وجود دارد که <code>FullName</code> را به‌همراه نام Assembly برمی‌گرداند. این همان رشته‌ای است که می‌توانید به <code>Type.GetType</code> بدهید و به‌طور منحصربه‌فرد یک Type را در محدوده‌ی بارگذاری پیش‌فرض مشخص می‌کند.</p>
<hr>
<h3>🔗 نام نوع‌های تو در تو (Nested Type Names)</h3>
<p>در نوع‌های تو در تو، نوع حاوی تنها در <code>FullName</code> ظاهر می‌شود:</p>
<pre class="hljs"><code>Type t = <span class="hljs-keyword">typeof</span>(System.Environment.SpecialFolder);
Console.WriteLine(t.Namespace);  <span class="hljs-comment">// System</span>
Console.WriteLine(t.Name);       <span class="hljs-comment">// SpecialFolder</span>
Console.WriteLine(t.FullName);   <span class="hljs-comment">// System.Environment+SpecialFolder</span>
</code></pre>
<p>🔹 علامت <code>+</code> نوع حاوی را از فضای نام تو در تو جدا می‌کند.</p>
<hr>
<h3>🌀 نام نوع‌های جنریک (Generic Type Names)</h3>
<p>نام نوع‌های جنریک با علامت بک‌تیک (<code>`</code>) و سپس تعداد پارامترهای نوع مشخص می‌شوند.</p>
<ul>
<li>اگر جنریک باز (Unbound) باشد، این قانون برای <code>Name</code> و <code>FullName</code> اعمال می‌شود:</li>
</ul>
<pre class="hljs"><code>Type t = <span class="hljs-keyword">typeof</span>(Dictionary&lt;,&gt;);
Console.WriteLine(t.Name);     <span class="hljs-comment">// Dictionary`2</span>
Console.WriteLine(t.FullName); <span class="hljs-comment">// System.Collections.Generic.Dictionary`2</span>
</code></pre>
<ul>
<li>اگر جنریک بسته (Closed) باشد، تنها <code>FullName</code> یک بخش اضافی طولانی شامل نام کامل Assembly هر پارامتر نوع را دریافت می‌کند:</li>
</ul>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-keyword">typeof</span>(Dictionary&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">string</span>&gt;).FullName);
</code></pre>
<p><strong>خروجی:</strong></p>
<pre class="hljs"><code>System.Collections.Generic.Dictionary`2[
 [System.Int32, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],
 [System.String, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]
]
</code></pre>
<p>این تضمین می‌کند که <code>AssemblyQualifiedName</code> اطلاعات کافی برای شناسایی کامل نوع جنریک و پارامترهای آن دارد.</p>
<hr>
<h3>📚 نام انواع آرایه و پوینتر (Array and Pointer Type Names)</h3>
<p>آرایه‌ها با همان پسوندی نمایش داده می‌شوند که در عبارت <code>typeof</code> استفاده می‌کنید:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>[]).Name);     <span class="hljs-comment">// Int32[]</span>
Console.WriteLine(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>[,]).Name);    <span class="hljs-comment">// Int32[,]</span>
Console.WriteLine(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>[,]).FullName);<span class="hljs-comment">// System.Int32[,]</span>
</code></pre>
<p>نوع‌های پوینتر مشابه هستند:</p>
<pre class="hljs"><code>Console.WriteLine(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">byte</span>*).Name);     <span class="hljs-comment">// Byte*</span>
</code></pre>
<hr>
<h3>🔄 نام انواع پارامترهای ref و out</h3>
<p>یک <code>Type</code> که نماینده‌ی پارامتر <code>ref</code> یا <code>out</code> باشد، پسوند <code>&amp;</code> دارد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RefMethod</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> p</span>)</span>
{
    Type t = MethodInfo.GetCurrentMethod().GetParameters()[<span class="hljs-number">0</span>].ParameterType;
    Console.WriteLine(t.Name);   <span class="hljs-comment">// Int32&amp;</span>
}
</code></pre>
<p>(جزئیات بیشتر در بخش «Reflecting and Invoking Members» در صفحه 813 توضیح داده می‌شود.)</p>
<hr>
<h2>🧬 Base Types و Interfaces</h2>
<p>کلاس <code>Type</code> یک ویژگی به نام <code>BaseType</code> دارد:</p>
<pre class="hljs"><code>Type base1 = <span class="hljs-keyword">typeof</span>(System.String).BaseType;
Type base2 = <span class="hljs-keyword">typeof</span>(System.IO.FileStream).BaseType;
Console.WriteLine(base1.Name);  <span class="hljs-comment">// Object</span>
Console.WriteLine(base2.Name);  <span class="hljs-comment">// Stream</span>
</code></pre>
<p>متد <code>GetInterfaces</code> رابط‌هایی (Interfaces) را که یک Type پیاده‌سازی می‌کند برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-function">Type iType <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span>(<span class="hljs-params">Guid</span>).<span class="hljs-title">GetInterfaces</span>())
    Console.<span class="hljs-title">WriteLine</span>(<span class="hljs-params">iType.Name</span>)</span>;
</code></pre>
<p><strong>خروجی:</strong></p>
<pre class="hljs"><code>IFormattable
IComparable
IComparable`1
IEquatable`1
</code></pre>
<p>(متد <code>GetInterfaceMap</code> یک ساختار بازمی‌گرداند که نشان می‌دهد هر عضو از یک Interface چگونه در یک کلاس یا Struct پیاده‌سازی شده است—نمونه‌ی آن در بخش «Calling Static Virtual/Abstract Interface Members» در صفحه 826 آمده است.)</p>
<hr>
<h2>⚖️ معادل‌های پویا برای عملگر is در C#</h2>
<p>Reflection سه معادل پویا برای عملگر ایستای <code>is</code> در C# ارائه می‌دهد:</p>
<ul>
<li><code>IsInstanceOfType</code> → یک Type و یک نمونه را می‌پذیرد.</li>
<li><code>IsAssignableFrom</code> و (از .NET 5) <code>IsAssignableTo</code> → دو Type را می‌پذیرند.</li>
</ul>
<h3>مثال ۱</h3>
<pre class="hljs"><code><span class="hljs-built_in">object</span> obj  = Guid.NewGuid();
Type target = <span class="hljs-keyword">typeof</span>(IFormattable);

<span class="hljs-built_in">bool</span> isTrue   = obj <span class="hljs-keyword">is</span> IFormattable;            <span class="hljs-comment">// عملگر ایستای C#</span>
<span class="hljs-built_in">bool</span> alsoTrue = target.IsInstanceOfType(obj);   <span class="hljs-comment">// معادل پویا</span>
</code></pre>
<h3>مثال ۲</h3>
<pre class="hljs"><code>Type target = <span class="hljs-keyword">typeof</span>(IComparable), source = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>);
Console.WriteLine(target.IsAssignableFrom(source));  <span class="hljs-comment">// True</span>
</code></pre>
<p>متد <code>IsSubclassOf</code> هم بر اساس همان اصل <code>IsAssignableFrom</code> کار می‌کند، با این تفاوت که Interfaceها را در نظر نمی‌گیرد.</p>
<h2>🏗 ایجاد نمونه از انواع (Instantiating Types)</h2>
<p>دو روش برای ایجاد دینامیکی یک شیء از روی نوع (Type) وجود دارد:</p>
<ol>
<li>فراخوانی متد استاتیک <code>Activator.CreateInstance</code></li>
<li>فراخوانی <code>Invoke</code> روی یک شیء از نوع <code>ConstructorInfo</code> که از متد <code>GetConstructor</code> روی یک Type به‌دست آمده است (برای سناریوهای پیشرفته)</li>
</ol>
<hr>
<h3>🔹 استفاده از Activator.CreateInstance</h3>
<p>متد <code>Activator.CreateInstance</code> یک Type و آرگومان‌های اختیاری دریافت می‌کند و آن‌ها را به سازنده (Constructor) پاس می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>)Activator.CreateInstance(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>));

DateTime dt = (DateTime)Activator.CreateInstance(<span class="hljs-keyword">typeof</span>(DateTime),
                                                 <span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
</code></pre>
<p>این متد گزینه‌های بیشتری نیز فراهم می‌کند، مانند مشخص‌کردن Assembly برای بارگذاری نوع یا امکان اتصال به سازنده‌های <strong>Nonpublic</strong>.<br>
اگر CLR نتواند سازنده‌ی مناسب پیدا کند، یک استثناء از نوع <code>MissingMethodException</code> پرتاب می‌شود. ⚠️</p>
<hr>
<h3>🔹 استفاده از ConstructorInfo.Invoke</h3>
<p>گاهی اوقات باید از <code>ConstructorInfo.Invoke</code> استفاده کنید، به‌ویژه زمانی که مقدار آرگومان‌ها نمی‌تواند بین سازنده‌های Overload تمایز ایجاد کند.</p>
<p>فرض کنید کلاس <code>X</code> دو سازنده دارد:</p>
<ul>
<li>یکی با پارامتر <code>string</code></li>
<li>دیگری با پارامتر <code>StringBuilder</code></li>
</ul>
<p>در این حالت اگر مقدار <code>null</code> را به <code>Activator.CreateInstance</code> بدهید، نتیجه مبهم خواهد بود. پس باید مستقیماً از <code>ConstructorInfo</code> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-comment">// گرفتن سازنده‌ای که یک پارامتر از نوع string دارد:</span>
ConstructorInfo ci = <span class="hljs-keyword">typeof</span>(X).GetConstructor(<span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>) });

<span class="hljs-comment">// ساخت شیء با همان overload و پاس دادن null:</span>
<span class="hljs-built_in">object</span> foo = ci.Invoke(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { <span class="hljs-literal">null</span> });
</code></pre>
<p>اگر هدف شما <strong>.NET Core 1</strong> یا پروفایل‌های قدیمی Windows Store باشد:</p>
<pre class="hljs"><code>ConstructorInfo ci = <span class="hljs-keyword">typeof</span>(X).GetTypeInfo().DeclaredConstructors
    .FirstOrDefault(c =&gt;
        c.GetParameters().Length == <span class="hljs-number">1</span> &amp;&amp;
        c.GetParameters()[<span class="hljs-number">0</span>].ParameterType == <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>));
</code></pre>
<p>برای گرفتن سازنده‌های <strong>Nonpublic</strong> باید از <strong>BindingFlags</strong> استفاده کنید (توضیح در بخش «Accessing Nonpublic Members» در صفحه 822).</p>
<hr>
<h3>⚡ نکته‌ی عملکردی</h3>
<p>ایجاد نمونه‌ی دینامیکی چند <strong>میکروثانیه</strong> به زمان ساخت شیء اضافه می‌کند. این مقدار در مقیاس نسبی زیاد است، چون CLR به‌طور عادی بسیار سریع در ایجاد اشیاء عمل می‌کند (یک <code>new</code> ساده روی یک کلاس کوچک در حد چند <strong>نانوسانیه</strong> زمان می‌برد).</p>
<hr>
<h3>📚 ایجاد دینامیکی آرایه‌ها و جنریک‌ها</h3>
<p>برای ایجاد آرایه‌ها به‌صورت دینامیکی، ابتدا باید <code>MakeArrayType</code> را فراخوانی کنید.<br>
ایجاد نوع‌های جنریک نیز ممکن است (در بخش بعدی توضیح داده می‌شود).</p>
<hr>
<h3>🪝 ایجاد دینامیکی Delegateها</h3>
<p>برای ایجاد Delegate به‌صورت دینامیکی، متد <code>Delegate.CreateDelegate</code> را فراخوانی کنید. مثال زیر ایجاد هر دو نوع Delegate (استاتیک و Instance) را نشان می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">IntFunc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>;

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Square</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x;        <span class="hljs-comment">// متد استاتیک</span>
    <span class="hljs-function"><span class="hljs-built_in">int</span>        <span class="hljs-title">Cube</span>  (<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * x * x;    <span class="hljs-comment">// متد Instance</span>

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        Delegate staticD = Delegate.CreateDelegate(
            <span class="hljs-keyword">typeof</span>(IntFunc), <span class="hljs-keyword">typeof</span>(Program), <span class="hljs-string">&quot;Square&quot;</span>);

        Delegate instanceD = Delegate.CreateDelegate(
            <span class="hljs-keyword">typeof</span>(IntFunc), <span class="hljs-keyword">new</span> Program(), <span class="hljs-string">&quot;Cube&quot;</span>);

        Console.WriteLine(staticD.DynamicInvoke(<span class="hljs-number">3</span>));   <span class="hljs-comment">// 9</span>
        Console.WriteLine(instanceD.DynamicInvoke(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 27</span>
    }
}
</code></pre>
<p>برای فراخوانی Delegate ایجادشده، می‌توانید از <code>DynamicInvoke</code> استفاده کنید (همان‌طور که در مثال بالا دیدیم) یا آن را به نوع Delegate اصلی Cast کنید:</p>
<pre class="hljs"><code>IntFunc f = (IntFunc)staticD;
Console.WriteLine(f(<span class="hljs-number">3</span>));   <span class="hljs-comment">// 9 (اما بسیار سریع‌تر!)</span>
</code></pre>
<p>همچنین می‌توانید به‌جای نام متد، یک <code>MethodInfo</code> به <code>CreateDelegate</code> بدهید. جزئیات مربوط به <code>MethodInfo</code> در بخش <strong>“Reflecting and Invoking Members”</strong> در صفحه 813 آمده است، همراه با دلیل اینکه چرا بهتر است یک Delegate ایجادشده‌ی دینامیکی را دوباره به نوع Delegate ایستای خودش Cast کنیم.</p>
<h2>🧩 انواع جنریک (Generic Types)</h2>
<p>یک شیء از نوع <code>Type</code> می‌تواند نشان‌دهنده‌ی یک نوع جنریک <strong>بسته (Closed)</strong> یا <strong>باز (Unbound)</strong> باشد.<br>
همانند زمان کامپایل، فقط نوع جنریک بسته را می‌توان نمونه‌سازی کرد، در حالی‌که نوع باز غیرقابل نمونه‌سازی است:</p>
<pre class="hljs"><code>Type closed = <span class="hljs-keyword">typeof</span>(List&lt;<span class="hljs-built_in">int</span>&gt;);
List&lt;<span class="hljs-built_in">int</span>&gt; list = (List&lt;<span class="hljs-built_in">int</span>&gt;)Activator.CreateInstance(closed);  <span class="hljs-comment">// OK ✅</span>

Type unbound = <span class="hljs-keyword">typeof</span>(List&lt;&gt;);
<span class="hljs-built_in">object</span> anError = Activator.CreateInstance(unbound);            <span class="hljs-comment">// خطای زمان اجرا ❌</span>
</code></pre>
<p>برای تبدیل یک نوع جنریک باز به بسته از متد <code>MakeGenericType</code> استفاده می‌کنیم:</p>
<pre class="hljs"><code>Type unbound = <span class="hljs-keyword">typeof</span>(List&lt;&gt;);
Type closed = unbound.MakeGenericType(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>));
</code></pre>
<p>برعکس آن، متد <code>GetGenericTypeDefinition</code> یک نوع بسته را دوباره به شکل باز برمی‌گرداند:</p>
<pre class="hljs"><code>Type unbound2 = closed.GetGenericTypeDefinition();  <span class="hljs-comment">// unbound == unbound2</span>
</code></pre>
<p>🔎 ویژگی‌های کلیدی:</p>
<ul>
<li><code>IsGenericType</code> → بررسی می‌کند که آیا یک نوع، جنریک است یا نه.</li>
<li><code>IsGenericTypeDefinition</code> → بررسی می‌کند که آیا نوع، <strong>باز (unbound)</strong> است یا نه.</li>
</ul>
<p>مثال بررسی نوع Nullable:</p>
<pre class="hljs"><code>Type nullable = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">bool</span>?);
Console.WriteLine(
    nullable.IsGenericType &amp;&amp;
    nullable.GetGenericTypeDefinition() == <span class="hljs-keyword">typeof</span>(Nullable&lt;&gt;));   <span class="hljs-comment">// True</span>
</code></pre>
<p>همچنین، متد <code>GetGenericArguments</code> آرگومان‌های نوع را بازمی‌گرداند:</p>
<pre class="hljs"><code>Console.WriteLine(closed.GetGenericArguments()[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// System.Int32</span>
Console.WriteLine(nullable.GetGenericArguments()[<span class="hljs-number">0</span>]); <span class="hljs-comment">// System.Boolean</span>
Console.WriteLine(unbound.GetGenericArguments()[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// T (پلا‌یس‌هولدر)</span>
</code></pre>
<p>📌 در زمان اجرا، تمام انواع جنریک یا <strong>باز (Unbound)</strong> هستند یا <strong>بسته (Closed)</strong>.</p>
<ul>
<li>حالت باز فقط در موارد نادری مثل <code>typeof(Foo&lt;&gt;)</code> رخ می‌دهد.</li>
<li>هیچ‌وقت نوع «باز» واقعی در زمان اجرا وجود ندارد؛ کامپایلر همه را به نوع بسته تبدیل می‌کند.</li>
</ul>
<p>مثال زیر همیشه False چاپ می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span>
        =&gt; Console.Write(GetType().IsGenericTypeDefinition);  
}
</code></pre>
<hr>
<h2>🔍 بازتاب اعضا (Reflecting and Invoking Members)</h2>
<p>برای بازتاب اعضای یک نوع، از متد <code>GetMembers</code> استفاده می‌کنیم.</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Walnut</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> cracked;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Crack</span>()</span> { cracked = <span class="hljs-literal">true</span>; }
}

MemberInfo[] members = <span class="hljs-keyword">typeof</span>(Walnut).GetMembers();
<span class="hljs-keyword">foreach</span> (MemberInfo m <span class="hljs-keyword">in</span> members)
    Console.WriteLine(m);
</code></pre>
<p>نتیجه:</p>
<pre class="hljs"><code>Void Crack()
System.Type GetType()
System.String ToString()
Boolean Equals(System.Object)
Int32 GetHashCode()
Void .ctor()
</code></pre>
<hr>
<h3>🔹 TypeInfo و بازتاب اعضا</h3>
<p>کلاس <code>TypeInfo</code> یک پروتکل ساده‌تر برای بازتاب اعضا ارائه می‌دهد.</p>
<ul>
<li>به جای متدهایی مثل <code>GetMembers</code> که آرایه بازمی‌گردانند، این کلاس ویژگی‌هایی از نوع <code>IEnumerable&lt;T&gt;</code> ارائه می‌دهد که معمولاً با <strong>LINQ</strong> استفاده می‌شوند.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code>IEnumerable&lt;MemberInfo&gt; members =
    <span class="hljs-keyword">typeof</span>(Walnut).GetTypeInfo().DeclaredMembers;
</code></pre>
<p>نتیجه (برخلاف <code>GetMembers</code> که اعضای ارث‌برده‌شده را هم برمی‌گرداند):</p>
<pre class="hljs"><code>Void Crack()
Void .ctor()
Boolean cracked
</code></pre>
<p>همچنین ویژگی‌های خاصی برای گرفتن نوع مشخصی از اعضا وجود دارد (مثل <code>DeclaredMethods</code>, <code>DeclaredProperties</code> و غیره).<br>
برای گرفتن یک متد خاص با نام (اما بدون امکان تعیین پارامترها)، از <code>GetDeclaredMethod</code> استفاده می‌شود.</p>
<p>برای متدهای overload باید از LINQ استفاده کرد:</p>
<pre class="hljs"><code>MethodInfo method = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>).GetTypeInfo().DeclaredMethods
    .FirstOrDefault(m =&gt; m.Name == <span class="hljs-string">&quot;ToString&quot;</span> &amp;&amp;
                         m.GetParameters().Length == <span class="hljs-number">0</span>);
</code></pre>
<hr>
<h3>🔹 جزئیات بیشتر در مورد GetMembers</h3>
<ul>
<li>بدون آرگومان → تمام اعضای public نوع و پایه‌هایش برگردانده می‌شوند.</li>
<li><code>GetMember(&quot;Crack&quot;)</code> → عضو خاصی را با نام می‌گیرد (اما به‌صورت آرایه برمی‌گرداند چون ممکن است overload داشته باشد).</li>
</ul>
<pre class="hljs"><code>MemberInfo[] m = <span class="hljs-keyword">typeof</span>(Walnut).GetMember(<span class="hljs-string">&quot;Crack&quot;</span>);
Console.WriteLine(m[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// Void Crack()</span>
</code></pre>
<p><code>MemberInfo.MemberType</code> یک enum از نوع <code>MemberTypes</code> است که مقادیر زیر را دارد:</p>
<pre class="hljs"><code>All, Constructor, Custom, Event, Field, Method,
NestedType, Property, TypeInfo
</code></pre>
<p>می‌توان با استفاده از این enum نتیجه‌ی متد <code>GetMembers</code> را محدود کرد یا مستقیماً از متدهای اختصاصی مثل <code>GetMethods</code>, <code>GetFields</code>, <code>GetProperties</code> و ... استفاده کرد.</p>
<p>✅ توصیه: همیشه هنگام گرفتن اعضا، تا جای ممکن دقیق باشید. مثلاً هنگام گرفتن متدی با نام خاص، نوع همه‌ی پارامترها را مشخص کنید تا اگر بعداً متد overload شد، کد شما همچنان درست کار کند.</p>
<hr>
<h3>🔹 DeclaringType و ReflectedType</h3>
<p>یک شیء <code>MemberInfo</code> دو ویژگی دارد:</p>
<ul>
<li><code>DeclaringType</code> → نوعی که عضو را تعریف کرده.</li>
<li><code>ReflectedType</code> → نوعی که متد <code>GetMembers</code> روی آن فراخوانی شده.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code>MethodInfo test = <span class="hljs-keyword">typeof</span>(Program).GetMethod(<span class="hljs-string">&quot;ToString&quot;</span>);
MethodInfo obj  = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">object</span>).GetMethod(<span class="hljs-string">&quot;ToString&quot;</span>);

Console.WriteLine(test.DeclaringType);   <span class="hljs-comment">// System.Object</span>
Console.WriteLine(obj.DeclaringType);    <span class="hljs-comment">// System.Object</span>
Console.WriteLine(test.ReflectedType);   <span class="hljs-comment">// Program</span>
Console.WriteLine(obj.ReflectedType);    <span class="hljs-comment">// System.Object</span>
Console.WriteLine(test == obj);          <span class="hljs-comment">// False</span>
</code></pre>
<p>در اینجا، تفاوت فقط به خاطر Reflection API است؛ در حقیقت <code>Program</code> هیچ متد جدیدی به نام <code>ToString</code> ندارد.</p>
<p>برای بررسی اینکه آیا دو متد واقعاً یکی هستند:</p>
<pre class="hljs"><code>Console.WriteLine(test.MethodHandle == obj.MethodHandle); <span class="hljs-comment">// True</span>
Console.WriteLine(test.MetadataToken == obj.MetadataToken
                  &amp;&amp; test.Module == obj.Module);           <span class="hljs-comment">// True</span>
</code></pre>
<hr>
<h3>📝 نکات پایانی</h3>
<ul>
<li><code>MethodHandle</code> → برای هر متد متمایز در یک پروسه یکتا است.</li>
<li><code>MetadataToken</code> → برای تمام انواع و اعضا در یک Assembly Module یکتا است.</li>
<li><code>MemberInfo</code> متدهایی برای دریافت Attributeهای سفارشی هم دارد (بخش «Retrieving Attributes at Runtime» در صفحه 832).</li>
<li>متد <code>MethodBase.GetCurrentMethod</code>، متد در حال اجرا را بازمی‌گرداند.</li>
</ul>
<p>📌 در نهایت، <code>MemberInfo</code> خودش انتزاعی است و پایه‌ای برای انواع دیگر است (به شکل <strong>Figure 18-1</strong> در کتاب).</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>شما می‌توانید یک MemberInfo را بر اساس ویژگی MemberType آن به زیرکلاس مناسبش Cast کنید. اگر یک عضو را از طریق GetMethod, GetField, GetProperty, GetEvent, GetConstructor یا GetNestedType (یا نسخه‌های جمع آن‌ها) به دست آورده باشید، نیازی به Cast نیست.</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>هر زیرکلاس از <code>MemberInfo</code> مجموعه‌ای غنی از ویژگی‌ها و متدها دارد که تمام جنبه‌های متادیتای یک عضو را آشکار می‌کند. این شامل مواردی مثل سطح دسترسی (visibility)، اصلاح‌کننده‌ها (modifiers)، آرگومان‌های نوع جنریک، پارامترها، نوع بازگشتی و ویژگی‌های سفارشی (custom attributes) می‌شود.</p>
<p>نمونه‌ای از استفاده از <code>GetMethod</code>:</p>
<pre class="hljs"><code>MethodInfo m = <span class="hljs-keyword">typeof</span> (Walnut).GetMethod (<span class="hljs-string">&quot;Crack&quot;</span>);
Console.WriteLine (m);            <span class="hljs-comment">// Void Crack()</span>
Console.WriteLine (m.ReturnType); <span class="hljs-comment">// System.Void</span>
</code></pre>
<p>تمام نمونه‌های *Info توسط Reflection API در اولین استفاده کش می‌شوند:</p>
<pre class="hljs"><code>MethodInfo method = <span class="hljs-keyword">typeof</span> (Walnut).GetMethod (<span class="hljs-string">&quot;Crack&quot;</span>);
MemberInfo member = <span class="hljs-keyword">typeof</span> (Walnut).GetMember (<span class="hljs-string">&quot;Crack&quot;</span>)[<span class="hljs-number">0</span>];
Console.Write (method == member);   <span class="hljs-comment">// True</span>
</code></pre>
<p>این کش شدن علاوه بر حفظ هویت شیء، کارایی را هم در یک API نسبتاً کند بهبود می‌دهد.</p>
<h3>اعضای C# در برابر اعضای CLR ⚖️</h3>
<p>جدول قبلی نشان داد که برخی از ساختارهای C# به‌طور مستقیم و یک‌به‌یک (1:1) با ساختارهای CLR متناظر نیستند. این منطقی است چون CLR و Reflection API برای تمام زبان‌های .NET طراحی شده‌اند—حتی می‌توان از Reflection در Visual Basic هم استفاده کرد.</p>
<p>برخی ساختارهای C# (مثل indexer، enum، operator و finalizer) در CLR به شکل متفاوتی پیاده‌سازی می‌شوند:</p>
<ul>
<li>یک <strong>C# indexer</strong> به پراپرتی‌ای ترجمه می‌شود که یک یا چند آرگومان می‌گیرد و با <code>[DefaultMember]</code> مشخص می‌شود.</li>
<li>یک <strong>C# enum</strong> به زیرکلاسی از <code>System.Enum</code> ترجمه می‌شود که برای هر عضو یک فیلد استاتیک دارد.</li>
<li>یک <strong>C# operator</strong> به متدی استاتیک با نامی خاص (شروع‌شده با <code>op_</code> مثل <code>&quot;op_Addition&quot;</code>) ترجمه می‌شود.</li>
<li>یک <strong>C# finalizer</strong> به متدی ترجمه می‌شود که <code>Finalize</code> را override می‌کند.</li>
</ul>
<p>❗ پیچیدگی دیگر این است که پراپرتی‌ها و رویدادها در واقع شامل دو چیز هستند:</p>
<ul>
<li>متادیتایی که پراپرتی یا رویداد را توصیف می‌کند (در قالب <code>PropertyInfo</code> یا <code>EventInfo</code>)</li>
<li>یک یا دو متد پشتیبان (backing methods)</li>
</ul>
<p>در برنامه C#، این متدهای پشتیبان داخل تعریف پراپرتی یا رویداد قرار دارند. اما وقتی به IL کامپایل می‌شود، این متدها مثل متدهای عادی دیده می‌شوند و می‌توان آن‌ها را فراخوانی کرد.</p>
<p>به همین دلیل <code>GetMethods</code> علاوه بر متدهای عادی، متدهای پشتیبان پراپرتی و رویدادها را هم برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X { <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; } <span class="hljs-keyword">set</span> {} } }

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Demo</span>()</span>
{
  <span class="hljs-keyword">foreach</span> (<span class="hljs-function">MethodInfo mi <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span> (<span class="hljs-params">Test</span>).<span class="hljs-title">GetMethods</span>())
    Console.<span class="hljs-title">Write</span> (<span class="hljs-params">mi.Name + <span class="hljs-string">&quot;  &quot;</span></span>)</span>;
}
<span class="hljs-comment">// OUTPUT:</span>
<span class="hljs-comment">// get_X  set_X  GetType  ToString  Equals  GetHashCode</span>
</code></pre>
<p>برای شناسایی این متدها می‌توان از ویژگی <code>IsSpecialName</code> در <code>MethodInfo</code> استفاده کرد. مقدار آن برای متدهای پراپرتی، ایندکسر، رویداد و عملگرها <strong>true</strong> است. برای متدهای معمولی C# (و متد <code>Finalize</code> در صورت وجود finalizer) مقدار آن <strong>false</strong> خواهد بود.</p>
<p>در ادامه، متدهای پشتیبانی که C# تولید می‌کند را خواهیم دید.</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>هر متد پشتیبان (backing method) شیء مخصوص به خودش از نوع <code>MethodInfo</code> دارد. می‌توانید به این صورت به آن‌ها دسترسی پیدا کنید:</p>
<pre class="hljs"><code>PropertyInfo pi = <span class="hljs-keyword">typeof</span> (Console).GetProperty (<span class="hljs-string">&quot;Title&quot;</span>);
MethodInfo getter = pi.GetGetMethod();                   <span class="hljs-comment">// get_Title</span>
MethodInfo setter = pi.GetSetMethod();                   <span class="hljs-comment">// set_Title</span>
MethodInfo[] both = pi.GetAccessors();                   <span class="hljs-comment">// Length==2</span>
</code></pre>
<p>برای رویدادها (Event)، متدهای <code>GetAddMethod</code> و <code>GetRemoveMethod</code> کار مشابهی برای <code>EventInfo</code> انجام می‌دهند.</p>
<p>برای حرکت در جهت عکس—یعنی رفتن از یک <code>MethodInfo</code> به <code>PropertyInfo</code> یا <code>EventInfo</code> مربوطه—باید یک کوئری انجام دهید. در اینجا LINQ برای این کار ایدئال است:</p>
<pre class="hljs"><code>PropertyInfo p = mi.DeclaringType.GetProperties()
                  .First (x =&gt; x.GetAccessors (<span class="hljs-literal">true</span>).Contains (mi));
</code></pre>
<hr>
<h3>پراپرتی‌های Init-only 🛠️</h3>
<p>پراپرتی‌های Init-only که در C# 9 معرفی شدند، می‌توانند از طریق <strong>object initializer</strong> مقداردهی شوند، اما بعد از آن توسط کامپایلر فقط به‌عنوان <em>فقط-خواندنی</em> در نظر گرفته می‌شوند.</p>
<p>از دید CLR، یک <strong>init accessor</strong> درست مثل یک <strong>set accessor</strong> عادی است، با این تفاوت که یک فلگ خاص روی نوع بازگشتی متد <code>set</code> اعمال می‌شود (این فلگ برای کامپایلر معنا دارد).</p>
<p>نکته جالب این است که این فلگ به شکل یک <strong>attribute قراردادی</strong> رمزگذاری نشده است. در عوض، از یک مکانیزم کمتر شناخته‌شده به نام <strong>modreq</strong> استفاده می‌کند. این باعث می‌شود که نسخه‌های قدیمی‌تر کامپایلر C# (که modreq جدید را نمی‌شناسند) آن accessor را نادیده بگیرند، به‌جای اینکه پراپرتی را قابل نوشتن در نظر بگیرند.</p>
<p>نام modreq برای accessorهای init-only برابر است با <code>IsExternalInit</code> و می‌توانید به این صورت آن را بررسی کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsInitOnly</span> (<span class="hljs-params">PropertyInfo pi</span>)</span> =&gt; pi
 .GetSetMethod().ReturnParameter.GetRequiredCustomModifiers()
 .Any (t =&gt; t.Name == <span class="hljs-string">&quot;IsExternalInit&quot;</span>);
</code></pre>
<hr>
<h3>NullabilityInfoContext ☑️</h3>
<p>از .NET 6 به بعد، می‌توانید با کلاس <code>NullabilityInfoContext</code> اطلاعاتی درباره <strong>annotation</strong>‌های nullability برای فیلد، پراپرتی، رویداد یا پارامترها به دست آورید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintPropertyNullability</span> (<span class="hljs-params">PropertyInfo pi</span>)</span>
{
 <span class="hljs-keyword">var</span> info = <span class="hljs-keyword">new</span> NullabilityInfoContext().Create (pi);
 Console.WriteLine (pi.Name + <span class="hljs-string">&quot; read &quot;</span> + info.ReadState);
 Console.WriteLine (pi.Name + <span class="hljs-string">&quot; write &quot;</span> + info.WriteState);
 <span class="hljs-comment">// از info.Element برای گرفتن اطلاعات nullability عناصر آرایه استفاده کنید</span>
}
</code></pre>
<hr>
<h3>اعضای نوع جنریک 🔁</h3>
<p>می‌توانید متادیتای اعضا را هم برای <strong>انواع جنریک باز (unbound generic types)</strong> و هم برای <strong>انواع جنریک بسته (closed generic types)</strong> به دست آورید:</p>
<pre class="hljs"><code>PropertyInfo unbound = <span class="hljs-keyword">typeof</span> (IEnumerator&lt;&gt;)  .GetProperty (<span class="hljs-string">&quot;Current&quot;</span>);
PropertyInfo closed = <span class="hljs-keyword">typeof</span> (IEnumerator&lt;<span class="hljs-built_in">int</span>&gt;).GetProperty (<span class="hljs-string">&quot;Current&quot;</span>);
Console.WriteLine (unbound);   <span class="hljs-comment">// T Current</span>
Console.WriteLine (closed);    <span class="hljs-comment">// Int32 Current</span>
Console.WriteLine (unbound.PropertyType.IsGenericParameter);  <span class="hljs-comment">// True</span>
Console.WriteLine (closed.PropertyType.IsGenericParameter);   <span class="hljs-comment">// False</span>
</code></pre>
<p>شیءهای <code>MemberInfo</code> که از انواع جنریک باز و بسته بازگردانده می‌شوند همیشه متمایز هستند، حتی اگر امضای اعضا شامل پارامترهای نوع جنریک نباشد:</p>
<pre class="hljs"><code>PropertyInfo unbound = <span class="hljs-keyword">typeof</span> (List&lt;&gt;)  .GetProperty (<span class="hljs-string">&quot;Count&quot;</span>);
PropertyInfo closed = <span class="hljs-keyword">typeof</span> (List&lt;<span class="hljs-built_in">int</span>&gt;).GetProperty (<span class="hljs-string">&quot;Count&quot;</span>);
Console.WriteLine (unbound);   <span class="hljs-comment">// Int32 Count</span>
Console.WriteLine (closed);    <span class="hljs-comment">// Int32 Count</span>
Console.WriteLine (unbound == closed);   <span class="hljs-comment">// False</span>
Console.WriteLine (unbound.DeclaringType.IsGenericTypeDefinition); <span class="hljs-comment">// True</span>
Console.WriteLine (closed.DeclaringType.IsGenericTypeDefinition); <span class="hljs-comment">// False</span>
</code></pre>
<p>❌ اعضای انواع جنریک باز (<strong>unbound generic types</strong>) را نمی‌توان به‌صورت داینامیک invoke کرد.</p>
<h3>فراخوانی پویا اعضا ⚡</h3>
<p>فراخوانی پویا یک عضو می‌تواند با استفاده از کتابخانه‌ی <strong>Uncapsulator</strong> (متن‌باز و موجود در NuGet و GitHub) بسیار راحت‌تر انجام شود. این کتابخانه که توسط نویسنده‌ی کتاب نوشته شده، یک API روان برای فراخوانی اعضای عمومی و غیرعمومی از طریق Reflection، با استفاده از یک <strong>dynamic binder</strong> سفارشی ارائه می‌دهد.</p>
<p>پس از آنکه یک شیء از نوع <code>MethodInfo</code>، <code>PropertyInfo</code> یا <code>FieldInfo</code> داشته باشید، می‌توانید آن را به‌صورت پویا فراخوانی کنید یا مقدارش را بگیرید/تعیین کنید. این کار <strong>late binding</strong> نام دارد، زیرا شما انتخاب می‌کنید کدام عضو در زمان اجرا (runtime) فراخوانی شود، نه در زمان کامپایل.</p>
<p>برای نمونه، این کد با <strong>static binding</strong> عادی نوشته شده است:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;Hello&quot;</span>;
<span class="hljs-built_in">int</span> length = s.Length;
</code></pre>
<p>و همین کار با <strong>late binding</strong> پویا چنین خواهد بود:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span> s = <span class="hljs-string">&quot;Hello&quot;</span>;
PropertyInfo prop = s.GetType().GetProperty (<span class="hljs-string">&quot;Length&quot;</span>);
<span class="hljs-built_in">int</span> length = (<span class="hljs-built_in">int</span>) prop.GetValue (s, <span class="hljs-literal">null</span>);   <span class="hljs-comment">// 5</span>
</code></pre>
<p>متدهای <code>GetValue</code> و <code>SetValue</code> مقدار یک <code>PropertyInfo</code> یا <code>FieldInfo</code> را می‌گیرند یا تنظیم می‌کنند. آرگومان اول نمونه (instance) است، که برای اعضای <code>static</code> می‌تواند <code>null</code> باشد.</p>
<p>برای دسترسی به <strong>Indexer</strong> نیز درست مثل پراپرتی‌ای به نام <code>&quot;Item&quot;</code> رفتار می‌شود، با این تفاوت که مقادیر indexer به‌عنوان آرگومان دوم به <code>GetValue</code> یا <code>SetValue</code> داده می‌شوند.</p>
<p>برای فراخوانی پویا یک متد، متد <code>Invoke</code> را روی یک <code>MethodInfo</code> صدا می‌زنید و یک آرایه از آرگومان‌ها به آن می‌دهید. اگر نوع یکی از آرگومان‌ها اشتباه باشد، یک <strong>exception</strong> در زمان اجرا رخ خواهد داد. با فراخوانی پویا، ایمنی نوع در زمان کامپایل را از دست می‌دهید، اما همچنان ایمنی نوع در زمان اجرا را دارید (دقیقاً مثل استفاده از کلیدواژه‌ی <code>dynamic</code>).</p>
<hr>
<h3>پارامترهای متد 📑</h3>
<p>فرض کنید بخواهیم متد <code>Substring</code> رشته را پویا فراخوانی کنیم. در حالت عادی (static):</p>
<pre class="hljs"><code>Console.WriteLine (<span class="hljs-string">&quot;stamp&quot;</span>.Substring(<span class="hljs-number">2</span>));   <span class="hljs-comment">// &quot;amp&quot;</span>
</code></pre>
<p>معادل پویا با reflection و late binding:</p>
<pre class="hljs"><code>Type type = <span class="hljs-keyword">typeof</span> (<span class="hljs-built_in">string</span>);
Type[] parameterTypes = { <span class="hljs-keyword">typeof</span> (<span class="hljs-built_in">int</span>) };
MethodInfo method = type.GetMethod (<span class="hljs-string">&quot;Substring&quot;</span>, parameterTypes);
<span class="hljs-built_in">object</span>[] arguments = { <span class="hljs-number">2</span> };
<span class="hljs-built_in">object</span> returnValue = method.Invoke (<span class="hljs-string">&quot;stamp&quot;</span>, arguments);
Console.WriteLine (returnValue);   <span class="hljs-comment">// &quot;amp&quot;</span>
</code></pre>
<p>از آنجا که متد <code>Substring</code> overload دارد، مجبور شدیم یک آرایه از نوع پارامترها بدهیم تا مشخص شود کدام نسخه‌ی متد را می‌خواهیم. در غیر این صورت، <code>GetMethod</code> خطای <code>AmbiguousMatchException</code> خواهد داد.</p>
<p>متد <code>GetParameters</code> که در کلاس پایه‌ی <code>MethodBase</code> (برای <code>MethodInfo</code> و <code>ConstructorInfo</code>) تعریف شده، اطلاعات متادیتا درباره‌ی پارامترها را برمی‌گرداند:</p>
<pre class="hljs"><code>ParameterInfo[] paramList = method.GetParameters();
<span class="hljs-keyword">foreach</span> (ParameterInfo x <span class="hljs-keyword">in</span> paramList)
{
 Console.WriteLine (x.Name);          <span class="hljs-comment">// startIndex</span>
 Console.WriteLine (x.ParameterType); <span class="hljs-comment">// System.Int32</span>
}
</code></pre>
<hr>
<h3>برخورد با پارامترهای ref و out 🔄</h3>
<p>برای پاس دادن پارامترهای <code>ref</code> یا <code>out</code>، باید قبل از گرفتن متد، متد <code>MakeByRefType</code> را روی نوع صدا بزنید. برای نمونه، اجرای پویا کد زیر:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x;
<span class="hljs-built_in">bool</span> successfulParse = <span class="hljs-built_in">int</span>.TryParse (<span class="hljs-string">&quot;23&quot;</span>, <span class="hljs-keyword">out</span> x);
</code></pre>
<p>به شکل زیر خواهد بود:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span>[] <span class="hljs-keyword">args</span> = { <span class="hljs-string">&quot;23&quot;</span>, <span class="hljs-number">0</span> };
Type[] argTypes = { <span class="hljs-keyword">typeof</span> (<span class="hljs-built_in">string</span>), <span class="hljs-keyword">typeof</span> (<span class="hljs-built_in">int</span>).MakeByRefType() };
MethodInfo tryParse = <span class="hljs-keyword">typeof</span> (<span class="hljs-built_in">int</span>).GetMethod (<span class="hljs-string">&quot;TryParse&quot;</span>, argTypes);
<span class="hljs-built_in">bool</span> successfulParse = (<span class="hljs-built_in">bool</span>) tryParse.Invoke (<span class="hljs-literal">null</span>, <span class="hljs-keyword">args</span>);
Console.WriteLine (successfulParse + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">args</span>[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// True 23</span>
</code></pre>
<p>همین روش برای هر دو نوع <code>ref</code> و <code>out</code> کار می‌کند.</p>
<hr>
<h3>بازیابی و فراخوانی متدهای جنریک 🔧</h3>
<p>گاهی لازم است هنگام فراخوانی <code>GetMethod</code> نوع پارامترها را مشخص کنیم تا بین متدهای overload تمایز قائل شویم. اما امکان مشخص کردن <strong>نوع‌های جنریک</strong> به‌طور مستقیم وجود ندارد.</p>
<p>برای نمونه، کلاس <code>System.Linq.Enumerable</code> دو overload برای متد <code>Where</code> دارد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">TSource</span>&gt; <span class="hljs-title">Where</span>&lt;<span class="hljs-title">TSource</span>&gt;
 (<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;TSource&gt; source, Func&lt;TSource, <span class="hljs-built_in">bool</span>&gt; predicate</span>)</span>;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">TSource</span>&gt; <span class="hljs-title">Where</span>&lt;<span class="hljs-title">TSource</span>&gt;
 (<span class="hljs-params"><span class="hljs-keyword">this</span> IEnumerable&lt;TSource&gt; source, Func&lt;TSource, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>&gt; predicate</span>)</span>;
</code></pre>
<p>برای بازیابی یک overload خاص، باید همه‌ی متدها را بگیریم و سپس مورد دلخواه را دستی انتخاب کنیم. کوئری زیر overload اول را برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">from</span> m <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span> (<span class="hljs-params">Enumerable</span>).<span class="hljs-title">GetMethods</span>()
<span class="hljs-keyword">where</span> m.Name</span> == <span class="hljs-string">&quot;Where&quot;</span> &amp;&amp; m.IsGenericMethod 
<span class="hljs-keyword">let</span> parameters = m.GetParameters()
<span class="hljs-keyword">where</span> parameters.Length == <span class="hljs-number">2</span>
<span class="hljs-keyword">let</span> genArg = m.GetGenericArguments().First()
<span class="hljs-keyword">let</span> enumerableOfT = <span class="hljs-keyword">typeof</span> (IEnumerable&lt;&gt;).MakeGenericType (genArg)
<span class="hljs-keyword">let</span> funcOfTBool = <span class="hljs-keyword">typeof</span> (Func&lt;,&gt;).MakeGenericType (genArg, <span class="hljs-keyword">typeof</span> (<span class="hljs-built_in">bool</span>))
<span class="hljs-keyword">where</span> parameters[<span class="hljs-number">0</span>].ParameterType == enumerableOfT
  &amp;&amp; parameters[<span class="hljs-number">1</span>].ParameterType == funcOfTBool
<span class="hljs-keyword">select</span> m
</code></pre>
<p>فراخوانی <code>.Single()</code> روی این کوئری، شیء <code>MethodInfo</code> درست با پارامترهای نوع باز (unbound) را برمی‌گرداند. گام بعدی بستن پارامترهای نوعی است، با استفاده از <code>MakeGenericMethod</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> closedMethod = unboundMethod.MakeGenericMethod (<span class="hljs-keyword">typeof</span> (<span class="hljs-built_in">int</span>));
</code></pre>
<p>در این حالت، نوع <code>TSource</code> با <code>int</code> بسته شده و می‌توانیم <code>Enumerable.Where</code> را با منبعی از نوع <code>IEnumerable&lt;int&gt;</code> و شرطی از نوع <code>Func&lt;int,bool&gt;</code> صدا بزنیم:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] source = { <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> };
Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>&gt; predicate = n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>;   <span class="hljs-comment">// فقط اعداد فرد</span>
<span class="hljs-keyword">var</span> query = (IEnumerable&lt;<span class="hljs-built_in">int</span>&gt;) closedMethod.Invoke 
 (<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { source, predicate });
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> element <span class="hljs-keyword">in</span> query) Console.Write (element + <span class="hljs-string">&quot;|&quot;</span>);   <span class="hljs-comment">// 3|5|7|</span>
</code></pre>
<hr>
<h3>استفاده از System.Linq.Expressions 🎭</h3>
<p>اگر از API مربوط به <code>System.Linq.Expressions</code> برای ساخت داینامیک expressionها استفاده کنید (فصل ۸)، دیگر نیازی به این کارهای دستی برای مشخص کردن متد جنریک ندارید. متد <code>Expression.Call</code> overloadهایی دارد که اجازه می‌دهد نوع‌های بسته‌ی جنریک را مشخص کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span>[] source = { <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> };
Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>&gt; predicate = n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> sourceExpr = Expression.Constant (source);
<span class="hljs-keyword">var</span> predicateExpr = Expression.Constant (predicate);
<span class="hljs-keyword">var</span> callExpression = Expression.Call (
 <span class="hljs-keyword">typeof</span> (Enumerable), <span class="hljs-string">&quot;Where&quot;</span>,
 <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span> (<span class="hljs-built_in">int</span>) },  <span class="hljs-comment">// نوع جنریک بسته</span>
 sourceExpr, predicateExpr);
</code></pre>
<h3>استفاده از Delegate برای بهبود عملکرد ⚡</h3>
<p>فراخوانی‌های داینامیک نسبتاً کم‌کارآمد هستند و معمولاً overhead آن‌ها در محدوده‌ی چند میکروثانیه است. اگر یک متد را بارها در یک حلقه فراخوانی می‌کنید، می‌توانید این overhead را به سطح نانوثانیه کاهش دهید، با ایجاد یک <strong>delegate داینامیک</strong> که به متد داینامیک شما اشاره می‌کند.</p>
<p>مثال زیر، متد <code>Trim</code> رشته را یک میلیون بار بدون overhead قابل توجه فراخوانی می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">string</span> <span class="hljs-title">StringToString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;

MethodInfo trimMethod = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>).GetMethod(<span class="hljs-string">&quot;Trim&quot;</span>, <span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]);
<span class="hljs-keyword">var</span> trim = (StringToString) Delegate.CreateDelegate(<span class="hljs-keyword">typeof</span>(StringToString), trimMethod);

<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++)
    trim(<span class="hljs-string">&quot;test&quot;</span>);
</code></pre>
<p>این روش سریع‌تر است زیرا <strong>late binding</strong> پرهزینه فقط یک بار اتفاق می‌افتد.</p>
<hr>
<h3>دسترسی به اعضای غیرعمومی 🔒</h3>
<p>تمام متدهای بازتابی برای بررسی metadata (مثل <code>GetProperty</code>, <code>GetField</code> و غیره) overloadهایی دارند که یک <code>BindingFlags</code> می‌گیرند. این enum به‌عنوان یک فیلتر عمل می‌کند و اجازه می‌دهد معیارهای انتخاب پیش‌فرض را تغییر دهید. رایج‌ترین کاربرد، بازیابی اعضای غیرعمومی است (کار می‌کند فقط در اپلیکیشن‌های دسکتاپ).</p>
<p>نمونه:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Walnut</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> cracked;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Crack</span>()</span> { cracked = <span class="hljs-literal">true</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span> { <span class="hljs-keyword">return</span> cracked.ToString(); }
}

Type t = <span class="hljs-keyword">typeof</span>(Walnut);
Walnut w = <span class="hljs-keyword">new</span> Walnut();
w.Crack();

FieldInfo f = t.GetField(<span class="hljs-string">&quot;cracked&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);
f.SetValue(w, <span class="hljs-literal">false</span>);

Console.WriteLine(w);   <span class="hljs-comment">// False</span>
</code></pre>
<p>دسترسی به اعضای غیرعمومی با reflection قدرتمند است، اما خطرناک هم هست؛ زیرا می‌توانید <strong>encapsulation</strong> را دور بزنید و وابستگی به پیاده‌سازی داخلی ایجاد کنید.</p>
<hr>
<h3>مقدمه‌ای بر BindingFlags 🏷</h3>
<p><code>BindingFlags</code> برای ترکیب بیتی طراحی شده است. برای اینکه چیزی پیدا شود، باید یکی از چهار ترکیب زیر را انتخاب کنید:</p>
<ul>
<li><code>BindingFlags.Public | BindingFlags.Instance</code></li>
<li><code>BindingFlags.Public | BindingFlags.Static</code></li>
<li><code>BindingFlags.NonPublic | BindingFlags.Instance</code></li>
<li><code>BindingFlags.NonPublic | BindingFlags.Static</code></li>
</ul>
<p><code>NonPublic</code> شامل internal، protected، protected internal و private می‌شود.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-comment">// همه اعضای public و static</span>
BindingFlags publicStatic = BindingFlags.Public | BindingFlags.Static;
MemberInfo[] members = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">object</span>).GetMembers(publicStatic);

<span class="hljs-comment">// همه اعضای nonpublic (static و instance)</span>
BindingFlags nonPublicBinding = BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
members = <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">object</span>).GetMembers(nonPublicBinding);
</code></pre>
<p>پرچم <code>DeclaredOnly</code> اعضای ارث‌بری شده را کنار می‌گذارد، مگر اینکه override شده باشند. این flag کمی گیج‌کننده است زیرا <strong>مجموعه نتیجه را محدود می‌کند</strong>، در حالی که بقیه flagها مجموعه نتیجه را گسترش می‌دهند.</p>
<hr>
<h3>فراخوانی متدهای جنریک 🎯</h3>
<p>شما نمی‌توانید مستقیماً متدهای جنریک را Invoke کنید؛ مثال زیر خطا می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Echo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T x</span>)</span> { <span class="hljs-keyword">return</span> x; }
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        MethodInfo echo = <span class="hljs-keyword">typeof</span>(Program).GetMethod(<span class="hljs-string">&quot;Echo&quot;</span>);
        Console.WriteLine(echo.IsGenericMethodDefinition);    <span class="hljs-comment">// True</span>
        echo.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { <span class="hljs-number">123</span> });             <span class="hljs-comment">// Exception</span>
    }
}
</code></pre>
<p>راه حل: ابتدا متد <code>MakeGenericMethod</code> را روی <code>MethodInfo</code> صدا بزنید و <strong>نوع‌های جنریک مشخص</strong> بدهید. این یک <code>MethodInfo</code> جدید برمی‌گرداند که می‌توان آن را فراخوانی کرد:</p>
<pre class="hljs"><code>MethodInfo echo = <span class="hljs-keyword">typeof</span>(Program).GetMethod(<span class="hljs-string">&quot;Echo&quot;</span>);
MethodInfo intEcho = echo.MakeGenericMethod(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>));

Console.WriteLine(intEcho.IsGenericMethodDefinition);          <span class="hljs-comment">// False</span>
Console.WriteLine(intEcho.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { <span class="hljs-number">3</span> }));   <span class="hljs-comment">// 3</span>
</code></pre>
<p>گاهی لازم است تا یک عضو از <strong>رابط جنریک</strong> را فراخوانی کنیم ولی پارامترهای نوع آن تا زمان اجرا مشخص نیستند. این مورد در طراحی‌های ایده‌آل کمیاب است، اما در عمل کاربرد دارد.</p>
<p>برای مثال، اگر بخواهیم نسخه‌ای قدرتمندتر از <code>ToString</code> بسازیم که نتایج LINQ را نیز گسترش دهد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToStringEx</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">IEnumerable&lt;T&gt; sequence</span>)</span> { ... }
</code></pre>
<p>اما این محدود است. اگر <code>sequence</code> شامل مجموعه‌های تو در تو باشد، باید overloadهای متعدد بسازیم که عملی نیست. راه حل بهتر، نوشتن متدی است که <strong>هر شیء دلخواهی</strong> را پردازش کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToStringEx</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;null&gt;&quot;</span>;
    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> IList)
        sb.AppendLine(<span class="hljs-string">&quot;A list with &quot;</span> + ((IList)<span class="hljs-keyword">value</span>).Count + <span class="hljs-string">&quot; items&quot;</span>);

    <span class="hljs-comment">// بررسی IGrouping&lt;,&gt; با reflection</span>
    Type closedIGrouping = <span class="hljs-keyword">value</span>.GetType().GetInterfaces()
        .Where(t =&gt; t.IsGenericType &amp;&amp;
                    t.GetGenericTypeDefinition() == <span class="hljs-keyword">typeof</span>(IGrouping&lt;,&gt;))
        .FirstOrDefault();

    <span class="hljs-keyword">if</span> (closedIGrouping != <span class="hljs-literal">null</span>)
    {
        PropertyInfo pi = closedIGrouping.GetProperty(<span class="hljs-string">&quot;Key&quot;</span>);
        <span class="hljs-built_in">object</span> key = pi.GetValue(<span class="hljs-keyword">value</span>, <span class="hljs-literal">null</span>);
        sb.Append(<span class="hljs-string">&quot;Group with key=&quot;</span> + key + <span class="hljs-string">&quot;: &quot;</span>);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> <span class="hljs-keyword">is</span> IEnumerable)
        <span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-built_in">object</span> element <span class="hljs-title">in</span> (<span class="hljs-params">IEnumerable</span>)<span class="hljs-keyword">value</span>)
            sb.<span class="hljs-title">Append</span>(<span class="hljs-params">ToStringEx(element</span>) + &quot; &quot;)</span>;

    <span class="hljs-keyword">if</span> (sb.Length == <span class="hljs-number">0</span>) sb.Append(<span class="hljs-keyword">value</span>.ToString());
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\r\n&quot;</span> + sb.ToString();
}
</code></pre>
<ul>
<li>برای <code>List&lt;&gt;</code> می‌توان از <code>IList</code> غیرجنریک استفاده کرد، زیرا <code>List&lt;&gt;</code> این رابط را پیاده‌سازی کرده است.</li>
<li>برای <code>IGrouping&lt;,&gt;</code> باید از <strong>نوع بسته (closed generic)</strong> استفاده کنیم و سپس با reflection عضو <code>Key</code> را فراخوانی کنیم.</li>
</ul>
<p>این روش پایدار است و چه <code>IGrouping&lt;,&gt;</code> به‌صورت <strong>ضمنی</strong> یا <strong>صریح</strong> پیاده‌سازی شده باشد، کار می‌کند.</p>
<p>مثال استفاده:</p>
<pre class="hljs"><code>Console.WriteLine(ToStringEx(<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; { <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> }));
Console.WriteLine(ToStringEx(<span class="hljs-string">&quot;xyyzzz&quot;</span>.GroupBy(c =&gt; c)));
</code></pre>
<p>خروجی:</p>
<pre class="hljs"><code>List of 3 items: 5 6 7
Group with key=x: x
Group with key=y: y y
Group with key=z: z z z
</code></pre>
<p>برای بازتاب یک Assembly به‌صورت دینامیک، می‌توان از <code>GetType</code> یا <code>GetTypes</code> استفاده کرد.</p>
<p>مثال دریافت نوع <code>Demos.TestProgram</code> از assembly جاری:</p>
<pre class="hljs"><code>Type t = Assembly.GetExecutingAssembly().GetType(<span class="hljs-string">&quot;Demos.TestProgram&quot;</span>);
</code></pre>
<p>یا از روی یک نوع موجود:</p>
<pre class="hljs"><code><span class="hljs-keyword">typeof</span>(Foo).Assembly.GetType(<span class="hljs-string">&quot;Demos.TestProgram&quot;</span>);
</code></pre>
<p>لیست تمام انواع در یک Assembly خارجی:</p>
<pre class="hljs"><code>Assembly a = Assembly.LoadFile(<span class="hljs-string">@&quot;e:\demo\mylib.dll&quot;</span>);
<span class="hljs-keyword">foreach</span> (Type t <span class="hljs-keyword">in</span> a.GetTypes())
    Console.WriteLine(t);
</code></pre>
<p>یا با <code>TypeInfo</code>:</p>
<pre class="hljs"><code>Assembly a = <span class="hljs-keyword">typeof</span>(Foo).GetTypeInfo().Assembly;
<span class="hljs-keyword">foreach</span> (Type t <span class="hljs-keyword">in</span> a.ExportedTypes)
    Console.WriteLine(t);
</code></pre>
<blockquote>
<p>توجه: <code>GetTypes</code> و <code>ExportedTypes</code> فقط انواع سطح بالا را برمی‌گردانند، انواع تو در تو را خیر.<br>
فراخوانی <code>GetTypes</code> روی یک اسمبلی چندماژوله، تمام نوع‌ها را در همه ماژول‌ها برمی‌گرداند. در نتیجه، می‌توانید وجود ماژول‌ها را نادیده بگیرید و یک اسمبلی را به‌عنوان <strong>کانتینر نوع‌ها</strong> در نظر بگیرید. با این حال، یک مورد وجود دارد که ماژول‌ها اهمیت پیدا می‌کنند—و آن زمانی است که با <strong>توکن‌های متادیتا (metadata tokens)</strong> کار می‌کنید.</p>
</blockquote>
<p>توکن متادیتا یک عدد صحیح است که به‌طور یکتا به یک نوع، عضو، رشته یا منبع در محدوده یک ماژول اشاره می‌کند. IL از توکن‌های متادیتا استفاده می‌کند، بنابراین اگر در حال تحلیل IL هستید، باید بتوانید آن‌ها را حل کنید. متدهای مرتبط در نوع <code>Module</code> تعریف شده‌اند و شامل <code>ResolveType</code>، <code>ResolveMember</code>، <code>ResolveString</code> و <code>ResolveSignature</code> می‌شوند. در بخش پایانی این فصل، هنگام نوشتن <strong>disassembler</strong> دوباره به این موضوع بازمی‌گردیم.</p>
<p>می‌توانید لیست همه ماژول‌های یک اسمبلی را با فراخوانی <code>GetModules</code> به‌دست آورید. همچنین می‌توانید به ماژول اصلی یک اسمبلی مستقیماً از طریق ویژگی <code>ManifestModule</code> دسترسی داشته باشید.</p>
<h3>کار با Attributes 🏷️</h3>
<p>CLR اجازه می‌دهد <strong>متادیتای اضافی</strong> به نوع‌ها، اعضا و اسمبلی‌ها از طریق Attributes متصل شود. این مکانیزم باعث می‌شود برخی از عملکردهای مهم CLR (مانند شناسایی اسمبلی یا marshaling نوع‌ها برای تعامل با native code) هدایت شوند و Attributes را به بخشی جدایی‌ناپذیر از برنامه تبدیل می‌کند.</p>
<p>یکی از ویژگی‌های کلیدی Attributes این است که شما می‌توانید <strong>Attributes خودتان</strong> را بنویسید و سپس مانند هر Attribute دیگری، آن‌ها را برای “تزئین” یک عنصر کد با اطلاعات اضافی استفاده کنید. این اطلاعات اضافی در اسمبلی پایه کامپایل می‌شوند و می‌توان آن‌ها را در زمان اجرا با استفاده از <strong>reflection</strong> بازیابی کرد تا سرویس‌هایی بسازید که به صورت <strong>دکوراتوری و خودکار</strong> عمل می‌کنند، مانند <strong>تست واحد خودکار (automated unit testing)</strong>.</p>
<p>سه نوع Attribute وجود دارد:</p>
<ul>
<li><strong>Bit-mapped attributes</strong></li>
<li><strong>Custom attributes</strong></li>
<li><strong>Pseudocustom attributes</strong></li>
</ul>
<p>از میان این‌ها، تنها <strong>custom attributes</strong> قابل توسعه هستند.</p>
<p>اصطلاح «attribute» به تنهایی می‌تواند به هر سه نوع اشاره کند، اما در دنیای C# بیشتر به <strong>custom attributes</strong> یا <strong>pseudocustom attributes</strong> اشاره دارد.</p>
<p><strong>Bit-mapped attributes</strong> (اصطلاح ما) به بیت‌های اختصاصی در متادیتای نوع نگاشت می‌شوند. اکثر کلمات کلیدی modifier در C#، مانند <code>public</code>، <code>abstract</code> و <code>sealed</code> به Bit-mapped attributes تبدیل می‌شوند. این Attributes بسیار کارآمد هستند زیرا فضای کمی در متادیتا مصرف می‌کنند (معمولاً تنها یک بیت) و CLR می‌تواند آن‌ها را با کمترین یا بدون هیچ واسطه‌ای پیدا کند.</p>
<p>API <strong>reflection</strong> آن‌ها را از طریق ویژگی‌های اختصاصی روی <code>Type</code> (و سایر زیرکلاس‌های <code>MemberInfo</code>) مانند <code>IsPublic</code>، <code>IsAbstract</code> و <code>IsSealed</code> نمایش می‌دهد. ویژگی <code>Attributes</code> یک <strong>enum با flag</strong> برمی‌گرداند که اکثر آن‌ها را به‌صورت یکجا توصیف می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
{
    TypeAttributes ta = <span class="hljs-keyword">typeof</span>(Console).Attributes;
    MethodAttributes ma = MethodInfo.GetCurrentMethod().Attributes;
    Console.WriteLine(ta + <span class="hljs-string">&quot;\r\n&quot;</span> + ma);
}
</code></pre>
<p>نتیجه:</p>
<pre class="hljs"><code>AutoLayout, AnsiClass, Class, Public, Abstract, Sealed, BeforeFieldInit
PrivateScope, Private, Static, HideBySig
</code></pre>
<p>در مقابل، <strong>custom attributes</strong> به یک Blob در متادیتای اصلی نوع متصل می‌شوند. همه Custom attributes توسط یک زیرکلاس از <code>System.Attribute</code> نمایش داده می‌شوند و برخلاف Bit-mapped attributes، <strong>قابل توسعه</strong> هستند. این Blob کلاس Attribute را شناسایی می‌کند و همچنین مقادیر هر آرگومان موقعیتی یا نام‌گذاری‌شده‌ای که هنگام اعمال Attribute مشخص شده را ذخیره می‌کند. Custom attributes که خودتان تعریف می‌کنید، از نظر معماری کاملاً مشابه آن‌هایی هستند که در کتابخانه‌های .NET تعریف شده‌اند.</p>
<p>در <strong>فصل 4</strong> توضیح داده شده است که چگونه می‌توان Custom attributes را به یک نوع یا عضو در C# متصل کرد. مثال زیر، Attribute از پیش تعریف‌شده <code>Obsolete</code> را به کلاس <code>Foo</code> اعمال می‌کند:</p>
<pre class="hljs"><code>[<span class="hljs-meta">Obsolete</span>] <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> { ... }
</code></pre>
<p>این به کامپایلر دستور می‌دهد که یک نمونه از <code>ObsoleteAttribute</code> را در متادیتای <code>Foo</code> قرار دهد، که سپس می‌توان آن را در زمان اجرا با فراخوانی <code>GetCustomAttributes</code> روی یک <code>Type</code> یا <code>MemberInfo</code> بازیابی کرد.</p>
<p><strong>Pseudocustom attributes</strong> ظاهر و عملکردی شبیه custom attributes استاندارد دارند. آن‌ها توسط یک زیرکلاس از <code>System.Attribute</code> نمایش داده می‌شوند و به روش استاندارد متصل می‌شوند:</p>
<pre class="hljs"><code>[<span class="hljs-meta">System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)</span>]
<span class="hljs-keyword">class</span> <span class="hljs-title">SystemTime</span> { ... }
</code></pre>
<p>تفاوت این است که کامپایلر یا CLR به‌صورت داخلی، Pseudocustom attributes را با تبدیل آن‌ها به Bit-mapped attributes بهینه می‌کند. نمونه‌ها شامل <code>StructLayout</code>، <code>In</code> و <code>Out</code> هستند (فصل 24). Reflection، Pseudocustom attributes را از طریق ویژگی‌های اختصاصی مانند <code>IsLayoutSequential</code> نمایش می‌دهد و در بسیاری از موارد، وقتی <code>GetCustomAttributes</code> فراخوانی شود، به‌عنوان شیء <code>System.Attribute</code> نیز برمی‌گردند.</p>
<p>این بدان معناست که می‌توانید تقریباً تفاوت بین <strong>pseudo-</strong> و <strong>non-pseudo custom attributes</strong> را نادیده بگیرید (استثنای مهم، زمانی است که از <code>Reflection.Emit</code> برای تولید نوع‌ها به‌صورت داینامیک در زمان اجرا استفاده می‌کنید؛ نگاه کنید به فصل «Emitting Assemblies and Types» صفحه 841).<br>
<strong>AttributeUsage</strong> یک Attribute است که روی کلاس‌های Attribute اعمال می‌شود و به کامپایلر می‌گوید چگونه باید Attribute هدف استفاده شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AttributeUsageAttribute</span> : <span class="hljs-title">Attribute</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AttributeUsageAttribute</span>(<span class="hljs-params">AttributeTargets validOn</span>)</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> AllowMultiple        { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> Inherited            { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> AttributeTargets ValidOn  { <span class="hljs-keyword">get</span>; }
}
</code></pre>
<ul>
<li><code>AllowMultiple</code> مشخص می‌کند که آیا Attribute تعریف‌شده می‌تواند بیش از یک بار روی همان هدف اعمال شود یا خیر.</li>
<li><code>Inherited</code> مشخص می‌کند که آیا Attribute اعمال‌شده روی یک کلاس پایه، به کلاس‌های مشتق نیز اعمال شود (یا در مورد متدها، آیا Attribute اعمال‌شده روی متد virtual به متدهای overriding نیز منتقل شود).</li>
<li><code>ValidOn</code> مجموعه اهدافی را تعیین می‌کند که Attribute می‌تواند به آن‌ها متصل شود، مانند کلاس‌ها، اینترفیس‌ها، Properties، متدها، پارامترها و غیره. این ویژگی هر ترکیبی از مقادیر enum <code>AttributeTargets</code> را می‌پذیرد، که شامل موارد زیر است:</li>
</ul>
<pre class="hljs"><code>All, Assembly, Class, Delegate, GenericParameter, Parameter,
Enum, Event, Constructor, Field, Interface, Method, Module,
Property, ReturnValue, Struct
</code></pre>
<p>مثال از نحوه استفاده توسعه‌دهندگان .NET از <code>AttributeUsage</code> روی <code>Serializable</code>:</p>
<pre class="hljs"><code>[<span class="hljs-meta">AttributeUsage(AttributeTargets.Delegate |
                AttributeTargets.Enum     |
                AttributeTargets.Struct   |
                AttributeTargets.Class, Inherited = false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SerializableAttribute</span> : <span class="hljs-title">Attribute</span> { }
</code></pre>
<p>این تقریباً کل تعریف Attribute <code>Serializable</code> است. نوشتن یک کلاس Attribute بدون property یا constructor ویژه، به همین سادگی است.</p>
<h3>تعریف Attribute سفارشی</h3>
<p>برای تعریف Attribute خودتان مراحل زیر را دنبال کنید:</p>
<ol>
<li>از کلاس <code>System.Attribute</code> یا یکی از زیرکلاس‌های آن مشتق شوید. طبق قرارداد، نام کلاس باید با <code>Attribute</code> ختم شود، اگرچه اجباری نیست.</li>
<li>Attribute <code>AttributeUsage</code> را اعمال کنید (توضیح داده شده در بخش قبل). اگر Attribute نیاز به property یا آرگومان ندارد، کار تمام است.</li>
<li>یک یا چند constructor عمومی بنویسید. پارامترهای constructor، پارامترهای موقعیتی (positional) Attribute را تعریف می‌کنند و هنگام استفاده از Attribute اجباری خواهند بود.</li>
<li>برای هر پارامتر نام‌گذاری‌شده (named parameter) که می‌خواهید پشتیبانی کنید، یک فیلد یا property عمومی تعریف کنید. پارامترهای نام‌گذاری‌شده هنگام استفاده از Attribute اختیاری هستند.</li>
</ol>
<p><strong>نوع propertyها و پارامترهای constructor باید یکی از موارد زیر باشد:</strong></p>
<ul>
<li>نوع primitive بسته‌شده (sealed)، مانند <code>bool</code>، <code>byte</code>، <code>char</code>، <code>double</code>، <code>float</code>، <code>int</code>، <code>long</code>، <code>short</code> یا <code>string</code></li>
<li>نوع <code>Type</code></li>
<li>یک enum</li>
<li>آرایه تک‌بعدی از هر یک از موارد بالا</li>
</ul>
<p>هنگام اعمال Attribute، باید امکان ارزیابی <strong>static</strong> compiler برای هر property یا آرگومان constructor وجود داشته باشد.</p>
<p>مثال: یک Attribute برای پشتیبانی از سیستم <strong>آزمون خودکار واحد (unit testing)</strong>:</p>
<pre class="hljs"><code>[<span class="hljs-meta">AttributeUsage(AttributeTargets.Method)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestAttribute</span> : <span class="hljs-title">Attribute</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>    Repetitions;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FailureMessage;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestAttribute</span>() : <span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span>     { }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestAttribute</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> repetitions</span>)</span> { Repetitions = repetitions; }
}
</code></pre>
<p>و کلاس <code>Foo</code> با متدهایی که با Test Attribute تزئین شده‌اند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{
    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method1</span>()</span> { ... }

    [<span class="hljs-meta">Test(20)</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method2</span>()</span> { ... }

    [<span class="hljs-meta">Test(20, FailureMessage=<span class="hljs-string">&quot;Debugging Time!&quot;</span>)</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method3</span>()</span> { ... }
}
</code></pre>
<p>دو روش استاندارد برای بازیابی Attributes در زمان اجرا وجود دارد:</p>
<ul>
<li>فراخوانی <code>GetCustomAttributes</code> روی هر شیء <code>Type</code> یا <code>MemberInfo</code></li>
<li>فراخوانی <code>Attribute.GetCustomAttribute</code> یا <code>Attribute.GetCustomAttributes</code></li>
</ul>
<p>این دو متد اخیر <strong>overload</strong> شده‌اند تا هر شیء reflection که با یک هدف Attribute معتبر مطابقت دارد (مانند <code>Type</code>، <code>Assembly</code>، <code>Module</code>، <code>MemberInfo</code> یا <code>ParameterInfo</code>) را بپذیرند.</p>
<p>همچنین می‌توان از <code>GetCustomAttributesData()</code> روی یک نوع یا عضو استفاده کرد تا اطلاعات Attribute را به‌دست آورد. تفاوت آن با <code>GetCustomAttributes()</code> این است که نسخه Data به شما نشان می‌دهد Attribute چگونه ایجاد شده است:</p>
<ul>
<li>کدام overload از constructor استفاده شده</li>
<li>مقدار هر آرگومان constructor و پارامتر نام‌گذاری‌شده</li>
</ul>
<p>این قابلیت زمانی مفید است که بخواهید کد یا IL تولید کنید تا Attribute را به همان وضعیت بازسازی کنید (نگاه کنید به «Emitting Type Members» صفحه 844).</p>
<p>مثال: فهرست کردن هر متدی در کلاس <code>Foo</code> که دارای <code>TestAttribute</code> است:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-function">MethodInfo mi <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span>(<span class="hljs-params">Foo</span>).<span class="hljs-title">GetMethods</span>())</span>
{
    TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute(mi, <span class="hljs-keyword">typeof</span>(TestAttribute));
    <span class="hljs-keyword">if</span> (att != <span class="hljs-literal">null</span>)
        Console.WriteLine(<span class="hljs-string">&quot;Method {0} will be tested; reps={1}; msg={2}&quot;</span>,
                          mi.Name, att.Repetitions, att.FailureMessage);
}
</code></pre>
<p>یا به شکل زیر:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-function">MethodInfo mi <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span>(<span class="hljs-params">Foo</span>).<span class="hljs-title">GetTypeInfo</span>().DeclaredMethods)</span>
{ ... }
</code></pre>
<p>خروجی:</p>
<pre class="hljs"><code>Method Method1 will be tested; reps=1; msg=
Method Method2 will be tested; reps=20; msg=
Method Method3 will be tested; reps=20; msg=Debugging Time!
</code></pre>
<p>برای تکمیل مثال و نشان دادن اینکه چگونه می‌توان از این روش برای نوشتن یک <strong>سیستم Unit Testing خودکار</strong> استفاده کرد، نسخه‌ای که متدها را واقعاً فراخوانی می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">foreach</span> (<span class="hljs-function">MethodInfo mi <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span>(<span class="hljs-params">Foo</span>).<span class="hljs-title">GetMethods</span>())</span>
{
    TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute(mi, <span class="hljs-keyword">typeof</span>(TestAttribute));
    <span class="hljs-keyword">if</span> (att != <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; att.Repetitions; i++)
            <span class="hljs-keyword">try</span>
            {
                mi.Invoke(<span class="hljs-keyword">new</span> Foo(), <span class="hljs-literal">null</span>);  <span class="hljs-comment">// فراخوانی متد بدون آرگومان</span>
            }
            <span class="hljs-keyword">catch</span> (Exception ex)
            {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Error: &quot;</span> + att.FailureMessage, ex);
            }
}
</code></pre>
<p>نمونه دیگر: فهرست کردن Attributes موجود روی یک نوع مشخص:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span>[] atts = Attribute.GetCustomAttributes(<span class="hljs-keyword">typeof</span>(Test));
<span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">object</span> att <span class="hljs-keyword">in</span> atts) Console.WriteLine(att);

[<span class="hljs-meta">Serializable, Obsolete</span>]
<span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> { }
</code></pre>
<p>خروجی:</p>
<pre class="hljs"><code>System.ObsoleteAttribute
System.SerializableAttribute
</code></pre>
<p>فضای نام <code>System.Reflection.Emit</code> شامل کلاس‌هایی برای ایجاد <strong>متادیتا و IL در زمان اجرا</strong> است. تولید کد به‌صورت داینامیک برای برخی از انواع برنامه‌نویسی کاربرد دارد. به‌عنوان مثال:</p>
<ul>
<li>API <strong>Regular Expressions</strong>، که انواع بهینه‌شده برای هر عبارت منظم تولید می‌کند.</li>
<li><strong>Entity Framework Core</strong>، که از Reflection.Emit برای ایجاد کلاس‌های Proxy جهت فعال‌سازی <strong>Lazy Loading</strong> استفاده می‌کند.</li>
</ul>
<h3>تولید IL با DynamicMethod</h3>
<p>کلاس <code>DynamicMethod</code> یک ابزار سبک در فضای نام <code>System.Reflection.Emit</code> برای ایجاد متدها در لحظه است. برخلاف <code>TypeBuilder</code>، نیازی به تعریف ابتدا یک <strong>Assembly داینامیک</strong>، <strong>Module</strong> و <strong>Type</strong> برای نگهداری متد ندارد. این باعث می‌شود برای کارهای ساده مناسب باشد و همچنین معرفی خوبی برای Reflection.Emit ارائه کند.</p>
<p>یک <code>DynamicMethod</code> و IL مربوط به آن هنگامی که دیگر به آن ارجاعی وجود نداشته باشد، <strong>توسط Garbage Collector پاک می‌شوند</strong>. این یعنی می‌توانید بارها متد داینامیک تولید کنید بدون پر شدن حافظه. (برای انجام همان کار با <strong>dynamic assemblies</strong>، باید پرچم <code>AssemblyBuilderAccess.RunAndCollect</code> را هنگام ایجاد Assembly اعمال کنید.)</p>
<p>نمونه‌ای ساده از استفاده <code>DynamicMethod</code> برای ایجاد متدی که <code>Hello world</code> را در کنسول می‌نویسد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        <span class="hljs-keyword">var</span> dynMeth = <span class="hljs-keyword">new</span> DynamicMethod(<span class="hljs-string">&quot;Foo&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Test));
        ILGenerator gen = dynMeth.GetILGenerator();
        gen.EmitWriteLine(<span class="hljs-string">&quot;Hello world&quot;</span>);
        gen.Emit(OpCodes.Ret);
        dynMeth.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// Hello world</span>
    }
}
</code></pre>
<p><code>OpCodes</code> شامل یک فیلد <code>static readonly</code> برای هر IL opcode است. بیشتر قابلیت‌ها از طریق این opcodes ارائه می‌شوند، اگرچه <code>ILGenerator</code> متدهای ویژه‌ای برای تولید <strong>Labels</strong>، <strong>متغیرهای محلی</strong> و <strong>مدیریت استثناها</strong> دارد.</p>
<p>یک متد همیشه با <code>OpCodes.Ret</code> که به معنی &quot;return&quot; است یا نوعی دستور branching/throwing پایان می‌یابد. متد <code>EmitWriteLine</code> در <code>ILGenerator</code> یک <strong>میان‌بر</strong> برای تولید تعدادی opcode سطح پایین‌تر است. می‌توانیم همان نتیجه را با جایگزینی آن به شکل زیر به دست آوریم:</p>
<pre class="hljs"><code>MethodInfo writeLineStr = <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-string">&quot;WriteLine&quot;</span>, <span class="hljs-keyword">new</span> Type[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>) });
gen.Emit(OpCodes.Ldstr, <span class="hljs-string">&quot;Hello world&quot;</span>); <span class="hljs-comment">// بارگذاری رشته</span>
gen.Emit(OpCodes.Call, writeLineStr);   <span class="hljs-comment">// فراخوانی متد</span>
</code></pre>
<p>توجه کنید که <code>typeof(Test)</code> را به سازنده <code>DynamicMethod</code> دادیم. این دسترسی متد داینامیک به <strong>متدهای غیر عمومی</strong> آن نوع را فراهم می‌کند، مانند مثال زیر:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        <span class="hljs-keyword">var</span> dynMeth = <span class="hljs-keyword">new</span> DynamicMethod(<span class="hljs-string">&quot;Foo&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(Test));
        ILGenerator gen = dynMeth.GetILGenerator();
        MethodInfo privateMethod = <span class="hljs-keyword">typeof</span>(Test).GetMethod(<span class="hljs-string">&quot;HelloWorld&quot;</span>, BindingFlags.Static | BindingFlags.NonPublic);
        gen.Emit(OpCodes.Call, privateMethod); <span class="hljs-comment">// فراخوانی HelloWorld</span>
        gen.Emit(OpCodes.Ret);
        dynMeth.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// Hello world</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HelloWorld</span>() <span class="hljs-comment">// متد private، ولی می‌توان آن را فراخوانی کرد</span></span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;Hello world&quot;</span>);
    }
}
</code></pre>
<h3>درک IL و Evaluation Stack</h3>
<p>درک IL نیازمند <strong>سرمایه‌گذاری زمانی قابل توجه</strong> است. به جای فهمیدن همه opcodes، آسان‌تر است که یک برنامه C# کامپایل کنید و سپس IL آن را بررسی، کپی و تغییر دهید. ابزارهایی مانند <strong>LINQPad</strong> IL هر متد یا قطعه کدی را نمایش می‌دهد و ابزارهایی مانند <strong>ILSpy</strong> برای بررسی Assemblyهای موجود مفید هستند.</p>
<p>مفهوم <strong>Evaluation Stack</strong> در IL مرکزی است. برای فراخوانی یک متد با آرگومان‌ها:</p>
<ol>
<li>ابتدا آرگومان‌ها را روی <strong>Evaluation Stack</strong> بارگذاری کنید.</li>
<li>سپس متد را فراخوانی کنید.</li>
</ol>
<p>متد مقدار مورد نیاز خود را از Stack می‌گیرد. مثال مشابه با یک عدد صحیح:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dynMeth = <span class="hljs-keyword">new</span> DynamicMethod(<span class="hljs-string">&quot;Foo&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">void</span>));
ILGenerator gen = dynMeth.GetILGenerator();
MethodInfo writeLineInt = <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-string">&quot;WriteLine&quot;</span>, <span class="hljs-keyword">new</span> Type[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>) });

gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">123</span>); <span class="hljs-comment">// بارگذاری عدد 4 بایتی روی Stack</span>
gen.Emit(OpCodes.Call, writeLineInt);
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 123</span>
</code></pre>
<p>برای جمع دو عدد: ابتدا هر عدد را روی Stack بارگذاری کرده و سپس <code>Add</code> را فراخوانی می‌کنیم. <code>Add</code> دو مقدار را از Stack برمی‌دارد و نتیجه را روی Stack قرار می‌دهد:</p>
<pre class="hljs"><code>gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">2</span>); <span class="hljs-comment">// بارگذاری عدد 2</span>
gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">2</span>); <span class="hljs-comment">// بارگذاری عدد 2</span>
gen.Emit(OpCodes.Add);        <span class="hljs-comment">// جمع دو عدد</span>
gen.Emit(OpCodes.Call, writeLineInt); <span class="hljs-comment">// نمایش نتیجه</span>
</code></pre>
<p>برای محاسبه <code>10 / 2 + 1</code> می‌توان یکی از این دو روش را انجام داد:</p>
<pre class="hljs"><code>gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">10</span>);
gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">2</span>);
gen.Emit(OpCodes.Div);
gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">1</span>);
gen.Emit(OpCodes.Add);
gen.Emit(OpCodes.Call, writeLineInt);
</code></pre>
<p>یا:</p>
<pre class="hljs"><code>gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">1</span>);
gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">10</span>);
gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">2</span>);
gen.Emit(OpCodes.Div);
gen.Emit(OpCodes.Add);
gen.Emit(OpCodes.Call, writeLineInt);
</code></pre>
<h3>ارسال آرگومان‌ها به یک متد داینامیک</h3>
<p>Opcodeهای <code>Ldarg</code> و <code>Ldarg_XXX</code> آرگومان‌های <strong>ارسال‌شده به متد</strong> را روی Stack بارگذاری می‌کنند. برای بازگرداندن یک مقدار، در پایان <strong>دقیقاً یک مقدار روی Stack</strong> باقی بگذارید. برای این کار، هنگام ایجاد <code>DynamicMethod</code> باید <strong>نوع بازگشتی</strong> و <strong>نوع آرگومان‌ها</strong> را مشخص کنید.</p>
<p>نمونه ایجاد متدی که جمع دو عدد صحیح را برمی‌گرداند:</p>
<pre class="hljs"><code>DynamicMethod dynMeth = <span class="hljs-keyword">new</span> DynamicMethod(
    <span class="hljs-string">&quot;Foo&quot;</span>,
    <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>),                          <span class="hljs-comment">// نوع بازگشتی = int</span>
    <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>), <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>) },   <span class="hljs-comment">// نوع پارامترها = int, int</span>
    <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">void</span>)
);

ILGenerator gen = dynMeth.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);  <span class="hljs-comment">// بارگذاری آرگومان اول روی Stack</span>
gen.Emit(OpCodes.Ldarg_1);  <span class="hljs-comment">// بارگذاری آرگومان دوم روی Stack</span>
gen.Emit(OpCodes.Add);       <span class="hljs-comment">// جمع دو عدد (نتیجه روی Stack)</span>
gen.Emit(OpCodes.Ret);       <span class="hljs-comment">// بازگشت با یک مقدار روی Stack</span>

<span class="hljs-built_in">int</span> result = (<span class="hljs-built_in">int</span>)dynMeth.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { <span class="hljs-number">3</span>, <span class="hljs-number">4</span> }); <span class="hljs-comment">// 7</span>
</code></pre>
<p>اگر از قوانین Stack پیروی نکنید، CLR اجرای متد را رد می‌کند. برای حذف یک مقدار بدون پردازش آن می‌توان از <code>OpCodes.Pop</code> استفاده کرد.</p>
<h3>استفاده از Delegate</h3>
<p>به جای فراخوانی <code>Invoke</code>، می‌توان از یک <strong>delegate تایپ‌شده</strong> استفاده کرد تا راحت‌تر کار کرد. متد <code>CreateDelegate</code> این کار را انجام می‌دهد. در مثال بالا:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> func = (Func&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;)dynMeth.CreateDelegate(<span class="hljs-keyword">typeof</span>(Func&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;));
<span class="hljs-built_in">int</span> result = func(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 7</span>
</code></pre>
<p>این کار همچنین <strong>overhead فراخوانی داینامیک</strong> را حذف می‌کند و چند میکروثانیه صرفه‌جویی می‌کند.</p>
<h3>تعریف متغیرهای محلی</h3>
<p>برای تعریف یک متغیر محلی از <code>DeclareLocal</code> روی <code>ILGenerator</code> استفاده کنید. این متد یک <code>LocalBuilder</code> برمی‌گرداند که می‌توان همراه با opcodeهایی مانند <code>Ldloc</code> (بارگذاری متغیر) یا <code>Stloc</code> (ذخیره متغیر) استفاده کرد. <code>Ldloc</code> مقدار را روی Stack می‌گذارد و <code>Stloc</code> آن را از Stack برمی‌دارد.</p>
<p>مثال کد C#:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">6</span>;
<span class="hljs-built_in">int</span> y = <span class="hljs-number">7</span>;
x *= y;
Console.WriteLine(x); <span class="hljs-comment">// 42</span>
</code></pre>
<p>ایجاد همان کد به صورت داینامیک:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dynMeth = <span class="hljs-keyword">new</span> DynamicMethod(<span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">void</span>));
ILGenerator gen = dynMeth.GetILGenerator();

LocalBuilder localX = gen.DeclareLocal(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>)); <span class="hljs-comment">// متغیر x</span>
LocalBuilder localY = gen.DeclareLocal(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>)); <span class="hljs-comment">// متغیر y</span>

gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">6</span>);
gen.Emit(OpCodes.Stloc, localX);

gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">7</span>);
gen.Emit(OpCodes.Stloc, localY);

gen.Emit(OpCodes.Ldloc, localX);
gen.Emit(OpCodes.Ldloc, localY);
gen.Emit(OpCodes.Mul);
gen.Emit(OpCodes.Stloc, localX);

gen.EmitWriteLine(localX);
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 42</span>
</code></pre>
<h3>شاخه‌بندی (Branching) 🔀</h3>
<p>در IL، حلقه‌های <code>while</code>، <code>do</code> و <code>for</code> وجود ندارند؛ همه با <strong>Labels</strong> و opcodeهای مشابه <code>goto</code> و شرطی انجام می‌شود:</p>
<ul>
<li><code>Br</code>: شاخه بدون شرط</li>
<li><code>Brtrue</code>: شاخه اگر مقدار روی Stack درست باشد</li>
<li><code>Blt</code>: شاخه اگر مقدار اول کمتر از مقدار دوم باشد</li>
</ul>
<p>برای ایجاد یک شاخه:</p>
<ol>
<li>با <code>DefineLabel</code> یک Label تعریف کنید.</li>
<li>با <code>MarkLabel</code> مکان Label را مشخص کنید.</li>
</ol>
<p>مثال حلقه <code>while</code> در C#:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-keyword">while</span> (x &lt;= <span class="hljs-number">10</span>) Console.WriteLine(x++);
</code></pre>
<p>ایجاد همان حلقه به صورت IL:</p>
<pre class="hljs"><code>ILGenerator gen = ...;
Label startLoop = gen.DefineLabel();
Label endLoop = gen.DefineLabel();

LocalBuilder x = gen.DeclareLocal(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>));

gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">5</span>);
gen.Emit(OpCodes.Stloc, x);

gen.MarkLabel(startLoop);

gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">10</span>);
gen.Emit(OpCodes.Ldloc, x);
gen.Emit(OpCodes.Blt, endLoop); <span class="hljs-comment">// if (x &gt; 10) goto endLoop</span>

gen.EmitWriteLine(x);

gen.Emit(OpCodes.Ldloc, x);
gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">1</span>);
gen.Emit(OpCodes.Add);
gen.Emit(OpCodes.Stloc, x);

gen.Emit(OpCodes.Br, startLoop);
gen.MarkLabel(endLoop);

gen.Emit(OpCodes.Ret);
</code></pre>
<h3>ساخت اشیاء</h3>
<p>معادل IL برای <code>new</code>، opcode <strong>Newobj</strong> است. این opcode یک <strong>constructor</strong> می‌گیرد و شیء ساخته‌شده را روی <strong>evaluation stack</strong> قرار می‌دهد.</p>
<p>مثال: ساخت یک <code>StringBuilder</code> داینامیک</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dynMeth = <span class="hljs-keyword">new</span> DynamicMethod(<span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">void</span>));
ILGenerator gen = dynMeth.GetILGenerator();

ConstructorInfo ci = <span class="hljs-keyword">typeof</span>(StringBuilder).GetConstructor(<span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]);
gen.Emit(OpCodes.Newobj, ci);
</code></pre>
<h3>فراخوانی متدهای نمونه</h3>
<p>پس از قرار دادن شیء روی <strong>stack</strong>، می‌توانید با opcodeهای <strong>Call</strong> یا <strong>Callvirt</strong> متدهای نمونه آن را فراخوانی کنید.</p>
<p>مثال: گرفتن مقدار <code>MaxCapacity</code> و نوشتن آن روی کنسول</p>
<pre class="hljs"><code>gen.Emit(OpCodes.Callvirt, <span class="hljs-keyword">typeof</span>(StringBuilder)
                           .GetProperty(<span class="hljs-string">&quot;MaxCapacity&quot;</span>).GetGetMethod());
gen.Emit(OpCodes.Call, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-string">&quot;WriteLine&quot;</span>, <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>) }));
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);  <span class="hljs-comment">// 2147483647</span>
</code></pre>
<ul>
<li><strong>Call</strong> برای فراخوانی متدهای static و متدهای نمونه نوع مقدار (value type)</li>
<li><strong>Callvirt</strong> برای فراخوانی متدهای نمونه نوع مرجع (reference type) حتی اگر virtual نباشند</li>
</ul>
<p>استفاده از <code>Callvirt</code> همیشه ایمن است، چون بررسی می‌کند که شیء null نباشد و خطر فراخوانی اشتباه متدهای virtual را کاهش می‌دهد.</p>
<h3>نمونه پیشرفته با پارامترها</h3>
<p>ساخت یک <code>StringBuilder</code> با دو پارامتر، الحاق رشته و تبدیل به رشته:</p>
<pre class="hljs"><code>ConstructorInfo ci = <span class="hljs-keyword">typeof</span>(StringBuilder).GetConstructor(<span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>) });

gen.Emit(OpCodes.Ldstr, <span class="hljs-string">&quot;Hello&quot;</span>);
gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">1000</span>);
gen.Emit(OpCodes.Newobj, ci);

Type[] strT = { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>) };
gen.Emit(OpCodes.Ldstr, <span class="hljs-string">&quot;, world!&quot;</span>);
gen.Emit(OpCodes.Call, <span class="hljs-keyword">typeof</span>(StringBuilder).GetMethod(<span class="hljs-string">&quot;Append&quot;</span>, strT));
gen.Emit(OpCodes.Callvirt, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">object</span>).GetMethod(<span class="hljs-string">&quot;ToString&quot;</span>));
gen.Emit(OpCodes.Call, <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-string">&quot;WriteLine&quot;</span>, strT));
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);  <span class="hljs-comment">// Hello, world!</span>
</code></pre>
<p>توجه: اگر به‌طور غیرvirtual متد <code>ToString</code> از نوع <code>object</code> را فراخوانی می‌کردیم، نتیجه <code>System.Text.StringBuilder</code> می‌شد و بازنویسی <code>ToString</code> نادیده گرفته می‌شد.</p>
<h3>مدیریت استثناها (Exception Handling) ⚠️</h3>
<p>ILGenerator متدهای مخصوص مدیریت استثنا دارد. مثال معادل IL برای کد C# زیر:</p>
<pre class="hljs"><code><span class="hljs-keyword">try</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotSupportedException(); }
<span class="hljs-keyword">catch</span> (NotSupportedException ex) { Console.WriteLine(ex.Message); }
<span class="hljs-keyword">finally</span> { Console.WriteLine(<span class="hljs-string">&quot;Finally&quot;</span>); }
</code></pre>
<p>معادل IL:</p>
<pre class="hljs"><code>MethodInfo getMessageProp = <span class="hljs-keyword">typeof</span>(NotSupportedException)
                           .GetProperty(<span class="hljs-string">&quot;Message&quot;</span>).GetGetMethod();
MethodInfo writeLineString = <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-string">&quot;WriteLine&quot;</span>, <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">object</span>) });

gen.BeginExceptionBlock();

ConstructorInfo ci = <span class="hljs-keyword">typeof</span>(NotSupportedException).GetConstructor(<span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]);
gen.Emit(OpCodes.Newobj, ci);
gen.Emit(OpCodes.Throw);

gen.BeginCatchBlock(<span class="hljs-keyword">typeof</span>(NotSupportedException));
gen.Emit(OpCodes.Callvirt, getMessageProp);
gen.Emit(OpCodes.Call, writeLineString);

gen.BeginFinallyBlock();
gen.EmitWriteLine(<span class="hljs-string">&quot;Finally&quot;</span>);
gen.EndExceptionBlock();
</code></pre>
<ul>
<li>می‌توانید چند catch block تعریف کنید.</li>
<li>برای پرتاب مجدد همان استثنا از opcode <code>Rethrow</code> استفاده می‌شود.</li>
<li>متد کمکی <code>ThrowException</code> فقط با <strong>MethodBuilder</strong> کار می‌کند و در DynamicMethod کاربرد ندارد.</li>
</ul>
<p>اگرچه <strong>DynamicMethod</strong> بسیار راحت است، اما فقط قادر به تولید <strong>متدها</strong>ست. برای ایجاد هر ساختار دیگر یا یک <strong>Type کامل</strong>، باید از API “سنگین” <strong>Reflection.Emit</strong> استفاده کنید. این یعنی ساخت یک <strong>assembly</strong> و <strong>module</strong> داینامیک.</p>
<p>توجه: assembly داینامیک نیازی به وجود روی دیسک ندارد و در .NET 5+ و .NET Core نمی‌توان آن را ذخیره کرد.</p>
<h3>ساخت Assembly و Module</h3>
<p>برای ایجاد یک نوع داینامیک، ابتدا باید <strong>assembly</strong> و <strong>module</strong> بسازیم:</p>
<pre class="hljs"><code>AssemblyName aname = <span class="hljs-keyword">new</span> AssemblyName(<span class="hljs-string">&quot;MyDynamicAssembly&quot;</span>);
AssemblyBuilder assemBuilder =
    AssemblyBuilder.DefineDynamicAssembly(aname, AssemblyBuilderAccess.Run);
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule(<span class="hljs-string">&quot;DynModule&quot;</span>);
</code></pre>
<ul>
<li>نمی‌توان یک type را به assembly موجود اضافه کرد، زیرا <strong>assembly پس از ایجاد، تغییرناپذیر است</strong>.</li>
<li>assemblyهای داینامیک معمولاً توسط <strong>garbage collector</strong> پاک نمی‌شوند و تا پایان فرآیند در حافظه می‌مانند، مگر اینکه هنگام تعریف، گزینه <strong>AssemblyBuilderAccess.RunAndCollect</strong> را استفاده کنید.</li>
</ul>
<h3>ایجاد یک Type داینامیک</h3>
<p>پس از داشتن module، می‌توان با <strong>TypeBuilder</strong> یک type ایجاد کرد:</p>
<pre class="hljs"><code>TypeBuilder tb = modBuilder.DefineType(<span class="hljs-string">&quot;Widget&quot;</span>, TypeAttributes.Public);
</code></pre>
<p>ویژگی‌های <code>TypeAttributes</code> شامل <strong>modifierهای CLR</strong>، <strong>visibility member flags</strong> و modifierهایی مانند <code>Abstract</code>، <code>Sealed</code> و <code>Interface</code> است. همچنین <code>Serializable</code> معادل [Serializable] در C# و <code>Explicit</code> معادل [StructLayout(LayoutKind.Explicit)] است. سایر attributeها را در بخش “Attaching Attributes” توضیح خواهیم داد.</p>
<p>همچنین می‌توان base type اختیاری مشخص کرد:</p>
<ul>
<li>برای struct: <code>System.ValueType</code></li>
<li>برای delegate: <code>System.MulticastDelegate</code></li>
<li>برای interface: آرایه‌ای از interfaceها</li>
<li>برای تعریف interface: <code>TypeAttributes.Interface | TypeAttributes.Abstract</code></li>
</ul>
<p>تعریف delegate نیازمند مراحل اضافی است (رجوع به مقاله Joel Pobar: “Creating delegate types via Reflection.Emit”).</p>
<h3>ایجاد متد در Type</h3>
<p>می‌توان اعضا را داخل type ایجاد کرد:</p>
<pre class="hljs"><code>MethodBuilder methBuilder = tb.DefineMethod(<span class="hljs-string">&quot;SayHello&quot;</span>,
                                             MethodAttributes.Public,
                                             <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
ILGenerator gen = methBuilder.GetILGenerator();
gen.EmitWriteLine(<span class="hljs-string">&quot;Hello world&quot;</span>);
gen.Emit(OpCodes.Ret);
</code></pre>
<h3>نهایی‌سازی Type</h3>
<pre class="hljs"><code>Type t = tb.CreateType();  <span class="hljs-comment">// نهایی کردن Type</span>
</code></pre>
<p>پس از ایجاد Type، می‌توان از <strong>reflection معمولی</strong> برای بازرسی و <strong>late binding</strong> استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span> o = Activator.CreateInstance(t);
t.GetMethod(<span class="hljs-string">&quot;SayHello&quot;</span>).Invoke(o, <span class="hljs-literal">null</span>);  <span class="hljs-comment">// Hello world</span>
</code></pre>
<h3>مدل شیء Reflection.Emit</h3>
<p>هر نوع در <strong>System.Reflection.Emit</strong> معادل یک ساختار CLR است و پایه آن در <strong>System.Reflection</strong> تعریف شده. این امکان را می‌دهد که از constructs داینامیک به جای constructs معمولی هنگام ساخت type استفاده کنید.</p>
<p>مثال: فراخوانی متد داینامیک به جای MethodInfo معمولی:</p>
<pre class="hljs"><code>MethodInfo writeLine = <span class="hljs-keyword">typeof</span>(Console).GetMethod(<span class="hljs-string">&quot;WriteLine&quot;</span>, <span class="hljs-keyword">new</span> Type[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>) });
gen.Emit(OpCodes.Call, writeLine);
</code></pre>
<p>با استفاده از <strong>MethodBuilder</strong> نیز می‌توان متد داینامیک دیگری را فراخوانی کرد، که برای ایجاد تعامل بین متدهای داینامیک در یک type ضروری است.</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>نکته مهم درباره CreateType</h3>
<p>پس از تکمیل تعریف یک <strong>TypeBuilder</strong>، باید <strong>CreateType</strong> را فراخوانی کنید. این کار باعث می‌شود:</p>
<ul>
<li>TypeBuilder و تمام اعضایش <strong>seal</strong> شوند (دیگر نمی‌توان چیزی اضافه یا تغییر داد).</li>
<li>یک <strong>Type واقعی</strong> برگردانده شود که بتوان آن را instantiate کرد.</li>
</ul>
<p>قبل از فراخوانی <strong>CreateType</strong>، TypeBuilder در حالت «uncreated» است و محدودیت‌های زیادی دارد:</p>
<ul>
<li>نمی‌توان متدهایی مانند <code>GetMembers</code>، <code>GetMethod</code> یا <code>GetProperty</code> را روی آن فراخوانی کرد، چون باعث ایجاد Exception می‌شوند.</li>
<li>اگر می‌خواهید به اعضای یک type ساخته نشده اشاره کنید، باید از <strong>MethodBuilder یا FieldBuilder اصلی</strong> استفاده کنید:</li>
</ul>
<pre class="hljs"><code>TypeBuilder tb = ...
MethodBuilder method1 = tb.DefineMethod(<span class="hljs-string">&quot;Method1&quot;</span>, ...);
MethodBuilder method2 = tb.DefineMethod(<span class="hljs-string">&quot;Method2&quot;</span>, ...);
ILGenerator gen1 = method1.GetILGenerator();

<span class="hljs-comment">// فراخوانی درست</span>
gen1.Emit(OpCodes.Call, method2);

<span class="hljs-comment">// فراخوانی اشتباه (روی TypeBuilder نامعتبر)</span>
gen1.Emit(OpCodes.Call, tb.GetMethod(<span class="hljs-string">&quot;Method2&quot;</span>));  <span class="hljs-comment">// Wrong</span>
</code></pre>
<p>پس از <code>CreateType</code>، می‌توان روی <strong>Type واقعی</strong> و حتی <strong>TypeBuilder اولیه</strong> بازتاب (reflect) و instantiate انجام داد. TypeBuilder به‌نوعی به proxy برای Type واقعی تبدیل می‌شود.</p>
<hr>
<h3>ایجاد متدها با TypeBuilder</h3>
<p>فرض کنید یک <strong>TypeBuilder</strong> داریم:</p>
<pre class="hljs"><code>AssemblyName aname = <span class="hljs-keyword">new</span> AssemblyName(<span class="hljs-string">&quot;MyEmissions&quot;</span>);
AssemblyBuilder assemBuilder = AssemblyBuilder.DefineDynamicAssembly(aname, AssemblyBuilderAccess.Run);
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule(<span class="hljs-string">&quot;MainModule&quot;</span>);
TypeBuilder tb = modBuilder.DefineType(<span class="hljs-string">&quot;Widget&quot;</span>, TypeAttributes.Public);
</code></pre>
<p>برای ایجاد یک متد مانند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">SquareRoot</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span></span>)</span> =&gt; Math.Sqrt(<span class="hljs-keyword">value</span>);
</code></pre>
<p>از <strong>DefineMethod</strong> و ILGenerator استفاده می‌کنیم:</p>
<pre class="hljs"><code>MethodBuilder mb = tb.DefineMethod(
    <span class="hljs-string">&quot;SquareRoot&quot;</span>,
    MethodAttributes.Static | MethodAttributes.Public,
    CallingConventions.Standard,
    <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">double</span>),                <span class="hljs-comment">// Return type</span>
    <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">double</span>) }       <span class="hljs-comment">// Parameter types</span>
);

mb.DefineParameter(<span class="hljs-number">1</span>, ParameterAttributes.None, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// Assign name</span>
ILGenerator gen = mb.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);                                <span class="hljs-comment">// Load first arg</span>
gen.Emit(OpCodes.Call, <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-string">&quot;Sqrt&quot;</span>));   
gen.Emit(OpCodes.Ret);

Type realType = tb.CreateType();
<span class="hljs-built_in">double</span> x = (<span class="hljs-built_in">double</span>)tb.GetMethod(<span class="hljs-string">&quot;SquareRoot&quot;</span>).Invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { <span class="hljs-number">10.0</span> });
Console.WriteLine(x);  <span class="hljs-comment">// 3.16227766016838</span>
</code></pre>
<ul>
<li>فراخوانی <strong>DefineParameter</strong> اختیاری است و فقط برای دادن نام به پارامتر استفاده می‌شود (<code>__p1</code>, <code>__p2</code> به‌صورت پیش‌فرض).</li>
<li><strong>ParameterBuilder</strong> برمی‌گرداند که می‌توان با <code>SetCustomAttribute</code> به آن attribute اضافه کرد.</li>
</ul>
<hr>
<h3>پارامترهای مرجع (ref)</h3>
<p>برای متدی با پارامتر <strong>ref</strong>، از <code>MakeByRefType()</code> استفاده می‌کنیم:</p>
<pre class="hljs"><code>MethodBuilder mb = tb.DefineMethod(
    <span class="hljs-string">&quot;SquareRoot&quot;</span>,
    MethodAttributes.Static | MethodAttributes.Public,
    CallingConventions.Standard,
    <span class="hljs-literal">null</span>,
    <span class="hljs-keyword">new</span> Type[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">double</span>).MakeByRefType() }
);

mb.DefineParameter(<span class="hljs-number">1</span>, ParameterAttributes.None, <span class="hljs-string">&quot;value&quot;</span>);
ILGenerator gen = mb.GetILGenerator();

gen.Emit(OpCodes.Ldarg_0);
gen.Emit(OpCodes.Ldarg_0);
gen.Emit(OpCodes.Ldind_R8);
gen.Emit(OpCodes.Call, <span class="hljs-keyword">typeof</span>(Math).GetMethod(<span class="hljs-string">&quot;Sqrt&quot;</span>));
gen.Emit(OpCodes.Stind_R8);
gen.Emit(OpCodes.Ret);

Type realType = tb.CreateType();
<span class="hljs-built_in">object</span>[] <span class="hljs-keyword">args</span> = { <span class="hljs-number">10.0</span> };
tb.GetMethod(<span class="hljs-string">&quot;SquareRoot&quot;</span>).Invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">args</span>);
Console.WriteLine(<span class="hljs-keyword">args</span>[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 3.16227766016838</span>
</code></pre>
<ul>
<li><code>Ldind</code> و <code>Stind</code> به معنی <strong>load/store indirectly</strong> هستند و <code>R8</code> مربوط به <strong>عدد شناور 8 بایتی</strong> است.</li>
</ul>
<p>برای <strong>out parameters</strong> نیز روند مشابه است، تنها تفاوت این است که هنگام <code>DefineParameter</code> از <code>ParameterAttributes.Out</code> استفاده می‌کنید.</p>
<h3>متدهای نمونه (Instance Methods)</h3>
<p>برای ایجاد یک متد نمونه، هنگام فراخوانی <strong>DefineMethod</strong> از <code>MethodAttributes.Instance</code> استفاده کنید:</p>
<pre class="hljs"><code>MethodBuilder mb = tb.DefineMethod(
    <span class="hljs-string">&quot;SquareRoot&quot;</span>,
    MethodAttributes.Instance | MethodAttributes.Public,
    <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">double</span>),
    <span class="hljs-keyword">new</span>[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">double</span>) }
);
</code></pre>
<p>نکات مهم:</p>
<ul>
<li>در متدهای نمونه، <strong>argument صفر (Ldarg_0)</strong> به <code>this</code> اشاره دارد.</li>
<li>آرگومان‌های واقعی از <strong>1 شروع می‌شوند</strong> (<code>Ldarg_1</code> اولین پارامتر واقعی را بارگذاری می‌کند).</li>
</ul>
<hr>
<h3>بازتعریف متدها (Overriding)</h3>
<p>برای override یک متد مجازی در کلاس پایه:</p>
<ul>
<li>متدی با <strong>همان نام، امضا و نوع بازگشتی</strong> تعریف کنید و <code>MethodAttributes.Virtual</code> را اضافه کنید.</li>
<li>برای پیاده‌سازی متدهای interface، روش مشابه اعمال می‌شود.</li>
<li>اگر می‌خواهید یک متد با نام متفاوت override شود (معمولاً برای explicit interface implementation)، از <code>DefineMethodOverride</code> استفاده کنید.</li>
</ul>
<h3>HideBySig</h3>
<p>هنگام subclassing بهتر است <code>MethodAttributes.HideBySig</code> را اضافه کنید:</p>
<ul>
<li>تضمین می‌کند که <strong>فقط متدی با امضای یکسان</strong> در subtype، متد base را مخفی کند.</li>
<li>بدون این، تنها نام متد بررسی می‌شود و ممکن است رفتار ناخواسته ایجاد شود.</li>
</ul>
<hr>
<h3>ایجاد فیلدها</h3>
<p>برای تعریف فیلد از <strong>DefineField</strong> استفاده کنید:</p>
<pre class="hljs"><code>FieldBuilder field = tb.DefineField(
    <span class="hljs-string">&quot;_text&quot;</span>,
    <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>),
    FieldAttributes.Private
);
</code></pre>
<hr>
<h3>ایجاد Properties</h3>
<p>برای ایجاد یک property:</p>
<ol>
<li><strong>DefineProperty</strong> روی TypeBuilder فراخوانی می‌کنیم:</li>
</ol>
<pre class="hljs"><code>PropertyBuilder prop = tb.DefineProperty(
    <span class="hljs-string">&quot;Text&quot;</span>,                     <span class="hljs-comment">// نام property</span>
    PropertyAttributes.None,
    <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>),             <span class="hljs-comment">// نوع property</span>
    <span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]                 <span class="hljs-comment">// نوع ایندکس (برای indexer)</span>
);
</code></pre>
<ol start="2">
<li>ایجاد متدهای get و set:</li>
</ol>
<pre class="hljs"><code><span class="hljs-comment">// Getter</span>
MethodBuilder getter = tb.DefineMethod(
    <span class="hljs-string">&quot;get_Text&quot;</span>,
    MethodAttributes.Public | MethodAttributes.SpecialName,
    <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>),
    <span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]
);
ILGenerator getGen = getter.GetILGenerator();
getGen.Emit(OpCodes.Ldarg_0);
getGen.Emit(OpCodes.Ldfld, field);
getGen.Emit(OpCodes.Ret);

<span class="hljs-comment">// Setter</span>
MethodBuilder setter = tb.DefineMethod(
    <span class="hljs-string">&quot;set_Text&quot;</span>,
    MethodAttributes.Assembly | MethodAttributes.SpecialName,
    <span class="hljs-literal">null</span>,
    <span class="hljs-keyword">new</span> Type[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>) }
);
ILGenerator setGen = setter.GetILGenerator();
setGen.Emit(OpCodes.Ldarg_0);
setGen.Emit(OpCodes.Ldarg_1);
setGen.Emit(OpCodes.Stfld, field);
setGen.Emit(OpCodes.Ret);

<span class="hljs-comment">// اتصال متدها به property</span>
prop.SetGetMethod(getter);
prop.SetSetMethod(setter);
</code></pre>
<ol start="3">
<li>تست property:</li>
</ol>
<pre class="hljs"><code>Type t = tb.CreateType();
<span class="hljs-built_in">object</span> o = Activator.CreateInstance(t);
t.GetProperty(<span class="hljs-string">&quot;Text&quot;</span>).SetValue(o, <span class="hljs-string">&quot;Good emissions!&quot;</span>, <span class="hljs-literal">null</span>);
<span class="hljs-built_in">string</span> text = (<span class="hljs-built_in">string</span>)t.GetProperty(<span class="hljs-string">&quot;Text&quot;</span>).GetValue(o, <span class="hljs-literal">null</span>);
Console.WriteLine(text);  <span class="hljs-comment">// Good emissions!</span>
</code></pre>
<p>نکات:</p>
<ul>
<li><code>SpecialName</code> باعث می‌شود این متدها به صورت مستقیم در کامپایلر قابل دسترسی نباشند و توسط ابزارهای reflection و IntelliSense به درستی شناسایی شوند.</li>
</ul>
<hr>
<h3>Events</h3>
<ul>
<li>برای ایجاد events، از <code>DefineEvent</code> روی TypeBuilder استفاده کنید.</li>
<li>سپس متدهای add و remove را نوشته و با <code>SetAddOnMethod</code> و <code>SetRemoveOnMethod</code> به EventBuilder متصل کنید.</li>
</ul>
<h3>تولید سازنده‌ها 🏗️</h3>
<p>می‌توانید سازنده‌های دلخواه خود را با فراخوانی <strong>DefineConstructor</strong> روی یک <strong>TypeBuilder</strong> تعریف کنید. لازم نیست حتماً این کار را انجام دهید—اگر این کار را نکنید، یک سازنده‌ی پیش‌فرض بدون پارامتر به‌طور خودکار ارائه می‌شود. سازنده‌ی پیش‌فرض، سازنده‌ی کلاس پایه را فراخوانی می‌کند (اگر از یک کلاس دیگر ارث‌بری می‌کنید)، دقیقاً مانند C#. اما اگر یک یا چند سازنده تعریف کنید، این سازنده‌ی پیش‌فرض جایگزین می‌شود.</p>
<p>اگر نیاز دارید فیلدها را مقداردهی اولیه کنید، سازنده بهترین مکان برای این کار است. در واقع، تنها مکان مناسب همین است، زیرا <strong>Field Initializers</strong> در C# پشتیبانی ویژه‌ای در CLR ندارند—آنها صرفاً یک میان‌بر نحوی برای مقداردهی به فیلدها در سازنده هستند.</p>
<p>مثلاً برای تولید معادل زیر:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>
{
    <span class="hljs-built_in">int</span> _capacity = <span class="hljs-number">4000</span>;
}
</code></pre>
<p>می‌توان یک سازنده به این شکل تعریف کرد:</p>
<pre class="hljs"><code>FieldBuilder field = tb.DefineField(<span class="hljs-string">&quot;_capacity&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>), FieldAttributes.Private);

ConstructorBuilder c = tb.DefineConstructor(
    MethodAttributes.Public,
    CallingConventions.Standard,
    <span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]   <span class="hljs-comment">// پارامترهای سازنده</span>
);

ILGenerator gen = c.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);        <span class="hljs-comment">// بارگذاری &quot;this&quot; روی استک ارزیابی</span>
gen.Emit(OpCodes.Ldc_I4, <span class="hljs-number">4000</span>);   <span class="hljs-comment">// بارگذاری عدد 4000 روی استک</span>
gen.Emit(OpCodes.Stfld, field);   <span class="hljs-comment">// ذخیره مقدار در فیلد</span>
gen.Emit(OpCodes.Ret);            <span class="hljs-comment">// بازگشت</span>
</code></pre>
<hr>
<h3>فراخوانی سازنده‌های پایه 🏛️</h3>
<p>اگر از یک کلاس دیگر ارث‌بری می‌کنید، سازنده‌ای که تعریف کردیم، <strong>سازنده‌ی کلاس پایه را نادیده می‌گیرد</strong>. این برخلاف C# است، که سازنده‌ی کلاس پایه همیشه فراخوانی می‌شود (مستقیماً یا غیرمستقیم).</p>
<p>مثال در C#:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> { <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span>()</span> { Console.Write(<span class="hljs-string">&quot;A&quot;</span>); } }
<span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">A</span> { <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">B</span>()</span> {} }
</code></pre>
<p>کامپایلر در واقع خط دوم را به شکل زیر ترجمه می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">A</span> { <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">B</span>() : <span class="hljs-title">base</span>()</span> {} }
</code></pre>
<p>در IL تولیدی، شما <strong>باید به‌صورت صریح سازنده‌ی پایه را فراخوانی کنید</strong> تا اجرا شود (که تقریباً همیشه می‌خواهید این کار انجام شود). فرض کنید کلاس پایه <strong>A</strong> است، می‌توانید این‌گونه عمل کنید:</p>
<pre class="hljs"><code>gen.Emit(OpCodes.Ldarg_0);
ConstructorInfo baseConstr = <span class="hljs-keyword">typeof</span>(A).GetConstructor(<span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]);
gen.Emit(OpCodes.Call, baseConstr);
</code></pre>
<p>فراخوانی سازنده‌ها با پارامتر نیز دقیقاً مشابه متدها است. 🎯</p>
<hr>
<h3>الحاق ویژگی‌ها (Attributes) 🏷️</h3>
<p>می‌توانید <strong>Custom Attribute</strong>ها را به یک سازه‌ی داینامیک اضافه کنید با فراخوانی <strong>SetCustomAttribute</strong> و استفاده از <strong>CustomAttributeBuilder</strong>.</p>
<p>مثلاً اگر بخواهیم ویژگی زیر را به یک فیلد یا پراپرتی اضافه کنیم:</p>
<pre class="hljs"><code>[<span class="hljs-meta">XmlElement(<span class="hljs-string">&quot;FirstName&quot;</span>, Namespace=<span class="hljs-string">&quot;http://test/&quot;</span>, Order=3)</span>]
</code></pre>
<p>این ویژگی از سازنده‌ی <strong>XmlElementAttribute</strong> که یک رشته می‌پذیرد استفاده می‌کند. برای استفاده از <strong>CustomAttributeBuilder</strong>، ابتدا باید سازنده و همچنین دو پراپرتی اضافی که می‌خواهیم مقداردهی کنیم (<strong>Namespace</strong> و <strong>Order</strong>) را بازیابی کنیم:</p>
<pre class="hljs"><code>Type attType = <span class="hljs-keyword">typeof</span>(XmlElementAttribute);
ConstructorInfo attConstructor = attType.GetConstructor(<span class="hljs-keyword">new</span> Type[] { <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>) });

<span class="hljs-keyword">var</span> att = <span class="hljs-keyword">new</span> CustomAttributeBuilder(
    attConstructor,                 <span class="hljs-comment">// سازنده</span>
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { <span class="hljs-string">&quot;FirstName&quot;</span> },   <span class="hljs-comment">// آرگومان‌های سازنده</span>
    <span class="hljs-keyword">new</span> PropertyInfo[] 
    {
        attType.GetProperty(<span class="hljs-string">&quot;Namespace&quot;</span>),  <span class="hljs-comment">// پراپرتی‌ها</span>
        attType.GetProperty(<span class="hljs-string">&quot;Order&quot;</span>)
    },
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] { <span class="hljs-string">&quot;http://test/&quot;</span>, <span class="hljs-number">3</span> }    <span class="hljs-comment">// مقادیر پراپرتی</span>
);

myFieldBuilder.SetCustomAttribute(att);
<span class="hljs-comment">// یا</span>
<span class="hljs-comment">// propBuilder.SetCustomAttribute(att);</span>
<span class="hljs-comment">// یا</span>
<span class="hljs-comment">// typeBuilder.SetCustomAttribute(att);  و غیره</span>
</code></pre>
<p>این روش به شما امکان می‌دهد ویژگی‌ها را به صورت داینامیک به فیلدها، پراپرتی‌ها و خود نوع‌ها اضافه کنید. 🛠️</p>
<h3>انتشار متدها و تایپ‌های جنریک 🧩</h3>
<p>تمام مثال‌های این بخش فرض می‌کنند که <strong>modBuilder</strong> به شکل زیر مقداردهی اولیه شده است:</p>
<pre class="hljs"><code>AssemblyName aname = <span class="hljs-keyword">new</span> AssemblyName(<span class="hljs-string">&quot;MyEmissions&quot;</span>);
AssemblyBuilder assemBuilder = AssemblyBuilder.DefineDynamicAssembly(
    aname, AssemblyBuilderAccess.Run);
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule(<span class="hljs-string">&quot;MainModule&quot;</span>);
</code></pre>
<hr>
<h4>تعریف متدهای جنریک 📝</h4>
<p>برای انتشار یک متد جنریک:</p>
<ol>
<li>
<p>روی <strong>MethodBuilder</strong> تابع <strong>DefineGenericParameters</strong> را فراخوانی کنید تا یک آرایه از <strong>GenericTypeParameterBuilder</strong> دریافت کنید.</p>
</li>
<li>
<p>روی <strong>MethodBuilder</strong> با استفاده از این پارامترهای جنریک، <strong>SetSignature</strong> را فراخوانی کنید.</p>
</li>
<li>
<p>به‌صورت اختیاری، نام پارامترها را همان‌طور که معمولاً انجام می‌دهید، تعیین کنید.</p>
</li>
</ol>
<p>مثال: متد جنریک زیر</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Echo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;
}
</code></pre>
<p>می‌تواند به شکل زیر منتشر شود:</p>
<pre class="hljs"><code>TypeBuilder tb = modBuilder.DefineType(<span class="hljs-string">&quot;Widget&quot;</span>, TypeAttributes.Public);
MethodBuilder mb = tb.DefineMethod(<span class="hljs-string">&quot;Echo&quot;</span>, MethodAttributes.Public |
                                          MethodAttributes.Static);

GenericTypeParameterBuilder[] genericParams
    = mb.DefineGenericParameters(<span class="hljs-string">&quot;T&quot;</span>);

mb.SetSignature(
    genericParams[<span class="hljs-number">0</span>],     <span class="hljs-comment">// نوع بازگشتی</span>
    <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,
    genericParams,        <span class="hljs-comment">// نوع پارامترها</span>
    <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>
);

mb.DefineParameter(<span class="hljs-number">1</span>, ParameterAttributes.None, <span class="hljs-string">&quot;value&quot;</span>);   <span class="hljs-comment">// اختیاری</span>

ILGenerator gen = mb.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);
gen.Emit(OpCodes.Ret);
</code></pre>
<hr>
<p>تابع <strong>DefineGenericParameters</strong> هر تعداد آرگومان رشته‌ای را می‌پذیرد—این آرگومان‌ها نام‌های موردنظر برای نوع‌های جنریک هستند. در این مثال تنها یک نوع جنریک به نام <strong>T</strong> نیاز داشتیم.</p>
<p><strong>GenericTypeParameterBuilder</strong> بر پایه <strong>System.Type</strong> ساخته شده است، بنابراین می‌توانید از آن به جای <strong>TypeBuilder</strong> هنگام انتشار کد IL استفاده کنید.</p>
<p>همچنین <strong>GenericTypeParameterBuilder</strong> امکان تعیین محدودیت نوع پایه را فراهم می‌کند:</p>
<pre class="hljs"><code>genericParams[<span class="hljs-number">0</span>].SetBaseTypeConstraint(<span class="hljs-keyword">typeof</span>(Foo));
</code></pre>
<p>و محدودیت‌های رابط‌ها:</p>
<pre class="hljs"><code>genericParams[<span class="hljs-number">0</span>].SetInterfaceConstraints(<span class="hljs-keyword">typeof</span>(IComparable));
</code></pre>
<p>برای بازتولید این متد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Echo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>) <span class="hljs-keyword">where</span> T : IComparable&lt;T&gt;
</span></code></pre>
<p>می‌توانید بنویسید:</p>
<pre class="hljs"><code>genericParams[<span class="hljs-number">0</span>].SetInterfaceConstraints(
    <span class="hljs-keyword">typeof</span>(IComparable&lt;&gt;).MakeGenericType(genericParams[<span class="hljs-number">0</span>])
);
</code></pre>
<p>برای انواع دیگر محدودیت‌ها، <strong>SetGenericParameterAttributes</strong> را فراخوانی کنید. این تابع یک عضو از <strong>GenericParameterAttributes</strong> می‌پذیرد که شامل مقادیر زیر است:</p>
<ul>
<li><strong>DefaultConstructorConstraint</strong></li>
<li><strong>NotNullableValueTypeConstraint</strong></li>
<li><strong>ReferenceTypeConstraint</strong></li>
<li><strong>Covariant</strong></li>
<li><strong>Contravariant</strong></li>
</ul>
<p>دو مقدار آخر معادل استفاده از <strong>out</strong> و <strong>in</strong> روی پارامترهای نوع هستند. ✅</p>
<h3>تعریف تایپ‌های جنریک 🏗️</h3>
<p>می‌توانید تایپ‌های جنریک را به شکل مشابه متدها تعریف کنید. تفاوت اصلی این است که <strong>DefineGenericParameters</strong> را روی <strong>TypeBuilder</strong> فراخوانی می‌کنید، نه <strong>MethodBuilder</strong>.</p>
<p>برای بازتولید این کلاس:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-keyword">public</span> T Value;
}
</code></pre>
<p>می‌توانید به شکل زیر عمل کنید:</p>
<pre class="hljs"><code>TypeBuilder tb = modBuilder.DefineType(<span class="hljs-string">&quot;Widget&quot;</span>, TypeAttributes.Public);
GenericTypeParameterBuilder[] genericParams
    = tb.DefineGenericParameters(<span class="hljs-string">&quot;T&quot;</span>);

tb.DefineField(<span class="hljs-string">&quot;Value&quot;</span>, genericParams[<span class="hljs-number">0</span>], FieldAttributes.Public);
</code></pre>
<p>محدودیت‌های جنریک را می‌توان دقیقاً همانند متدها اضافه کرد. ✅</p>
<hr>
<h3>اهداف انتشار نامتعارف ⚠️</h3>
<p>تمام مثال‌های این بخش فرض می‌کنند که <strong>modBuilder</strong> همانند بخش‌های قبلی مقداردهی اولیه شده است.</p>
<hr>
<h4>جنریک‌های بسته ایجاد نشده</h4>
<p>فرض کنید می‌خواهید یک متد منتشر کنید که از یک تایپ جنریک بسته استفاده می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span> { <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); }
}
</code></pre>
<p>این کار نسبتاً ساده است:</p>
<pre class="hljs"><code>TypeBuilder tb = modBuilder.DefineType(<span class="hljs-string">&quot;Widget&quot;</span>, TypeAttributes.Public);
MethodBuilder mb = tb.DefineMethod(<span class="hljs-string">&quot;Test&quot;</span>, MethodAttributes.Public | MethodAttributes.Static);

ILGenerator gen = mb.GetILGenerator();
Type variableType = <span class="hljs-keyword">typeof</span>(List&lt;<span class="hljs-built_in">int</span>&gt;);
ConstructorInfo ci = variableType.GetConstructor(<span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]);
LocalBuilder listVar = gen.DeclareLocal(variableType);

gen.Emit(OpCodes.Newobj, ci);
gen.Emit(OpCodes.Stloc, listVar);
gen.Emit(OpCodes.Ret);
</code></pre>
<hr>
<p>حالا فرض کنید به جای یک لیست از اعداد صحیح، می‌خواهیم لیستی از ویجت‌ها داشته باشیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span> { <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;Widget&gt;(); }
}
</code></pre>
<p>در تئوری، این تغییر ساده است؛ فقط خط زیر را جایگزین می‌کنیم:</p>
<pre class="hljs"><code>Type variableType = <span class="hljs-keyword">typeof</span>(List&lt;<span class="hljs-built_in">int</span>&gt;);
</code></pre>
<p>با این خط:</p>
<pre class="hljs"><code>Type variableType = <span class="hljs-keyword">typeof</span>(List&lt;&gt;).MakeGenericType(tb);
</code></pre>
<p>اما متأسفانه این باعث پرتاب <strong>NotSupportedException</strong> هنگام فراخوانی <strong>GetConstructor</strong> می‌شود. مشکل این است که نمی‌توان <strong>GetConstructor</strong> را روی یک تایپ جنریک بسته با <strong>TypeBuilder</strong> ایجاد نشده فراخوانی کرد. همین موضوع برای <strong>GetField</strong> و <strong>GetMethod</strong> نیز صادق است.</p>
<hr>
<h4>راه حل غیر مستقیم 💡</h4>
<p><strong>TypeBuilder</strong> سه متد استاتیک ارائه می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConstructorInfo <span class="hljs-title">GetConstructor</span>(<span class="hljs-params">Type, ConstructorInfo</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FieldInfo       <span class="hljs-title">GetField</span>(<span class="hljs-params">Type, FieldInfo</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodInfo      <span class="hljs-title">GetMethod</span>(<span class="hljs-params">Type, MethodInfo</span>)</span>;
</code></pre>
<p>اگرچه به نظر نمی‌آید، این متدها دقیقاً برای گرفتن اعضای تایپ‌های جنریک بسته با <strong>TypeBuilder</strong> ایجاد نشده طراحی شده‌اند!</p>
<p>پارامتر اول: تایپ جنریک بسته<br>
پارامتر دوم: عضوی که می‌خواهید از تایپ جنریک بدون بسته دریافت کنید</p>
<p>نسخه اصلاح‌شده مثال ما به شکل زیر است:</p>
<pre class="hljs"><code>MethodBuilder mb = tb.DefineMethod(<span class="hljs-string">&quot;Test&quot;</span>, MethodAttributes.Public | MethodAttributes.Static);
ILGenerator gen = mb.GetILGenerator();

Type variableType = <span class="hljs-keyword">typeof</span>(List&lt;&gt;).MakeGenericType(tb);
ConstructorInfo unbound = <span class="hljs-keyword">typeof</span>(List&lt;&gt;).GetConstructor(<span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]);
ConstructorInfo ci = TypeBuilder.GetConstructor(variableType, unbound);

LocalBuilder listVar = gen.DeclareLocal(variableType);
gen.Emit(OpCodes.Newobj, ci);
gen.Emit(OpCodes.Stloc, listVar);
gen.Emit(OpCodes.Ret);
</code></pre>
<h3>وابستگی‌های دایره‌ای 🔄</h3>
<p>فرض کنید می‌خواهید دو تایپ بسازید که به یکدیگر ارجاع دارند، مانند این مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> { <span class="hljs-keyword">public</span> B Bee; }
<span class="hljs-keyword">class</span> <span class="hljs-title">B</span> { <span class="hljs-keyword">public</span> A Aye; }
</code></pre>
<p>می‌توانید این را به صورت داینامیک به شکل زیر ایجاد کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> publicAtt = FieldAttributes.Public;

TypeBuilder aBuilder = modBuilder.DefineType(<span class="hljs-string">&quot;A&quot;</span>);
TypeBuilder bBuilder = modBuilder.DefineType(<span class="hljs-string">&quot;B&quot;</span>);

FieldBuilder bee = aBuilder.DefineField(<span class="hljs-string">&quot;Bee&quot;</span>, bBuilder, publicAtt);
FieldBuilder aye = bBuilder.DefineField(<span class="hljs-string">&quot;Aye&quot;</span>, aBuilder, publicAtt);

Type realA = aBuilder.CreateType();
Type realB = bBuilder.CreateType();
</code></pre>
<p>توجه کنید که ما <strong>تا زمانی که هر دو تایپ پر نشده‌اند،</strong> روی <strong>aBuilder</strong> یا <strong>bBuilder</strong> تابع <strong>CreateType</strong> را فراخوانی نکردیم. اصل موضوع این است: اول همه چیز را متصل کنید، سپس <strong>CreateType</strong> را روی هر <strong>TypeBuilder</strong> فراخوانی کنید. ✅</p>
<hr>
<p>جالب است بدانید که <strong>realA</strong> تا قبل از فراخوانی <strong>CreateType</strong> روی <strong>bBuilder</strong> معتبر اما غیرفعال است. (اگر قبل از این از <strong>aBuilder</strong> استفاده کنید، هنگام دسترسی به فیلد <strong>Bee</strong> استثنا پرتاب می‌شود.)</p>
<p>ممکن است بپرسید چگونه <strong>bBuilder</strong> می‌داند که پس از ایجاد <strong>realB</strong> باید <strong>realA</strong> را «اصلاح» کند. پاسخ این است که نمی‌داند: <strong>realA</strong> خودش هنگام استفاده بعدی اصلاح می‌شود. این امکان‌پذیر است زیرا پس از فراخوانی <strong>CreateType</strong>، <strong>TypeBuilder</strong> به یک پروکسی برای تایپ واقعی زمان اجرا تبدیل می‌شود. بنابراین <strong>realA</strong> با ارجاع به <strong>bBuilder</strong> می‌تواند به راحتی متادیتای مورد نیاز برای ارتقا را دریافت کند.</p>
<hr>
<p>این سیستم زمانی کار می‌کند که <strong>TypeBuilder</strong> تنها به اطلاعات ساده از تایپ ایجاد نشده نیاز داشته باشد—اطلاعاتی که از قبل قابل تعیین هستند—مثل نوع، اعضا و ارجاعات به اشیاء.</p>
<p>هنگام ایجاد <strong>realA</strong>، <strong>TypeBuilder</strong> نیازی به دانستن تعداد بایت‌های اشغال‌شده توسط <strong>realB</strong> در حافظه ندارد. این خوب است زیرا <strong>realB</strong> هنوز ایجاد نشده است!</p>
<p>اما تصور کنید <strong>realB</strong> یک <strong>struct</strong> باشد. اندازه نهایی <strong>realB</strong> اطلاعات حیاتی برای ایجاد <strong>realA</strong> است.</p>
<hr>
<p>اگر رابطه غیر دایره‌ای باشد؛ برای مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> A { <span class="hljs-keyword">public</span> B Bee; }
<span class="hljs-keyword">struct</span> B { }
</code></pre>
<p>می‌توان با ایجاد اول <strong>struct B</strong> و سپس <strong>struct A</strong> مشکل را حل کرد.</p>
<p>اما اگر رابطه دایره‌ای باشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> A { <span class="hljs-keyword">public</span> B Bee; }
<span class="hljs-keyword">struct</span> B { <span class="hljs-keyword">public</span> A Aye; }
</code></pre>
<p>ما نمی‌توانیم این را منتشر کنیم زیرا منطقی نیست که دو struct یکدیگر را شامل شوند (C# هنگام کامپایل خطا می‌دهد).</p>
<p>اما نسخه زیر هم قانونی و هم مفید است:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> S&lt;T&gt; { ... }    <span class="hljs-comment">// S می‌تواند خالی باشد و این دمو کار می‌کند.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">A</span> { S&lt;B&gt; Bee; }
<span class="hljs-keyword">class</span> <span class="hljs-title">B</span> { S&lt;A&gt; Aye; }
</code></pre>
<p>در ایجاد <strong>A</strong>، <strong>TypeBuilder</strong> اکنون باید اندازه حافظه <strong>B</strong> را بداند و بالعکس. فرض کنید <strong>struct S</strong> به صورت استاتیک تعریف شده باشد. کد انتشار کلاس‌های <strong>A</strong> و <strong>B</strong> به شکل زیر است:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> pub = FieldAttributes.Public;
TypeBuilder aBuilder = modBuilder.DefineType(<span class="hljs-string">&quot;A&quot;</span>);
TypeBuilder bBuilder = modBuilder.DefineType(<span class="hljs-string">&quot;B&quot;</span>);

aBuilder.DefineField(<span class="hljs-string">&quot;Bee&quot;</span>, <span class="hljs-keyword">typeof</span>(S&lt;&gt;).MakeGenericType(bBuilder), pub);
bBuilder.DefineField(<span class="hljs-string">&quot;Aye&quot;</span>, <span class="hljs-keyword">typeof</span>(S&lt;&gt;).MakeGenericType(aBuilder), pub);

Type realA = aBuilder.CreateType();    <span class="hljs-comment">// خطا: نمی‌توان تایپ B را بارگذاری کرد</span>
Type realB = bBuilder.CreateType();
</code></pre>
<p>اکنون <strong>CreateType</strong> یک <strong>TypeLoadException</strong> پرتاب می‌کند، فرقی نمی‌کند که به چه ترتیبی عمل کنید:</p>
<ul>
<li>اگر اول <strong>aBuilder.CreateType</strong> را فراخوانی کنید، می‌گوید «نمی‌توان تایپ B را بارگذاری کرد».</li>
<li>اگر اول <strong>bBuilder.CreateType</strong> را فراخوانی کنید، می‌گوید «نمی‌توان تایپ A را بارگذاری کرد».</li>
</ul>
<hr>
<p>برای حل این مشکل، باید اجازه دهید <strong>TypeBuilder</strong> هنگام ایجاد <strong>realA</strong>، <strong>realB</strong> را به صورت موقت ایجاد کند. این کار با هندل کردن رویداد <strong>TypeResolve</strong> روی کلاس <strong>AppDomain</strong> درست قبل از فراخوانی <strong>CreateType</strong> انجام می‌شود.</p>
<p>در مثال ما، دو خط آخر را با این کد جایگزین می‌کنیم:</p>
<pre class="hljs"><code>TypeBuilder[] uncreatedTypes = { aBuilder, bBuilder };

ResolveEventHandler handler = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">object</span> o, ResolveEventArgs <span class="hljs-keyword">args</span>)
{
    <span class="hljs-keyword">var</span> type = uncreatedTypes.FirstOrDefault(t =&gt; t.FullName == <span class="hljs-keyword">args</span>.Name);
    <span class="hljs-keyword">return</span> type == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : type.CreateType().Assembly;
};

AppDomain.CurrentDomain.TypeResolve += handler;

Type realA = aBuilder.CreateType();
Type realB = bBuilder.CreateType();

AppDomain.CurrentDomain.TypeResolve -= handler;
</code></pre>
<p>رویداد <strong>TypeResolve</strong> هنگام فراخوانی <strong>aBuilder.CreateType</strong> فعال می‌شود، در نقطه‌ای که نیاز است شما <strong>CreateType</strong> را روی <strong>bBuilder</strong> فراخوانی کنید.</p>
<h3>تجزیه IL 🧩</h3>
<p>می‌توانید اطلاعاتی درباره محتوای یک متد موجود با فراخوانی <strong>GetMethodBody</strong> روی یک شیء <strong>MethodBase</strong> به دست آورید. این متد یک <strong>MethodBody</strong> بازمی‌گرداند که دارای خصوصیات برای بررسی متغیرهای محلی، بلوک‌های مدیریت استثنا، اندازه پشته و همچنین <strong>IL خام</strong> است. تقریباً مانند معکوس <strong>Reflection.Emit</strong>!</p>
<p>بررسی <strong>IL خام</strong> یک متد می‌تواند در <strong>پروفایلینگ کد</strong> مفید باشد. یک استفاده ساده آن می‌تواند تعیین این باشد که هنگام به‌روزرسانی یک اسمبلی، کدام متدها تغییر کرده‌اند.</p>
<p>برای مثال، می‌خواهیم یک برنامه بنویسیم که <strong>IL را به سبک ildasm جدا کند</strong>. این می‌تواند نقطه شروعی برای یک ابزار تحلیل کد یا <strong>دیس‌اسمبلر زبان سطح بالاتر</strong> باشد.</p>
<p>به یاد داشته باشید که در <strong>Reflection API</strong>، تمام ساختارهای تابعی C# یا توسط یک زیرکلاس <strong>MethodBase</strong> نمایش داده می‌شوند یا (در مورد <strong>properties</strong>، <strong>events</strong> و <strong>indexers</strong>) به آنها اشیاء <strong>MethodBase</strong> متصل هستند.</p>
<hr>
<h3>نوشتن یک دیس‌اسمبلر 🛠️</h3>
<p>نمونه‌ای از خروجی که دیس‌اسمبلر ما تولید خواهد کرد:</p>
<pre class="hljs"><code>IL_00EB:  ldfld        Disassembler._pos
IL_00F0:  ldloc.2
IL_00F1:  add
IL_00F2:  ldelema      System.Byte
IL_00F7:  ldstr        &quot;Hello world&quot;
IL_00FC:  call         System.Byte.ToString
IL_0101:  ldstr        &quot; &quot;
IL_0106:  call         System.String.Concat
</code></pre>
<p>برای به دست آوردن این خروجی، باید <strong>توکن‌های باینری تشکیل‌دهنده IL</strong> را تجزیه کنیم.</p>
<hr>
<h4>مرحله اول: گرفتن IL به صورت آرایه بایت</h4>
<p>برای آسان‌تر کردن کار، این را در یک کلاس می‌نویسیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Disassembler</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Disassemble</span>(<span class="hljs-params">MethodBase method</span>)</span>
        =&gt; <span class="hljs-keyword">new</span> Disassembler(method).Dis();

    StringBuilder _output;    <span class="hljs-comment">// خروجی که به آن اضافه می‌کنیم</span>
    Module _module;           <span class="hljs-comment">// بعداً به کار خواهد آمد</span>
    <span class="hljs-built_in">byte</span>[] _il;               <span class="hljs-comment">// کد بایت خام</span>
    <span class="hljs-built_in">int</span> _pos;                 <span class="hljs-comment">// موقعیتی که در کد بایت هستیم</span>

    Disassembler(MethodBase method)
    {
        _module = method.DeclaringType.Module;
        _il = method.GetMethodBody().GetILAsByteArray();
    }

    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Dis</span>()</span>
    {
        _output = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">while</span> (_pos &lt; _il.Length) DisassembleNextInstruction();
        <span class="hljs-keyword">return</span> _output.ToString();
    }
}
</code></pre>
<ul>
<li>متد استاتیک <strong>Disassemble</strong> تنها عضو عمومی این کلاس خواهد بود.</li>
<li>بقیه اعضا خصوصی و مختص فرآیند دیس‌اسمبلی هستند.</li>
<li>متد <strong>Dis</strong> حلقه اصلی را شامل می‌شود که هر دستور را پردازش می‌کند.</li>
</ul>
<hr>
<h4>آماده‌سازی برای تجزیه دستورات</h4>
<p>با این ساختار، تنها کاری که باقی می‌ماند نوشتن <strong>DisassembleNextInstruction</strong> است.</p>
<p>اما قبل از آن، بهتر است همه <strong>opcodes</strong> را در یک دیکشنری استاتیک بارگذاری کنیم تا بتوانیم بر اساس مقدار ۸ یا ۱۶ بیتی به آنها دسترسی داشته باشیم. ساده‌ترین روش، استفاده از <strong>Reflection</strong> برای دریافت تمام فیلدهای استاتیک از کلاس <strong>OpCodes</strong> است که نوع آنها <strong>OpCode</strong> باشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">short</span>, OpCode&gt; _opcodes = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">short</span>, OpCode&gt;();

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Disassembler</span>()</span>
{
    Dictionary&lt;<span class="hljs-built_in">short</span>, OpCode&gt; opcodes = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">short</span>, OpCode&gt;();
    <span class="hljs-keyword">foreach</span> (<span class="hljs-function">FieldInfo fi <span class="hljs-keyword">in</span> <span class="hljs-title">typeof</span>(<span class="hljs-params">OpCodes</span>).<span class="hljs-title">GetFields</span>(<span class="hljs-params">BindingFlags.Public | BindingFlags.Static</span>))
        <span class="hljs-title">if</span> (<span class="hljs-params"><span class="hljs-keyword">typeof</span>(OpCode</span>).<span class="hljs-title">IsAssignableFrom</span>(<span class="hljs-params">fi.FieldType</span>))</span>
        {
            OpCode code = (OpCode)fi.GetValue(<span class="hljs-literal">null</span>);   <span class="hljs-comment">// گرفتن مقدار فیلد</span>
            <span class="hljs-keyword">if</span> (code.OpCodeType != OpCodeType.Nternal)
                _opcodes.Add(code.Value, code);
        }
}
</code></pre>
<ul>
<li>این کار در <strong>سازنده استاتیک</strong> انجام شده تا تنها یک بار اجرا شود. ✅</li>
</ul>
<h3>نوشتن DisassembleNextInstruction 🛠️</h3>
<p>هر دستور IL از یک <strong>opcode یک یا دو بایتی</strong> تشکیل شده و پس از آن یک <strong>عملوند</strong> با طول صفر، یک، دو، چهار یا هشت بایت می‌آید.<br>
(استثنا: <strong>inline switch opcodes</strong> که پس از آن تعداد متغیری از عملوندها می‌آید.)</p>
<p>الگوریتم کلی این است: ابتدا opcode را می‌خوانیم، سپس عملوند را، و در نهایت نتیجه را می‌نویسیم:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DisassembleNextInstruction</span>()</span>
{
    <span class="hljs-built_in">int</span> opStart = _pos;
    OpCode code = ReadOpCode();
    <span class="hljs-built_in">string</span> operand = ReadOperand(code);
    _output.AppendFormat(<span class="hljs-string">&quot;IL_{0:X4}:  {1,-12} {2}&quot;</span>, opStart, code.Name, operand);
    _output.AppendLine();
}
</code></pre>
<hr>
<h4>خواندن یک Opcode 🔍</h4>
<p>برای خواندن یک <strong>opcode</strong>:</p>
<ol>
<li>یک بایت جلو می‌رویم و بررسی می‌کنیم آیا دستور معتبر است.</li>
<li>اگر نبود، یک بایت دیگر جلو رفته و به دنبال دستور دو بایتی می‌گردیم:</li>
</ol>
<pre class="hljs"><code><span class="hljs-function">OpCode <span class="hljs-title">ReadOpCode</span>()</span>
{
    <span class="hljs-built_in">byte</span> byteCode = _il[_pos++];
    <span class="hljs-keyword">if</span> (_opcodes.ContainsKey(byteCode)) <span class="hljs-keyword">return</span> _opcodes[byteCode];
    <span class="hljs-keyword">if</span> (_pos == _il.Length) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Unexpected end of IL&quot;</span>);
    <span class="hljs-built_in">short</span> shortCode = (<span class="hljs-built_in">short</span>)(byteCode * <span class="hljs-number">256</span> + _il[_pos++]);
    <span class="hljs-keyword">if</span> (!_opcodes.ContainsKey(shortCode))
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Cannot find opcode &quot;</span> + shortCode);
    <span class="hljs-keyword">return</span> _opcodes[shortCode];
}
</code></pre>
<hr>
<h4>خواندن عملوند ⚙️</h4>
<p>ابتدا باید طول عملوند را تعیین کنیم. می‌توان این کار را بر اساس <strong>نوع عملوند</strong> انجام داد.<br>
چون بیشتر عملوندها ۴ بایت طول دارند، استثناها به راحتی در یک شرط فیلتر می‌شوند.</p>
<p>سپس متد <strong>FormatOperand</strong> فراخوانی می‌شود تا عملوند را قالب‌بندی کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ReadOperand</span>(<span class="hljs-params">OpCode c</span>)</span>
{
    <span class="hljs-built_in">int</span> operandLength =
        c.OperandType == OperandType.InlineNone ? <span class="hljs-number">0</span> :
        c.OperandType == OperandType.ShortInlineBrTarget ||
        c.OperandType == OperandType.ShortInlineI ||
        c.OperandType == OperandType.ShortInlineVar ? <span class="hljs-number">1</span> :
        c.OperandType == OperandType.InlineVar ? <span class="hljs-number">2</span> :
        c.OperandType == OperandType.InlineI8 ||
        c.OperandType == OperandType.InlineR ? <span class="hljs-number">8</span> :
        c.OperandType == OperandType.InlineSwitch ? <span class="hljs-number">4</span> * (BitConverter.ToInt32(_il, _pos) + <span class="hljs-number">1</span>) :
        <span class="hljs-number">4</span>;  <span class="hljs-comment">// بقیه عملوندها 4 بایت هستند</span>

    <span class="hljs-keyword">if</span> (_pos + operandLength &gt; _il.Length)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Unexpected end of IL&quot;</span>);

    <span class="hljs-built_in">string</span> result = FormatOperand(c, operandLength);

    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>)   <span class="hljs-comment">// اگر قالب‌بندی خاص نیاز نباشد</span>
    {
        result = <span class="hljs-string">&quot;&quot;</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; operandLength; i++)
            result += _il[_pos + i].ToString(<span class="hljs-string">&quot;X2&quot;</span>) + <span class="hljs-string">&quot; &quot;</span>;
    }

    _pos += operandLength;
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<ul>
<li>اگر <strong>FormatOperand</strong> مقدار <strong>null</strong> برگرداند، یعنی عملوند نیازی به قالب‌بندی خاص ندارد و به صورت <strong>هگزادسیمال</strong> نوشته می‌شود.</li>
</ul>
<p>می‌توان دیس‌اسمبلر را در این مرحله تست کرد با یک <strong>FormatOperand</strong> که همیشه <strong>null</strong> برگرداند. خروجی شبیه به این خواهد بود:</p>
<pre class="hljs"><code>IL_00A8:  ldfld        98 00 00 04
IL_00AD:  ldloc.2
IL_00AE:  add
IL_00AF:  ldelema      64 00 00 01
IL_00B4:  ldstr        26 04 00 70
IL_00B9:  call         B6 00 00 0A
IL_00BE:  ldstr        11 01 00 70
IL_00C3:  call         91 00 00 0A
</code></pre>
<ul>
<li>در این حالت، <strong>opcodes</strong> درست هستند اما عملوندها به درد خیلی نمی‌خورند.</li>
<li>ما می‌خواهیم به جای اعداد هگزادسیمال، <strong>نام اعضا و رشته‌ها</strong> را ببینیم.</li>
</ul>
<hr>
<h4>قالب‌بندی عملوندها 📐</h4>
<p>متد <strong>FormatOperand</strong> این کار را انجام می‌دهد و موارد خاصی که نیاز به قالب‌بندی دارند، شناسایی می‌کند. این شامل اکثر عملوندهای چهار بایتی و دستورهای <strong>short branch</strong> است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">FormatOperand</span>(<span class="hljs-params">OpCode c, <span class="hljs-built_in">int</span> operandLength</span>)</span>
{
    <span class="hljs-keyword">if</span> (operandLength == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;
    <span class="hljs-keyword">if</span> (operandLength == <span class="hljs-number">4</span>)
        <span class="hljs-keyword">return</span> Get4ByteOperand(c);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.OperandType == OperandType.ShortInlineBrTarget)
        <span class="hljs-keyword">return</span> GetShortRelativeTarget();
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.OperandType == OperandType.InlineSwitch)
        <span class="hljs-keyword">return</span> GetSwitchTarget(operandLength);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<hr>
<p>با این روش، اکنون پایه برای <strong>یک دیس‌اسمبلر IL کامل و قابل توسعه</strong> آماده است. ✅</p>
<h3>پردازش عملوندهای چهار بایتی و شاخه‌ها 🧩</h3>
<p>سه نوع عملوند چهار بایتی وجود دارد که باید به شکل خاصی پردازش شوند:</p>
<ol>
<li>
<p><strong>ارجاع به اعضا یا تایپ‌ها</strong><br>
با این نوع، نام عضو یا تایپ را با فراخوانی <strong>ResolveMember</strong> روی ماژول تعریف‌کننده استخراج می‌کنیم.</p>
</li>
<li>
<p><strong>رشته‌ها</strong><br>
رشته‌ها در <strong>metadata</strong> ماژول اسمبلی ذخیره شده‌اند و با <strong>ResolveString</strong> بازیابی می‌شوند.</p>
</li>
<li>
<p><strong>شاخه‌ها (Branch targets)</strong><br>
عملوند به یک آفست بایتی در IL اشاره می‌کند. این‌ها را با محاسبه آدرس مطلق بعد از دستور فعلی (+ چهار بایت) قالب‌بندی می‌کنیم.</p>
</li>
</ol>
<p>مثال کد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Get4ByteOperand</span>(<span class="hljs-params">OpCode c</span>)</span>
{
    <span class="hljs-built_in">int</span> intOp = BitConverter.ToInt32(_il, _pos);
    <span class="hljs-keyword">switch</span> (c.OperandType)
    {
        <span class="hljs-keyword">case</span> OperandType.InlineTok:
        <span class="hljs-keyword">case</span> OperandType.InlineMethod:
        <span class="hljs-keyword">case</span> OperandType.InlineField:
        <span class="hljs-keyword">case</span> OperandType.InlineType:
            MemberInfo mi;
            <span class="hljs-keyword">try</span> { mi = _module.ResolveMember(intOp); }
            <span class="hljs-keyword">catch</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; }
            <span class="hljs-keyword">if</span> (mi == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">if</span> (mi.ReflectedType != <span class="hljs-literal">null</span>)
                <span class="hljs-keyword">return</span> mi.ReflectedType.FullName + <span class="hljs-string">&quot;.&quot;</span> + mi.Name;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mi <span class="hljs-keyword">is</span> Type)
                <span class="hljs-keyword">return</span> ((Type)mi).FullName;
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> mi.Name;

        <span class="hljs-keyword">case</span> OperandType.InlineString:
            <span class="hljs-built_in">string</span> s = _module.ResolveString(intOp);
            <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>) s = <span class="hljs-string">&quot;&#x27;&quot;</span> + s + <span class="hljs-string">&quot;&#x27;&quot;</span>;
            <span class="hljs-keyword">return</span> s;

        <span class="hljs-keyword">case</span> OperandType.InlineBrTarget:
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IL_&quot;</span> + (_pos + intOp + <span class="hljs-number">4</span>).ToString(<span class="hljs-string">&quot;X4&quot;</span>);

        <span class="hljs-literal">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
}
</code></pre>
<ul>
<li>نقطه‌ای که <strong>ResolveMember</strong> فراخوانی می‌شود، پنجره خوبی برای ابزارهای تحلیل کد است تا وابستگی‌های متدها را گزارش کنند.</li>
<li>برای سایر opcodes چهار بایتی، <strong>null</strong> برگردانده می‌شود تا <strong>ReadOperand</strong> عملوند را به صورت هگزادسیمال نمایش دهد.</li>
</ul>
<hr>
<h3>شاخه‌های کوتاه و inline switch 🚦</h3>
<ul>
<li><strong>شاخه کوتاه (Short branch target)</strong>: آفست مقصد به صورت یک بایت با علامت نشان داده می‌شود (در انتهای دستور فعلی، + یک بایت).</li>
<li><strong>Switch target</strong>: پس از آن تعداد متغیری از مقاصد چهار بایتی قرار می‌گیرد.</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetShortRelativeTarget</span>()</span>
{
    <span class="hljs-built_in">int</span> absoluteTarget = _pos + (<span class="hljs-built_in">sbyte</span>)_il[_pos] + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;IL_&quot;</span> + absoluteTarget.ToString(<span class="hljs-string">&quot;X4&quot;</span>);
}

<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetSwitchTarget</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> operandLength</span>)</span>
{
    <span class="hljs-built_in">int</span> targetCount = BitConverter.ToInt32(_il, _pos);
    <span class="hljs-built_in">string</span>[] targets = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[targetCount];
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; targetCount; i++)
    {
        <span class="hljs-built_in">int</span> ilTarget = BitConverter.ToInt32(_il, _pos + (i + <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>);
        targets[i] = <span class="hljs-string">&quot;IL_&quot;</span> + (_pos + ilTarget + operandLength).ToString(<span class="hljs-string">&quot;X4&quot;</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + <span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;, &quot;</span>, targets) + <span class="hljs-string">&quot;)&quot;</span>;
}
</code></pre>
<hr>
<p>با این کد، دیس‌اسمبلر کامل می‌شود.<br>
می‌توان آن را با دیس‌اسمبل کردن یکی از متدهای خودش تست کرد:</p>
<pre class="hljs"><code>MethodInfo mi = <span class="hljs-keyword">typeof</span>(Disassembler).GetMethod(
    <span class="hljs-string">&quot;ReadOperand&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic);
Console.WriteLine(Disassembler.Disassemble(mi));
</code></pre>
<ul>
<li>این خروجی IL خوانا و مشابه <strong>ildasm</strong> تولید می‌کند. ✅</li>
</ul>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
