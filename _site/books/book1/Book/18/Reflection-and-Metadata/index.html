<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gitab | ฺฉุชุงุจุฎุงููู ุชุฑุฌููโูุง ุฏุงุชโูุช ู ุณ ุดุงุฑูพ</title>
  <meta name="description" content="ุชุฑุฌููโูุง ูุงุฑุณ ฺฉุชุงุจโูุง ูู โ ุณุฑุนุ ูููุงู ู ูุงุจู ุงุชฺฉุง.">
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <!-- ูุฏุฑ ูุดุชุฑฺฉ -->
  <header class="header">
    <div class="container nav-wrap">
      <a class="brand" href="/">
        <img src="/icone/logo.svg" alt="Gitab" width="28" height="28">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/">ุฎุงูู</a>
        <a href="/books/list-books">ฺฉุชุงุจโูุง</a>
        <a href="#">ููฺฉุงุฑ</a>
        <a href="#">ุฏุฑุจุงุฑูโูุง</a>
      </nav>

     <div class="nav-actions">
  <button id="themeToggle" class="icon-btn theme-btn" aria-label="ุชุบุฑ ุญุงูุช">
    <img class="icon-sun" src="/icone/sun.svg" alt="ุฑูุดู">
    <img class="icon-moon" src="/icone/moon.svg" alt="ุชุงุฑฺฉ">
  </button>

  <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
    <img src="/icone/github.svg" alt="GitHub">
  </a>
</div>

  </header>

  <!-- ูุญุชูุง ุตูุญู -->
  <main class="site-main">
    <h1>ูุตู ูุฌุฏูู:  ุจุงุฒุชุงุจ (Reflection) ู ูุชุงุฏุชุง</h1>
<p>ููุงูโุทูุฑ ฺฉู ุฏุฑ ูุตู ฑท ุฏุฏูุ ฺฉ ุจุฑูุงููโ C# ุจู ฺฉ <strong>Assembly</strong> ฺฉุงููพุงู ูโุดูุฏ ฺฉู ุดุงูู <strong>ูุชุงุฏุชุง (Metadata)</strong>ุ ฺฉุฏ ฺฉุงููพุงูโุดุฏู ู ููุงุจุน (Resources) ุงุณุช. ุจุฑุฑุณ ูุชุงุฏุชุง ู ฺฉุฏ ฺฉุงููพุงูโุดุฏู ุฏุฑ ุฒูุงู ุงุฌุฑุง ุฑุง <strong>Reflection (ุจุงุฒุชุงุจ)</strong> ูโูุงููุฏ.</p>
<p>ฺฉุฏ ฺฉุงููพุงูโุดุฏู ุฏุฑ ฺฉ Assembly ุชูุฑุจุงู ุชูุงู ูุญุชูุง ฺฉุฏ ููุจุน ุงุตู ุฑุง ุฏุฑ ุจุฑ ุฏุงุฑุฏ. ุจุง ุงู ุญุงูุ ุจุฑุฎ ุงุทูุงุนุงุช ูุงููุฏ ูุงู ูุชุบุฑูุง ูุญูุ ุชูุถุญุงุช (Comments) ู ุฏุณุชูุฑูุง ูพุดโูพุฑุฏุงุฒูุฏู (Preprocessor Directives) ุงุฒ ุฏุณุช ูโุฑููุฏ. ุงูุง ุจุงุฒุชุงุจ ุจู ูุง ุงูฺฉุงู ุฏุณุชุฑุณ ุจู ุชูุฑุจุงู ุชูุงู ููุงุฑุฏ ุฏฺฏุฑ ุฑุง ูโุฏูุฏโุญุช ุชุง ุญุฏ ฺฉู ูโุชูุงู ฺฉ <strong>Decompiler</strong> (ุฏโฺฉุงููพุงูุฑ) ููุดุช. ๐</p>
<p>ุจุณุงุฑ ุงุฒ ุณุฑูุณโูุง ููุฌูุฏ ุฏุฑ .NET ู ุฏุฑ ุฏุณุชุฑุณ ุงุฒ ุทุฑู C# (ูุงููุฏ <strong>Dynamic Binding</strong>ุ <strong>Serialization</strong> ู <strong>Data Binding</strong>) ุจู ูุฌูุฏ ูุชุงุฏุชุง ูุงุจุณุชู ูุณุชูุฏ. ููฺูู ุจุฑูุงููโูุง ุดูุง ูุฒ ูโุชูุงููุฏ ุงุฒ ุงู ูุชุงุฏุชุง ุงุณุชูุงุฏู ฺฉููุฏ ู ุญุช ุขู ุฑุง ุจุง ุงุทูุงุนุงุช ุฌุฏุฏ ุงุฒ ุทุฑู <strong>Custom Attributes</strong> ฺฏุณุชุฑุด ุฏููุฏ. ูุถุง ูุงู <code>System.Reflection</code> ุดุงูู API ูุฑุจูุท ุจู Reflection ุงุณุช. ุนูุงูู ุจุฑ ุงูุ ุฏุฑ ุฒูุงู ุงุฌุฑุง ูโุชูุงู ูุชุงุฏุชุง ู ุฏุณุชูุฑุงูุนููโูุง ุงุฌุฑุง ุฌุฏุฏ ุฏุฑ ุณุทุญ <strong>Intermediate Language (IL)</strong> ุจุง ุงุณุชูุงุฏู ุงุฒ ฺฉูุงุณโูุง ููุฌูุฏ ุฏุฑ ูุถุง ูุงู <code>System.Reflection.Emit</code> ุงุฌุงุฏ ฺฉุฑุฏ.</p>
<p>ูููููโูุง ุงู ูุตู ูุฑุถ ูโฺฉููุฏ ฺฉู ุดูุง ูุถุง ูุงูโูุง <code>System</code> ู <code>System.Reflection</code> ู ููฺูู <code>System.Reflection.Emit</code> ุฑุง ูุงุฑุฏ ฺฉุฑุฏูโุงุฏ.</p>
<p>ููุช ุฏุฑ ุงู ูุตู ุงุฒ ุงุตุทูุงุญ <strong>ยซุจูโุตูุฑุช ุฏูุงูฺฉยป (Dynamically)</strong> ุงุณุชูุงุฏู ูโฺฉููุ ููุธูุฑ ุงู ุงุณุช ฺฉู ุนูู ุฑุง ุจุง Reflection ุงูุฌุงู ุฏูู ฺฉู <strong>ุงูู ููุน (Type Safety)</strong> ุขู ููุท ุฏุฑ ุฒูุงู ุงุฌุฑุง ฺฉูุชุฑู ูโุดูุฏ. ุงู ููุถูุน ุงุฒ ูุธุฑ ุงุตูู ูุดุงุจู <strong>Dynamic Binding</strong> ุฏุฑ C# ุจุง ฺฉูุฏูุงฺูโ <code>dynamic</code> ุงุณุชุ ุงูุง ูฺฉุงูุฒู ู ุนููฺฉุฑุฏ ุขู ูุชูุงูุช ุงุณุช.</p>
<ul>
<li><strong>Dynamic Binding</strong> ุงุณุชูุงุฏูโ ุขุณุงูโุชุฑ ุฏุงุฑุฏ ู ุงุฒ <strong>Dynamic Language Runtime (DLR)</strong> ุจุฑุง ุณุงุฒฺฏุงุฑ ุจุง ุฒุจุงูโูุง ูพูุง ุงุณุชูุงุฏู ูโฺฉูุฏ.</li>
<li><strong>Reflection</strong> ูุณุจุช ุจู ุขู ฺฉู ุฏุณุชโููพุงฺฏุฑุชุฑ ุงุณุชุ ุงูุง ุงูุนุทุงู ุจุดุชุฑ ุฏุฑ ุงุฑุชุจุงุท ุจุง <strong>CLR</strong> ุงุฑุงุฆู ูโุฏูุฏ.</li>
</ul>
<p>ุจุฑุง ูุซุงูุ Reflection ุจู ุดูุง ุงุฌุงุฒู ูโุฏูุฏ:
โ๏ธ ููุฑุณุช ุงุฒ <strong>Types</strong> ู <strong>Members</strong> ุฏุฑุงูุช ฺฉูุฏ.
โ๏ธ ฺฉ ุดุก ุฑุง ุจุง ูุงู ฺฉู ุงุฒ ฺฉ ุฑุดุชู (String) ูโุขุฏ ุจุณุงุฒุฏ.
โ๏ธ ุฏุฑ ูุญุธู (On the fly) Assembly ุชููุฏ ฺฉูุฏ.</p>
<hr>
<h2>๐ Reflecting and Activating Types</h2>
<p>ุฏุฑ ุงู ุจุฎุด ุจุฑุฑุณ ูโฺฉูู ฺฉู ฺฺฏููู ูโุชูุงู ฺฉ <strong>Type</strong> ุฑุง ุจู ุฏุณุช ุขูุฑุฏุ ูุชุงุฏุชุง ุขู ุฑุง ุจุฑุฑุณ ฺฉุฑุฏ ู ุงุฒ ุขู ุจุฑุง ุงุฌุงุฏ ุฏูุงูฺฉ ฺฉ ุดุก ุงุณุชูุงุฏู ูููุฏ.</p>
<h3>๐ Obtaining a Type</h3>
<p>ฺฉ ููููู ุงุฒ <code>System.Type</code> ููุงุงูฺฏุฑ ูุชุงุฏุชุง ฺฉ Type ุงุณุช. ุงุฒ ุขูโุฌุง ฺฉู <strong>Type</strong> ุจุณุงุฑ ูพุฑฺฉุงุฑุจุฑุฏ ุงุณุชุ ุฏุฑ ูุถุง ูุงู <code>System</code> ูุฑุงุฑ ุฏุงุฑุฏุ ูู ุฏุฑ <code>System.Reflection</code>.</p>
<p>ุฑูุดโูุง ุจูโุฏุณุชโุขูุฑุฏู ฺฉ ูููููโ <code>System.Type</code>:</p>
<p>ฑ. ูุฑุงุฎูุงู ูุชุฏ <code>GetType</code> ุฑู ูุฑ ุดุก:</p>
<pre><code class="language-csharp">Type t1 = DateTime.Now.GetType();     // Type ุจุฏุณุชโุขูุฏู ุฏุฑ ุฒูุงู ุงุฌุฑุง
</code></pre>
<p>ฒ. ุงุณุชูุงุฏู ุงุฒ ุนููฺฏุฑ <code>typeof</code> ุฏุฑ C#:</p>
<pre><code class="language-csharp">Type t2 = typeof(DateTime);          // Type ุจุฏุณุชโุขูุฏู ุฏุฑ ุฒูุงู ฺฉุงููพุงู
</code></pre>
<p>ุจุง ุงุณุชูุงุฏู ุงุฒ <code>typeof</code> ูโุชูุงูุฏ Type ุขุฑุงูโูุง ู Typeูุง ุฌูุฑฺฉ ุฑุง ูุฒ ุจฺฏุฑุฏ:</p>
<pre><code class="language-csharp">Type t3 = typeof(DateTime[]);          // ุขุฑุงู ฺฉโุจุนุฏ
Type t4 = typeof(DateTime[,]);         // ุขุฑุงู ุฏูุจุนุฏ
Type t5 = typeof(Dictionary&lt;int,int&gt;); // ุฌูุฑฺฉ ุจุณุชู (Closed Generic Type)
Type t6 = typeof(Dictionary&lt;,&gt;);       // ุฌูุฑฺฉ ุจุงุฒ (Unbound Generic Type)
</code></pre>
<p>ณ. ุฏุฑุงูุช Type ุงุฒ ุทุฑู ูุงู (Name):
ุงฺฏุฑ ฺฉ ูุฑุฌุน ุจู Assembly ุฏุงุดุชู ุจุงุดุฏ:</p>
<pre><code class="language-csharp">Type t = Assembly.GetExecutingAssembly().GetType(&quot;Demos.TestProgram&quot;);
</code></pre>
<p>ุงฺฏุฑ Assembly ุฑุง ูุฏุงุดุชู ุจุงุดุฏุ ูโุชูุงูุฏ ุงุฒ <strong>Assembly Qualified Name</strong> ุงุณุชูุงุฏู ฺฉูุฏ (ูุงู ฺฉุงูู Type ุจูโููุฑุงู ูุงู ฺฉุงูู ุง ุฌุฒุฆ Assembly). ุฏุฑ ุงู ุญุงูุช Assembly ุจูโุทูุฑ ุถูู ุจุงุฑฺฏุฐุงุฑ ูโุดูุฏ:</p>
<pre><code class="language-csharp">Type t = Type.GetType(&quot;System.Int32, System.Private.CoreLib&quot;);
</code></pre>
<p>ูพุณ ุงุฒ ุฏุฑ ุงุฎุชุงุฑ ุฏุงุดุชู ฺฉ ุดุก <code>System.Type</code>ุ ูโุชูุงูุฏ ุจุง ุงุณุชูุงุฏู ุงุฒ ูฺฺฏโูุง ุขู ุจู ุงุทูุงุนุงุช ูุงููุฏ ูุงูุ Assemblyุ Base Typeุ ุณุทุญ ุฏุณุชุฑุณ (Visibility) ู ... ุฏุณุชุฑุณ ุฏุงุดุชู ุจุงุดุฏ:</p>
<pre><code class="language-csharp">Type stringType = typeof(string);
string name     = stringType.Name;          // String
Type baseType   = stringType.BaseType;      // typeof(Object)
Assembly assem  = stringType.Assembly;      // System.Private.CoreLib
bool isPublic   = stringType.IsPublic;      // true
</code></pre>
<p>ฺฉ ุดุก ุงุฒ ููุน <code>System.Type</code> ุฏุฑ ูุงูุน ูพูุฌุฑูโุง ุจู ุชูุงู ูุชุงุฏุชุง ูุฑุจูุท ุจู ุขู Type ู Assembly ุญุงู ุขู ุงุณุช.</p>
<blockquote>
<p><code>System.Type</code> ฺฉ ฺฉูุงุณ <strong>Abstract</strong> ุงุณุชุ ุจูุงุจุฑุงู ุนููฺฏุฑ <code>typeof</code> ุฏุฑ ูุงูุน ฺฉ ุฒุฑฺฉูุงุณ ุงุฒ Type ุฑุง ุจุฑูโฺฏุฑุฏุงูุฏ. ุฒุฑฺฉูุงุณ ฺฉู CLR ุงุณุชูุงุฏู ูโฺฉูุฏ ุฏุงุฎู (Internal) ุจูุฏู ู ูุงู ุขู <strong>RuntimeType</strong> ุงุณุช.</p>
</blockquote>
<hr>
<h2>๐ TypeInfo</h2>
<p>ุงฺฏุฑ ุดูุง ูุฏูโฺฏุฐุงุฑ ุฑู <strong>.NET Core 1.x</strong> (ุง ูพุฑููุงูโูุง ูุฏูโุชุฑ Windows Store) ุฏุงุดุชู ุจุงุดุฏุ ุจุณุงุฑ ุงุฒ ุงุนุถุง <code>Type</code> ุฏุฑ ุฏุณุชุฑุณ ูุณุชูุฏ. ุงู ุงุนุถุง ุจู ุฌุง ุขู ุฏุฑ ฺฉูุงุณ ุจู ูุงู <code>TypeInfo</code> ุงุฑุงุฆู ูโุดููุฏ ฺฉู ุงุฒ ุทุฑู ูุฑุงุฎูุงู <code>GetTypeInfo</code> ุจูโุฏุณุช ูโุขุฏ.</p>
<p>ุจุฑุง ุงุฌุฑุง ูุซุงู ูุจู ุฏุฑ ฺูู ูุญุทุ ฺฉุฏ ุดูุง ุงูโฺฏููู ุฎูุงูุฏ ุจูุฏ:</p>
<pre><code class="language-csharp">Type stringType = typeof(string);
string name = stringType.Name;
Type baseType = stringType.GetTypeInfo().BaseType;
Assembly assem = stringType.GetTypeInfo().Assembly;
bool isPublic = stringType.GetTypeInfo().IsPublic;
</code></pre>
<p>ฺฉูุงุณ <code>TypeInfo</code> ุฏุฑ <strong>.NET Core 2 ู 3</strong> ู <strong>.NET 5+</strong> (ู ููฺูู ุฏุฑ <strong>.NET Framework 4.5+</strong> ู ุชูุงู ูุณุฎูโูุง <strong>.NET Standard</strong>) ูุฒ ูุฌูุฏ ุฏุงุฑุฏ. ุจูุงุจุฑุงู ฺฉุฏ ุจุงูุง ุชูุฑุจุงู ุจูโุทูุฑ ุฌูุงู (Universal) ูุงุจู ุงุฌุฑุงุณุช.</p>
<p>ููฺูู <code>TypeInfo</code> ูฺฺฏโูุง ู ูุชุฏูุง ุงุถุงู ุจุฑุง ุจุงุฒุชุงุจ ุฑู ุงุนุถุง (Reflecting over Members) ุฏุฑ ุงุฎุชุงุฑ ูุฑุงุฑ ูโุฏูุฏ.</p>
<h2>๐ฆ ุจูโุฏุณุชโุขูุฑุฏู ุงููุงุน ุขุฑุงูโูุง (Obtaining Array Types)</h2>
<p>ููุงูโุทูุฑ ฺฉู ุฏุฏูุ <code>typeof</code> ู <code>GetType</code> ุจุง ุขุฑุงูโูุง ฺฉุงุฑ ูโฺฉููุฏ. ุนูุงูู ุจุฑ ุงู ูโุชูุงูุฏ ุจุง ูุฑุงุฎูุงู <code>MakeArrayType</code> ุฑู <strong>ููุน ุงูููุช (Element Type)</strong>ุ ฺฉ ููุน ุขุฑุงู ุจุณุงุฒุฏ:</p>
<pre><code class="language-csharp">Type simpleArrayType = typeof(int).MakeArrayType();
Console.WriteLine(simpleArrayType == typeof(int[]));  // True
</code></pre>
<p>ุจุฑุง ุงุฌุงุฏ ุขุฑุงูโูุง ฺูุฏุจุนุฏุ ฺฉุงู ุงุณุช ฺฉ ุขุฑฺฏููุงู ุนุฏุฏ ุตุญุญ ุจู <code>MakeArrayType</code> ุจุฏูุฏ:</p>
<pre><code class="language-csharp">Type cubeType = typeof(int).MakeArrayType(3);   // ุขุฑุงู ุณูโุจุนุฏ (ุดฺฉู ูฺฉุนุจ)
Console.WriteLine(cubeType == typeof(int[,,])); // True
</code></pre>
<p>ูุชุฏ <code>GetElementType</code> ุนูู ูุนฺฉูุณ ุฑุง ุงูุฌุงู ูโุฏูุฏ: ููุน ุงูููุช ฺฉ ุขุฑุงู ุฑุง ุจุงุฒูโฺฏุฑุฏุงูุฏ:</p>
<pre><code class="language-csharp">Type e = typeof(int[]).GetElementType();   // e == typeof(int)
</code></pre>
<p>ูุชุฏ <code>GetArrayRank</code> ุชุนุฏุงุฏ ุงุจุนุงุฏ ฺฉ ุขุฑุงู ูุณุชุทู ุฑุง ุจุฑูโฺฏุฑุฏุงูุฏ:</p>
<pre><code class="language-csharp">int rank = typeof(int[,,]).GetArrayRank();  // 3
</code></pre>
<hr>
<h2>๐งฉ ุจูโุฏุณุชโุขูุฑุฏู ููุนโูุง ุชู ุฏุฑ ุชู (Obtaining Nested Types)</h2>
<p>ุจุฑุง ฺฏุฑูุชู ููุนโูุง ุชู ุฏุฑ ุชู (Nested Types)ุ ูุชุฏ <code>GetNestedTypes</code> ุฑุง ุฑู ููุน ุญุงู (Containing Type) ูุฑุงุฎูุงู ฺฉูุฏ:</p>
<pre><code class="language-csharp">foreach (Type t in typeof(System.Environment).GetNestedTypes())
    Console.WriteLine(t.FullName);
</code></pre>
<p><strong>ุฎุฑูุฌ:</strong></p>
<pre><code>System.Environment+SpecialFolder
</code></pre>
<p>ุง ุจู ุฑูุด ุฏฺฏุฑ:</p>
<pre><code class="language-csharp">foreach (TypeInfo t in typeof(System.Environment)
                        .GetTypeInfo().DeclaredNestedTypes)
    Debug.WriteLine(t.FullName);
</code></pre>
<p>โ๏ธ ุชููุง ูฺฉุชู ุงู ุงุณุช ฺฉู CLR ฺฉ ููุน ุชู ุฏุฑ ุชู ุฑุง ุจุง ุณุทูุญ ุฏุณุชุฑุณ ูฺู ยซNestedยป ุฏุฑ ูุธุฑ ูโฺฏุฑุฏ:</p>
<pre><code class="language-csharp">Type t = typeof(System.Environment.SpecialFolder);
Console.WriteLine(t.IsPublic);       // False
Console.WriteLine(t.IsNestedPublic); // True
</code></pre>
<hr>
<h2>๐ท ูุงู ุงููุงุน (Type Names)</h2>
<p>ฺฉ Type ุฏุงุฑุง ูฺฺฏโูุง <code>Namespace</code>ุ <code>Name</code> ู <code>FullName</code> ุงุณุช. ุฏุฑ ุจุดุชุฑ ููุงุฑุฏุ <code>FullName</code> ุชุฑฺฉุจ ุงุฒ ุฏู ููุฑุฏ ุงูู ุงุณุช:</p>
<pre><code class="language-csharp">Type t = typeof(System.Text.StringBuilder);
Console.WriteLine(t.Namespace);  // System.Text
Console.WriteLine(t.Name);       // StringBuilder
Console.WriteLine(t.FullName);   // System.Text.StringBuilder
</code></pre>
<p>๐ ุฏู ุงุณุชุซูุง ูุฌูุฏ ุฏุงุฑุฏ:</p>
<ol>
<li>ููุนโูุง ุชู ุฏุฑ ุชู (Nested Types)</li>
<li>ููุนโูุง ุฌูุฑฺฉ ุจุณุชู (Closed Generic Types)</li>
</ol>
<p>ููฺูู ูฺฺฏ <code>AssemblyQualifiedName</code> ูุฌูุฏ ุฏุงุฑุฏ ฺฉู <code>FullName</code> ุฑุง ุจูโููุฑุงู ูุงู Assembly ุจุฑูโฺฏุฑุฏุงูุฏ. ุงู ููุงู ุฑุดุชูโุง ุงุณุช ฺฉู ูโุชูุงูุฏ ุจู <code>Type.GetType</code> ุจุฏูุฏ ู ุจูโุทูุฑ ููุญุตุฑุจูโูุฑุฏ ฺฉ Type ุฑุง ุฏุฑ ูุญุฏูุฏูโ ุจุงุฑฺฏุฐุงุฑ ูพุดโูุฑุถ ูุดุฎุต ูโฺฉูุฏ.</p>
<hr>
<h3>๐ ูุงู ููุนโูุง ุชู ุฏุฑ ุชู (Nested Type Names)</h3>
<p>ุฏุฑ ููุนโูุง ุชู ุฏุฑ ุชูุ ููุน ุญุงู ุชููุง ุฏุฑ <code>FullName</code> ุธุงูุฑ ูโุดูุฏ:</p>
<pre><code class="language-csharp">Type t = typeof(System.Environment.SpecialFolder);
Console.WriteLine(t.Namespace);  // System
Console.WriteLine(t.Name);       // SpecialFolder
Console.WriteLine(t.FullName);   // System.Environment+SpecialFolder
</code></pre>
<p>๐น ุนูุงูุช <code>+</code> ููุน ุญุงู ุฑุง ุงุฒ ูุถุง ูุงู ุชู ุฏุฑ ุชู ุฌุฏุง ูโฺฉูุฏ.</p>
<hr>
<h3>๐ ูุงู ููุนโูุง ุฌูุฑฺฉ (Generic Type Names)</h3>
<p>ูุงู ููุนโูุง ุฌูุฑฺฉ ุจุง ุนูุงูุช ุจฺฉโุชฺฉ (<code>`</code>) ู ุณูพุณ ุชุนุฏุงุฏ ูพุงุฑุงูุชุฑูุง ููุน ูุดุฎุต ูโุดููุฏ.</p>
<ul>
<li>ุงฺฏุฑ ุฌูุฑฺฉ ุจุงุฒ (Unbound) ุจุงุดุฏุ ุงู ูุงููู ุจุฑุง <code>Name</code> ู <code>FullName</code> ุงุนูุงู ูโุดูุฏ:</li>
</ul>
<pre><code class="language-csharp">Type t = typeof(Dictionary&lt;,&gt;);
Console.WriteLine(t.Name);     // Dictionary`2
Console.WriteLine(t.FullName); // System.Collections.Generic.Dictionary`2
</code></pre>
<ul>
<li>ุงฺฏุฑ ุฌูุฑฺฉ ุจุณุชู (Closed) ุจุงุดุฏุ ุชููุง <code>FullName</code> ฺฉ ุจุฎุด ุงุถุงู ุทููุงู ุดุงูู ูุงู ฺฉุงูู Assembly ูุฑ ูพุงุฑุงูุชุฑ ููุน ุฑุง ุฏุฑุงูุช ูโฺฉูุฏ:</li>
</ul>
<pre><code class="language-csharp">Console.WriteLine(typeof(Dictionary&lt;int,string&gt;).FullName);
</code></pre>
<p><strong>ุฎุฑูุฌ:</strong></p>
<pre><code>System.Collections.Generic.Dictionary`2[
 [System.Int32, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],
 [System.String, System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]
]
</code></pre>
<p>ุงู ุชุถูู ูโฺฉูุฏ ฺฉู <code>AssemblyQualifiedName</code> ุงุทูุงุนุงุช ฺฉุงู ุจุฑุง ุดูุงุณุง ฺฉุงูู ููุน ุฌูุฑฺฉ ู ูพุงุฑุงูุชุฑูุง ุขู ุฏุงุฑุฏ.</p>
<hr>
<h3>๐ ูุงู ุงููุงุน ุขุฑุงู ู ูพููุชุฑ (Array and Pointer Type Names)</h3>
<p>ุขุฑุงูโูุง ุจุง ููุงู ูพุณููุฏ ููุงุด ุฏุงุฏู ูโุดููุฏ ฺฉู ุฏุฑ ุนุจุงุฑุช <code>typeof</code> ุงุณุชูุงุฏู ูโฺฉูุฏ:</p>
<pre><code class="language-csharp">Console.WriteLine(typeof(int[]).Name);     // Int32[]
Console.WriteLine(typeof(int[,]).Name);    // Int32[,]
Console.WriteLine(typeof(int[,]).FullName);// System.Int32[,]
</code></pre>
<p>ููุนโูุง ูพููุชุฑ ูุดุงุจู ูุณุชูุฏ:</p>
<pre><code class="language-csharp">Console.WriteLine(typeof(byte*).Name);     // Byte*
</code></pre>
<hr>
<h3>๐ ูุงู ุงููุงุน ูพุงุฑุงูุชุฑูุง ref ู out</h3>
<p>ฺฉ <code>Type</code> ฺฉู ููุงูุฏูโ ูพุงุฑุงูุชุฑ <code>ref</code> ุง <code>out</code> ุจุงุดุฏุ ูพุณููุฏ <code>&amp;</code> ุฏุงุฑุฏ:</p>
<pre><code class="language-csharp">public void RefMethod(ref int p)
{
    Type t = MethodInfo.GetCurrentMethod().GetParameters()[0].ParameterType;
    Console.WriteLine(t.Name);   // Int32&amp;
}
</code></pre>
<p>(ุฌุฒุฆุงุช ุจุดุชุฑ ุฏุฑ ุจุฎุด ยซReflecting and Invoking Membersยป ุฏุฑ ุตูุญู 813 ุชูุถุญ ุฏุงุฏู ูโุดูุฏ.)</p>
<hr>
<h2>๐งฌ Base Types ู Interfaces</h2>
<p>ฺฉูุงุณ <code>Type</code> ฺฉ ูฺฺฏ ุจู ูุงู <code>BaseType</code> ุฏุงุฑุฏ:</p>
<pre><code class="language-csharp">Type base1 = typeof(System.String).BaseType;
Type base2 = typeof(System.IO.FileStream).BaseType;
Console.WriteLine(base1.Name);  // Object
Console.WriteLine(base2.Name);  // Stream
</code></pre>
<p>ูุชุฏ <code>GetInterfaces</code> ุฑุงุจุทโูุง (Interfaces) ุฑุง ฺฉู ฺฉ Type ูพุงุฏูโุณุงุฒ ูโฺฉูุฏ ุจุฑูโฺฏุฑุฏุงูุฏ:</p>
<pre><code class="language-csharp">foreach (Type iType in typeof(Guid).GetInterfaces())
    Console.WriteLine(iType.Name);
</code></pre>
<p><strong>ุฎุฑูุฌ:</strong></p>
<pre><code>IFormattable
IComparable
IComparable`1
IEquatable`1
</code></pre>
<p>(ูุชุฏ <code>GetInterfaceMap</code> ฺฉ ุณุงุฎุชุงุฑ ุจุงุฒูโฺฏุฑุฏุงูุฏ ฺฉู ูุดุงู ูโุฏูุฏ ูุฑ ุนุถู ุงุฒ ฺฉ Interface ฺฺฏููู ุฏุฑ ฺฉ ฺฉูุงุณ ุง Struct ูพุงุฏูโุณุงุฒ ุดุฏู ุงุณุชโูููููโ ุขู ุฏุฑ ุจุฎุด ยซCalling Static Virtual/Abstract Interface Membersยป ุฏุฑ ุตูุญู 826 ุขูุฏู ุงุณุช.)</p>
<hr>
<h2>โ๏ธ ูุนุงุฏูโูุง ูพูุง ุจุฑุง ุนููฺฏุฑ is ุฏุฑ C#</h2>
<p>Reflection ุณู ูุนุงุฏู ูพูุง ุจุฑุง ุนููฺฏุฑ ุงุณุชุง <code>is</code> ุฏุฑ C# ุงุฑุงุฆู ูโุฏูุฏ:</p>
<ul>
<li><code>IsInstanceOfType</code> โ ฺฉ Type ู ฺฉ ููููู ุฑุง ูโูพุฐุฑุฏ.</li>
<li><code>IsAssignableFrom</code> ู (ุงุฒ .NET 5) <code>IsAssignableTo</code> โ ุฏู Type ุฑุง ูโูพุฐุฑูุฏ.</li>
</ul>
<h3>ูุซุงู ฑ</h3>
<pre><code class="language-csharp">object obj  = Guid.NewGuid();
Type target = typeof(IFormattable);

bool isTrue   = obj is IFormattable;            // ุนููฺฏุฑ ุงุณุชุง C#
bool alsoTrue = target.IsInstanceOfType(obj);   // ูุนุงุฏู ูพูุง
</code></pre>
<h3>ูุซุงู ฒ</h3>
<pre><code class="language-csharp">Type target = typeof(IComparable), source = typeof(string);
Console.WriteLine(target.IsAssignableFrom(source));  // True
</code></pre>
<p>ูุชุฏ <code>IsSubclassOf</code> ูู ุจุฑ ุงุณุงุณ ููุงู ุงุตู <code>IsAssignableFrom</code> ฺฉุงุฑ ูโฺฉูุฏุ ุจุง ุงู ุชูุงูุช ฺฉู Interfaceูุง ุฑุง ุฏุฑ ูุธุฑ ููโฺฏุฑุฏ.</p>
<h2>๐ ุงุฌุงุฏ ููููู ุงุฒ ุงููุงุน (Instantiating Types)</h2>
<p>ุฏู ุฑูุด ุจุฑุง ุงุฌุงุฏ ุฏูุงูฺฉ ฺฉ ุดุก ุงุฒ ุฑู ููุน (Type) ูุฌูุฏ ุฏุงุฑุฏ:</p>
<ol>
<li>ูุฑุงุฎูุงู ูุชุฏ ุงุณุชุงุชฺฉ <code>Activator.CreateInstance</code></li>
<li>ูุฑุงุฎูุงู <code>Invoke</code> ุฑู ฺฉ ุดุก ุงุฒ ููุน <code>ConstructorInfo</code> ฺฉู ุงุฒ ูุชุฏ <code>GetConstructor</code> ุฑู ฺฉ Type ุจูโุฏุณุช ุขูุฏู ุงุณุช (ุจุฑุง ุณูุงุฑููุง ูพุดุฑูุชู)</li>
</ol>
<hr>
<h3>๐น ุงุณุชูุงุฏู ุงุฒ Activator.CreateInstance</h3>
<p>ูุชุฏ <code>Activator.CreateInstance</code> ฺฉ Type ู ุขุฑฺฏููุงูโูุง ุงุฎุชุงุฑ ุฏุฑุงูุช ูโฺฉูุฏ ู ุขูโูุง ุฑุง ุจู ุณุงุฒูุฏู (Constructor) ูพุงุณ ูโุฏูุฏ:</p>
<pre><code class="language-csharp">int i = (int)Activator.CreateInstance(typeof(int));

DateTime dt = (DateTime)Activator.CreateInstance(typeof(DateTime),
                                                 2000, 1, 1);
</code></pre>
<p>ุงู ูุชุฏ ฺฏุฒููโูุง ุจุดุชุฑ ูุฒ ูุฑุงูู ูโฺฉูุฏุ ูุงููุฏ ูุดุฎุตโฺฉุฑุฏู Assembly ุจุฑุง ุจุงุฑฺฏุฐุงุฑ ููุน ุง ุงูฺฉุงู ุงุชุตุงู ุจู ุณุงุฒูุฏูโูุง <strong>Nonpublic</strong>.
ุงฺฏุฑ CLR ูุชูุงูุฏ ุณุงุฒูุฏูโ ููุงุณุจ ูพุฏุง ฺฉูุฏุ ฺฉ ุงุณุชุซูุงุก ุงุฒ ููุน <code>MissingMethodException</code> ูพุฑุชุงุจ ูโุดูุฏ. โ๏ธ</p>
<hr>
<h3>๐น ุงุณุชูุงุฏู ุงุฒ ConstructorInfo.Invoke</h3>
<p>ฺฏุงู ุงููุงุช ุจุงุฏ ุงุฒ <code>ConstructorInfo.Invoke</code> ุงุณุชูุงุฏู ฺฉูุฏุ ุจูโูฺู ุฒูุงู ฺฉู ููุฏุงุฑ ุขุฑฺฏููุงูโูุง ููโุชูุงูุฏ ุจู ุณุงุฒูุฏูโูุง Overload ุชูุงุฒ ุงุฌุงุฏ ฺฉูุฏ.</p>
<p>ูุฑุถ ฺฉูุฏ ฺฉูุงุณ <code>X</code> ุฏู ุณุงุฒูุฏู ุฏุงุฑุฏ:</p>
<ul>
<li>ฺฉ ุจุง ูพุงุฑุงูุชุฑ <code>string</code></li>
<li>ุฏฺฏุฑ ุจุง ูพุงุฑุงูุชุฑ <code>StringBuilder</code></li>
</ul>
<p>ุฏุฑ ุงู ุญุงูุช ุงฺฏุฑ ููุฏุงุฑ <code>null</code> ุฑุง ุจู <code>Activator.CreateInstance</code> ุจุฏูุฏุ ูุชุฌู ูุจูู ุฎูุงูุฏ ุจูุฏ. ูพุณ ุจุงุฏ ูุณุชููุงู ุงุฒ <code>ConstructorInfo</code> ุงุณุชูุงุฏู ฺฉูุฏ:</p>
<pre><code class="language-csharp">// ฺฏุฑูุชู ุณุงุฒูุฏูโุง ฺฉู ฺฉ ูพุงุฑุงูุชุฑ ุงุฒ ููุน string ุฏุงุฑุฏ:
ConstructorInfo ci = typeof(X).GetConstructor(new[] { typeof(string) });

// ุณุงุฎุช ุดุก ุจุง ููุงู overload ู ูพุงุณ ุฏุงุฏู null:
object foo = ci.Invoke(new object[] { null });
</code></pre>
<p>ุงฺฏุฑ ูุฏู ุดูุง <strong>.NET Core 1</strong> ุง ูพุฑููุงูโูุง ูุฏู Windows Store ุจุงุดุฏ:</p>
<pre><code class="language-csharp">ConstructorInfo ci = typeof(X).GetTypeInfo().DeclaredConstructors
    .FirstOrDefault(c =&gt;
        c.GetParameters().Length == 1 &amp;&amp;
        c.GetParameters()[0].ParameterType == typeof(string));
</code></pre>
<p>ุจุฑุง ฺฏุฑูุชู ุณุงุฒูุฏูโูุง <strong>Nonpublic</strong> ุจุงุฏ ุงุฒ <strong>BindingFlags</strong> ุงุณุชูุงุฏู ฺฉูุฏ (ุชูุถุญ ุฏุฑ ุจุฎุด ยซAccessing Nonpublic Membersยป ุฏุฑ ุตูุญู 822).</p>
<hr>
<h3>โก ูฺฉุชูโ ุนููฺฉุฑุฏ</h3>
<p>ุงุฌุงุฏ ูููููโ ุฏูุงูฺฉ ฺูุฏ <strong>ูฺฉุฑูุซุงูู</strong> ุจู ุฒูุงู ุณุงุฎุช ุดุก ุงุถุงูู ูโฺฉูุฏ. ุงู ููุฏุงุฑ ุฏุฑ ููุงุณ ูุณุจ ุฒุงุฏ ุงุณุชุ ฺูู CLR ุจูโุทูุฑ ุนุงุฏ ุจุณุงุฑ ุณุฑุน ุฏุฑ ุงุฌุงุฏ ุงุดุงุก ุนูู ูโฺฉูุฏ (ฺฉ <code>new</code> ุณุงุฏู ุฑู ฺฉ ฺฉูุงุณ ฺฉูฺฺฉ ุฏุฑ ุญุฏ ฺูุฏ <strong>ูุงููุณุงูู</strong> ุฒูุงู ูโุจุฑุฏ).</p>
<hr>
<h3>๐ ุงุฌุงุฏ ุฏูุงูฺฉ ุขุฑุงูโูุง ู ุฌูุฑฺฉโูุง</h3>
<p>ุจุฑุง ุงุฌุงุฏ ุขุฑุงูโูุง ุจูโุตูุฑุช ุฏูุงูฺฉุ ุงุจุชุฏุง ุจุงุฏ <code>MakeArrayType</code> ุฑุง ูุฑุงุฎูุงู ฺฉูุฏ.
ุงุฌุงุฏ ููุนโูุง ุฌูุฑฺฉ ูุฒ ููฺฉู ุงุณุช (ุฏุฑ ุจุฎุด ุจุนุฏ ุชูุถุญ ุฏุงุฏู ูโุดูุฏ).</p>
<hr>
<h3>๐ช ุงุฌุงุฏ ุฏูุงูฺฉ Delegateูุง</h3>
<p>ุจุฑุง ุงุฌุงุฏ Delegate ุจูโุตูุฑุช ุฏูุงูฺฉุ ูุชุฏ <code>Delegate.CreateDelegate</code> ุฑุง ูุฑุงุฎูุงู ฺฉูุฏ. ูุซุงู ุฒุฑ ุงุฌุงุฏ ูุฑ ุฏู ููุน Delegate (ุงุณุชุงุชฺฉ ู Instance) ุฑุง ูุดุงู ูโุฏูุฏ:</p>
<pre><code class="language-csharp">class Program
{
    delegate int IntFunc(int x);

    static int Square(int x) =&gt; x * x;        // ูุชุฏ ุงุณุชุงุชฺฉ
    int        Cube  (int x) =&gt; x * x * x;    // ูุชุฏ Instance

    static void Main()
    {
        Delegate staticD = Delegate.CreateDelegate(
            typeof(IntFunc), typeof(Program), &quot;Square&quot;);

        Delegate instanceD = Delegate.CreateDelegate(
            typeof(IntFunc), new Program(), &quot;Cube&quot;);

        Console.WriteLine(staticD.DynamicInvoke(3));   // 9
        Console.WriteLine(instanceD.DynamicInvoke(3)); // 27
    }
}
</code></pre>
<p>ุจุฑุง ูุฑุงุฎูุงู Delegate ุงุฌุงุฏุดุฏูุ ูโุชูุงูุฏ ุงุฒ <code>DynamicInvoke</code> ุงุณุชูุงุฏู ฺฉูุฏ (ููุงูโุทูุฑ ฺฉู ุฏุฑ ูุซุงู ุจุงูุง ุฏุฏู) ุง ุขู ุฑุง ุจู ููุน Delegate ุงุตู Cast ฺฉูุฏ:</p>
<pre><code class="language-csharp">IntFunc f = (IntFunc)staticD;
Console.WriteLine(f(3));   // 9 (ุงูุง ุจุณุงุฑ ุณุฑุนโุชุฑ!)
</code></pre>
<p>ููฺูู ูโุชูุงูุฏ ุจูโุฌุง ูุงู ูุชุฏุ ฺฉ <code>MethodInfo</code> ุจู <code>CreateDelegate</code> ุจุฏูุฏ. ุฌุฒุฆุงุช ูุฑุจูุท ุจู <code>MethodInfo</code> ุฏุฑ ุจุฎุด <strong>โReflecting and Invoking Membersโ</strong> ุฏุฑ ุตูุญู 813 ุขูุฏู ุงุณุชุ ููุฑุงู ุจุง ุฏูู ุงูฺฉู ฺุฑุง ุจูุชุฑ ุงุณุช ฺฉ Delegate ุงุฌุงุฏุดุฏูโ ุฏูุงูฺฉ ุฑุง ุฏูุจุงุฑู ุจู ููุน Delegate ุงุณุชุง ุฎูุฏุด Cast ฺฉูู.</p>
<h2>๐งฉ ุงููุงุน ุฌูุฑฺฉ (Generic Types)</h2>
<p>ฺฉ ุดุก ุงุฒ ููุน <code>Type</code> ูโุชูุงูุฏ ูุดุงูโุฏููุฏูโ ฺฉ ููุน ุฌูุฑฺฉ <strong>ุจุณุชู (Closed)</strong> ุง <strong>ุจุงุฒ (Unbound)</strong> ุจุงุดุฏ.
ููุงููุฏ ุฒูุงู ฺฉุงููพุงูุ ููุท ููุน ุฌูุฑฺฉ ุจุณุชู ุฑุง ูโุชูุงู ูููููโุณุงุฒ ฺฉุฑุฏุ ุฏุฑ ุญุงูโฺฉู ููุน ุจุงุฒ ุบุฑูุงุจู ูููููโุณุงุฒ ุงุณุช:</p>
<pre><code class="language-csharp">Type closed = typeof(List&lt;int&gt;);
List&lt;int&gt; list = (List&lt;int&gt;)Activator.CreateInstance(closed);  // OK โ

Type unbound = typeof(List&lt;&gt;);
object anError = Activator.CreateInstance(unbound);            // ุฎุทุง ุฒูุงู ุงุฌุฑุง โ
</code></pre>
<p>ุจุฑุง ุชุจุฏู ฺฉ ููุน ุฌูุฑฺฉ ุจุงุฒ ุจู ุจุณุชู ุงุฒ ูุชุฏ <code>MakeGenericType</code> ุงุณุชูุงุฏู ูโฺฉูู:</p>
<pre><code class="language-csharp">Type unbound = typeof(List&lt;&gt;);
Type closed = unbound.MakeGenericType(typeof(int));
</code></pre>
<p>ุจุฑุนฺฉุณ ุขูุ ูุชุฏ <code>GetGenericTypeDefinition</code> ฺฉ ููุน ุจุณุชู ุฑุง ุฏูุจุงุฑู ุจู ุดฺฉู ุจุงุฒ ุจุฑูโฺฏุฑุฏุงูุฏ:</p>
<pre><code class="language-csharp">Type unbound2 = closed.GetGenericTypeDefinition();  // unbound == unbound2
</code></pre>
<p>๐ ูฺฺฏโูุง ฺฉูุฏ:</p>
<ul>
<li><code>IsGenericType</code> โ ุจุฑุฑุณ ูโฺฉูุฏ ฺฉู ุขุง ฺฉ ููุนุ ุฌูุฑฺฉ ุงุณุช ุง ูู.</li>
<li><code>IsGenericTypeDefinition</code> โ ุจุฑุฑุณ ูโฺฉูุฏ ฺฉู ุขุง ููุนุ <strong>ุจุงุฒ (unbound)</strong> ุงุณุช ุง ูู.</li>
</ul>
<p>ูุซุงู ุจุฑุฑุณ ููุน Nullable:</p>
<pre><code class="language-csharp">Type nullable = typeof(bool?);
Console.WriteLine(
    nullable.IsGenericType &amp;&amp;
    nullable.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;));   // True
</code></pre>
<p>ููฺููุ ูุชุฏ <code>GetGenericArguments</code> ุขุฑฺฏููุงูโูุง ููุน ุฑุง ุจุงุฒูโฺฏุฑุฏุงูุฏ:</p>
<pre><code class="language-csharp">Console.WriteLine(closed.GetGenericArguments()[0]);   // System.Int32
Console.WriteLine(nullable.GetGenericArguments()[0]); // System.Boolean
Console.WriteLine(unbound.GetGenericArguments()[0]);  // T (ูพูุงโุณโูููุฏุฑ)
</code></pre>
<p>๐ ุฏุฑ ุฒูุงู ุงุฌุฑุงุ ุชูุงู ุงููุงุน ุฌูุฑฺฉ ุง <strong>ุจุงุฒ (Unbound)</strong> ูุณุชูุฏ ุง <strong>ุจุณุชู (Closed)</strong>.</p>
<ul>
<li>ุญุงูุช ุจุงุฒ ููุท ุฏุฑ ููุงุฑุฏ ูุงุฏุฑ ูุซู <code>typeof(Foo&lt;&gt;)</code> ุฑุฎ ูโุฏูุฏ.</li>
<li>ูฺโููุช ููุน ยซุจุงุฒยป ูุงูุน ุฏุฑ ุฒูุงู ุงุฌุฑุง ูุฌูุฏ ูุฏุงุฑุฏุ ฺฉุงููพุงูุฑ ููู ุฑุง ุจู ููุน ุจุณุชู ุชุจุฏู ูโฺฉูุฏ.</li>
</ul>
<p>ูุซุงู ุฒุฑ ููุดู False ฺุงูพ ูโฺฉูุฏ:</p>
<pre><code class="language-csharp">class Foo&lt;T&gt;
{
    public void Test()
        =&gt; Console.Write(GetType().IsGenericTypeDefinition);  
}
</code></pre>
<hr>
<h2>๐ ุจุงุฒุชุงุจ ุงุนุถุง (Reflecting and Invoking Members)</h2>
<p>ุจุฑุง ุจุงุฒุชุงุจ ุงุนุถุง ฺฉ ููุนุ ุงุฒ ูุชุฏ <code>GetMembers</code> ุงุณุชูุงุฏู ูโฺฉูู.</p>
<pre><code class="language-csharp">class Walnut
{
    private bool cracked;
    public void Crack() { cracked = true; }
}

MemberInfo[] members = typeof(Walnut).GetMembers();
foreach (MemberInfo m in members)
    Console.WriteLine(m);
</code></pre>
<p>ูุชุฌู:</p>
<pre><code>Void Crack()
System.Type GetType()
System.String ToString()
Boolean Equals(System.Object)
Int32 GetHashCode()
Void .ctor()
</code></pre>
<hr>
<h3>๐น TypeInfo ู ุจุงุฒุชุงุจ ุงุนุถุง</h3>
<p>ฺฉูุงุณ <code>TypeInfo</code> ฺฉ ูพุฑูุชฺฉู ุณุงุฏูโุชุฑ ุจุฑุง ุจุงุฒุชุงุจ ุงุนุถุง ุงุฑุงุฆู ูโุฏูุฏ.</p>
<ul>
<li>ุจู ุฌุง ูุชุฏูุง ูุซู <code>GetMembers</code> ฺฉู ุขุฑุงู ุจุงุฒูโฺฏุฑุฏุงููุฏุ ุงู ฺฉูุงุณ ูฺฺฏโูุง ุงุฒ ููุน <code>IEnumerable&lt;T&gt;</code> ุงุฑุงุฆู ูโุฏูุฏ ฺฉู ูุนูููุงู ุจุง <strong>LINQ</strong> ุงุณุชูุงุฏู ูโุดููุฏ.</li>
</ul>
<p>ูุซุงู:</p>
<pre><code class="language-csharp">IEnumerable&lt;MemberInfo&gt; members =
    typeof(Walnut).GetTypeInfo().DeclaredMembers;
</code></pre>
<p>ูุชุฌู (ุจุฑุฎูุงู <code>GetMembers</code> ฺฉู ุงุนุถุง ุงุฑุซโุจุฑุฏูโุดุฏู ุฑุง ูู ุจุฑูโฺฏุฑุฏุงูุฏ):</p>
<pre><code>Void Crack()
Void .ctor()
Boolean cracked
</code></pre>
<p>ููฺูู ูฺฺฏโูุง ุฎุงุต ุจุฑุง ฺฏุฑูุชู ููุน ูุดุฎุต ุงุฒ ุงุนุถุง ูุฌูุฏ ุฏุงุฑุฏ (ูุซู <code>DeclaredMethods</code>, <code>DeclaredProperties</code> ู ุบุฑู).
ุจุฑุง ฺฏุฑูุชู ฺฉ ูุชุฏ ุฎุงุต ุจุง ูุงู (ุงูุง ุจุฏูู ุงูฺฉุงู ุชุนู ูพุงุฑุงูุชุฑูุง)ุ ุงุฒ <code>GetDeclaredMethod</code> ุงุณุชูุงุฏู ูโุดูุฏ.</p>
<p>ุจุฑุง ูุชุฏูุง overload ุจุงุฏ ุงุฒ LINQ ุงุณุชูุงุฏู ฺฉุฑุฏ:</p>
<pre><code class="language-csharp">MethodInfo method = typeof(int).GetTypeInfo().DeclaredMethods
    .FirstOrDefault(m =&gt; m.Name == &quot;ToString&quot; &amp;&amp;
                         m.GetParameters().Length == 0);
</code></pre>
<hr>
<h3>๐น ุฌุฒุฆุงุช ุจุดุชุฑ ุฏุฑ ููุฑุฏ GetMembers</h3>
<ul>
<li>ุจุฏูู ุขุฑฺฏููุงู โ ุชูุงู ุงุนุถุง public ููุน ู ูพุงูโูุงุด ุจุฑฺฏุฑุฏุงูุฏู ูโุดููุฏ.</li>
<li><code>GetMember(&quot;Crack&quot;)</code> โ ุนุถู ุฎุงุต ุฑุง ุจุง ูุงู ูโฺฏุฑุฏ (ุงูุง ุจูโุตูุฑุช ุขุฑุงู ุจุฑูโฺฏุฑุฏุงูุฏ ฺูู ููฺฉู ุงุณุช overload ุฏุงุดุชู ุจุงุดุฏ).</li>
</ul>
<pre><code class="language-csharp">MemberInfo[] m = typeof(Walnut).GetMember(&quot;Crack&quot;);
Console.WriteLine(m[0]);   // Void Crack()
</code></pre>
<p><code>MemberInfo.MemberType</code> ฺฉ enum ุงุฒ ููุน <code>MemberTypes</code> ุงุณุช ฺฉู ููุงุฏุฑ ุฒุฑ ุฑุง ุฏุงุฑุฏ:</p>
<pre><code>All, Constructor, Custom, Event, Field, Method,
NestedType, Property, TypeInfo
</code></pre>
<p>ูโุชูุงู ุจุง ุงุณุชูุงุฏู ุงุฒ ุงู enum ูุชุฌูโ ูุชุฏ <code>GetMembers</code> ุฑุง ูุญุฏูุฏ ฺฉุฑุฏ ุง ูุณุชููุงู ุงุฒ ูุชุฏูุง ุงุฎุชุตุงุต ูุซู <code>GetMethods</code>, <code>GetFields</code>, <code>GetProperties</code> ู ... ุงุณุชูุงุฏู ฺฉุฑุฏ.</p>
<p>โ ุชูุตู: ููุดู ููฺฏุงู ฺฏุฑูุชู ุงุนุถุงุ ุชุง ุฌุง ููฺฉู ุฏูู ุจุงุดุฏ. ูุซูุงู ููฺฏุงู ฺฏุฑูุชู ูุชุฏ ุจุง ูุงู ุฎุงุตุ ููุน ูููโ ูพุงุฑุงูุชุฑูุง ุฑุง ูุดุฎุต ฺฉูุฏ ุชุง ุงฺฏุฑ ุจุนุฏุงู ูุชุฏ overload ุดุฏุ ฺฉุฏ ุดูุง ููฺูุงู ุฏุฑุณุช ฺฉุงุฑ ฺฉูุฏ.</p>
<hr>
<h3>๐น DeclaringType ู ReflectedType</h3>
<p>ฺฉ ุดุก <code>MemberInfo</code> ุฏู ูฺฺฏ ุฏุงุฑุฏ:</p>
<ul>
<li><code>DeclaringType</code> โ ููุน ฺฉู ุนุถู ุฑุง ุชุนุฑู ฺฉุฑุฏู.</li>
<li><code>ReflectedType</code> โ ููุน ฺฉู ูุชุฏ <code>GetMembers</code> ุฑู ุขู ูุฑุงุฎูุงู ุดุฏู.</li>
</ul>
<p>ูุซุงู:</p>
<pre><code class="language-csharp">MethodInfo test = typeof(Program).GetMethod(&quot;ToString&quot;);
MethodInfo obj  = typeof(object).GetMethod(&quot;ToString&quot;);

Console.WriteLine(test.DeclaringType);   // System.Object
Console.WriteLine(obj.DeclaringType);    // System.Object
Console.WriteLine(test.ReflectedType);   // Program
Console.WriteLine(obj.ReflectedType);    // System.Object
Console.WriteLine(test == obj);          // False
</code></pre>
<p>ุฏุฑ ุงูุฌุงุ ุชูุงูุช ููุท ุจู ุฎุงุทุฑ Reflection API ุงุณุชุ ุฏุฑ ุญููุช <code>Program</code> ูฺ ูุชุฏ ุฌุฏุฏ ุจู ูุงู <code>ToString</code> ูุฏุงุฑุฏ.</p>
<p>ุจุฑุง ุจุฑุฑุณ ุงูฺฉู ุขุง ุฏู ูุชุฏ ูุงูุนุงู ฺฉ ูุณุชูุฏ:</p>
<pre><code class="language-csharp">Console.WriteLine(test.MethodHandle == obj.MethodHandle); // True
Console.WriteLine(test.MetadataToken == obj.MetadataToken
                  &amp;&amp; test.Module == obj.Module);           // True
</code></pre>
<hr>
<h3>๐ ูฺฉุงุช ูพุงุงู</h3>
<ul>
<li><code>MethodHandle</code> โ ุจุฑุง ูุฑ ูุชุฏ ูุชูุงุฒ ุฏุฑ ฺฉ ูพุฑูุณู ฺฉุชุง ุงุณุช.</li>
<li><code>MetadataToken</code> โ ุจุฑุง ุชูุงู ุงููุงุน ู ุงุนุถุง ุฏุฑ ฺฉ Assembly Module ฺฉุชุง ุงุณุช.</li>
<li><code>MemberInfo</code> ูุชุฏูุง ุจุฑุง ุฏุฑุงูุช Attributeูุง ุณูุงุฑุด ูู ุฏุงุฑุฏ (ุจุฎุด ยซRetrieving Attributes at Runtimeยป ุฏุฑ ุตูุญู 832).</li>
<li>ูุชุฏ <code>MethodBase.GetCurrentMethod</code>ุ ูุชุฏ ุฏุฑ ุญุงู ุงุฌุฑุง ุฑุง ุจุงุฒูโฺฏุฑุฏุงูุฏ.</li>
</ul>
<p>๐ ุฏุฑ ููุงุชุ <code>MemberInfo</code> ุฎูุฏุด ุงูุชุฒุงุน ุงุณุช ู ูพุงูโุง ุจุฑุง ุงููุงุน ุฏฺฏุฑ ุงุณุช (ุจู ุดฺฉู <strong>Figure 18-1</strong> ุฏุฑ ฺฉุชุงุจ).</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>ุดูุง ูโุชูุงูุฏ ฺฉ MemberInfo ุฑุง ุจุฑ ุงุณุงุณ ูฺฺฏ MemberType ุขู ุจู ุฒุฑฺฉูุงุณ ููุงุณุจุด Cast ฺฉูุฏ. ุงฺฏุฑ ฺฉ ุนุถู ุฑุง ุงุฒ ุทุฑู GetMethod, GetField, GetProperty, GetEvent, GetConstructor ุง GetNestedType (ุง ูุณุฎูโูุง ุฌูุน ุขูโูุง) ุจู ุฏุณุช ุขูุฑุฏู ุจุงุดุฏุ ูุงุฒ ุจู Cast ูุณุช.</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>ูุฑ ุฒุฑฺฉูุงุณ ุงุฒ <code>MemberInfo</code> ูุฌููุนูโุง ุบู ุงุฒ ูฺฺฏโูุง ู ูุชุฏูุง ุฏุงุฑุฏ ฺฉู ุชูุงู ุฌูุจูโูุง ูุชุงุฏุชุง ฺฉ ุนุถู ุฑุง ุขุดฺฉุงุฑ ูโฺฉูุฏ. ุงู ุดุงูู ููุงุฑุฏ ูุซู ุณุทุญ ุฏุณุชุฑุณ (visibility)ุ ุงุตูุงุญโฺฉููุฏูโูุง (modifiers)ุ ุขุฑฺฏููุงูโูุง ููุน ุฌูุฑฺฉุ ูพุงุฑุงูุชุฑูุงุ ููุน ุจุงุฒฺฏุดุช ู ูฺฺฏโูุง ุณูุงุฑุด (custom attributes) ูโุดูุฏ.</p>
<p>ูููููโุง ุงุฒ ุงุณุชูุงุฏู ุงุฒ <code>GetMethod</code>:</p>
<pre><code class="language-csharp">MethodInfo m = typeof (Walnut).GetMethod (&quot;Crack&quot;);
Console.WriteLine (m);            // Void Crack()
Console.WriteLine (m.ReturnType); // System.Void
</code></pre>
<p>ุชูุงู ูููููโูุง *Info ุชูุณุท Reflection API ุฏุฑ ุงููู ุงุณุชูุงุฏู ฺฉุด ูโุดููุฏ:</p>
<pre><code class="language-csharp">MethodInfo method = typeof (Walnut).GetMethod (&quot;Crack&quot;);
MemberInfo member = typeof (Walnut).GetMember (&quot;Crack&quot;)[0];
Console.Write (method == member);   // True
</code></pre>
<p>ุงู ฺฉุด ุดุฏู ุนูุงูู ุจุฑ ุญูุธ ููุช ุดุกุ ฺฉุงุฑุง ุฑุง ูู ุฏุฑ ฺฉ API ูุณุจุชุงู ฺฉูุฏ ุจูุจูุฏ ูโุฏูุฏ.</p>
<h3>ุงุนุถุง C# ุฏุฑ ุจุฑุงุจุฑ ุงุนุถุง CLR โ๏ธ</h3>
<p>ุฌุฏูู ูุจู ูุดุงู ุฏุงุฏ ฺฉู ุจุฑุฎ ุงุฒ ุณุงุฎุชุงุฑูุง C# ุจูโุทูุฑ ูุณุชูู ู ฺฉโุจูโฺฉ (1:1) ุจุง ุณุงุฎุชุงุฑูุง CLR ูุชูุงุธุฑ ูุณุชูุฏ. ุงู ููุทู ุงุณุช ฺูู CLR ู Reflection API ุจุฑุง ุชูุงู ุฒุจุงูโูุง .NET ุทุฑุงุญ ุดุฏูโุงูุฏโุญุช ูโุชูุงู ุงุฒ Reflection ุฏุฑ Visual Basic ูู ุงุณุชูุงุฏู ฺฉุฑุฏ.</p>
<p>ุจุฑุฎ ุณุงุฎุชุงุฑูุง C# (ูุซู indexerุ enumุ operator ู finalizer) ุฏุฑ CLR ุจู ุดฺฉู ูุชูุงูุช ูพุงุฏูโุณุงุฒ ูโุดููุฏ:</p>
<ul>
<li>ฺฉ <strong>C# indexer</strong> ุจู ูพุฑุงูพุฑุชโุง ุชุฑุฌูู ูโุดูุฏ ฺฉู ฺฉ ุง ฺูุฏ ุขุฑฺฏููุงู ูโฺฏุฑุฏ ู ุจุง <code>[DefaultMember]</code> ูุดุฎุต ูโุดูุฏ.</li>
<li>ฺฉ <strong>C# enum</strong> ุจู ุฒุฑฺฉูุงุณ ุงุฒ <code>System.Enum</code> ุชุฑุฌูู ูโุดูุฏ ฺฉู ุจุฑุง ูุฑ ุนุถู ฺฉ ููุฏ ุงุณุชุงุชฺฉ ุฏุงุฑุฏ.</li>
<li>ฺฉ <strong>C# operator</strong> ุจู ูุชุฏ ุงุณุชุงุชฺฉ ุจุง ูุงู ุฎุงุต (ุดุฑูุนโุดุฏู ุจุง <code>op_</code> ูุซู <code>&quot;op_Addition&quot;</code>) ุชุฑุฌูู ูโุดูุฏ.</li>
<li>ฺฉ <strong>C# finalizer</strong> ุจู ูุชุฏ ุชุฑุฌูู ูโุดูุฏ ฺฉู <code>Finalize</code> ุฑุง override ูโฺฉูุฏ.</li>
</ul>
<p>โ ูพฺุฏฺฏ ุฏฺฏุฑ ุงู ุงุณุช ฺฉู ูพุฑุงูพุฑุชโูุง ู ุฑูุฏุงุฏูุง ุฏุฑ ูุงูุน ุดุงูู ุฏู ฺุฒ ูุณุชูุฏ:</p>
<ul>
<li>ูุชุงุฏุชุง ฺฉู ูพุฑุงูพุฑุช ุง ุฑูุฏุงุฏ ุฑุง ุชูุตู ูโฺฉูุฏ (ุฏุฑ ูุงูุจ <code>PropertyInfo</code> ุง <code>EventInfo</code>)</li>
<li>ฺฉ ุง ุฏู ูุชุฏ ูพุดุชุจุงู (backing methods)</li>
</ul>
<p>ุฏุฑ ุจุฑูุงูู C#ุ ุงู ูุชุฏูุง ูพุดุชุจุงู ุฏุงุฎู ุชุนุฑู ูพุฑุงูพุฑุช ุง ุฑูุฏุงุฏ ูุฑุงุฑ ุฏุงุฑูุฏ. ุงูุง ููุช ุจู IL ฺฉุงููพุงู ูโุดูุฏุ ุงู ูุชุฏูุง ูุซู ูุชุฏูุง ุนุงุฏ ุฏุฏู ูโุดููุฏ ู ูโุชูุงู ุขูโูุง ุฑุง ูุฑุงุฎูุงู ฺฉุฑุฏ.</p>
<p>ุจู ููู ุฏูู <code>GetMethods</code> ุนูุงูู ุจุฑ ูุชุฏูุง ุนุงุฏุ ูุชุฏูุง ูพุดุชุจุงู ูพุฑุงูพุฑุช ู ุฑูุฏุงุฏูุง ุฑุง ูู ุจุฑูโฺฏุฑุฏุงูุฏ:</p>
<pre><code class="language-csharp">class Test { public int X { get { return 0; } set {} } }

void Demo()
{
  foreach (MethodInfo mi in typeof (Test).GetMethods())
    Console.Write (mi.Name + &quot;  &quot;);
}
// OUTPUT:
// get_X  set_X  GetType  ToString  Equals  GetHashCode
</code></pre>
<p>ุจุฑุง ุดูุงุณุง ุงู ูุชุฏูุง ูโุชูุงู ุงุฒ ูฺฺฏ <code>IsSpecialName</code> ุฏุฑ <code>MethodInfo</code> ุงุณุชูุงุฏู ฺฉุฑุฏ. ููุฏุงุฑ ุขู ุจุฑุง ูุชุฏูุง ูพุฑุงูพุฑุชุ ุงูุฏฺฉุณุฑุ ุฑูุฏุงุฏ ู ุนููฺฏุฑูุง <strong>true</strong> ุงุณุช. ุจุฑุง ูุชุฏูุง ูุนููู C# (ู ูุชุฏ <code>Finalize</code> ุฏุฑ ุตูุฑุช ูุฌูุฏ finalizer) ููุฏุงุฑ ุขู <strong>false</strong> ุฎูุงูุฏ ุจูุฏ.</p>
<p>ุฏุฑ ุงุฏุงููุ ูุชุฏูุง ูพุดุชุจุงู ฺฉู C# ุชููุฏ ูโฺฉูุฏ ุฑุง ุฎูุงูู ุฏุฏ.</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>ูุฑ ูุชุฏ ูพุดุชุจุงู (backing method) ุดุก ูุฎุตูุต ุจู ุฎูุฏุด ุงุฒ ููุน <code>MethodInfo</code> ุฏุงุฑุฏ. ูโุชูุงูุฏ ุจู ุงู ุตูุฑุช ุจู ุขูโูุง ุฏุณุชุฑุณ ูพุฏุง ฺฉูุฏ:</p>
<pre><code class="language-csharp">PropertyInfo pi = typeof (Console).GetProperty (&quot;Title&quot;);
MethodInfo getter = pi.GetGetMethod();                   // get_Title
MethodInfo setter = pi.GetSetMethod();                   // set_Title
MethodInfo[] both = pi.GetAccessors();                   // Length==2
</code></pre>
<p>ุจุฑุง ุฑูุฏุงุฏูุง (Event)ุ ูุชุฏูุง <code>GetAddMethod</code> ู <code>GetRemoveMethod</code> ฺฉุงุฑ ูุดุงุจู ุจุฑุง <code>EventInfo</code> ุงูุฌุงู ูโุฏููุฏ.</p>
<p>ุจุฑุง ุญุฑฺฉุช ุฏุฑ ุฌูุช ุนฺฉุณโุนู ุฑูุชู ุงุฒ ฺฉ <code>MethodInfo</code> ุจู <code>PropertyInfo</code> ุง <code>EventInfo</code> ูุฑุจูุทูโุจุงุฏ ฺฉ ฺฉูุฆุฑ ุงูุฌุงู ุฏูุฏ. ุฏุฑ ุงูุฌุง LINQ ุจุฑุง ุงู ฺฉุงุฑ ุงุฏุฆุงู ุงุณุช:</p>
<pre><code class="language-csharp">PropertyInfo p = mi.DeclaringType.GetProperties()
                  .First (x =&gt; x.GetAccessors (true).Contains (mi));
</code></pre>
<hr>
<h3>ูพุฑุงูพุฑุชโูุง Init-only ๐๏ธ</h3>
<p>ูพุฑุงูพุฑุชโูุง Init-only ฺฉู ุฏุฑ C# 9 ูุนุฑู ุดุฏูุฏุ ูโุชูุงููุฏ ุงุฒ ุทุฑู <strong>object initializer</strong> ููุฏุงุฑุฏู ุดููุฏุ ุงูุง ุจุนุฏ ุงุฒ ุขู ุชูุณุท ฺฉุงููพุงูุฑ ููุท ุจูโุนููุงู <em>ููุท-ุฎูุงูุฏู</em> ุฏุฑ ูุธุฑ ฺฏุฑูุชู ูโุดููุฏ.</p>
<p>ุงุฒ ุฏุฏ CLRุ ฺฉ <strong>init accessor</strong> ุฏุฑุณุช ูุซู ฺฉ <strong>set accessor</strong> ุนุงุฏ ุงุณุชุ ุจุง ุงู ุชูุงูุช ฺฉู ฺฉ ููฺฏ ุฎุงุต ุฑู ููุน ุจุงุฒฺฏุดุช ูุชุฏ <code>set</code> ุงุนูุงู ูโุดูุฏ (ุงู ููฺฏ ุจุฑุง ฺฉุงููพุงูุฑ ูุนูุง ุฏุงุฑุฏ).</p>
<p>ูฺฉุชู ุฌุงูุจ ุงู ุงุณุช ฺฉู ุงู ููฺฏ ุจู ุดฺฉู ฺฉ <strong>attribute ูุฑุงุฑุฏุงุฏ</strong> ุฑูุฒฺฏุฐุงุฑ ูุดุฏู ุงุณุช. ุฏุฑ ุนูุถุ ุงุฒ ฺฉ ูฺฉุงูุฒู ฺฉูุชุฑ ุดูุงุฎุชูโุดุฏู ุจู ูุงู <strong>modreq</strong> ุงุณุชูุงุฏู ูโฺฉูุฏ. ุงู ุจุงุนุซ ูโุดูุฏ ฺฉู ูุณุฎูโูุง ูุฏูโุชุฑ ฺฉุงููพุงูุฑ C# (ฺฉู modreq ุฌุฏุฏ ุฑุง ููโุดูุงุณูุฏ) ุขู accessor ุฑุง ูุงุฏุฏู ุจฺฏุฑูุฏุ ุจูโุฌุง ุงูฺฉู ูพุฑุงูพุฑุช ุฑุง ูุงุจู ููุดุชู ุฏุฑ ูุธุฑ ุจฺฏุฑูุฏ.</p>
<p>ูุงู modreq ุจุฑุง accessorูุง init-only ุจุฑุงุจุฑ ุงุณุช ุจุง <code>IsExternalInit</code> ู ูโุชูุงูุฏ ุจู ุงู ุตูุฑุช ุขู ุฑุง ุจุฑุฑุณ ฺฉูุฏ:</p>
<pre><code class="language-csharp">bool IsInitOnly (PropertyInfo pi) =&gt; pi
 .GetSetMethod().ReturnParameter.GetRequiredCustomModifiers()
 .Any (t =&gt; t.Name == &quot;IsExternalInit&quot;);
</code></pre>
<hr>
<h3>NullabilityInfoContext โ๏ธ</h3>
<p>ุงุฒ .NET 6 ุจู ุจุนุฏุ ูโุชูุงูุฏ ุจุง ฺฉูุงุณ <code>NullabilityInfoContext</code> ุงุทูุงุนุงุช ุฏุฑุจุงุฑู <strong>annotation</strong>โูุง nullability ุจุฑุง ููุฏุ ูพุฑุงูพุฑุชุ ุฑูุฏุงุฏ ุง ูพุงุฑุงูุชุฑูุง ุจู ุฏุณุช ุขูุฑุฏ:</p>
<pre><code class="language-csharp">void PrintPropertyNullability (PropertyInfo pi)
{
 var info = new NullabilityInfoContext().Create (pi);
 Console.WriteLine (pi.Name + &quot; read &quot; + info.ReadState);
 Console.WriteLine (pi.Name + &quot; write &quot; + info.WriteState);
 // ุงุฒ info.Element ุจุฑุง ฺฏุฑูุชู ุงุทูุงุนุงุช nullability ุนูุงุตุฑ ุขุฑุงู ุงุณุชูุงุฏู ฺฉูุฏ
}
</code></pre>
<hr>
<h3>ุงุนุถุง ููุน ุฌูุฑฺฉ ๐</h3>
<p>ูโุชูุงูุฏ ูุชุงุฏุชุง ุงุนุถุง ุฑุง ูู ุจุฑุง <strong>ุงููุงุน ุฌูุฑฺฉ ุจุงุฒ (unbound generic types)</strong> ู ูู ุจุฑุง <strong>ุงููุงุน ุฌูุฑฺฉ ุจุณุชู (closed generic types)</strong> ุจู ุฏุณุช ุขูุฑุฏ:</p>
<pre><code class="language-csharp">PropertyInfo unbound = typeof (IEnumerator&lt;&gt;)  .GetProperty (&quot;Current&quot;);
PropertyInfo closed = typeof (IEnumerator&lt;int&gt;).GetProperty (&quot;Current&quot;);
Console.WriteLine (unbound);   // T Current
Console.WriteLine (closed);    // Int32 Current
Console.WriteLine (unbound.PropertyType.IsGenericParameter);  // True
Console.WriteLine (closed.PropertyType.IsGenericParameter);   // False
</code></pre>
<p>ุดุกูุง <code>MemberInfo</code> ฺฉู ุงุฒ ุงููุงุน ุฌูุฑฺฉ ุจุงุฒ ู ุจุณุชู ุจุงุฒฺฏุฑุฏุงูุฏู ูโุดููุฏ ููุดู ูุชูุงุฒ ูุณุชูุฏุ ุญุช ุงฺฏุฑ ุงูุถุง ุงุนุถุง ุดุงูู ูพุงุฑุงูุชุฑูุง ููุน ุฌูุฑฺฉ ูุจุงุดุฏ:</p>
<pre><code class="language-csharp">PropertyInfo unbound = typeof (List&lt;&gt;)  .GetProperty (&quot;Count&quot;);
PropertyInfo closed = typeof (List&lt;int&gt;).GetProperty (&quot;Count&quot;);
Console.WriteLine (unbound);   // Int32 Count
Console.WriteLine (closed);    // Int32 Count
Console.WriteLine (unbound == closed);   // False
Console.WriteLine (unbound.DeclaringType.IsGenericTypeDefinition); // True
Console.WriteLine (closed.DeclaringType.IsGenericTypeDefinition); // False
</code></pre>
<p>โ ุงุนุถุง ุงููุงุน ุฌูุฑฺฉ ุจุงุฒ (<strong>unbound generic types</strong>) ุฑุง ููโุชูุงู ุจูโุตูุฑุช ุฏุงูุงูฺฉ invoke ฺฉุฑุฏ.</p>
<h3>ูุฑุงุฎูุงู ูพูุง ุงุนุถุง โก</h3>
<p>ูุฑุงุฎูุงู ูพูุง ฺฉ ุนุถู ูโุชูุงูุฏ ุจุง ุงุณุชูุงุฏู ุงุฒ ฺฉุชุงุจุฎุงููโ <strong>Uncapsulator</strong> (ูุชูโุจุงุฒ ู ููุฌูุฏ ุฏุฑ NuGet ู GitHub) ุจุณุงุฑ ุฑุงุญุชโุชุฑ ุงูุฌุงู ุดูุฏ. ุงู ฺฉุชุงุจุฎุงูู ฺฉู ุชูุณุท ููุณูุฏูโ ฺฉุชุงุจ ููุดุชู ุดุฏูุ ฺฉ API ุฑูุงู ุจุฑุง ูุฑุงุฎูุงู ุงุนุถุง ุนููู ู ุบุฑุนููู ุงุฒ ุทุฑู Reflectionุ ุจุง ุงุณุชูุงุฏู ุงุฒ ฺฉ <strong>dynamic binder</strong> ุณูุงุฑุด ุงุฑุงุฆู ูโุฏูุฏ.</p>
<p>ูพุณ ุงุฒ ุขูฺฉู ฺฉ ุดุก ุงุฒ ููุน <code>MethodInfo</code>ุ <code>PropertyInfo</code> ุง <code>FieldInfo</code> ุฏุงุดุชู ุจุงุดุฏุ ูโุชูุงูุฏ ุขู ุฑุง ุจูโุตูุฑุช ูพูุง ูุฑุงุฎูุงู ฺฉูุฏ ุง ููุฏุงุฑุด ุฑุง ุจฺฏุฑุฏ/ุชุนู ฺฉูุฏ. ุงู ฺฉุงุฑ <strong>late binding</strong> ูุงู ุฏุงุฑุฏุ ุฒุฑุง ุดูุง ุงูุชุฎุงุจ ูโฺฉูุฏ ฺฉุฏุงู ุนุถู ุฏุฑ ุฒูุงู ุงุฌุฑุง (runtime) ูุฑุงุฎูุงู ุดูุฏุ ูู ุฏุฑ ุฒูุงู ฺฉุงููพุงู.</p>
<p>ุจุฑุง ูููููุ ุงู ฺฉุฏ ุจุง <strong>static binding</strong> ุนุงุฏ ููุดุชู ุดุฏู ุงุณุช:</p>
<pre><code class="language-csharp">string s = &quot;Hello&quot;;
int length = s.Length;
</code></pre>
<p>ู ููู ฺฉุงุฑ ุจุง <strong>late binding</strong> ูพูุง ฺูู ุฎูุงูุฏ ุจูุฏ:</p>
<pre><code class="language-csharp">object s = &quot;Hello&quot;;
PropertyInfo prop = s.GetType().GetProperty (&quot;Length&quot;);
int length = (int) prop.GetValue (s, null);   // 5
</code></pre>
<p>ูุชุฏูุง <code>GetValue</code> ู <code>SetValue</code> ููุฏุงุฑ ฺฉ <code>PropertyInfo</code> ุง <code>FieldInfo</code> ุฑุง ูโฺฏุฑูุฏ ุง ุชูุธู ูโฺฉููุฏ. ุขุฑฺฏููุงู ุงูู ููููู (instance) ุงุณุชุ ฺฉู ุจุฑุง ุงุนุถุง <code>static</code> ูโุชูุงูุฏ <code>null</code> ุจุงุดุฏ.</p>
<p>ุจุฑุง ุฏุณุชุฑุณ ุจู <strong>Indexer</strong> ูุฒ ุฏุฑุณุช ูุซู ูพุฑุงูพุฑุชโุง ุจู ูุงู <code>&quot;Item&quot;</code> ุฑูุชุงุฑ ูโุดูุฏุ ุจุง ุงู ุชูุงูุช ฺฉู ููุงุฏุฑ indexer ุจูโุนููุงู ุขุฑฺฏููุงู ุฏูู ุจู <code>GetValue</code> ุง <code>SetValue</code> ุฏุงุฏู ูโุดููุฏ.</p>
<p>ุจุฑุง ูุฑุงุฎูุงู ูพูุง ฺฉ ูุชุฏุ ูุชุฏ <code>Invoke</code> ุฑุง ุฑู ฺฉ <code>MethodInfo</code> ุตุฏุง ูโุฒูุฏ ู ฺฉ ุขุฑุงู ุงุฒ ุขุฑฺฏููุงูโูุง ุจู ุขู ูโุฏูุฏ. ุงฺฏุฑ ููุน ฺฉ ุงุฒ ุขุฑฺฏููุงูโูุง ุงุดุชุจุงู ุจุงุดุฏุ ฺฉ <strong>exception</strong> ุฏุฑ ุฒูุงู ุงุฌุฑุง ุฑุฎ ุฎูุงูุฏ ุฏุงุฏ. ุจุง ูุฑุงุฎูุงู ูพูุงุ ุงูู ููุน ุฏุฑ ุฒูุงู ฺฉุงููพุงู ุฑุง ุงุฒ ุฏุณุช ูโุฏูุฏุ ุงูุง ููฺูุงู ุงูู ููุน ุฏุฑ ุฒูุงู ุงุฌุฑุง ุฑุง ุฏุงุฑุฏ (ุฏููุงู ูุซู ุงุณุชูุงุฏู ุงุฒ ฺฉูุฏูุงฺูโ <code>dynamic</code>).</p>
<hr>
<h3>ูพุงุฑุงูุชุฑูุง ูุชุฏ ๐</h3>
<p>ูุฑุถ ฺฉูุฏ ุจุฎูุงูู ูุชุฏ <code>Substring</code> ุฑุดุชู ุฑุง ูพูุง ูุฑุงุฎูุงู ฺฉูู. ุฏุฑ ุญุงูุช ุนุงุฏ (static):</p>
<pre><code class="language-csharp">Console.WriteLine (&quot;stamp&quot;.Substring(2));   // &quot;amp&quot;
</code></pre>
<p>ูุนุงุฏู ูพูุง ุจุง reflection ู late binding:</p>
<pre><code class="language-csharp">Type type = typeof (string);
Type[] parameterTypes = { typeof (int) };
MethodInfo method = type.GetMethod (&quot;Substring&quot;, parameterTypes);
object[] arguments = { 2 };
object returnValue = method.Invoke (&quot;stamp&quot;, arguments);
Console.WriteLine (returnValue);   // &quot;amp&quot;
</code></pre>
<p>ุงุฒ ุขูุฌุง ฺฉู ูุชุฏ <code>Substring</code> overload ุฏุงุฑุฏุ ูุฌุจูุฑ ุดุฏู ฺฉ ุขุฑุงู ุงุฒ ููุน ูพุงุฑุงูุชุฑูุง ุจุฏูู ุชุง ูุดุฎุต ุดูุฏ ฺฉุฏุงู ูุณุฎูโ ูุชุฏ ุฑุง ูโุฎูุงูู. ุฏุฑ ุบุฑ ุงู ุตูุฑุชุ <code>GetMethod</code> ุฎุทุง <code>AmbiguousMatchException</code> ุฎูุงูุฏ ุฏุงุฏ.</p>
<p>ูุชุฏ <code>GetParameters</code> ฺฉู ุฏุฑ ฺฉูุงุณ ูพุงูโ <code>MethodBase</code> (ุจุฑุง <code>MethodInfo</code> ู <code>ConstructorInfo</code>) ุชุนุฑู ุดุฏูุ ุงุทูุงุนุงุช ูุชุงุฏุชุง ุฏุฑุจุงุฑูโ ูพุงุฑุงูุชุฑูุง ุฑุง ุจุฑูโฺฏุฑุฏุงูุฏ:</p>
<pre><code class="language-csharp">ParameterInfo[] paramList = method.GetParameters();
foreach (ParameterInfo x in paramList)
{
 Console.WriteLine (x.Name);          // startIndex
 Console.WriteLine (x.ParameterType); // System.Int32
}
</code></pre>
<hr>
<h3>ุจุฑุฎูุฑุฏ ุจุง ูพุงุฑุงูุชุฑูุง ref ู out ๐</h3>
<p>ุจุฑุง ูพุงุณ ุฏุงุฏู ูพุงุฑุงูุชุฑูุง <code>ref</code> ุง <code>out</code>ุ ุจุงุฏ ูุจู ุงุฒ ฺฏุฑูุชู ูุชุฏุ ูุชุฏ <code>MakeByRefType</code> ุฑุง ุฑู ููุน ุตุฏุง ุจุฒูุฏ. ุจุฑุง ูููููุ ุงุฌุฑุง ูพูุง ฺฉุฏ ุฒุฑ:</p>
<pre><code class="language-csharp">int x;
bool successfulParse = int.TryParse (&quot;23&quot;, out x);
</code></pre>
<p>ุจู ุดฺฉู ุฒุฑ ุฎูุงูุฏ ุจูุฏ:</p>
<pre><code class="language-csharp">object[] args = { &quot;23&quot;, 0 };
Type[] argTypes = { typeof (string), typeof (int).MakeByRefType() };
MethodInfo tryParse = typeof (int).GetMethod (&quot;TryParse&quot;, argTypes);
bool successfulParse = (bool) tryParse.Invoke (null, args);
Console.WriteLine (successfulParse + &quot; &quot; + args[1]);   // True 23
</code></pre>
<p>ููู ุฑูุด ุจุฑุง ูุฑ ุฏู ููุน <code>ref</code> ู <code>out</code> ฺฉุงุฑ ูโฺฉูุฏ.</p>
<hr>
<h3>ุจุงุฒุงุจ ู ูุฑุงุฎูุงู ูุชุฏูุง ุฌูุฑฺฉ ๐ง</h3>
<p>ฺฏุงู ูุงุฒู ุงุณุช ููฺฏุงู ูุฑุงุฎูุงู <code>GetMethod</code> ููุน ูพุงุฑุงูุชุฑูุง ุฑุง ูุดุฎุต ฺฉูู ุชุง ุจู ูุชุฏูุง overload ุชูุงุฒ ูุงุฆู ุดูู. ุงูุง ุงูฺฉุงู ูุดุฎุต ฺฉุฑุฏู <strong>ููุนโูุง ุฌูุฑฺฉ</strong> ุจูโุทูุฑ ูุณุชูู ูุฌูุฏ ูุฏุงุฑุฏ.</p>
<p>ุจุฑุง ูููููุ ฺฉูุงุณ <code>System.Linq.Enumerable</code> ุฏู overload ุจุฑุง ูุชุฏ <code>Where</code> ุฏุงุฑุฏ:</p>
<pre><code class="language-csharp">public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;
 (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);

public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;
 (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, bool&gt; predicate);
</code></pre>
<p>ุจุฑุง ุจุงุฒุงุจ ฺฉ overload ุฎุงุตุ ุจุงุฏ ูููโ ูุชุฏูุง ุฑุง ุจฺฏุฑู ู ุณูพุณ ููุฑุฏ ุฏูุฎูุงู ุฑุง ุฏุณุช ุงูุชุฎุงุจ ฺฉูู. ฺฉูุฆุฑ ุฒุฑ overload ุงูู ุฑุง ุจุฑูโฺฏุฑุฏุงูุฏ:</p>
<pre><code class="language-csharp">from m in typeof (Enumerable).GetMethods()
where m.Name == &quot;Where&quot; &amp;&amp; m.IsGenericMethod 
let parameters = m.GetParameters()
where parameters.Length == 2
let genArg = m.GetGenericArguments().First()
let enumerableOfT = typeof (IEnumerable&lt;&gt;).MakeGenericType (genArg)
let funcOfTBool = typeof (Func&lt;,&gt;).MakeGenericType (genArg, typeof (bool))
where parameters[0].ParameterType == enumerableOfT
  &amp;&amp; parameters[1].ParameterType == funcOfTBool
select m
</code></pre>
<p>ูุฑุงุฎูุงู <code>.Single()</code> ุฑู ุงู ฺฉูุฆุฑุ ุดุก <code>MethodInfo</code> ุฏุฑุณุช ุจุง ูพุงุฑุงูุชุฑูุง ููุน ุจุงุฒ (unbound) ุฑุง ุจุฑูโฺฏุฑุฏุงูุฏ. ฺฏุงู ุจุนุฏ ุจุณุชู ูพุงุฑุงูุชุฑูุง ููุน ุงุณุชุ ุจุง ุงุณุชูุงุฏู ุงุฒ <code>MakeGenericMethod</code>:</p>
<pre><code class="language-csharp">var closedMethod = unboundMethod.MakeGenericMethod (typeof (int));
</code></pre>
<p>ุฏุฑ ุงู ุญุงูุชุ ููุน <code>TSource</code> ุจุง <code>int</code> ุจุณุชู ุดุฏู ู ูโุชูุงูู <code>Enumerable.Where</code> ุฑุง ุจุง ููุจุน ุงุฒ ููุน <code>IEnumerable&lt;int&gt;</code> ู ุดุฑุท ุงุฒ ููุน <code>Func&lt;int,bool&gt;</code> ุตุฏุง ุจุฒูู:</p>
<pre><code class="language-csharp">int[] source = { 3, 4, 5, 6, 7, 8 };
Func&lt;int, bool&gt; predicate = n =&gt; n % 2 == 1;   // ููุท ุงุนุฏุงุฏ ูุฑุฏ
var query = (IEnumerable&lt;int&gt;) closedMethod.Invoke 
 (null, new object[] { source, predicate });
foreach (int element in query) Console.Write (element + &quot;|&quot;);   // 3|5|7|
</code></pre>
<hr>
<h3>ุงุณุชูุงุฏู ุงุฒ System.Linq.Expressions ๐ญ</h3>
<p>ุงฺฏุฑ ุงุฒ API ูุฑุจูุท ุจู <code>System.Linq.Expressions</code> ุจุฑุง ุณุงุฎุช ุฏุงูุงูฺฉ expressionูุง ุงุณุชูุงุฏู ฺฉูุฏ (ูุตู ธ)ุ ุฏฺฏุฑ ูุงุฒ ุจู ุงู ฺฉุงุฑูุง ุฏุณุช ุจุฑุง ูุดุฎุต ฺฉุฑุฏู ูุชุฏ ุฌูุฑฺฉ ูุฏุงุฑุฏ. ูุชุฏ <code>Expression.Call</code> overloadูุง ุฏุงุฑุฏ ฺฉู ุงุฌุงุฒู ูโุฏูุฏ ููุนโูุง ุจุณุชูโ ุฌูุฑฺฉ ุฑุง ูุดุฎุต ฺฉูุฏ:</p>
<pre><code class="language-csharp">int[] source = { 3, 4, 5, 6, 7, 8 };
Func&lt;int, bool&gt; predicate = n =&gt; n % 2 == 1;
var sourceExpr = Expression.Constant (source);
var predicateExpr = Expression.Constant (predicate);
var callExpression = Expression.Call (
 typeof (Enumerable), &quot;Where&quot;,
 new[] { typeof (int) },  // ููุน ุฌูุฑฺฉ ุจุณุชู
 sourceExpr, predicateExpr);
</code></pre>
<h3>ุงุณุชูุงุฏู ุงุฒ Delegate ุจุฑุง ุจูุจูุฏ ุนููฺฉุฑุฏ โก</h3>
<p>ูุฑุงุฎูุงูโูุง ุฏุงูุงูฺฉ ูุณุจุชุงู ฺฉูโฺฉุงุฑุขูุฏ ูุณุชูุฏ ู ูุนูููุงู overhead ุขูโูุง ุฏุฑ ูุญุฏูุฏูโ ฺูุฏ ูฺฉุฑูุซุงูู ุงุณุช. ุงฺฏุฑ ฺฉ ูุชุฏ ุฑุง ุจุงุฑูุง ุฏุฑ ฺฉ ุญููู ูุฑุงุฎูุงู ูโฺฉูุฏุ ูโุชูุงูุฏ ุงู overhead ุฑุง ุจู ุณุทุญ ูุงููุซุงูู ฺฉุงูุด ุฏูุฏุ ุจุง ุงุฌุงุฏ ฺฉ <strong>delegate ุฏุงูุงูฺฉ</strong> ฺฉู ุจู ูุชุฏ ุฏุงูุงูฺฉ ุดูุง ุงุดุงุฑู ูโฺฉูุฏ.</p>
<p>ูุซุงู ุฒุฑุ ูุชุฏ <code>Trim</code> ุฑุดุชู ุฑุง ฺฉ ูููู ุจุงุฑ ุจุฏูู overhead ูุงุจู ุชูุฌู ูุฑุงุฎูุงู ูโฺฉูุฏ:</p>
<pre><code class="language-csharp">delegate string StringToString(string s);

MethodInfo trimMethod = typeof(string).GetMethod(&quot;Trim&quot;, new Type[0]);
var trim = (StringToString) Delegate.CreateDelegate(typeof(StringToString), trimMethod);

for (int i = 0; i &lt; 1000000; i++)
    trim(&quot;test&quot;);
</code></pre>
<p>ุงู ุฑูุด ุณุฑุนโุชุฑ ุงุณุช ุฒุฑุง <strong>late binding</strong> ูพุฑูุฒูู ููุท ฺฉ ุจุงุฑ ุงุชูุงู ูโุงูุชุฏ.</p>
<hr>
<h3>ุฏุณุชุฑุณ ุจู ุงุนุถุง ุบุฑุนููู ๐</h3>
<p>ุชูุงู ูุชุฏูุง ุจุงุฒุชุงุจ ุจุฑุง ุจุฑุฑุณ metadata (ูุซู <code>GetProperty</code>, <code>GetField</code> ู ุบุฑู) overloadูุง ุฏุงุฑูุฏ ฺฉู ฺฉ <code>BindingFlags</code> ูโฺฏุฑูุฏ. ุงู enum ุจูโุนููุงู ฺฉ ููุชุฑ ุนูู ูโฺฉูุฏ ู ุงุฌุงุฒู ูโุฏูุฏ ูุนุงุฑูุง ุงูุชุฎุงุจ ูพุดโูุฑุถ ุฑุง ุชุบุฑ ุฏูุฏ. ุฑุงุฌโุชุฑู ฺฉุงุฑุจุฑุฏุ ุจุงุฒุงุจ ุงุนุถุง ุบุฑุนููู ุงุณุช (ฺฉุงุฑ ูโฺฉูุฏ ููุท ุฏุฑ ุงูพูฺฉุดูโูุง ุฏุณฺฉุชุงูพ).</p>
<p>ููููู:</p>
<pre><code class="language-csharp">class Walnut
{
    private bool cracked;
    public void Crack() { cracked = true; }
    public override string ToString() { return cracked.ToString(); }
}

Type t = typeof(Walnut);
Walnut w = new Walnut();
w.Crack();

FieldInfo f = t.GetField(&quot;cracked&quot;, BindingFlags.NonPublic | BindingFlags.Instance);
f.SetValue(w, false);

Console.WriteLine(w);   // False
</code></pre>
<p>ุฏุณุชุฑุณ ุจู ุงุนุถุง ุบุฑุนููู ุจุง reflection ูุฏุฑุชููุฏ ุงุณุชุ ุงูุง ุฎุทุฑูุงฺฉ ูู ูุณุชุ ุฒุฑุง ูโุชูุงูุฏ <strong>encapsulation</strong> ุฑุง ุฏูุฑ ุจุฒูุฏ ู ูุงุจุณุชฺฏ ุจู ูพุงุฏูโุณุงุฒ ุฏุงุฎู ุงุฌุงุฏ ฺฉูุฏ.</p>
<hr>
<h3>ููุฏููโุง ุจุฑ BindingFlags ๐ท</h3>
<p><code>BindingFlags</code> ุจุฑุง ุชุฑฺฉุจ ุจุช ุทุฑุงุญ ุดุฏู ุงุณุช. ุจุฑุง ุงูฺฉู ฺุฒ ูพุฏุง ุดูุฏุ ุจุงุฏ ฺฉ ุงุฒ ฺูุงุฑ ุชุฑฺฉุจ ุฒุฑ ุฑุง ุงูุชุฎุงุจ ฺฉูุฏ:</p>
<ul>
<li><code>BindingFlags.Public | BindingFlags.Instance</code></li>
<li><code>BindingFlags.Public | BindingFlags.Static</code></li>
<li><code>BindingFlags.NonPublic | BindingFlags.Instance</code></li>
<li><code>BindingFlags.NonPublic | BindingFlags.Static</code></li>
</ul>
<p><code>NonPublic</code> ุดุงูู internalุ protectedุ protected internal ู private ูโุดูุฏ.</p>
<p>ูุซุงู:</p>
<pre><code class="language-csharp">// ููู ุงุนุถุง public ู static
BindingFlags publicStatic = BindingFlags.Public | BindingFlags.Static;
MemberInfo[] members = typeof(object).GetMembers(publicStatic);

// ููู ุงุนุถุง nonpublic (static ู instance)
BindingFlags nonPublicBinding = BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;
members = typeof(object).GetMembers(nonPublicBinding);
</code></pre>
<p>ูพุฑฺู <code>DeclaredOnly</code> ุงุนุถุง ุงุฑุซโุจุฑ ุดุฏู ุฑุง ฺฉูุงุฑ ูโฺฏุฐุงุฑุฏุ ูฺฏุฑ ุงูฺฉู override ุดุฏู ุจุงุดูุฏ. ุงู flag ฺฉู ฺฏุฌโฺฉููุฏู ุงุณุช ุฒุฑุง <strong>ูุฌููุนู ูุชุฌู ุฑุง ูุญุฏูุฏ ูโฺฉูุฏ</strong>ุ ุฏุฑ ุญุงู ฺฉู ุจูู flagูุง ูุฌููุนู ูุชุฌู ุฑุง ฺฏุณุชุฑุด ูโุฏููุฏ.</p>
<hr>
<h3>ูุฑุงุฎูุงู ูุชุฏูุง ุฌูุฑฺฉ ๐ฏ</h3>
<p>ุดูุง ููโุชูุงูุฏ ูุณุชููุงู ูุชุฏูุง ุฌูุฑฺฉ ุฑุง Invoke ฺฉูุฏุ ูุซุงู ุฒุฑ ุฎุทุง ูโุฏูุฏ:</p>
<pre><code class="language-csharp">class Program
{
    public static T Echo&lt;T&gt;(T x) { return x; }
    static void Main()
    {
        MethodInfo echo = typeof(Program).GetMethod(&quot;Echo&quot;);
        Console.WriteLine(echo.IsGenericMethodDefinition);    // True
        echo.Invoke(null, new object[] { 123 });             // Exception
    }
}
</code></pre>
<p>ุฑุงู ุญู: ุงุจุชุฏุง ูุชุฏ <code>MakeGenericMethod</code> ุฑุง ุฑู <code>MethodInfo</code> ุตุฏุง ุจุฒูุฏ ู <strong>ููุนโูุง ุฌูุฑฺฉ ูุดุฎุต</strong> ุจุฏูุฏ. ุงู ฺฉ <code>MethodInfo</code> ุฌุฏุฏ ุจุฑูโฺฏุฑุฏุงูุฏ ฺฉู ูโุชูุงู ุขู ุฑุง ูุฑุงุฎูุงู ฺฉุฑุฏ:</p>
<pre><code class="language-csharp">MethodInfo echo = typeof(Program).GetMethod(&quot;Echo&quot;);
MethodInfo intEcho = echo.MakeGenericMethod(typeof(int));

Console.WriteLine(intEcho.IsGenericMethodDefinition);          // False
Console.WriteLine(intEcho.Invoke(null, new object[] { 3 }));   // 3
</code></pre>
<p>ฺฏุงู ูุงุฒู ุงุณุช ุชุง ฺฉ ุนุถู ุงุฒ <strong>ุฑุงุจุท ุฌูุฑฺฉ</strong> ุฑุง ูุฑุงุฎูุงู ฺฉูู ูู ูพุงุฑุงูุชุฑูุง ููุน ุขู ุชุง ุฒูุงู ุงุฌุฑุง ูุดุฎุต ูุณุชูุฏ. ุงู ููุฑุฏ ุฏุฑ ุทุฑุงุญโูุง ุงุฏูโุขู ฺฉูุงุจ ุงุณุชุ ุงูุง ุฏุฑ ุนูู ฺฉุงุฑุจุฑุฏ ุฏุงุฑุฏ.</p>
<p>ุจุฑุง ูุซุงูุ ุงฺฏุฑ ุจุฎูุงูู ูุณุฎูโุง ูุฏุฑุชููุฏุชุฑ ุงุฒ <code>ToString</code> ุจุณุงุฒู ฺฉู ูุชุงุฌ LINQ ุฑุง ูุฒ ฺฏุณุชุฑุด ุฏูุฏ:</p>
<pre><code class="language-csharp">public static string ToStringEx&lt;T&gt;(IEnumerable&lt;T&gt; sequence) { ... }
</code></pre>
<p>ุงูุง ุงู ูุญุฏูุฏ ุงุณุช. ุงฺฏุฑ <code>sequence</code> ุดุงูู ูุฌููุนูโูุง ุชู ุฏุฑ ุชู ุจุงุดุฏุ ุจุงุฏ overloadูุง ูุชุนุฏุฏ ุจุณุงุฒู ฺฉู ุนูู ูุณุช. ุฑุงู ุญู ุจูุชุฑุ ููุดุชู ูุชุฏ ุงุณุช ฺฉู <strong>ูุฑ ุดุก ุฏูุฎูุงู</strong> ุฑุง ูพุฑุฏุงุฒุด ฺฉูุฏ:</p>
<pre><code class="language-csharp">public static string ToStringEx(object value)
{
    if (value == null) return &quot;&lt;null&gt;&quot;;
    StringBuilder sb = new StringBuilder();

    if (value is IList)
        sb.AppendLine(&quot;A list with &quot; + ((IList)value).Count + &quot; items&quot;);

    // ุจุฑุฑุณ IGrouping&lt;,&gt; ุจุง reflection
    Type closedIGrouping = value.GetType().GetInterfaces()
        .Where(t =&gt; t.IsGenericType &amp;&amp;
                    t.GetGenericTypeDefinition() == typeof(IGrouping&lt;,&gt;))
        .FirstOrDefault();

    if (closedIGrouping != null)
    {
        PropertyInfo pi = closedIGrouping.GetProperty(&quot;Key&quot;);
        object key = pi.GetValue(value, null);
        sb.Append(&quot;Group with key=&quot; + key + &quot;: &quot;);
    }

    if (value is IEnumerable)
        foreach (object element in (IEnumerable)value)
            sb.Append(ToStringEx(element) + &quot; &quot;);

    if (sb.Length == 0) sb.Append(value.ToString());
    return &quot;\r\n&quot; + sb.ToString();
}
</code></pre>
<ul>
<li>ุจุฑุง <code>List&lt;&gt;</code> ูโุชูุงู ุงุฒ <code>IList</code> ุบุฑุฌูุฑฺฉ ุงุณุชูุงุฏู ฺฉุฑุฏุ ุฒุฑุง <code>List&lt;&gt;</code> ุงู ุฑุงุจุท ุฑุง ูพุงุฏูโุณุงุฒ ฺฉุฑุฏู ุงุณุช.</li>
<li>ุจุฑุง <code>IGrouping&lt;,&gt;</code> ุจุงุฏ ุงุฒ <strong>ููุน ุจุณุชู (closed generic)</strong> ุงุณุชูุงุฏู ฺฉูู ู ุณูพุณ ุจุง reflection ุนุถู <code>Key</code> ุฑุง ูุฑุงุฎูุงู ฺฉูู.</li>
</ul>
<p>ุงู ุฑูุด ูพุงุฏุงุฑ ุงุณุช ู ฺู <code>IGrouping&lt;,&gt;</code> ุจูโุตูุฑุช <strong>ุถูู</strong> ุง <strong>ุตุฑุญ</strong> ูพุงุฏูโุณุงุฒ ุดุฏู ุจุงุดุฏุ ฺฉุงุฑ ูโฺฉูุฏ.</p>
<p>ูุซุงู ุงุณุชูุงุฏู:</p>
<pre><code class="language-csharp">Console.WriteLine(ToStringEx(new List&lt;int&gt; { 5, 6, 7 }));
Console.WriteLine(ToStringEx(&quot;xyyzzz&quot;.GroupBy(c =&gt; c)));
</code></pre>
<p>ุฎุฑูุฌ:</p>
<pre><code>List of 3 items: 5 6 7
Group with key=x: x
Group with key=y: y y
Group with key=z: z z z
</code></pre>
<p>ุจุฑุง ุจุงุฒุชุงุจ ฺฉ Assembly ุจูโุตูุฑุช ุฏูุงูฺฉุ ูโุชูุงู ุงุฒ <code>GetType</code> ุง <code>GetTypes</code> ุงุณุชูุงุฏู ฺฉุฑุฏ.</p>
<p>ูุซุงู ุฏุฑุงูุช ููุน <code>Demos.TestProgram</code> ุงุฒ assembly ุฌุงุฑ:</p>
<pre><code class="language-csharp">Type t = Assembly.GetExecutingAssembly().GetType(&quot;Demos.TestProgram&quot;);
</code></pre>
<p>ุง ุงุฒ ุฑู ฺฉ ููุน ููุฌูุฏ:</p>
<pre><code class="language-csharp">typeof(Foo).Assembly.GetType(&quot;Demos.TestProgram&quot;);
</code></pre>
<p>ูุณุช ุชูุงู ุงููุงุน ุฏุฑ ฺฉ Assembly ุฎุงุฑุฌ:</p>
<pre><code class="language-csharp">Assembly a = Assembly.LoadFile(@&quot;e:\demo\mylib.dll&quot;);
foreach (Type t in a.GetTypes())
    Console.WriteLine(t);
</code></pre>
<p>ุง ุจุง <code>TypeInfo</code>:</p>
<pre><code class="language-csharp">Assembly a = typeof(Foo).GetTypeInfo().Assembly;
foreach (Type t in a.ExportedTypes)
    Console.WriteLine(t);
</code></pre>
<blockquote>
<p>ุชูุฌู: <code>GetTypes</code> ู <code>ExportedTypes</code> ููุท ุงููุงุน ุณุทุญ ุจุงูุง ุฑุง ุจุฑูโฺฏุฑุฏุงููุฏุ ุงููุงุน ุชู ุฏุฑ ุชู ุฑุง ุฎุฑ.
ูุฑุงุฎูุงู <code>GetTypes</code> ุฑู ฺฉ ุงุณูุจู ฺูุฏูุงฺูููุ ุชูุงู ููุนโูุง ุฑุง ุฏุฑ ููู ูุงฺููโูุง ุจุฑูโฺฏุฑุฏุงูุฏ. ุฏุฑ ูุชุฌูุ ูโุชูุงูุฏ ูุฌูุฏ ูุงฺููโูุง ุฑุง ูุงุฏุฏู ุจฺฏุฑุฏ ู ฺฉ ุงุณูุจู ุฑุง ุจูโุนููุงู <strong>ฺฉุงูุชูุฑ ููุนโูุง</strong> ุฏุฑ ูุธุฑ ุจฺฏุฑุฏ. ุจุง ุงู ุญุงูุ ฺฉ ููุฑุฏ ูุฌูุฏ ุฏุงุฑุฏ ฺฉู ูุงฺููโูุง ุงููุช ูพุฏุง ูโฺฉููุฏโู ุขู ุฒูุงู ุงุณุช ฺฉู ุจุง <strong>ุชูฺฉูโูุง ูุชุงุฏุชุง (metadata tokens)</strong> ฺฉุงุฑ ูโฺฉูุฏ.</p>
</blockquote>
<p>ุชูฺฉู ูุชุงุฏุชุง ฺฉ ุนุฏุฏ ุตุญุญ ุงุณุช ฺฉู ุจูโุทูุฑ ฺฉุชุง ุจู ฺฉ ููุนุ ุนุถูุ ุฑุดุชู ุง ููุจุน ุฏุฑ ูุญุฏูุฏู ฺฉ ูุงฺูู ุงุดุงุฑู ูโฺฉูุฏ. IL ุงุฒ ุชูฺฉูโูุง ูุชุงุฏุชุง ุงุณุชูุงุฏู ูโฺฉูุฏุ ุจูุงุจุฑุงู ุงฺฏุฑ ุฏุฑ ุญุงู ุชุญูู IL ูุณุชุฏุ ุจุงุฏ ุจุชูุงูุฏ ุขูโูุง ุฑุง ุญู ฺฉูุฏ. ูุชุฏูุง ูุฑุชุจุท ุฏุฑ ููุน <code>Module</code> ุชุนุฑู ุดุฏูโุงูุฏ ู ุดุงูู <code>ResolveType</code>ุ <code>ResolveMember</code>ุ <code>ResolveString</code> ู <code>ResolveSignature</code> ูโุดููุฏ. ุฏุฑ ุจุฎุด ูพุงุงู ุงู ูุตูุ ููฺฏุงู ููุดุชู <strong>disassembler</strong> ุฏูุจุงุฑู ุจู ุงู ููุถูุน ุจุงุฒูโฺฏุฑุฏู.</p>
<p>ูโุชูุงูุฏ ูุณุช ููู ูุงฺููโูุง ฺฉ ุงุณูุจู ุฑุง ุจุง ูุฑุงุฎูุงู <code>GetModules</code> ุจูโุฏุณุช ุขูุฑุฏ. ููฺูู ูโุชูุงูุฏ ุจู ูุงฺูู ุงุตู ฺฉ ุงุณูุจู ูุณุชููุงู ุงุฒ ุทุฑู ูฺฺฏ <code>ManifestModule</code> ุฏุณุชุฑุณ ุฏุงุดุชู ุจุงุดุฏ.</p>
<h3>ฺฉุงุฑ ุจุง Attributes ๐ท๏ธ</h3>
<p>CLR ุงุฌุงุฒู ูโุฏูุฏ <strong>ูุชุงุฏุชุง ุงุถุงู</strong> ุจู ููุนโูุงุ ุงุนุถุง ู ุงุณูุจูโูุง ุงุฒ ุทุฑู Attributes ูุชุตู ุดูุฏ. ุงู ูฺฉุงูุฒู ุจุงุนุซ ูโุดูุฏ ุจุฑุฎ ุงุฒ ุนููฺฉุฑุฏูุง ููู CLR (ูุงููุฏ ุดูุงุณุง ุงุณูุจู ุง marshaling ููุนโูุง ุจุฑุง ุชุนุงูู ุจุง native code) ูุฏุงุช ุดููุฏ ู Attributes ุฑุง ุจู ุจุฎุด ุฌุฏุงโูุงูพุฐุฑ ุงุฒ ุจุฑูุงูู ุชุจุฏู ูโฺฉูุฏ.</p>
<p>ฺฉ ุงุฒ ูฺฺฏโูุง ฺฉูุฏ Attributes ุงู ุงุณุช ฺฉู ุดูุง ูโุชูุงูุฏ <strong>Attributes ุฎูุฏุชุงู</strong> ุฑุง ุจููุณุฏ ู ุณูพุณ ูุงููุฏ ูุฑ Attribute ุฏฺฏุฑุ ุขูโูุง ุฑุง ุจุฑุง โุชุฒุฆูโ ฺฉ ุนูุตุฑ ฺฉุฏ ุจุง ุงุทูุงุนุงุช ุงุถุงู ุงุณุชูุงุฏู ฺฉูุฏ. ุงู ุงุทูุงุนุงุช ุงุถุงู ุฏุฑ ุงุณูุจู ูพุงู ฺฉุงููพุงู ูโุดููุฏ ู ูโุชูุงู ุขูโูุง ุฑุง ุฏุฑ ุฒูุงู ุงุฌุฑุง ุจุง ุงุณุชูุงุฏู ุงุฒ <strong>reflection</strong> ุจุงุฒุงุจ ฺฉุฑุฏ ุชุง ุณุฑูุณโูุง ุจุณุงุฒุฏ ฺฉู ุจู ุตูุฑุช <strong>ุฏฺฉูุฑุงุชูุฑ ู ุฎูุฏฺฉุงุฑ</strong> ุนูู ูโฺฉููุฏุ ูุงููุฏ <strong>ุชุณุช ูุงุญุฏ ุฎูุฏฺฉุงุฑ (automated unit testing)</strong>.</p>
<p>ุณู ููุน Attribute ูุฌูุฏ ุฏุงุฑุฏ:</p>
<ul>
<li><strong>Bit-mapped attributes</strong></li>
<li><strong>Custom attributes</strong></li>
<li><strong>Pseudocustom attributes</strong></li>
</ul>
<p>ุงุฒ ูุงู ุงูโูุงุ ุชููุง <strong>custom attributes</strong> ูุงุจู ุชูุณุนู ูุณุชูุฏ.</p>
<p>ุงุตุทูุงุญ ยซattributeยป ุจู ุชููุง ูโุชูุงูุฏ ุจู ูุฑ ุณู ููุน ุงุดุงุฑู ฺฉูุฏุ ุงูุง ุฏุฑ ุฏูุง C# ุจุดุชุฑ ุจู <strong>custom attributes</strong> ุง <strong>pseudocustom attributes</strong> ุงุดุงุฑู ุฏุงุฑุฏ.</p>
<p><strong>Bit-mapped attributes</strong> (ุงุตุทูุงุญ ูุง) ุจู ุจุชโูุง ุงุฎุชุตุงุต ุฏุฑ ูุชุงุฏุชุง ููุน ูฺฏุงุดุช ูโุดููุฏ. ุงฺฉุซุฑ ฺฉููุงุช ฺฉูุฏ modifier ุฏุฑ C#ุ ูุงููุฏ <code>public</code>ุ <code>abstract</code> ู <code>sealed</code> ุจู Bit-mapped attributes ุชุจุฏู ูโุดููุฏ. ุงู Attributes ุจุณุงุฑ ฺฉุงุฑุขูุฏ ูุณุชูุฏ ุฒุฑุง ูุถุง ฺฉู ุฏุฑ ูุชุงุฏุชุง ูุตุฑู ูโฺฉููุฏ (ูุนูููุงู ุชููุง ฺฉ ุจุช) ู CLR ูโุชูุงูุฏ ุขูโูุง ุฑุง ุจุง ฺฉูุชุฑู ุง ุจุฏูู ูฺ ูุงุณุทูโุง ูพุฏุง ฺฉูุฏ.</p>
<p>API <strong>reflection</strong> ุขูโูุง ุฑุง ุงุฒ ุทุฑู ูฺฺฏโูุง ุงุฎุชุตุงุต ุฑู <code>Type</code> (ู ุณุงุฑ ุฒุฑฺฉูุงุณโูุง <code>MemberInfo</code>) ูุงููุฏ <code>IsPublic</code>ุ <code>IsAbstract</code> ู <code>IsSealed</code> ููุงุด ูโุฏูุฏ. ูฺฺฏ <code>Attributes</code> ฺฉ <strong>enum ุจุง flag</strong> ุจุฑูโฺฏุฑุฏุงูุฏ ฺฉู ุงฺฉุซุฑ ุขูโูุง ุฑุง ุจูโุตูุฑุช ฺฉุฌุง ุชูุตู ูโฺฉูุฏ:</p>
<pre><code class="language-csharp">static void Main()
{
    TypeAttributes ta = typeof(Console).Attributes;
    MethodAttributes ma = MethodInfo.GetCurrentMethod().Attributes;
    Console.WriteLine(ta + &quot;\r\n&quot; + ma);
}
</code></pre>
<p>ูุชุฌู:</p>
<pre><code>AutoLayout, AnsiClass, Class, Public, Abstract, Sealed, BeforeFieldInit
PrivateScope, Private, Static, HideBySig
</code></pre>
<p>ุฏุฑ ููุงุจูุ <strong>custom attributes</strong> ุจู ฺฉ Blob ุฏุฑ ูุชุงุฏุชุง ุงุตู ููุน ูุชุตู ูโุดููุฏ. ููู Custom attributes ุชูุณุท ฺฉ ุฒุฑฺฉูุงุณ ุงุฒ <code>System.Attribute</code> ููุงุด ุฏุงุฏู ูโุดููุฏ ู ุจุฑุฎูุงู Bit-mapped attributesุ <strong>ูุงุจู ุชูุณุนู</strong> ูุณุชูุฏ. ุงู Blob ฺฉูุงุณ Attribute ุฑุง ุดูุงุณุง ูโฺฉูุฏ ู ููฺูู ููุงุฏุฑ ูุฑ ุขุฑฺฏููุงู ูููุนุช ุง ูุงูโฺฏุฐุงุฑโุดุฏูโุง ฺฉู ููฺฏุงู ุงุนูุงู Attribute ูุดุฎุต ุดุฏู ุฑุง ุฐุฎุฑู ูโฺฉูุฏ. Custom attributes ฺฉู ุฎูุฏุชุงู ุชุนุฑู ูโฺฉูุฏุ ุงุฒ ูุธุฑ ูุนูุงุฑ ฺฉุงููุงู ูุดุงุจู ุขูโูุง ูุณุชูุฏ ฺฉู ุฏุฑ ฺฉุชุงุจุฎุงููโูุง .NET ุชุนุฑู ุดุฏูโุงูุฏ.</p>
<p>ุฏุฑ <strong>ูุตู 4</strong> ุชูุถุญ ุฏุงุฏู ุดุฏู ุงุณุช ฺฉู ฺฺฏููู ูโุชูุงู Custom attributes ุฑุง ุจู ฺฉ ููุน ุง ุนุถู ุฏุฑ C# ูุชุตู ฺฉุฑุฏ. ูุซุงู ุฒุฑุ Attribute ุงุฒ ูพุด ุชุนุฑูโุดุฏู <code>Obsolete</code> ุฑุง ุจู ฺฉูุงุณ <code>Foo</code> ุงุนูุงู ูโฺฉูุฏ:</p>
<pre><code class="language-csharp">[Obsolete] public class Foo { ... }
</code></pre>
<p>ุงู ุจู ฺฉุงููพุงูุฑ ุฏุณุชูุฑ ูโุฏูุฏ ฺฉู ฺฉ ููููู ุงุฒ <code>ObsoleteAttribute</code> ุฑุง ุฏุฑ ูุชุงุฏุชุง <code>Foo</code> ูุฑุงุฑ ุฏูุฏุ ฺฉู ุณูพุณ ูโุชูุงู ุขู ุฑุง ุฏุฑ ุฒูุงู ุงุฌุฑุง ุจุง ูุฑุงุฎูุงู <code>GetCustomAttributes</code> ุฑู ฺฉ <code>Type</code> ุง <code>MemberInfo</code> ุจุงุฒุงุจ ฺฉุฑุฏ.</p>
<p><strong>Pseudocustom attributes</strong> ุธุงูุฑ ู ุนููฺฉุฑุฏ ุดุจู custom attributes ุงุณุชุงูุฏุงุฑุฏ ุฏุงุฑูุฏ. ุขูโูุง ุชูุณุท ฺฉ ุฒุฑฺฉูุงุณ ุงุฒ <code>System.Attribute</code> ููุงุด ุฏุงุฏู ูโุดููุฏ ู ุจู ุฑูุด ุงุณุชุงูุฏุงุฑุฏ ูุชุตู ูโุดููุฏ:</p>
<pre><code class="language-csharp">[System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]
class SystemTime { ... }
</code></pre>
<p>ุชูุงูุช ุงู ุงุณุช ฺฉู ฺฉุงููพุงูุฑ ุง CLR ุจูโุตูุฑุช ุฏุงุฎูุ Pseudocustom attributes ุฑุง ุจุง ุชุจุฏู ุขูโูุง ุจู Bit-mapped attributes ุจููู ูโฺฉูุฏ. ูููููโูุง ุดุงูู <code>StructLayout</code>ุ <code>In</code> ู <code>Out</code> ูุณุชูุฏ (ูุตู 24). Reflectionุ Pseudocustom attributes ุฑุง ุงุฒ ุทุฑู ูฺฺฏโูุง ุงุฎุชุตุงุต ูุงููุฏ <code>IsLayoutSequential</code> ููุงุด ูโุฏูุฏ ู ุฏุฑ ุจุณุงุฑ ุงุฒ ููุงุฑุฏุ ููุช <code>GetCustomAttributes</code> ูุฑุงุฎูุงู ุดูุฏุ ุจูโุนููุงู ุดุก <code>System.Attribute</code> ูุฒ ุจุฑูโฺฏุฑุฏูุฏ.</p>
<p>ุงู ุจุฏุงู ูุนูุงุณุช ฺฉู ูโุชูุงูุฏ ุชูุฑุจุงู ุชูุงูุช ุจู <strong>pseudo-</strong> ู <strong>non-pseudo custom attributes</strong> ุฑุง ูุงุฏุฏู ุจฺฏุฑุฏ (ุงุณุชุซูุง ูููุ ุฒูุงู ุงุณุช ฺฉู ุงุฒ <code>Reflection.Emit</code> ุจุฑุง ุชููุฏ ููุนโูุง ุจูโุตูุฑุช ุฏุงูุงูฺฉ ุฏุฑ ุฒูุงู ุงุฌุฑุง ุงุณุชูุงุฏู ูโฺฉูุฏุ ูฺฏุงู ฺฉูุฏ ุจู ูุตู ยซEmitting Assemblies and Typesยป ุตูุญู 841).
<strong>AttributeUsage</strong> ฺฉ Attribute ุงุณุช ฺฉู ุฑู ฺฉูุงุณโูุง Attribute ุงุนูุงู ูโุดูุฏ ู ุจู ฺฉุงููพุงูุฑ ูโฺฏูุฏ ฺฺฏููู ุจุงุฏ Attribute ูุฏู ุงุณุชูุงุฏู ุดูุฏ:</p>
<pre><code class="language-csharp">public sealed class AttributeUsageAttribute : Attribute
{
    public AttributeUsageAttribute(AttributeTargets validOn);
    public bool AllowMultiple        { get; set; }
    public bool Inherited            { get; set; }
    public AttributeTargets ValidOn  { get; }
}
</code></pre>
<ul>
<li><code>AllowMultiple</code> ูุดุฎุต ูโฺฉูุฏ ฺฉู ุขุง Attribute ุชุนุฑูโุดุฏู ูโุชูุงูุฏ ุจุด ุงุฒ ฺฉ ุจุงุฑ ุฑู ููุงู ูุฏู ุงุนูุงู ุดูุฏ ุง ุฎุฑ.</li>
<li><code>Inherited</code> ูุดุฎุต ูโฺฉูุฏ ฺฉู ุขุง Attribute ุงุนูุงูโุดุฏู ุฑู ฺฉ ฺฉูุงุณ ูพุงูุ ุจู ฺฉูุงุณโูุง ูุดุชู ูุฒ ุงุนูุงู ุดูุฏ (ุง ุฏุฑ ููุฑุฏ ูุชุฏูุงุ ุขุง Attribute ุงุนูุงูโุดุฏู ุฑู ูุชุฏ virtual ุจู ูุชุฏูุง overriding ูุฒ ููุชูู ุดูุฏ).</li>
<li><code>ValidOn</code> ูุฌููุนู ุงูุฏุงู ุฑุง ุชุนู ูโฺฉูุฏ ฺฉู Attribute ูโุชูุงูุฏ ุจู ุขูโูุง ูุชุตู ุดูุฏุ ูุงููุฏ ฺฉูุงุณโูุงุ ุงูุชุฑูุณโูุงุ Propertiesุ ูุชุฏูุงุ ูพุงุฑุงูุชุฑูุง ู ุบุฑู. ุงู ูฺฺฏ ูุฑ ุชุฑฺฉุจ ุงุฒ ููุงุฏุฑ enum <code>AttributeTargets</code> ุฑุง ูโูพุฐุฑุฏุ ฺฉู ุดุงูู ููุงุฑุฏ ุฒุฑ ุงุณุช:</li>
</ul>
<pre><code>All, Assembly, Class, Delegate, GenericParameter, Parameter,
Enum, Event, Constructor, Field, Interface, Method, Module,
Property, ReturnValue, Struct
</code></pre>
<p>ูุซุงู ุงุฒ ูุญูู ุงุณุชูุงุฏู ุชูุณุนูโุฏููุฏฺฏุงู .NET ุงุฒ <code>AttributeUsage</code> ุฑู <code>Serializable</code>:</p>
<pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Delegate |
                AttributeTargets.Enum     |
                AttributeTargets.Struct   |
                AttributeTargets.Class, Inherited = false)]
public sealed class SerializableAttribute : Attribute { }
</code></pre>
<p>ุงู ุชูุฑุจุงู ฺฉู ุชุนุฑู Attribute <code>Serializable</code> ุงุณุช. ููุดุชู ฺฉ ฺฉูุงุณ Attribute ุจุฏูู property ุง constructor ูฺูุ ุจู ููู ุณุงุฏฺฏ ุงุณุช.</p>
<h3>ุชุนุฑู Attribute ุณูุงุฑุด</h3>
<p>ุจุฑุง ุชุนุฑู Attribute ุฎูุฏุชุงู ูุฑุงุญู ุฒุฑ ุฑุง ุฏูุจุงู ฺฉูุฏ:</p>
<ol>
<li>ุงุฒ ฺฉูุงุณ <code>System.Attribute</code> ุง ฺฉ ุงุฒ ุฒุฑฺฉูุงุณโูุง ุขู ูุดุชู ุดูุฏ. ุทุจู ูุฑุงุฑุฏุงุฏุ ูุงู ฺฉูุงุณ ุจุงุฏ ุจุง <code>Attribute</code> ุฎุชู ุดูุฏุ ุงฺฏุฑฺู ุงุฌุจุงุฑ ูุณุช.</li>
<li>Attribute <code>AttributeUsage</code> ุฑุง ุงุนูุงู ฺฉูุฏ (ุชูุถุญ ุฏุงุฏู ุดุฏู ุฏุฑ ุจุฎุด ูุจู). ุงฺฏุฑ Attribute ูุงุฒ ุจู property ุง ุขุฑฺฏููุงู ูุฏุงุฑุฏุ ฺฉุงุฑ ุชูุงู ุงุณุช.</li>
<li>ฺฉ ุง ฺูุฏ constructor ุนููู ุจููุณุฏ. ูพุงุฑุงูุชุฑูุง constructorุ ูพุงุฑุงูุชุฑูุง ูููุนุช (positional) Attribute ุฑุง ุชุนุฑู ูโฺฉููุฏ ู ููฺฏุงู ุงุณุชูุงุฏู ุงุฒ Attribute ุงุฌุจุงุฑ ุฎูุงููุฏ ุจูุฏ.</li>
<li>ุจุฑุง ูุฑ ูพุงุฑุงูุชุฑ ูุงูโฺฏุฐุงุฑโุดุฏู (named parameter) ฺฉู ูโุฎูุงูุฏ ูพุดุชุจุงู ฺฉูุฏุ ฺฉ ููุฏ ุง property ุนููู ุชุนุฑู ฺฉูุฏ. ูพุงุฑุงูุชุฑูุง ูุงูโฺฏุฐุงุฑโุดุฏู ููฺฏุงู ุงุณุชูุงุฏู ุงุฒ Attribute ุงุฎุชุงุฑ ูุณุชูุฏ.</li>
</ol>
<p><strong>ููุน propertyูุง ู ูพุงุฑุงูุชุฑูุง constructor ุจุงุฏ ฺฉ ุงุฒ ููุงุฑุฏ ุฒุฑ ุจุงุดุฏ:</strong></p>
<ul>
<li>ููุน primitive ุจุณุชูโุดุฏู (sealed)ุ ูุงููุฏ <code>bool</code>ุ <code>byte</code>ุ <code>char</code>ุ <code>double</code>ุ <code>float</code>ุ <code>int</code>ุ <code>long</code>ุ <code>short</code> ุง <code>string</code></li>
<li>ููุน <code>Type</code></li>
<li>ฺฉ enum</li>
<li>ุขุฑุงู ุชฺฉโุจุนุฏ ุงุฒ ูุฑ ฺฉ ุงุฒ ููุงุฑุฏ ุจุงูุง</li>
</ul>
<p>ููฺฏุงู ุงุนูุงู Attributeุ ุจุงุฏ ุงูฺฉุงู ุงุฑุฒุงุจ <strong>static</strong> compiler ุจุฑุง ูุฑ property ุง ุขุฑฺฏููุงู constructor ูุฌูุฏ ุฏุงุดุชู ุจุงุดุฏ.</p>
<p>ูุซุงู: ฺฉ Attribute ุจุฑุง ูพุดุชุจุงู ุงุฒ ุณุณุชู <strong>ุขุฒููู ุฎูุฏฺฉุงุฑ ูุงุญุฏ (unit testing)</strong>:</p>
<pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Method)]
public sealed class TestAttribute : Attribute
{
    public int    Repetitions;
    public string FailureMessage;
    public TestAttribute() : this(1)     { }
    public TestAttribute(int repetitions) { Repetitions = repetitions; }
}
</code></pre>
<p>ู ฺฉูุงุณ <code>Foo</code> ุจุง ูุชุฏูุง ฺฉู ุจุง Test Attribute ุชุฒุฆู ุดุฏูโุงูุฏ:</p>
<pre><code class="language-csharp">class Foo
{
    [Test]
    public void Method1() { ... }

    [Test(20)]
    public void Method2() { ... }

    [Test(20, FailureMessage=&quot;Debugging Time!&quot;)]
    public void Method3() { ... }
}
</code></pre>
<p>ุฏู ุฑูุด ุงุณุชุงูุฏุงุฑุฏ ุจุฑุง ุจุงุฒุงุจ Attributes ุฏุฑ ุฒูุงู ุงุฌุฑุง ูุฌูุฏ ุฏุงุฑุฏ:</p>
<ul>
<li>ูุฑุงุฎูุงู <code>GetCustomAttributes</code> ุฑู ูุฑ ุดุก <code>Type</code> ุง <code>MemberInfo</code></li>
<li>ูุฑุงุฎูุงู <code>Attribute.GetCustomAttribute</code> ุง <code>Attribute.GetCustomAttributes</code></li>
</ul>
<p>ุงู ุฏู ูุชุฏ ุงุฎุฑ <strong>overload</strong> ุดุฏูโุงูุฏ ุชุง ูุฑ ุดุก reflection ฺฉู ุจุง ฺฉ ูุฏู Attribute ูุนุชุจุฑ ูุทุงุจูุช ุฏุงุฑุฏ (ูุงููุฏ <code>Type</code>ุ <code>Assembly</code>ุ <code>Module</code>ุ <code>MemberInfo</code> ุง <code>ParameterInfo</code>) ุฑุง ุจูพุฐุฑูุฏ.</p>
<p>ููฺูู ูโุชูุงู ุงุฒ <code>GetCustomAttributesData()</code> ุฑู ฺฉ ููุน ุง ุนุถู ุงุณุชูุงุฏู ฺฉุฑุฏ ุชุง ุงุทูุงุนุงุช Attribute ุฑุง ุจูโุฏุณุช ุขูุฑุฏ. ุชูุงูุช ุขู ุจุง <code>GetCustomAttributes()</code> ุงู ุงุณุช ฺฉู ูุณุฎู Data ุจู ุดูุง ูุดุงู ูโุฏูุฏ Attribute ฺฺฏููู ุงุฌุงุฏ ุดุฏู ุงุณุช:</p>
<ul>
<li>ฺฉุฏุงู overload ุงุฒ constructor ุงุณุชูุงุฏู ุดุฏู</li>
<li>ููุฏุงุฑ ูุฑ ุขุฑฺฏููุงู constructor ู ูพุงุฑุงูุชุฑ ูุงูโฺฏุฐุงุฑโุดุฏู</li>
</ul>
<p>ุงู ูุงุจูุช ุฒูุงู ููุฏ ุงุณุช ฺฉู ุจุฎูุงูุฏ ฺฉุฏ ุง IL ุชููุฏ ฺฉูุฏ ุชุง Attribute ุฑุง ุจู ููุงู ูุถุนุช ุจุงุฒุณุงุฒ ฺฉูุฏ (ูฺฏุงู ฺฉูุฏ ุจู ยซEmitting Type Membersยป ุตูุญู 844).</p>
<p>ูุซุงู: ููุฑุณุช ฺฉุฑุฏู ูุฑ ูุชุฏ ุฏุฑ ฺฉูุงุณ <code>Foo</code> ฺฉู ุฏุงุฑุง <code>TestAttribute</code> ุงุณุช:</p>
<pre><code class="language-csharp">foreach (MethodInfo mi in typeof(Foo).GetMethods())
{
    TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute(mi, typeof(TestAttribute));
    if (att != null)
        Console.WriteLine(&quot;Method {0} will be tested; reps={1}; msg={2}&quot;,
                          mi.Name, att.Repetitions, att.FailureMessage);
}
</code></pre>
<p>ุง ุจู ุดฺฉู ุฒุฑ:</p>
<pre><code class="language-csharp">foreach (MethodInfo mi in typeof(Foo).GetTypeInfo().DeclaredMethods)
{ ... }
</code></pre>
<p>ุฎุฑูุฌ:</p>
<pre><code>Method Method1 will be tested; reps=1; msg=
Method Method2 will be tested; reps=20; msg=
Method Method3 will be tested; reps=20; msg=Debugging Time!
</code></pre>
<p>ุจุฑุง ุชฺฉูู ูุซุงู ู ูุดุงู ุฏุงุฏู ุงูฺฉู ฺฺฏููู ูโุชูุงู ุงุฒ ุงู ุฑูุด ุจุฑุง ููุดุชู ฺฉ <strong>ุณุณุชู Unit Testing ุฎูุฏฺฉุงุฑ</strong> ุงุณุชูุงุฏู ฺฉุฑุฏุ ูุณุฎูโุง ฺฉู ูุชุฏูุง ุฑุง ูุงูุนุงู ูุฑุงุฎูุงู ูโฺฉูุฏ:</p>
<pre><code class="language-csharp">foreach (MethodInfo mi in typeof(Foo).GetMethods())
{
    TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute(mi, typeof(TestAttribute));
    if (att != null)
        for (int i = 0; i &lt; att.Repetitions; i++)
            try
            {
                mi.Invoke(new Foo(), null);  // ูุฑุงุฎูุงู ูุชุฏ ุจุฏูู ุขุฑฺฏููุงู
            }
            catch (Exception ex)
            {
                throw new Exception(&quot;Error: &quot; + att.FailureMessage, ex);
            }
}
</code></pre>
<p>ููููู ุฏฺฏุฑ: ููุฑุณุช ฺฉุฑุฏู Attributes ููุฌูุฏ ุฑู ฺฉ ููุน ูุดุฎุต:</p>
<pre><code class="language-csharp">object[] atts = Attribute.GetCustomAttributes(typeof(Test));
foreach (object att in atts) Console.WriteLine(att);

[Serializable, Obsolete]
class Test { }
</code></pre>
<p>ุฎุฑูุฌ:</p>
<pre><code>System.ObsoleteAttribute
System.SerializableAttribute
</code></pre>
<p>ูุถุง ูุงู <code>System.Reflection.Emit</code> ุดุงูู ฺฉูุงุณโูุง ุจุฑุง ุงุฌุงุฏ <strong>ูุชุงุฏุชุง ู IL ุฏุฑ ุฒูุงู ุงุฌุฑุง</strong> ุงุณุช. ุชููุฏ ฺฉุฏ ุจูโุตูุฑุช ุฏุงูุงูฺฉ ุจุฑุง ุจุฑุฎ ุงุฒ ุงููุงุน ุจุฑูุงููโููุณ ฺฉุงุฑุจุฑุฏ ุฏุงุฑุฏ. ุจูโุนููุงู ูุซุงู:</p>
<ul>
<li>API <strong>Regular Expressions</strong>ุ ฺฉู ุงููุงุน ุจูููโุดุฏู ุจุฑุง ูุฑ ุนุจุงุฑุช ููุธู ุชููุฏ ูโฺฉูุฏ.</li>
<li><strong>Entity Framework Core</strong>ุ ฺฉู ุงุฒ Reflection.Emit ุจุฑุง ุงุฌุงุฏ ฺฉูุงุณโูุง Proxy ุฌูุช ูุนุงูโุณุงุฒ <strong>Lazy Loading</strong> ุงุณุชูุงุฏู ูโฺฉูุฏ.</li>
</ul>
<h3>ุชููุฏ IL ุจุง DynamicMethod</h3>
<p>ฺฉูุงุณ <code>DynamicMethod</code> ฺฉ ุงุจุฒุงุฑ ุณุจฺฉ ุฏุฑ ูุถุง ูุงู <code>System.Reflection.Emit</code> ุจุฑุง ุงุฌุงุฏ ูุชุฏูุง ุฏุฑ ูุญุธู ุงุณุช. ุจุฑุฎูุงู <code>TypeBuilder</code>ุ ูุงุฒ ุจู ุชุนุฑู ุงุจุชุฏุง ฺฉ <strong>Assembly ุฏุงูุงูฺฉ</strong>ุ <strong>Module</strong> ู <strong>Type</strong> ุจุฑุง ูฺฏูุฏุงุฑ ูุชุฏ ูุฏุงุฑุฏ. ุงู ุจุงุนุซ ูโุดูุฏ ุจุฑุง ฺฉุงุฑูุง ุณุงุฏู ููุงุณุจ ุจุงุดุฏ ู ููฺูู ูุนุฑู ุฎูุจ ุจุฑุง Reflection.Emit ุงุฑุงุฆู ฺฉูุฏ.</p>
<p>ฺฉ <code>DynamicMethod</code> ู IL ูุฑุจูุท ุจู ุขู ููฺฏุงู ฺฉู ุฏฺฏุฑ ุจู ุขู ุงุฑุฌุงุน ูุฌูุฏ ูุฏุงุดุชู ุจุงุดุฏุ <strong>ุชูุณุท Garbage Collector ูพุงฺฉ ูโุดููุฏ</strong>. ุงู ุนู ูโุชูุงูุฏ ุจุงุฑูุง ูุชุฏ ุฏุงูุงูฺฉ ุชููุฏ ฺฉูุฏ ุจุฏูู ูพุฑ ุดุฏู ุญุงูุธู. (ุจุฑุง ุงูุฌุงู ููุงู ฺฉุงุฑ ุจุง <strong>dynamic assemblies</strong>ุ ุจุงุฏ ูพุฑฺู <code>AssemblyBuilderAccess.RunAndCollect</code> ุฑุง ููฺฏุงู ุงุฌุงุฏ Assembly ุงุนูุงู ฺฉูุฏ.)</p>
<p>ูููููโุง ุณุงุฏู ุงุฒ ุงุณุชูุงุฏู <code>DynamicMethod</code> ุจุฑุง ุงุฌุงุฏ ูุชุฏ ฺฉู <code>Hello world</code> ุฑุง ุฏุฑ ฺฉูุณูู ูโููุณุฏ:</p>
<pre><code class="language-csharp">public class Test
{
    static void Main()
    {
        var dynMeth = new DynamicMethod(&quot;Foo&quot;, null, null, typeof(Test));
        ILGenerator gen = dynMeth.GetILGenerator();
        gen.EmitWriteLine(&quot;Hello world&quot;);
        gen.Emit(OpCodes.Ret);
        dynMeth.Invoke(null, null); // Hello world
    }
}
</code></pre>
<p><code>OpCodes</code> ุดุงูู ฺฉ ููุฏ <code>static readonly</code> ุจุฑุง ูุฑ IL opcode ุงุณุช. ุจุดุชุฑ ูุงุจูุชโูุง ุงุฒ ุทุฑู ุงู opcodes ุงุฑุงุฆู ูโุดููุฏุ ุงฺฏุฑฺู <code>ILGenerator</code> ูุชุฏูุง ูฺูโุง ุจุฑุง ุชููุฏ <strong>Labels</strong>ุ <strong>ูุชุบุฑูุง ูุญู</strong> ู <strong>ูุฏุฑุช ุงุณุชุซูุงูุง</strong> ุฏุงุฑุฏ.</p>
<p>ฺฉ ูุชุฏ ููุดู ุจุง <code>OpCodes.Ret</code> ฺฉู ุจู ูุนู &quot;return&quot; ุงุณุช ุง ููุน ุฏุณุชูุฑ branching/throwing ูพุงุงู ูโุงุจุฏ. ูุชุฏ <code>EmitWriteLine</code> ุฏุฑ <code>ILGenerator</code> ฺฉ <strong>ูุงูโุจุฑ</strong> ุจุฑุง ุชููุฏ ุชุนุฏุงุฏ opcode ุณุทุญ ูพุงูโุชุฑ ุงุณุช. ูโุชูุงูู ููุงู ูุชุฌู ุฑุง ุจุง ุฌุงฺฏุฒู ุขู ุจู ุดฺฉู ุฒุฑ ุจู ุฏุณุช ุขูุฑู:</p>
<pre><code class="language-csharp">MethodInfo writeLineStr = typeof(Console).GetMethod(&quot;WriteLine&quot;, new Type[] { typeof(string) });
gen.Emit(OpCodes.Ldstr, &quot;Hello world&quot;); // ุจุงุฑฺฏุฐุงุฑ ุฑุดุชู
gen.Emit(OpCodes.Call, writeLineStr);   // ูุฑุงุฎูุงู ูุชุฏ
</code></pre>
<p>ุชูุฌู ฺฉูุฏ ฺฉู <code>typeof(Test)</code> ุฑุง ุจู ุณุงุฒูุฏู <code>DynamicMethod</code> ุฏุงุฏู. ุงู ุฏุณุชุฑุณ ูุชุฏ ุฏุงูุงูฺฉ ุจู <strong>ูุชุฏูุง ุบุฑ ุนููู</strong> ุขู ููุน ุฑุง ูุฑุงูู ูโฺฉูุฏุ ูุงููุฏ ูุซุงู ุฒุฑ:</p>
<pre><code class="language-csharp">public class Test
{
    static void Main()
    {
        var dynMeth = new DynamicMethod(&quot;Foo&quot;, null, null, typeof(Test));
        ILGenerator gen = dynMeth.GetILGenerator();
        MethodInfo privateMethod = typeof(Test).GetMethod(&quot;HelloWorld&quot;, BindingFlags.Static | BindingFlags.NonPublic);
        gen.Emit(OpCodes.Call, privateMethod); // ูุฑุงุฎูุงู HelloWorld
        gen.Emit(OpCodes.Ret);
        dynMeth.Invoke(null, null); // Hello world
    }

    static void HelloWorld() // ูุชุฏ privateุ ูู ูโุชูุงู ุขู ุฑุง ูุฑุงุฎูุงู ฺฉุฑุฏ
    {
        Console.WriteLine(&quot;Hello world&quot;);
    }
}
</code></pre>
<h3>ุฏุฑฺฉ IL ู Evaluation Stack</h3>
<p>ุฏุฑฺฉ IL ูุงุฒููุฏ <strong>ุณุฑูุงูโฺฏุฐุงุฑ ุฒูุงู ูุงุจู ุชูุฌู</strong> ุงุณุช. ุจู ุฌุง ูููุฏู ููู opcodesุ ุขุณุงูโุชุฑ ุงุณุช ฺฉู ฺฉ ุจุฑูุงูู C# ฺฉุงููพุงู ฺฉูุฏ ู ุณูพุณ IL ุขู ุฑุง ุจุฑุฑุณุ ฺฉูพ ู ุชุบุฑ ุฏูุฏ. ุงุจุฒุงุฑูุง ูุงููุฏ <strong>LINQPad</strong> IL ูุฑ ูุชุฏ ุง ูุทุนู ฺฉุฏ ุฑุง ููุงุด ูโุฏูุฏ ู ุงุจุฒุงุฑูุง ูุงููุฏ <strong>ILSpy</strong> ุจุฑุง ุจุฑุฑุณ Assemblyูุง ููุฌูุฏ ููุฏ ูุณุชูุฏ.</p>
<p>ููููู <strong>Evaluation Stack</strong> ุฏุฑ IL ูุฑฺฉุฒ ุงุณุช. ุจุฑุง ูุฑุงุฎูุงู ฺฉ ูุชุฏ ุจุง ุขุฑฺฏููุงูโูุง:</p>
<ol>
<li>ุงุจุชุฏุง ุขุฑฺฏููุงูโูุง ุฑุง ุฑู <strong>Evaluation Stack</strong> ุจุงุฑฺฏุฐุงุฑ ฺฉูุฏ.</li>
<li>ุณูพุณ ูุชุฏ ุฑุง ูุฑุงุฎูุงู ฺฉูุฏ.</li>
</ol>
<p>ูุชุฏ ููุฏุงุฑ ููุฑุฏ ูุงุฒ ุฎูุฏ ุฑุง ุงุฒ Stack ูโฺฏุฑุฏ. ูุซุงู ูุดุงุจู ุจุง ฺฉ ุนุฏุฏ ุตุญุญ:</p>
<pre><code class="language-csharp">var dynMeth = new DynamicMethod(&quot;Foo&quot;, null, null, typeof(void));
ILGenerator gen = dynMeth.GetILGenerator();
MethodInfo writeLineInt = typeof(Console).GetMethod(&quot;WriteLine&quot;, new Type[] { typeof(int) });

gen.Emit(OpCodes.Ldc_I4, 123); // ุจุงุฑฺฏุฐุงุฑ ุนุฏุฏ 4 ุจุงุช ุฑู Stack
gen.Emit(OpCodes.Call, writeLineInt);
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(null, null); // 123
</code></pre>
<p>ุจุฑุง ุฌูุน ุฏู ุนุฏุฏ: ุงุจุชุฏุง ูุฑ ุนุฏุฏ ุฑุง ุฑู Stack ุจุงุฑฺฏุฐุงุฑ ฺฉุฑุฏู ู ุณูพุณ <code>Add</code> ุฑุง ูุฑุงุฎูุงู ูโฺฉูู. <code>Add</code> ุฏู ููุฏุงุฑ ุฑุง ุงุฒ Stack ุจุฑูโุฏุงุฑุฏ ู ูุชุฌู ุฑุง ุฑู Stack ูุฑุงุฑ ูโุฏูุฏ:</p>
<pre><code class="language-csharp">gen.Emit(OpCodes.Ldc_I4, 2); // ุจุงุฑฺฏุฐุงุฑ ุนุฏุฏ 2
gen.Emit(OpCodes.Ldc_I4, 2); // ุจุงุฑฺฏุฐุงุฑ ุนุฏุฏ 2
gen.Emit(OpCodes.Add);        // ุฌูุน ุฏู ุนุฏุฏ
gen.Emit(OpCodes.Call, writeLineInt); // ููุงุด ูุชุฌู
</code></pre>
<p>ุจุฑุง ูุญุงุณุจู <code>10 / 2 + 1</code> ูโุชูุงู ฺฉ ุงุฒ ุงู ุฏู ุฑูุด ุฑุง ุงูุฌุงู ุฏุงุฏ:</p>
<pre><code class="language-csharp">gen.Emit(OpCodes.Ldc_I4, 10);
gen.Emit(OpCodes.Ldc_I4, 2);
gen.Emit(OpCodes.Div);
gen.Emit(OpCodes.Ldc_I4, 1);
gen.Emit(OpCodes.Add);
gen.Emit(OpCodes.Call, writeLineInt);
</code></pre>
<p>ุง:</p>
<pre><code class="language-csharp">gen.Emit(OpCodes.Ldc_I4, 1);
gen.Emit(OpCodes.Ldc_I4, 10);
gen.Emit(OpCodes.Ldc_I4, 2);
gen.Emit(OpCodes.Div);
gen.Emit(OpCodes.Add);
gen.Emit(OpCodes.Call, writeLineInt);
</code></pre>
<h3>ุงุฑุณุงู ุขุฑฺฏููุงูโูุง ุจู ฺฉ ูุชุฏ ุฏุงูุงูฺฉ</h3>
<p>Opcodeูุง <code>Ldarg</code> ู <code>Ldarg_XXX</code> ุขุฑฺฏููุงูโูุง <strong>ุงุฑุณุงูโุดุฏู ุจู ูุชุฏ</strong> ุฑุง ุฑู Stack ุจุงุฑฺฏุฐุงุฑ ูโฺฉููุฏ. ุจุฑุง ุจุงุฒฺฏุฑุฏุงูุฏู ฺฉ ููุฏุงุฑุ ุฏุฑ ูพุงุงู <strong>ุฏููุงู ฺฉ ููุฏุงุฑ ุฑู Stack</strong> ุจุงู ุจฺฏุฐุงุฑุฏ. ุจุฑุง ุงู ฺฉุงุฑุ ููฺฏุงู ุงุฌุงุฏ <code>DynamicMethod</code> ุจุงุฏ <strong>ููุน ุจุงุฒฺฏุดุช</strong> ู <strong>ููุน ุขุฑฺฏููุงูโูุง</strong> ุฑุง ูุดุฎุต ฺฉูุฏ.</p>
<p>ููููู ุงุฌุงุฏ ูุชุฏ ฺฉู ุฌูุน ุฏู ุนุฏุฏ ุตุญุญ ุฑุง ุจุฑูโฺฏุฑุฏุงูุฏ:</p>
<pre><code class="language-csharp">DynamicMethod dynMeth = new DynamicMethod(
    &quot;Foo&quot;,
    typeof(int),                          // ููุน ุจุงุฒฺฏุดุช = int
    new[] { typeof(int), typeof(int) },   // ููุน ูพุงุฑุงูุชุฑูุง = int, int
    typeof(void)
);

ILGenerator gen = dynMeth.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);  // ุจุงุฑฺฏุฐุงุฑ ุขุฑฺฏููุงู ุงูู ุฑู Stack
gen.Emit(OpCodes.Ldarg_1);  // ุจุงุฑฺฏุฐุงุฑ ุขุฑฺฏููุงู ุฏูู ุฑู Stack
gen.Emit(OpCodes.Add);       // ุฌูุน ุฏู ุนุฏุฏ (ูุชุฌู ุฑู Stack)
gen.Emit(OpCodes.Ret);       // ุจุงุฒฺฏุดุช ุจุง ฺฉ ููุฏุงุฑ ุฑู Stack

int result = (int)dynMeth.Invoke(null, new object[] { 3, 4 }); // 7
</code></pre>
<p>ุงฺฏุฑ ุงุฒ ููุงูู Stack ูพุฑู ูฺฉูุฏุ CLR ุงุฌุฑุง ูุชุฏ ุฑุง ุฑุฏ ูโฺฉูุฏ. ุจุฑุง ุญุฐู ฺฉ ููุฏุงุฑ ุจุฏูู ูพุฑุฏุงุฒุด ุขู ูโุชูุงู ุงุฒ <code>OpCodes.Pop</code> ุงุณุชูุงุฏู ฺฉุฑุฏ.</p>
<h3>ุงุณุชูุงุฏู ุงุฒ Delegate</h3>
<p>ุจู ุฌุง ูุฑุงุฎูุงู <code>Invoke</code>ุ ูโุชูุงู ุงุฒ ฺฉ <strong>delegate ุชุงูพโุดุฏู</strong> ุงุณุชูุงุฏู ฺฉุฑุฏ ุชุง ุฑุงุญุชโุชุฑ ฺฉุงุฑ ฺฉุฑุฏ. ูุชุฏ <code>CreateDelegate</code> ุงู ฺฉุงุฑ ุฑุง ุงูุฌุงู ูโุฏูุฏ. ุฏุฑ ูุซุงู ุจุงูุง:</p>
<pre><code class="language-csharp">var func = (Func&lt;int,int,int&gt;)dynMeth.CreateDelegate(typeof(Func&lt;int,int,int&gt;));
int result = func(3, 4);  // 7
</code></pre>
<p>ุงู ฺฉุงุฑ ููฺูู <strong>overhead ูุฑุงุฎูุงู ุฏุงูุงูฺฉ</strong> ุฑุง ุญุฐู ูโฺฉูุฏ ู ฺูุฏ ูฺฉุฑูุซุงูู ุตุฑููโุฌู ูโฺฉูุฏ.</p>
<h3>ุชุนุฑู ูุชุบุฑูุง ูุญู</h3>
<p>ุจุฑุง ุชุนุฑู ฺฉ ูุชุบุฑ ูุญู ุงุฒ <code>DeclareLocal</code> ุฑู <code>ILGenerator</code> ุงุณุชูุงุฏู ฺฉูุฏ. ุงู ูุชุฏ ฺฉ <code>LocalBuilder</code> ุจุฑูโฺฏุฑุฏุงูุฏ ฺฉู ูโุชูุงู ููุฑุงู ุจุง opcodeูุง ูุงููุฏ <code>Ldloc</code> (ุจุงุฑฺฏุฐุงุฑ ูุชุบุฑ) ุง <code>Stloc</code> (ุฐุฎุฑู ูุชุบุฑ) ุงุณุชูุงุฏู ฺฉุฑุฏ. <code>Ldloc</code> ููุฏุงุฑ ุฑุง ุฑู Stack ูโฺฏุฐุงุฑุฏ ู <code>Stloc</code> ุขู ุฑุง ุงุฒ Stack ุจุฑูโุฏุงุฑุฏ.</p>
<p>ูุซุงู ฺฉุฏ C#:</p>
<pre><code class="language-csharp">int x = 6;
int y = 7;
x *= y;
Console.WriteLine(x); // 42
</code></pre>
<p>ุงุฌุงุฏ ููุงู ฺฉุฏ ุจู ุตูุฑุช ุฏุงูุงูฺฉ:</p>
<pre><code class="language-csharp">var dynMeth = new DynamicMethod(&quot;Test&quot;, null, null, typeof(void));
ILGenerator gen = dynMeth.GetILGenerator();

LocalBuilder localX = gen.DeclareLocal(typeof(int)); // ูุชุบุฑ x
LocalBuilder localY = gen.DeclareLocal(typeof(int)); // ูุชุบุฑ y

gen.Emit(OpCodes.Ldc_I4, 6);
gen.Emit(OpCodes.Stloc, localX);

gen.Emit(OpCodes.Ldc_I4, 7);
gen.Emit(OpCodes.Stloc, localY);

gen.Emit(OpCodes.Ldloc, localX);
gen.Emit(OpCodes.Ldloc, localY);
gen.Emit(OpCodes.Mul);
gen.Emit(OpCodes.Stloc, localX);

gen.EmitWriteLine(localX);
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(null, null); // 42
</code></pre>
<h3>ุดุงุฎูโุจูุฏ (Branching) ๐</h3>
<p>ุฏุฑ ILุ ุญูููโูุง <code>while</code>ุ <code>do</code> ู <code>for</code> ูุฌูุฏ ูุฏุงุฑูุฏุ ููู ุจุง <strong>Labels</strong> ู opcodeูุง ูุดุงุจู <code>goto</code> ู ุดุฑุท ุงูุฌุงู ูโุดูุฏ:</p>
<ul>
<li><code>Br</code>: ุดุงุฎู ุจุฏูู ุดุฑุท</li>
<li><code>Brtrue</code>: ุดุงุฎู ุงฺฏุฑ ููุฏุงุฑ ุฑู Stack ุฏุฑุณุช ุจุงุดุฏ</li>
<li><code>Blt</code>: ุดุงุฎู ุงฺฏุฑ ููุฏุงุฑ ุงูู ฺฉูุชุฑ ุงุฒ ููุฏุงุฑ ุฏูู ุจุงุดุฏ</li>
</ul>
<p>ุจุฑุง ุงุฌุงุฏ ฺฉ ุดุงุฎู:</p>
<ol>
<li>ุจุง <code>DefineLabel</code> ฺฉ Label ุชุนุฑู ฺฉูุฏ.</li>
<li>ุจุง <code>MarkLabel</code> ูฺฉุงู Label ุฑุง ูุดุฎุต ฺฉูุฏ.</li>
</ol>
<p>ูุซุงู ุญููู <code>while</code> ุฏุฑ C#:</p>
<pre><code class="language-csharp">int x = 5;
while (x &lt;= 10) Console.WriteLine(x++);
</code></pre>
<p>ุงุฌุงุฏ ููุงู ุญููู ุจู ุตูุฑุช IL:</p>
<pre><code class="language-csharp">ILGenerator gen = ...;
Label startLoop = gen.DefineLabel();
Label endLoop = gen.DefineLabel();

LocalBuilder x = gen.DeclareLocal(typeof(int));

gen.Emit(OpCodes.Ldc_I4, 5);
gen.Emit(OpCodes.Stloc, x);

gen.MarkLabel(startLoop);

gen.Emit(OpCodes.Ldc_I4, 10);
gen.Emit(OpCodes.Ldloc, x);
gen.Emit(OpCodes.Blt, endLoop); // if (x &gt; 10) goto endLoop

gen.EmitWriteLine(x);

gen.Emit(OpCodes.Ldloc, x);
gen.Emit(OpCodes.Ldc_I4, 1);
gen.Emit(OpCodes.Add);
gen.Emit(OpCodes.Stloc, x);

gen.Emit(OpCodes.Br, startLoop);
gen.MarkLabel(endLoop);

gen.Emit(OpCodes.Ret);
</code></pre>
<h3>ุณุงุฎุช ุงุดุงุก</h3>
<p>ูุนุงุฏู IL ุจุฑุง <code>new</code>ุ opcode <strong>Newobj</strong> ุงุณุช. ุงู opcode ฺฉ <strong>constructor</strong> ูโฺฏุฑุฏ ู ุดุก ุณุงุฎุชูโุดุฏู ุฑุง ุฑู <strong>evaluation stack</strong> ูุฑุงุฑ ูโุฏูุฏ.</p>
<p>ูุซุงู: ุณุงุฎุช ฺฉ <code>StringBuilder</code> ุฏุงูุงูฺฉ</p>
<pre><code class="language-csharp">var dynMeth = new DynamicMethod(&quot;Test&quot;, null, null, typeof(void));
ILGenerator gen = dynMeth.GetILGenerator();

ConstructorInfo ci = typeof(StringBuilder).GetConstructor(new Type[0]);
gen.Emit(OpCodes.Newobj, ci);
</code></pre>
<h3>ูุฑุงุฎูุงู ูุชุฏูุง ููููู</h3>
<p>ูพุณ ุงุฒ ูุฑุงุฑ ุฏุงุฏู ุดุก ุฑู <strong>stack</strong>ุ ูโุชูุงูุฏ ุจุง opcodeูุง <strong>Call</strong> ุง <strong>Callvirt</strong> ูุชุฏูุง ููููู ุขู ุฑุง ูุฑุงุฎูุงู ฺฉูุฏ.</p>
<p>ูุซุงู: ฺฏุฑูุชู ููุฏุงุฑ <code>MaxCapacity</code> ู ููุดุชู ุขู ุฑู ฺฉูุณูู</p>
<pre><code class="language-csharp">gen.Emit(OpCodes.Callvirt, typeof(StringBuilder)
                           .GetProperty(&quot;MaxCapacity&quot;).GetGetMethod());
gen.Emit(OpCodes.Call, typeof(Console).GetMethod(&quot;WriteLine&quot;, new[] { typeof(int) }));
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(null, null);  // 2147483647
</code></pre>
<ul>
<li><strong>Call</strong> ุจุฑุง ูุฑุงุฎูุงู ูุชุฏูุง static ู ูุชุฏูุง ููููู ููุน ููุฏุงุฑ (value type)</li>
<li><strong>Callvirt</strong> ุจุฑุง ูุฑุงุฎูุงู ูุชุฏูุง ููููู ููุน ูุฑุฌุน (reference type) ุญุช ุงฺฏุฑ virtual ูุจุงุดูุฏ</li>
</ul>
<p>ุงุณุชูุงุฏู ุงุฒ <code>Callvirt</code> ููุดู ุงูู ุงุณุชุ ฺูู ุจุฑุฑุณ ูโฺฉูุฏ ฺฉู ุดุก null ูุจุงุดุฏ ู ุฎุทุฑ ูุฑุงุฎูุงู ุงุดุชุจุงู ูุชุฏูุง virtual ุฑุง ฺฉุงูุด ูโุฏูุฏ.</p>
<h3>ููููู ูพุดุฑูุชู ุจุง ูพุงุฑุงูุชุฑูุง</h3>
<p>ุณุงุฎุช ฺฉ <code>StringBuilder</code> ุจุง ุฏู ูพุงุฑุงูุชุฑุ ุงูุญุงู ุฑุดุชู ู ุชุจุฏู ุจู ุฑุดุชู:</p>
<pre><code class="language-csharp">ConstructorInfo ci = typeof(StringBuilder).GetConstructor(new[] { typeof(string), typeof(int) });

gen.Emit(OpCodes.Ldstr, &quot;Hello&quot;);
gen.Emit(OpCodes.Ldc_I4, 1000);
gen.Emit(OpCodes.Newobj, ci);

Type[] strT = { typeof(string) };
gen.Emit(OpCodes.Ldstr, &quot;, world!&quot;);
gen.Emit(OpCodes.Call, typeof(StringBuilder).GetMethod(&quot;Append&quot;, strT));
gen.Emit(OpCodes.Callvirt, typeof(object).GetMethod(&quot;ToString&quot;));
gen.Emit(OpCodes.Call, typeof(Console).GetMethod(&quot;WriteLine&quot;, strT));
gen.Emit(OpCodes.Ret);

dynMeth.Invoke(null, null);  // Hello, world!
</code></pre>
<p>ุชูุฌู: ุงฺฏุฑ ุจูโุทูุฑ ุบุฑvirtual ูุชุฏ <code>ToString</code> ุงุฒ ููุน <code>object</code> ุฑุง ูุฑุงุฎูุงู ูโฺฉุฑุฏูุ ูุชุฌู <code>System.Text.StringBuilder</code> ูโุดุฏ ู ุจุงุฒููุณ <code>ToString</code> ูุงุฏุฏู ฺฏุฑูุชู ูโุดุฏ.</p>
<h3>ูุฏุฑุช ุงุณุชุซูุงูุง (Exception Handling) โ๏ธ</h3>
<p>ILGenerator ูุชุฏูุง ูุฎุตูุต ูุฏุฑุช ุงุณุชุซูุง ุฏุงุฑุฏ. ูุซุงู ูุนุงุฏู IL ุจุฑุง ฺฉุฏ C# ุฒุฑ:</p>
<pre><code class="language-csharp">try { throw new NotSupportedException(); }
catch (NotSupportedException ex) { Console.WriteLine(ex.Message); }
finally { Console.WriteLine(&quot;Finally&quot;); }
</code></pre>
<p>ูุนุงุฏู IL:</p>
<pre><code class="language-csharp">MethodInfo getMessageProp = typeof(NotSupportedException)
                           .GetProperty(&quot;Message&quot;).GetGetMethod();
MethodInfo writeLineString = typeof(Console).GetMethod(&quot;WriteLine&quot;, new[] { typeof(object) });

gen.BeginExceptionBlock();

ConstructorInfo ci = typeof(NotSupportedException).GetConstructor(new Type[0]);
gen.Emit(OpCodes.Newobj, ci);
gen.Emit(OpCodes.Throw);

gen.BeginCatchBlock(typeof(NotSupportedException));
gen.Emit(OpCodes.Callvirt, getMessageProp);
gen.Emit(OpCodes.Call, writeLineString);

gen.BeginFinallyBlock();
gen.EmitWriteLine(&quot;Finally&quot;);
gen.EndExceptionBlock();
</code></pre>
<ul>
<li>ูโุชูุงูุฏ ฺูุฏ catch block ุชุนุฑู ฺฉูุฏ.</li>
<li>ุจุฑุง ูพุฑุชุงุจ ูุฌุฏุฏ ููุงู ุงุณุชุซูุง ุงุฒ opcode <code>Rethrow</code> ุงุณุชูุงุฏู ูโุดูุฏ.</li>
<li>ูุชุฏ ฺฉูฺฉ <code>ThrowException</code> ููุท ุจุง <strong>MethodBuilder</strong> ฺฉุงุฑ ูโฺฉูุฏ ู ุฏุฑ DynamicMethod ฺฉุงุฑุจุฑุฏ ูุฏุงุฑุฏ.</li>
</ul>
<p>ุงฺฏุฑฺู <strong>DynamicMethod</strong> ุจุณุงุฑ ุฑุงุญุช ุงุณุชุ ุงูุง ููุท ูุงุฏุฑ ุจู ุชููุฏ <strong>ูุชุฏูุง</strong>ุณุช. ุจุฑุง ุงุฌุงุฏ ูุฑ ุณุงุฎุชุงุฑ ุฏฺฏุฑ ุง ฺฉ <strong>Type ฺฉุงูู</strong>ุ ุจุงุฏ ุงุฒ API โุณูฺฏูโ <strong>Reflection.Emit</strong> ุงุณุชูุงุฏู ฺฉูุฏ. ุงู ุนู ุณุงุฎุช ฺฉ <strong>assembly</strong> ู <strong>module</strong> ุฏุงูุงูฺฉ.</p>
<p>ุชูุฌู: assembly ุฏุงูุงูฺฉ ูุงุฒ ุจู ูุฌูุฏ ุฑู ุฏุณฺฉ ูุฏุงุฑุฏ ู ุฏุฑ .NET 5+ ู .NET Core ููโุชูุงู ุขู ุฑุง ุฐุฎุฑู ฺฉุฑุฏ.</p>
<h3>ุณุงุฎุช Assembly ู Module</h3>
<p>ุจุฑุง ุงุฌุงุฏ ฺฉ ููุน ุฏุงูุงูฺฉุ ุงุจุชุฏุง ุจุงุฏ <strong>assembly</strong> ู <strong>module</strong> ุจุณุงุฒู:</p>
<pre><code class="language-csharp">AssemblyName aname = new AssemblyName(&quot;MyDynamicAssembly&quot;);
AssemblyBuilder assemBuilder =
    AssemblyBuilder.DefineDynamicAssembly(aname, AssemblyBuilderAccess.Run);
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule(&quot;DynModule&quot;);
</code></pre>
<ul>
<li>ููโุชูุงู ฺฉ type ุฑุง ุจู assembly ููุฌูุฏ ุงุถุงูู ฺฉุฑุฏุ ุฒุฑุง <strong>assembly ูพุณ ุงุฒ ุงุฌุงุฏุ ุชุบุฑูุงูพุฐุฑ ุงุณุช</strong>.</li>
<li>assemblyูุง ุฏุงูุงูฺฉ ูุนูููุงู ุชูุณุท <strong>garbage collector</strong> ูพุงฺฉ ููโุดููุฏ ู ุชุง ูพุงุงู ูุฑุขูุฏ ุฏุฑ ุญุงูุธู ูโูุงููุฏุ ูฺฏุฑ ุงูฺฉู ููฺฏุงู ุชุนุฑูุ ฺฏุฒูู <strong>AssemblyBuilderAccess.RunAndCollect</strong> ุฑุง ุงุณุชูุงุฏู ฺฉูุฏ.</li>
</ul>
<h3>ุงุฌุงุฏ ฺฉ Type ุฏุงูุงูฺฉ</h3>
<p>ูพุณ ุงุฒ ุฏุงุดุชู moduleุ ูโุชูุงู ุจุง <strong>TypeBuilder</strong> ฺฉ type ุงุฌุงุฏ ฺฉุฑุฏ:</p>
<pre><code class="language-csharp">TypeBuilder tb = modBuilder.DefineType(&quot;Widget&quot;, TypeAttributes.Public);
</code></pre>
<p>ูฺฺฏโูุง <code>TypeAttributes</code> ุดุงูู <strong>modifierูุง CLR</strong>ุ <strong>visibility member flags</strong> ู modifierูุง ูุงููุฏ <code>Abstract</code>ุ <code>Sealed</code> ู <code>Interface</code> ุงุณุช. ููฺูู <code>Serializable</code> ูุนุงุฏู [Serializable] ุฏุฑ C# ู <code>Explicit</code> ูุนุงุฏู [StructLayout(LayoutKind.Explicit)] ุงุณุช. ุณุงุฑ attributeูุง ุฑุง ุฏุฑ ุจุฎุด โAttaching Attributesโ ุชูุถุญ ุฎูุงูู ุฏุงุฏ.</p>
<p>ููฺูู ูโุชูุงู base type ุงุฎุชุงุฑ ูุดุฎุต ฺฉุฑุฏ:</p>
<ul>
<li>ุจุฑุง struct: <code>System.ValueType</code></li>
<li>ุจุฑุง delegate: <code>System.MulticastDelegate</code></li>
<li>ุจุฑุง interface: ุขุฑุงูโุง ุงุฒ interfaceูุง</li>
<li>ุจุฑุง ุชุนุฑู interface: <code>TypeAttributes.Interface | TypeAttributes.Abstract</code></li>
</ul>
<p>ุชุนุฑู delegate ูุงุฒููุฏ ูุฑุงุญู ุงุถุงู ุงุณุช (ุฑุฌูุน ุจู ููุงูู Joel Pobar: โCreating delegate types via Reflection.Emitโ).</p>
<h3>ุงุฌุงุฏ ูุชุฏ ุฏุฑ Type</h3>
<p>ูโุชูุงู ุงุนุถุง ุฑุง ุฏุงุฎู type ุงุฌุงุฏ ฺฉุฑุฏ:</p>
<pre><code class="language-csharp">MethodBuilder methBuilder = tb.DefineMethod(&quot;SayHello&quot;,
                                             MethodAttributes.Public,
                                             null, null);
ILGenerator gen = methBuilder.GetILGenerator();
gen.EmitWriteLine(&quot;Hello world&quot;);
gen.Emit(OpCodes.Ret);
</code></pre>
<h3>ููุงโุณุงุฒ Type</h3>
<pre><code class="language-csharp">Type t = tb.CreateType();  // ููุง ฺฉุฑุฏู Type
</code></pre>
<p>ูพุณ ุงุฒ ุงุฌุงุฏ Typeุ ูโุชูุงู ุงุฒ <strong>reflection ูุนููู</strong> ุจุฑุง ุจุงุฒุฑุณ ู <strong>late binding</strong> ุงุณุชูุงุฏู ฺฉุฑุฏ:</p>
<pre><code class="language-csharp">object o = Activator.CreateInstance(t);
t.GetMethod(&quot;SayHello&quot;).Invoke(o, null);  // Hello world
</code></pre>
<h3>ูุฏู ุดุก Reflection.Emit</h3>
<p>ูุฑ ููุน ุฏุฑ <strong>System.Reflection.Emit</strong> ูุนุงุฏู ฺฉ ุณุงุฎุชุงุฑ CLR ุงุณุช ู ูพุงู ุขู ุฏุฑ <strong>System.Reflection</strong> ุชุนุฑู ุดุฏู. ุงู ุงูฺฉุงู ุฑุง ูโุฏูุฏ ฺฉู ุงุฒ constructs ุฏุงูุงูฺฉ ุจู ุฌุง constructs ูุนููู ููฺฏุงู ุณุงุฎุช type ุงุณุชูุงุฏู ฺฉูุฏ.</p>
<p>ูุซุงู: ูุฑุงุฎูุงู ูุชุฏ ุฏุงูุงูฺฉ ุจู ุฌุง MethodInfo ูุนููู:</p>
<pre><code class="language-csharp">MethodInfo writeLine = typeof(Console).GetMethod(&quot;WriteLine&quot;, new Type[] { typeof(string) });
gen.Emit(OpCodes.Call, writeLine);
</code></pre>
<p>ุจุง ุงุณุชูุงุฏู ุงุฒ <strong>MethodBuilder</strong> ูุฒ ูโุชูุงู ูุชุฏ ุฏุงูุงูฺฉ ุฏฺฏุฑ ุฑุง ูุฑุงุฎูุงู ฺฉุฑุฏุ ฺฉู ุจุฑุง ุงุฌุงุฏ ุชุนุงูู ุจู ูุชุฏูุง ุฏุงูุงูฺฉ ุฏุฑ ฺฉ type ุถุฑูุฑ ุงุณุช.</p>
<div align="center">
<p><img src="../../../assets/image/18/Table-18-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>ูฺฉุชู ููู ุฏุฑุจุงุฑู CreateType</h3>
<p>ูพุณ ุงุฒ ุชฺฉูู ุชุนุฑู ฺฉ <strong>TypeBuilder</strong>ุ ุจุงุฏ <strong>CreateType</strong> ุฑุง ูุฑุงุฎูุงู ฺฉูุฏ. ุงู ฺฉุงุฑ ุจุงุนุซ ูโุดูุฏ:</p>
<ul>
<li>TypeBuilder ู ุชูุงู ุงุนุถุงุด <strong>seal</strong> ุดููุฏ (ุฏฺฏุฑ ููโุชูุงู ฺุฒ ุงุถุงูู ุง ุชุบุฑ ุฏุงุฏ).</li>
<li>ฺฉ <strong>Type ูุงูุน</strong> ุจุฑฺฏุฑุฏุงูุฏู ุดูุฏ ฺฉู ุจุชูุงู ุขู ุฑุง instantiate ฺฉุฑุฏ.</li>
</ul>
<p>ูุจู ุงุฒ ูุฑุงุฎูุงู <strong>CreateType</strong>ุ TypeBuilder ุฏุฑ ุญุงูุช ยซuncreatedยป ุงุณุช ู ูุญุฏูุฏุชโูุง ุฒุงุฏ ุฏุงุฑุฏ:</p>
<ul>
<li>ููโุชูุงู ูุชุฏูุง ูุงููุฏ <code>GetMembers</code>ุ <code>GetMethod</code> ุง <code>GetProperty</code> ุฑุง ุฑู ุขู ูุฑุงุฎูุงู ฺฉุฑุฏุ ฺูู ุจุงุนุซ ุงุฌุงุฏ Exception ูโุดููุฏ.</li>
<li>ุงฺฏุฑ ูโุฎูุงูุฏ ุจู ุงุนุถุง ฺฉ type ุณุงุฎุชู ูุดุฏู ุงุดุงุฑู ฺฉูุฏุ ุจุงุฏ ุงุฒ <strong>MethodBuilder ุง FieldBuilder ุงุตู</strong> ุงุณุชูุงุฏู ฺฉูุฏ:</li>
</ul>
<pre><code class="language-csharp">TypeBuilder tb = ...
MethodBuilder method1 = tb.DefineMethod(&quot;Method1&quot;, ...);
MethodBuilder method2 = tb.DefineMethod(&quot;Method2&quot;, ...);
ILGenerator gen1 = method1.GetILGenerator();

// ูุฑุงุฎูุงู ุฏุฑุณุช
gen1.Emit(OpCodes.Call, method2);

// ูุฑุงุฎูุงู ุงุดุชุจุงู (ุฑู TypeBuilder ูุงูุนุชุจุฑ)
gen1.Emit(OpCodes.Call, tb.GetMethod(&quot;Method2&quot;));  // Wrong
</code></pre>
<p>ูพุณ ุงุฒ <code>CreateType</code>ุ ูโุชูุงู ุฑู <strong>Type ูุงูุน</strong> ู ุญุช <strong>TypeBuilder ุงููู</strong> ุจุงุฒุชุงุจ (reflect) ู instantiate ุงูุฌุงู ุฏุงุฏ. TypeBuilder ุจูโููุน ุจู proxy ุจุฑุง Type ูุงูุน ุชุจุฏู ูโุดูุฏ.</p>
<hr>
<h3>ุงุฌุงุฏ ูุชุฏูุง ุจุง TypeBuilder</h3>
<p>ูุฑุถ ฺฉูุฏ ฺฉ <strong>TypeBuilder</strong> ุฏุงุฑู:</p>
<pre><code class="language-csharp">AssemblyName aname = new AssemblyName(&quot;MyEmissions&quot;);
AssemblyBuilder assemBuilder = AssemblyBuilder.DefineDynamicAssembly(aname, AssemblyBuilderAccess.Run);
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule(&quot;MainModule&quot;);
TypeBuilder tb = modBuilder.DefineType(&quot;Widget&quot;, TypeAttributes.Public);
</code></pre>
<p>ุจุฑุง ุงุฌุงุฏ ฺฉ ูุชุฏ ูุงููุฏ:</p>
<pre><code class="language-csharp">public static double SquareRoot(double value) =&gt; Math.Sqrt(value);
</code></pre>
<p>ุงุฒ <strong>DefineMethod</strong> ู ILGenerator ุงุณุชูุงุฏู ูโฺฉูู:</p>
<pre><code class="language-csharp">MethodBuilder mb = tb.DefineMethod(
    &quot;SquareRoot&quot;,
    MethodAttributes.Static | MethodAttributes.Public,
    CallingConventions.Standard,
    typeof(double),                // Return type
    new[] { typeof(double) }       // Parameter types
);

mb.DefineParameter(1, ParameterAttributes.None, &quot;value&quot;); // Assign name
ILGenerator gen = mb.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);                                // Load first arg
gen.Emit(OpCodes.Call, typeof(Math).GetMethod(&quot;Sqrt&quot;));   
gen.Emit(OpCodes.Ret);

Type realType = tb.CreateType();
double x = (double)tb.GetMethod(&quot;SquareRoot&quot;).Invoke(null, new object[] { 10.0 });
Console.WriteLine(x);  // 3.16227766016838
</code></pre>
<ul>
<li>ูุฑุงุฎูุงู <strong>DefineParameter</strong> ุงุฎุชุงุฑ ุงุณุช ู ููุท ุจุฑุง ุฏุงุฏู ูุงู ุจู ูพุงุฑุงูุชุฑ ุงุณุชูุงุฏู ูโุดูุฏ (<code>__p1</code>, <code>__p2</code> ุจูโุตูุฑุช ูพุดโูุฑุถ).</li>
<li><strong>ParameterBuilder</strong> ุจุฑูโฺฏุฑุฏุงูุฏ ฺฉู ูโุชูุงู ุจุง <code>SetCustomAttribute</code> ุจู ุขู attribute ุงุถุงูู ฺฉุฑุฏ.</li>
</ul>
<hr>
<h3>ูพุงุฑุงูุชุฑูุง ูุฑุฌุน (ref)</h3>
<p>ุจุฑุง ูุชุฏ ุจุง ูพุงุฑุงูุชุฑ <strong>ref</strong>ุ ุงุฒ <code>MakeByRefType()</code> ุงุณุชูุงุฏู ูโฺฉูู:</p>
<pre><code class="language-csharp">MethodBuilder mb = tb.DefineMethod(
    &quot;SquareRoot&quot;,
    MethodAttributes.Static | MethodAttributes.Public,
    CallingConventions.Standard,
    null,
    new Type[] { typeof(double).MakeByRefType() }
);

mb.DefineParameter(1, ParameterAttributes.None, &quot;value&quot;);
ILGenerator gen = mb.GetILGenerator();

gen.Emit(OpCodes.Ldarg_0);
gen.Emit(OpCodes.Ldarg_0);
gen.Emit(OpCodes.Ldind_R8);
gen.Emit(OpCodes.Call, typeof(Math).GetMethod(&quot;Sqrt&quot;));
gen.Emit(OpCodes.Stind_R8);
gen.Emit(OpCodes.Ret);

Type realType = tb.CreateType();
object[] args = { 10.0 };
tb.GetMethod(&quot;SquareRoot&quot;).Invoke(null, args);
Console.WriteLine(args[0]);  // 3.16227766016838
</code></pre>
<ul>
<li><code>Ldind</code> ู <code>Stind</code> ุจู ูุนู <strong>load/store indirectly</strong> ูุณุชูุฏ ู <code>R8</code> ูุฑุจูุท ุจู <strong>ุนุฏุฏ ุดูุงูุฑ 8 ุจุงุช</strong> ุงุณุช.</li>
</ul>
<p>ุจุฑุง <strong>out parameters</strong> ูุฒ ุฑููุฏ ูุดุงุจู ุงุณุชุ ุชููุง ุชูุงูุช ุงู ุงุณุช ฺฉู ููฺฏุงู <code>DefineParameter</code> ุงุฒ <code>ParameterAttributes.Out</code> ุงุณุชูุงุฏู ูโฺฉูุฏ.</p>
<h3>ูุชุฏูุง ููููู (Instance Methods)</h3>
<p>ุจุฑุง ุงุฌุงุฏ ฺฉ ูุชุฏ ูููููุ ููฺฏุงู ูุฑุงุฎูุงู <strong>DefineMethod</strong> ุงุฒ <code>MethodAttributes.Instance</code> ุงุณุชูุงุฏู ฺฉูุฏ:</p>
<pre><code class="language-csharp">MethodBuilder mb = tb.DefineMethod(
    &quot;SquareRoot&quot;,
    MethodAttributes.Instance | MethodAttributes.Public,
    typeof(double),
    new[] { typeof(double) }
);
</code></pre>
<p>ูฺฉุงุช ููู:</p>
<ul>
<li>ุฏุฑ ูุชุฏูุง ูููููุ <strong>argument ุตูุฑ (Ldarg_0)</strong> ุจู <code>this</code> ุงุดุงุฑู ุฏุงุฑุฏ.</li>
<li>ุขุฑฺฏููุงูโูุง ูุงูุน ุงุฒ <strong>1 ุดุฑูุน ูโุดููุฏ</strong> (<code>Ldarg_1</code> ุงููู ูพุงุฑุงูุชุฑ ูุงูุน ุฑุง ุจุงุฑฺฏุฐุงุฑ ูโฺฉูุฏ).</li>
</ul>
<hr>
<h3>ุจุงุฒุชุนุฑู ูุชุฏูุง (Overriding)</h3>
<p>ุจุฑุง override ฺฉ ูุชุฏ ูุฌุงุฒ ุฏุฑ ฺฉูุงุณ ูพุงู:</p>
<ul>
<li>ูุชุฏ ุจุง <strong>ููุงู ูุงูุ ุงูุถุง ู ููุน ุจุงุฒฺฏุดุช</strong> ุชุนุฑู ฺฉูุฏ ู <code>MethodAttributes.Virtual</code> ุฑุง ุงุถุงูู ฺฉูุฏ.</li>
<li>ุจุฑุง ูพุงุฏูโุณุงุฒ ูุชุฏูุง interfaceุ ุฑูุด ูุดุงุจู ุงุนูุงู ูโุดูุฏ.</li>
<li>ุงฺฏุฑ ูโุฎูุงูุฏ ฺฉ ูุชุฏ ุจุง ูุงู ูุชูุงูุช override ุดูุฏ (ูุนูููุงู ุจุฑุง explicit interface implementation)ุ ุงุฒ <code>DefineMethodOverride</code> ุงุณุชูุงุฏู ฺฉูุฏ.</li>
</ul>
<h3>HideBySig</h3>
<p>ููฺฏุงู subclassing ุจูุชุฑ ุงุณุช <code>MethodAttributes.HideBySig</code> ุฑุง ุงุถุงูู ฺฉูุฏ:</p>
<ul>
<li>ุชุถูู ูโฺฉูุฏ ฺฉู <strong>ููุท ูุชุฏ ุจุง ุงูุถุง ฺฉุณุงู</strong> ุฏุฑ subtypeุ ูุชุฏ base ุฑุง ูุฎู ฺฉูุฏ.</li>
<li>ุจุฏูู ุงูุ ุชููุง ูุงู ูุชุฏ ุจุฑุฑุณ ูโุดูุฏ ู ููฺฉู ุงุณุช ุฑูุชุงุฑ ูุงุฎูุงุณุชู ุงุฌุงุฏ ุดูุฏ.</li>
</ul>
<hr>
<h3>ุงุฌุงุฏ ููุฏูุง</h3>
<p>ุจุฑุง ุชุนุฑู ููุฏ ุงุฒ <strong>DefineField</strong> ุงุณุชูุงุฏู ฺฉูุฏ:</p>
<pre><code class="language-csharp">FieldBuilder field = tb.DefineField(
    &quot;_text&quot;,
    typeof(string),
    FieldAttributes.Private
);
</code></pre>
<hr>
<h3>ุงุฌุงุฏ Properties</h3>
<p>ุจุฑุง ุงุฌุงุฏ ฺฉ property:</p>
<ol>
<li><strong>DefineProperty</strong> ุฑู TypeBuilder ูุฑุงุฎูุงู ูโฺฉูู:</li>
</ol>
<pre><code class="language-csharp">PropertyBuilder prop = tb.DefineProperty(
    &quot;Text&quot;,                     // ูุงู property
    PropertyAttributes.None,
    typeof(string),             // ููุน property
    new Type[0]                 // ููุน ุงูุฏฺฉุณ (ุจุฑุง indexer)
);
</code></pre>
<ol start="2">
<li>ุงุฌุงุฏ ูุชุฏูุง get ู set:</li>
</ol>
<pre><code class="language-csharp">// Getter
MethodBuilder getter = tb.DefineMethod(
    &quot;get_Text&quot;,
    MethodAttributes.Public | MethodAttributes.SpecialName,
    typeof(string),
    new Type[0]
);
ILGenerator getGen = getter.GetILGenerator();
getGen.Emit(OpCodes.Ldarg_0);
getGen.Emit(OpCodes.Ldfld, field);
getGen.Emit(OpCodes.Ret);

// Setter
MethodBuilder setter = tb.DefineMethod(
    &quot;set_Text&quot;,
    MethodAttributes.Assembly | MethodAttributes.SpecialName,
    null,
    new Type[] { typeof(string) }
);
ILGenerator setGen = setter.GetILGenerator();
setGen.Emit(OpCodes.Ldarg_0);
setGen.Emit(OpCodes.Ldarg_1);
setGen.Emit(OpCodes.Stfld, field);
setGen.Emit(OpCodes.Ret);

// ุงุชุตุงู ูุชุฏูุง ุจู property
prop.SetGetMethod(getter);
prop.SetSetMethod(setter);
</code></pre>
<ol start="3">
<li>ุชุณุช property:</li>
</ol>
<pre><code class="language-csharp">Type t = tb.CreateType();
object o = Activator.CreateInstance(t);
t.GetProperty(&quot;Text&quot;).SetValue(o, &quot;Good emissions!&quot;, null);
string text = (string)t.GetProperty(&quot;Text&quot;).GetValue(o, null);
Console.WriteLine(text);  // Good emissions!
</code></pre>
<p>ูฺฉุงุช:</p>
<ul>
<li><code>SpecialName</code> ุจุงุนุซ ูโุดูุฏ ุงู ูุชุฏูุง ุจู ุตูุฑุช ูุณุชูู ุฏุฑ ฺฉุงููพุงูุฑ ูุงุจู ุฏุณุชุฑุณ ูุจุงุดูุฏ ู ุชูุณุท ุงุจุฒุงุฑูุง reflection ู IntelliSense ุจู ุฏุฑุณุช ุดูุงุณุง ุดููุฏ.</li>
</ul>
<hr>
<h3>Events</h3>
<ul>
<li>ุจุฑุง ุงุฌุงุฏ eventsุ ุงุฒ <code>DefineEvent</code> ุฑู TypeBuilder ุงุณุชูุงุฏู ฺฉูุฏ.</li>
<li>ุณูพุณ ูุชุฏูุง add ู remove ุฑุง ููุดุชู ู ุจุง <code>SetAddOnMethod</code> ู <code>SetRemoveOnMethod</code> ุจู EventBuilder ูุชุตู ฺฉูุฏ.</li>
</ul>
<h3>ุชููุฏ ุณุงุฒูุฏูโูุง ๐๏ธ</h3>
<p>ูโุชูุงูุฏ ุณุงุฒูุฏูโูุง ุฏูุฎูุงู ุฎูุฏ ุฑุง ุจุง ูุฑุงุฎูุงู <strong>DefineConstructor</strong> ุฑู ฺฉ <strong>TypeBuilder</strong> ุชุนุฑู ฺฉูุฏ. ูุงุฒู ูุณุช ุญุชูุงู ุงู ฺฉุงุฑ ุฑุง ุงูุฌุงู ุฏูุฏโุงฺฏุฑ ุงู ฺฉุงุฑ ุฑุง ูฺฉูุฏุ ฺฉ ุณุงุฒูุฏูโ ูพุดโูุฑุถ ุจุฏูู ูพุงุฑุงูุชุฑ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑ ุงุฑุงุฆู ูโุดูุฏ. ุณุงุฒูุฏูโ ูพุดโูุฑุถุ ุณุงุฒูุฏูโ ฺฉูุงุณ ูพุงู ุฑุง ูุฑุงุฎูุงู ูโฺฉูุฏ (ุงฺฏุฑ ุงุฒ ฺฉ ฺฉูุงุณ ุฏฺฏุฑ ุงุฑุซโุจุฑ ูโฺฉูุฏ)ุ ุฏููุงู ูุงููุฏ C#. ุงูุง ุงฺฏุฑ ฺฉ ุง ฺูุฏ ุณุงุฒูุฏู ุชุนุฑู ฺฉูุฏุ ุงู ุณุงุฒูุฏูโ ูพุดโูุฑุถ ุฌุงฺฏุฒู ูโุดูุฏ.</p>
<p>ุงฺฏุฑ ูุงุฒ ุฏุงุฑุฏ ููุฏูุง ุฑุง ููุฏุงุฑุฏู ุงููู ฺฉูุฏุ ุณุงุฒูุฏู ุจูุชุฑู ูฺฉุงู ุจุฑุง ุงู ฺฉุงุฑ ุงุณุช. ุฏุฑ ูุงูุนุ ุชููุง ูฺฉุงู ููุงุณุจ ููู ุงุณุชุ ุฒุฑุง <strong>Field Initializers</strong> ุฏุฑ C# ูพุดุชุจุงู ูฺูโุง ุฏุฑ CLR ูุฏุงุฑูุฏโุขููุง ุตุฑูุงู ฺฉ ูุงูโุจุฑ ูุญู ุจุฑุง ููุฏุงุฑุฏู ุจู ููุฏูุง ุฏุฑ ุณุงุฒูุฏู ูุณุชูุฏ.</p>
<p>ูุซูุงู ุจุฑุง ุชููุฏ ูุนุงุฏู ุฒุฑ:</p>
<pre><code class="language-csharp">class Widget
{
    int _capacity = 4000;
}
</code></pre>
<p>ูโุชูุงู ฺฉ ุณุงุฒูุฏู ุจู ุงู ุดฺฉู ุชุนุฑู ฺฉุฑุฏ:</p>
<pre><code class="language-csharp">FieldBuilder field = tb.DefineField(&quot;_capacity&quot;, typeof(int), FieldAttributes.Private);

ConstructorBuilder c = tb.DefineConstructor(
    MethodAttributes.Public,
    CallingConventions.Standard,
    new Type[0]   // ูพุงุฑุงูุชุฑูุง ุณุงุฒูุฏู
);

ILGenerator gen = c.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);        // ุจุงุฑฺฏุฐุงุฑ &quot;this&quot; ุฑู ุงุณุชฺฉ ุงุฑุฒุงุจ
gen.Emit(OpCodes.Ldc_I4, 4000);   // ุจุงุฑฺฏุฐุงุฑ ุนุฏุฏ 4000 ุฑู ุงุณุชฺฉ
gen.Emit(OpCodes.Stfld, field);   // ุฐุฎุฑู ููุฏุงุฑ ุฏุฑ ููุฏ
gen.Emit(OpCodes.Ret);            // ุจุงุฒฺฏุดุช
</code></pre>
<hr>
<h3>ูุฑุงุฎูุงู ุณุงุฒูุฏูโูุง ูพุงู ๐๏ธ</h3>
<p>ุงฺฏุฑ ุงุฒ ฺฉ ฺฉูุงุณ ุฏฺฏุฑ ุงุฑุซโุจุฑ ูโฺฉูุฏุ ุณุงุฒูุฏูโุง ฺฉู ุชุนุฑู ฺฉุฑุฏูุ <strong>ุณุงุฒูุฏูโ ฺฉูุงุณ ูพุงู ุฑุง ูุงุฏุฏู ูโฺฏุฑุฏ</strong>. ุงู ุจุฑุฎูุงู C# ุงุณุชุ ฺฉู ุณุงุฒูุฏูโ ฺฉูุงุณ ูพุงู ููุดู ูุฑุงุฎูุงู ูโุดูุฏ (ูุณุชููุงู ุง ุบุฑูุณุชูู).</p>
<p>ูุซุงู ุฏุฑ C#:</p>
<pre><code class="language-csharp">class A { public A() { Console.Write(&quot;A&quot;); } }
class B : A { public B() {} }
</code></pre>
<p>ฺฉุงููพุงูุฑ ุฏุฑ ูุงูุน ุฎุท ุฏูู ุฑุง ุจู ุดฺฉู ุฒุฑ ุชุฑุฌูู ูโฺฉูุฏ:</p>
<pre><code class="language-csharp">class B : A { public B() : base() {} }
</code></pre>
<p>ุฏุฑ IL ุชููุฏุ ุดูุง <strong>ุจุงุฏ ุจูโุตูุฑุช ุตุฑุญ ุณุงุฒูุฏูโ ูพุงู ุฑุง ูุฑุงุฎูุงู ฺฉูุฏ</strong> ุชุง ุงุฌุฑุง ุดูุฏ (ฺฉู ุชูุฑุจุงู ููุดู ูโุฎูุงูุฏ ุงู ฺฉุงุฑ ุงูุฌุงู ุดูุฏ). ูุฑุถ ฺฉูุฏ ฺฉูุงุณ ูพุงู <strong>A</strong> ุงุณุชุ ูโุชูุงูุฏ ุงูโฺฏููู ุนูู ฺฉูุฏ:</p>
<pre><code class="language-csharp">gen.Emit(OpCodes.Ldarg_0);
ConstructorInfo baseConstr = typeof(A).GetConstructor(new Type[0]);
gen.Emit(OpCodes.Call, baseConstr);
</code></pre>
<p>ูุฑุงุฎูุงู ุณุงุฒูุฏูโูุง ุจุง ูพุงุฑุงูุชุฑ ูุฒ ุฏููุงู ูุดุงุจู ูุชุฏูุง ุงุณุช. ๐ฏ</p>
<hr>
<h3>ุงูุญุงู ูฺฺฏโูุง (Attributes) ๐ท๏ธ</h3>
<p>ูโุชูุงูุฏ <strong>Custom Attribute</strong>ูุง ุฑุง ุจู ฺฉ ุณุงุฒูโ ุฏุงูุงูฺฉ ุงุถุงูู ฺฉูุฏ ุจุง ูุฑุงุฎูุงู <strong>SetCustomAttribute</strong> ู ุงุณุชูุงุฏู ุงุฒ <strong>CustomAttributeBuilder</strong>.</p>
<p>ูุซูุงู ุงฺฏุฑ ุจุฎูุงูู ูฺฺฏ ุฒุฑ ุฑุง ุจู ฺฉ ููุฏ ุง ูพุฑุงูพุฑุช ุงุถุงูู ฺฉูู:</p>
<pre><code class="language-csharp">[XmlElement(&quot;FirstName&quot;, Namespace=&quot;http://test/&quot;, Order=3)]
</code></pre>
<p>ุงู ูฺฺฏ ุงุฒ ุณุงุฒูุฏูโ <strong>XmlElementAttribute</strong> ฺฉู ฺฉ ุฑุดุชู ูโูพุฐุฑุฏ ุงุณุชูุงุฏู ูโฺฉูุฏ. ุจุฑุง ุงุณุชูุงุฏู ุงุฒ <strong>CustomAttributeBuilder</strong>ุ ุงุจุชุฏุง ุจุงุฏ ุณุงุฒูุฏู ู ููฺูู ุฏู ูพุฑุงูพุฑุช ุงุถุงู ฺฉู ูโุฎูุงูู ููุฏุงุฑุฏู ฺฉูู (<strong>Namespace</strong> ู <strong>Order</strong>) ุฑุง ุจุงุฒุงุจ ฺฉูู:</p>
<pre><code class="language-csharp">Type attType = typeof(XmlElementAttribute);
ConstructorInfo attConstructor = attType.GetConstructor(new Type[] { typeof(string) });

var att = new CustomAttributeBuilder(
    attConstructor,                 // ุณุงุฒูุฏู
    new object[] { &quot;FirstName&quot; },   // ุขุฑฺฏููุงูโูุง ุณุงุฒูุฏู
    new PropertyInfo[] 
    {
        attType.GetProperty(&quot;Namespace&quot;),  // ูพุฑุงูพุฑุชโูุง
        attType.GetProperty(&quot;Order&quot;)
    },
    new object[] { &quot;http://test/&quot;, 3 }    // ููุงุฏุฑ ูพุฑุงูพุฑุช
);

myFieldBuilder.SetCustomAttribute(att);
// ุง
// propBuilder.SetCustomAttribute(att);
// ุง
// typeBuilder.SetCustomAttribute(att);  ู ุบุฑู
</code></pre>
<p>ุงู ุฑูุด ุจู ุดูุง ุงูฺฉุงู ูโุฏูุฏ ูฺฺฏโูุง ุฑุง ุจู ุตูุฑุช ุฏุงูุงูฺฉ ุจู ููุฏูุงุ ูพุฑุงูพุฑุชโูุง ู ุฎูุฏ ููุนโูุง ุงุถุงูู ฺฉูุฏ. ๐๏ธ</p>
<h3>ุงูุชุดุงุฑ ูุชุฏูุง ู ุชุงูพโูุง ุฌูุฑฺฉ ๐งฉ</h3>
<p>ุชูุงู ูุซุงูโูุง ุงู ุจุฎุด ูุฑุถ ูโฺฉููุฏ ฺฉู <strong>modBuilder</strong> ุจู ุดฺฉู ุฒุฑ ููุฏุงุฑุฏู ุงููู ุดุฏู ุงุณุช:</p>
<pre><code class="language-csharp">AssemblyName aname = new AssemblyName(&quot;MyEmissions&quot;);
AssemblyBuilder assemBuilder = AssemblyBuilder.DefineDynamicAssembly(
    aname, AssemblyBuilderAccess.Run);
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule(&quot;MainModule&quot;);
</code></pre>
<hr>
<h4>ุชุนุฑู ูุชุฏูุง ุฌูุฑฺฉ ๐</h4>
<p>ุจุฑุง ุงูุชุดุงุฑ ฺฉ ูุชุฏ ุฌูุฑฺฉ:</p>
<ol>
<li>
<p>ุฑู <strong>MethodBuilder</strong> ุชุงุจุน <strong>DefineGenericParameters</strong> ุฑุง ูุฑุงุฎูุงู ฺฉูุฏ ุชุง ฺฉ ุขุฑุงู ุงุฒ <strong>GenericTypeParameterBuilder</strong> ุฏุฑุงูุช ฺฉูุฏ.</p>
</li>
<li>
<p>ุฑู <strong>MethodBuilder</strong> ุจุง ุงุณุชูุงุฏู ุงุฒ ุงู ูพุงุฑุงูุชุฑูุง ุฌูุฑฺฉุ <strong>SetSignature</strong> ุฑุง ูุฑุงุฎูุงู ฺฉูุฏ.</p>
</li>
<li>
<p>ุจูโุตูุฑุช ุงุฎุชุงุฑุ ูุงู ูพุงุฑุงูุชุฑูุง ุฑุง ููุงูโุทูุฑ ฺฉู ูุนูููุงู ุงูุฌุงู ูโุฏูุฏุ ุชุนู ฺฉูุฏ.</p>
</li>
</ol>
<p>ูุซุงู: ูุชุฏ ุฌูุฑฺฉ ุฒุฑ</p>
<pre><code class="language-csharp">public static T Echo&lt;T&gt;(T value)
{
    return value;
}
</code></pre>
<p>ูโุชูุงูุฏ ุจู ุดฺฉู ุฒุฑ ููุชุดุฑ ุดูุฏ:</p>
<pre><code class="language-csharp">TypeBuilder tb = modBuilder.DefineType(&quot;Widget&quot;, TypeAttributes.Public);
MethodBuilder mb = tb.DefineMethod(&quot;Echo&quot;, MethodAttributes.Public |
                                          MethodAttributes.Static);

GenericTypeParameterBuilder[] genericParams
    = mb.DefineGenericParameters(&quot;T&quot;);

mb.SetSignature(
    genericParams[0],     // ููุน ุจุงุฒฺฏุดุช
    null, null,
    genericParams,        // ููุน ูพุงุฑุงูุชุฑูุง
    null, null
);

mb.DefineParameter(1, ParameterAttributes.None, &quot;value&quot;);   // ุงุฎุชุงุฑ

ILGenerator gen = mb.GetILGenerator();
gen.Emit(OpCodes.Ldarg_0);
gen.Emit(OpCodes.Ret);
</code></pre>
<hr>
<p>ุชุงุจุน <strong>DefineGenericParameters</strong> ูุฑ ุชุนุฏุงุฏ ุขุฑฺฏููุงู ุฑุดุชูโุง ุฑุง ูโูพุฐุฑุฏโุงู ุขุฑฺฏููุงูโูุง ูุงูโูุง ููุฑุฏูุธุฑ ุจุฑุง ููุนโูุง ุฌูุฑฺฉ ูุณุชูุฏ. ุฏุฑ ุงู ูุซุงู ุชููุง ฺฉ ููุน ุฌูุฑฺฉ ุจู ูุงู <strong>T</strong> ูุงุฒ ุฏุงุดุชู.</p>
<p><strong>GenericTypeParameterBuilder</strong> ุจุฑ ูพุงู <strong>System.Type</strong> ุณุงุฎุชู ุดุฏู ุงุณุชุ ุจูุงุจุฑุงู ูโุชูุงูุฏ ุงุฒ ุขู ุจู ุฌุง <strong>TypeBuilder</strong> ููฺฏุงู ุงูุชุดุงุฑ ฺฉุฏ IL ุงุณุชูุงุฏู ฺฉูุฏ.</p>
<p>ููฺูู <strong>GenericTypeParameterBuilder</strong> ุงูฺฉุงู ุชุนู ูุญุฏูุฏุช ููุน ูพุงู ุฑุง ูุฑุงูู ูโฺฉูุฏ:</p>
<pre><code class="language-csharp">genericParams[0].SetBaseTypeConstraint(typeof(Foo));
</code></pre>
<p>ู ูุญุฏูุฏุชโูุง ุฑุงุจุทโูุง:</p>
<pre><code class="language-csharp">genericParams[0].SetInterfaceConstraints(typeof(IComparable));
</code></pre>
<p>ุจุฑุง ุจุงุฒุชููุฏ ุงู ูุชุฏ:</p>
<pre><code class="language-csharp">public static T Echo&lt;T&gt;(T value) where T : IComparable&lt;T&gt;
</code></pre>
<p>ูโุชูุงูุฏ ุจููุณุฏ:</p>
<pre><code class="language-csharp">genericParams[0].SetInterfaceConstraints(
    typeof(IComparable&lt;&gt;).MakeGenericType(genericParams[0])
);
</code></pre>
<p>ุจุฑุง ุงููุงุน ุฏฺฏุฑ ูุญุฏูุฏุชโูุงุ <strong>SetGenericParameterAttributes</strong> ุฑุง ูุฑุงุฎูุงู ฺฉูุฏ. ุงู ุชุงุจุน ฺฉ ุนุถู ุงุฒ <strong>GenericParameterAttributes</strong> ูโูพุฐุฑุฏ ฺฉู ุดุงูู ููุงุฏุฑ ุฒุฑ ุงุณุช:</p>
<ul>
<li><strong>DefaultConstructorConstraint</strong></li>
<li><strong>NotNullableValueTypeConstraint</strong></li>
<li><strong>ReferenceTypeConstraint</strong></li>
<li><strong>Covariant</strong></li>
<li><strong>Contravariant</strong></li>
</ul>
<p>ุฏู ููุฏุงุฑ ุขุฎุฑ ูุนุงุฏู ุงุณุชูุงุฏู ุงุฒ <strong>out</strong> ู <strong>in</strong> ุฑู ูพุงุฑุงูุชุฑูุง ููุน ูุณุชูุฏ. โ</p>
<h3>ุชุนุฑู ุชุงูพโูุง ุฌูุฑฺฉ ๐๏ธ</h3>
<p>ูโุชูุงูุฏ ุชุงูพโูุง ุฌูุฑฺฉ ุฑุง ุจู ุดฺฉู ูุดุงุจู ูุชุฏูุง ุชุนุฑู ฺฉูุฏ. ุชูุงูุช ุงุตู ุงู ุงุณุช ฺฉู <strong>DefineGenericParameters</strong> ุฑุง ุฑู <strong>TypeBuilder</strong> ูุฑุงุฎูุงู ูโฺฉูุฏุ ูู <strong>MethodBuilder</strong>.</p>
<p>ุจุฑุง ุจุงุฒุชููุฏ ุงู ฺฉูุงุณ:</p>
<pre><code class="language-csharp">public class Widget&lt;T&gt;
{
    public T Value;
}
</code></pre>
<p>ูโุชูุงูุฏ ุจู ุดฺฉู ุฒุฑ ุนูู ฺฉูุฏ:</p>
<pre><code class="language-csharp">TypeBuilder tb = modBuilder.DefineType(&quot;Widget&quot;, TypeAttributes.Public);
GenericTypeParameterBuilder[] genericParams
    = tb.DefineGenericParameters(&quot;T&quot;);

tb.DefineField(&quot;Value&quot;, genericParams[0], FieldAttributes.Public);
</code></pre>
<p>ูุญุฏูุฏุชโูุง ุฌูุฑฺฉ ุฑุง ูโุชูุงู ุฏููุงู ููุงููุฏ ูุชุฏูุง ุงุถุงูู ฺฉุฑุฏ. โ</p>
<hr>
<h3>ุงูุฏุงู ุงูุชุดุงุฑ ูุงูุชุนุงุฑู โ๏ธ</h3>
<p>ุชูุงู ูุซุงูโูุง ุงู ุจุฎุด ูุฑุถ ูโฺฉููุฏ ฺฉู <strong>modBuilder</strong> ููุงููุฏ ุจุฎุดโูุง ูุจู ููุฏุงุฑุฏู ุงููู ุดุฏู ุงุณุช.</p>
<hr>
<h4>ุฌูุฑฺฉโูุง ุจุณุชู ุงุฌุงุฏ ูุดุฏู</h4>
<p>ูุฑุถ ฺฉูุฏ ูโุฎูุงูุฏ ฺฉ ูุชุฏ ููุชุดุฑ ฺฉูุฏ ฺฉู ุงุฒ ฺฉ ุชุงูพ ุฌูุฑฺฉ ุจุณุชู ุงุณุชูุงุฏู ูโฺฉูุฏ:</p>
<pre><code class="language-csharp">public class Widget
{
    public static void Test() { var list = new List&lt;int&gt;(); }
}
</code></pre>
<p>ุงู ฺฉุงุฑ ูุณุจุชุงู ุณุงุฏู ุงุณุช:</p>
<pre><code class="language-csharp">TypeBuilder tb = modBuilder.DefineType(&quot;Widget&quot;, TypeAttributes.Public);
MethodBuilder mb = tb.DefineMethod(&quot;Test&quot;, MethodAttributes.Public | MethodAttributes.Static);

ILGenerator gen = mb.GetILGenerator();
Type variableType = typeof(List&lt;int&gt;);
ConstructorInfo ci = variableType.GetConstructor(new Type[0]);
LocalBuilder listVar = gen.DeclareLocal(variableType);

gen.Emit(OpCodes.Newobj, ci);
gen.Emit(OpCodes.Stloc, listVar);
gen.Emit(OpCodes.Ret);
</code></pre>
<hr>
<p>ุญุงูุง ูุฑุถ ฺฉูุฏ ุจู ุฌุง ฺฉ ูุณุช ุงุฒ ุงุนุฏุงุฏ ุตุญุญุ ูโุฎูุงูู ูุณุช ุงุฒ ูุฌุชโูุง ุฏุงุดุชู ุจุงุดู:</p>
<pre><code class="language-csharp">public class Widget
{
    public static void Test() { var list = new List&lt;Widget&gt;(); }
}
</code></pre>
<p>ุฏุฑ ุชุฆูุฑุ ุงู ุชุบุฑ ุณุงุฏู ุงุณุชุ ููุท ุฎุท ุฒุฑ ุฑุง ุฌุงฺฏุฒู ูโฺฉูู:</p>
<pre><code class="language-csharp">Type variableType = typeof(List&lt;int&gt;);
</code></pre>
<p>ุจุง ุงู ุฎุท:</p>
<pre><code class="language-csharp">Type variableType = typeof(List&lt;&gt;).MakeGenericType(tb);
</code></pre>
<p>ุงูุง ูุชุฃุณูุงูู ุงู ุจุงุนุซ ูพุฑุชุงุจ <strong>NotSupportedException</strong> ููฺฏุงู ูุฑุงุฎูุงู <strong>GetConstructor</strong> ูโุดูุฏ. ูุดฺฉู ุงู ุงุณุช ฺฉู ููโุชูุงู <strong>GetConstructor</strong> ุฑุง ุฑู ฺฉ ุชุงูพ ุฌูุฑฺฉ ุจุณุชู ุจุง <strong>TypeBuilder</strong> ุงุฌุงุฏ ูุดุฏู ูุฑุงุฎูุงู ฺฉุฑุฏ. ููู ููุถูุน ุจุฑุง <strong>GetField</strong> ู <strong>GetMethod</strong> ูุฒ ุตุงุฏู ุงุณุช.</p>
<hr>
<h4>ุฑุงู ุญู ุบุฑ ูุณุชูู ๐ก</h4>
<p><strong>TypeBuilder</strong> ุณู ูุชุฏ ุงุณุชุงุชฺฉ ุงุฑุงุฆู ูโุฏูุฏ:</p>
<pre><code class="language-csharp">public static ConstructorInfo GetConstructor(Type, ConstructorInfo);
public static FieldInfo       GetField(Type, FieldInfo);
public static MethodInfo      GetMethod(Type, MethodInfo);
</code></pre>
<p>ุงฺฏุฑฺู ุจู ูุธุฑ ููโุขุฏุ ุงู ูุชุฏูุง ุฏููุงู ุจุฑุง ฺฏุฑูุชู ุงุนุถุง ุชุงูพโูุง ุฌูุฑฺฉ ุจุณุชู ุจุง <strong>TypeBuilder</strong> ุงุฌุงุฏ ูุดุฏู ุทุฑุงุญ ุดุฏูโุงูุฏ!</p>
<p>ูพุงุฑุงูุชุฑ ุงูู: ุชุงูพ ุฌูุฑฺฉ ุจุณุชู
ูพุงุฑุงูุชุฑ ุฏูู: ุนุถู ฺฉู ูโุฎูุงูุฏ ุงุฒ ุชุงูพ ุฌูุฑฺฉ ุจุฏูู ุจุณุชู ุฏุฑุงูุช ฺฉูุฏ</p>
<p>ูุณุฎู ุงุตูุงุญโุดุฏู ูุซุงู ูุง ุจู ุดฺฉู ุฒุฑ ุงุณุช:</p>
<pre><code class="language-csharp">MethodBuilder mb = tb.DefineMethod(&quot;Test&quot;, MethodAttributes.Public | MethodAttributes.Static);
ILGenerator gen = mb.GetILGenerator();

Type variableType = typeof(List&lt;&gt;).MakeGenericType(tb);
ConstructorInfo unbound = typeof(List&lt;&gt;).GetConstructor(new Type[0]);
ConstructorInfo ci = TypeBuilder.GetConstructor(variableType, unbound);

LocalBuilder listVar = gen.DeclareLocal(variableType);
gen.Emit(OpCodes.Newobj, ci);
gen.Emit(OpCodes.Stloc, listVar);
gen.Emit(OpCodes.Ret);
</code></pre>
<h3>ูุงุจุณุชฺฏโูุง ุฏุงุฑูโุง ๐</h3>
<p>ูุฑุถ ฺฉูุฏ ูโุฎูุงูุฏ ุฏู ุชุงูพ ุจุณุงุฒุฏ ฺฉู ุจู ฺฉุฏฺฏุฑ ุงุฑุฌุงุน ุฏุงุฑูุฏุ ูุงููุฏ ุงู ูุซุงู:</p>
<pre><code class="language-csharp">class A { public B Bee; }
class B { public A Aye; }
</code></pre>
<p>ูโุชูุงูุฏ ุงู ุฑุง ุจู ุตูุฑุช ุฏุงูุงูฺฉ ุจู ุดฺฉู ุฒุฑ ุงุฌุงุฏ ฺฉูุฏ:</p>
<pre><code class="language-csharp">var publicAtt = FieldAttributes.Public;

TypeBuilder aBuilder = modBuilder.DefineType(&quot;A&quot;);
TypeBuilder bBuilder = modBuilder.DefineType(&quot;B&quot;);

FieldBuilder bee = aBuilder.DefineField(&quot;Bee&quot;, bBuilder, publicAtt);
FieldBuilder aye = bBuilder.DefineField(&quot;Aye&quot;, aBuilder, publicAtt);

Type realA = aBuilder.CreateType();
Type realB = bBuilder.CreateType();
</code></pre>
<p>ุชูุฌู ฺฉูุฏ ฺฉู ูุง <strong>ุชุง ุฒูุงู ฺฉู ูุฑ ุฏู ุชุงูพ ูพุฑ ูุดุฏูโุงูุฏุ</strong> ุฑู <strong>aBuilder</strong> ุง <strong>bBuilder</strong> ุชุงุจุน <strong>CreateType</strong> ุฑุง ูุฑุงุฎูุงู ูฺฉุฑุฏู. ุงุตู ููุถูุน ุงู ุงุณุช: ุงูู ููู ฺุฒ ุฑุง ูุชุตู ฺฉูุฏุ ุณูพุณ <strong>CreateType</strong> ุฑุง ุฑู ูุฑ <strong>TypeBuilder</strong> ูุฑุงุฎูุงู ฺฉูุฏ. โ</p>
<hr>
<p>ุฌุงูุจ ุงุณุช ุจุฏุงูุฏ ฺฉู <strong>realA</strong> ุชุง ูุจู ุงุฒ ูุฑุงุฎูุงู <strong>CreateType</strong> ุฑู <strong>bBuilder</strong> ูุนุชุจุฑ ุงูุง ุบุฑูุนุงู ุงุณุช. (ุงฺฏุฑ ูุจู ุงุฒ ุงู ุงุฒ <strong>aBuilder</strong> ุงุณุชูุงุฏู ฺฉูุฏุ ููฺฏุงู ุฏุณุชุฑุณ ุจู ููุฏ <strong>Bee</strong> ุงุณุชุซูุง ูพุฑุชุงุจ ูโุดูุฏ.)</p>
<p>ููฺฉู ุงุณุช ุจูพุฑุณุฏ ฺฺฏููู <strong>bBuilder</strong> ูโุฏุงูุฏ ฺฉู ูพุณ ุงุฒ ุงุฌุงุฏ <strong>realB</strong> ุจุงุฏ <strong>realA</strong> ุฑุง ยซุงุตูุงุญยป ฺฉูุฏ. ูพุงุณุฎ ุงู ุงุณุช ฺฉู ููโุฏุงูุฏ: <strong>realA</strong> ุฎูุฏุด ููฺฏุงู ุงุณุชูุงุฏู ุจุนุฏ ุงุตูุงุญ ูโุดูุฏ. ุงู ุงูฺฉุงูโูพุฐุฑ ุงุณุช ุฒุฑุง ูพุณ ุงุฒ ูุฑุงุฎูุงู <strong>CreateType</strong>ุ <strong>TypeBuilder</strong> ุจู ฺฉ ูพุฑูฺฉุณ ุจุฑุง ุชุงูพ ูุงูุน ุฒูุงู ุงุฌุฑุง ุชุจุฏู ูโุดูุฏ. ุจูุงุจุฑุงู <strong>realA</strong> ุจุง ุงุฑุฌุงุน ุจู <strong>bBuilder</strong> ูโุชูุงูุฏ ุจู ุฑุงุญุช ูุชุงุฏุชุง ููุฑุฏ ูุงุฒ ุจุฑุง ุงุฑุชูุง ุฑุง ุฏุฑุงูุช ฺฉูุฏ.</p>
<hr>
<p>ุงู ุณุณุชู ุฒูุงู ฺฉุงุฑ ูโฺฉูุฏ ฺฉู <strong>TypeBuilder</strong> ุชููุง ุจู ุงุทูุงุนุงุช ุณุงุฏู ุงุฒ ุชุงูพ ุงุฌุงุฏ ูุดุฏู ูุงุฒ ุฏุงุดุชู ุจุงุดุฏโุงุทูุงุนุงุช ฺฉู ุงุฒ ูุจู ูุงุจู ุชุนู ูุณุชูุฏโูุซู ููุนุ ุงุนุถุง ู ุงุฑุฌุงุนุงุช ุจู ุงุดุงุก.</p>
<p>ููฺฏุงู ุงุฌุงุฏ <strong>realA</strong>ุ <strong>TypeBuilder</strong> ูุงุฒ ุจู ุฏุงูุณุชู ุชุนุฏุงุฏ ุจุงุชโูุง ุงุดุบุงูโุดุฏู ุชูุณุท <strong>realB</strong> ุฏุฑ ุญุงูุธู ูุฏุงุฑุฏ. ุงู ุฎูุจ ุงุณุช ุฒุฑุง <strong>realB</strong> ูููุฒ ุงุฌุงุฏ ูุดุฏู ุงุณุช!</p>
<p>ุงูุง ุชุตูุฑ ฺฉูุฏ <strong>realB</strong> ฺฉ <strong>struct</strong> ุจุงุดุฏ. ุงูุฏุงุฒู ููุง <strong>realB</strong> ุงุทูุงุนุงุช ุญุงุช ุจุฑุง ุงุฌุงุฏ <strong>realA</strong> ุงุณุช.</p>
<hr>
<p>ุงฺฏุฑ ุฑุงุจุทู ุบุฑ ุฏุงุฑูโุง ุจุงุดุฏุ ุจุฑุง ูุซุงู:</p>
<pre><code class="language-csharp">struct A { public B Bee; }
struct B { }
</code></pre>
<p>ูโุชูุงู ุจุง ุงุฌุงุฏ ุงูู <strong>struct B</strong> ู ุณูพุณ <strong>struct A</strong> ูุดฺฉู ุฑุง ุญู ฺฉุฑุฏ.</p>
<p>ุงูุง ุงฺฏุฑ ุฑุงุจุทู ุฏุงุฑูโุง ุจุงุดุฏ:</p>
<pre><code class="language-csharp">struct A { public B Bee; }
struct B { public A Aye; }
</code></pre>
<p>ูุง ููโุชูุงูู ุงู ุฑุง ููุชุดุฑ ฺฉูู ุฒุฑุง ููุทู ูุณุช ฺฉู ุฏู struct ฺฉุฏฺฏุฑ ุฑุง ุดุงูู ุดููุฏ (C# ููฺฏุงู ฺฉุงููพุงู ุฎุทุง ูโุฏูุฏ).</p>
<p>ุงูุง ูุณุฎู ุฒุฑ ูู ูุงููู ู ูู ููุฏ ุงุณุช:</p>
<pre><code class="language-csharp">public struct S&lt;T&gt; { ... }    // S ูโุชูุงูุฏ ุฎุงู ุจุงุดุฏ ู ุงู ุฏูู ฺฉุงุฑ ูโฺฉูุฏ.
class A { S&lt;B&gt; Bee; }
class B { S&lt;A&gt; Aye; }
</code></pre>
<p>ุฏุฑ ุงุฌุงุฏ <strong>A</strong>ุ <strong>TypeBuilder</strong> ุงฺฉููู ุจุงุฏ ุงูุฏุงุฒู ุญุงูุธู <strong>B</strong> ุฑุง ุจุฏุงูุฏ ู ุจุงูุนฺฉุณ. ูุฑุถ ฺฉูุฏ <strong>struct S</strong> ุจู ุตูุฑุช ุงุณุชุงุชฺฉ ุชุนุฑู ุดุฏู ุจุงุดุฏ. ฺฉุฏ ุงูุชุดุงุฑ ฺฉูุงุณโูุง <strong>A</strong> ู <strong>B</strong> ุจู ุดฺฉู ุฒุฑ ุงุณุช:</p>
<pre><code class="language-csharp">var pub = FieldAttributes.Public;
TypeBuilder aBuilder = modBuilder.DefineType(&quot;A&quot;);
TypeBuilder bBuilder = modBuilder.DefineType(&quot;B&quot;);

aBuilder.DefineField(&quot;Bee&quot;, typeof(S&lt;&gt;).MakeGenericType(bBuilder), pub);
bBuilder.DefineField(&quot;Aye&quot;, typeof(S&lt;&gt;).MakeGenericType(aBuilder), pub);

Type realA = aBuilder.CreateType();    // ุฎุทุง: ููโุชูุงู ุชุงูพ B ุฑุง ุจุงุฑฺฏุฐุงุฑ ฺฉุฑุฏ
Type realB = bBuilder.CreateType();
</code></pre>
<p>ุงฺฉููู <strong>CreateType</strong> ฺฉ <strong>TypeLoadException</strong> ูพุฑุชุงุจ ูโฺฉูุฏุ ูุฑู ููโฺฉูุฏ ฺฉู ุจู ฺู ุชุฑุชุจ ุนูู ฺฉูุฏ:</p>
<ul>
<li>ุงฺฏุฑ ุงูู <strong>aBuilder.CreateType</strong> ุฑุง ูุฑุงุฎูุงู ฺฉูุฏุ ูโฺฏูุฏ ยซููโุชูุงู ุชุงูพ B ุฑุง ุจุงุฑฺฏุฐุงุฑ ฺฉุฑุฏยป.</li>
<li>ุงฺฏุฑ ุงูู <strong>bBuilder.CreateType</strong> ุฑุง ูุฑุงุฎูุงู ฺฉูุฏุ ูโฺฏูุฏ ยซููโุชูุงู ุชุงูพ A ุฑุง ุจุงุฑฺฏุฐุงุฑ ฺฉุฑุฏยป.</li>
</ul>
<hr>
<p>ุจุฑุง ุญู ุงู ูุดฺฉูุ ุจุงุฏ ุงุฌุงุฒู ุฏูุฏ <strong>TypeBuilder</strong> ููฺฏุงู ุงุฌุงุฏ <strong>realA</strong>ุ <strong>realB</strong> ุฑุง ุจู ุตูุฑุช ูููุช ุงุฌุงุฏ ฺฉูุฏ. ุงู ฺฉุงุฑ ุจุง ููุฏู ฺฉุฑุฏู ุฑูุฏุงุฏ <strong>TypeResolve</strong> ุฑู ฺฉูุงุณ <strong>AppDomain</strong> ุฏุฑุณุช ูุจู ุงุฒ ูุฑุงุฎูุงู <strong>CreateType</strong> ุงูุฌุงู ูโุดูุฏ.</p>
<p>ุฏุฑ ูุซุงู ูุงุ ุฏู ุฎุท ุขุฎุฑ ุฑุง ุจุง ุงู ฺฉุฏ ุฌุงฺฏุฒู ูโฺฉูู:</p>
<pre><code class="language-csharp">TypeBuilder[] uncreatedTypes = { aBuilder, bBuilder };

ResolveEventHandler handler = delegate(object o, ResolveEventArgs args)
{
    var type = uncreatedTypes.FirstOrDefault(t =&gt; t.FullName == args.Name);
    return type == null ? null : type.CreateType().Assembly;
};

AppDomain.CurrentDomain.TypeResolve += handler;

Type realA = aBuilder.CreateType();
Type realB = bBuilder.CreateType();

AppDomain.CurrentDomain.TypeResolve -= handler;
</code></pre>
<p>ุฑูุฏุงุฏ <strong>TypeResolve</strong> ููฺฏุงู ูุฑุงุฎูุงู <strong>aBuilder.CreateType</strong> ูุนุงู ูโุดูุฏุ ุฏุฑ ููุทูโุง ฺฉู ูุงุฒ ุงุณุช ุดูุง <strong>CreateType</strong> ุฑุง ุฑู <strong>bBuilder</strong> ูุฑุงุฎูุงู ฺฉูุฏ.</p>
<h3>ุชุฌุฒู IL ๐งฉ</h3>
<p>ูโุชูุงูุฏ ุงุทูุงุนุงุช ุฏุฑุจุงุฑู ูุญุชูุง ฺฉ ูุชุฏ ููุฌูุฏ ุจุง ูุฑุงุฎูุงู <strong>GetMethodBody</strong> ุฑู ฺฉ ุดุก <strong>MethodBase</strong> ุจู ุฏุณุช ุขูุฑุฏ. ุงู ูุชุฏ ฺฉ <strong>MethodBody</strong> ุจุงุฒูโฺฏุฑุฏุงูุฏ ฺฉู ุฏุงุฑุง ุฎุตูุตุงุช ุจุฑุง ุจุฑุฑุณ ูุชุบุฑูุง ูุญูุ ุจููฺฉโูุง ูุฏุฑุช ุงุณุชุซูุงุ ุงูุฏุงุฒู ูพุดุชู ู ููฺูู <strong>IL ุฎุงู</strong> ุงุณุช. ุชูุฑุจุงู ูุงููุฏ ูุนฺฉูุณ <strong>Reflection.Emit</strong>!</p>
<p>ุจุฑุฑุณ <strong>IL ุฎุงู</strong> ฺฉ ูุชุฏ ูโุชูุงูุฏ ุฏุฑ <strong>ูพุฑููุงููฺฏ ฺฉุฏ</strong> ููุฏ ุจุงุดุฏ. ฺฉ ุงุณุชูุงุฏู ุณุงุฏู ุขู ูโุชูุงูุฏ ุชุนู ุงู ุจุงุดุฏ ฺฉู ููฺฏุงู ุจูโุฑูุฒุฑุณุงู ฺฉ ุงุณูุจูุ ฺฉุฏุงู ูุชุฏูุง ุชุบุฑ ฺฉุฑุฏูโุงูุฏ.</p>
<p>ุจุฑุง ูุซุงูุ ูโุฎูุงูู ฺฉ ุจุฑูุงูู ุจููุณู ฺฉู <strong>IL ุฑุง ุจู ุณุจฺฉ ildasm ุฌุฏุง ฺฉูุฏ</strong>. ุงู ูโุชูุงูุฏ ููุทู ุดุฑูุน ุจุฑุง ฺฉ ุงุจุฒุงุฑ ุชุญูู ฺฉุฏ ุง <strong>ุฏุณโุงุณูุจูุฑ ุฒุจุงู ุณุทุญ ุจุงูุงุชุฑ</strong> ุจุงุดุฏ.</p>
<p>ุจู ุงุฏ ุฏุงุดุชู ุจุงุดุฏ ฺฉู ุฏุฑ <strong>Reflection API</strong>ุ ุชูุงู ุณุงุฎุชุงุฑูุง ุชุงุจุน C# ุง ุชูุณุท ฺฉ ุฒุฑฺฉูุงุณ <strong>MethodBase</strong> ููุงุด ุฏุงุฏู ูโุดููุฏ ุง (ุฏุฑ ููุฑุฏ <strong>properties</strong>ุ <strong>events</strong> ู <strong>indexers</strong>) ุจู ุขููุง ุงุดุงุก <strong>MethodBase</strong> ูุชุตู ูุณุชูุฏ.</p>
<hr>
<h3>ููุดุชู ฺฉ ุฏุณโุงุณูุจูุฑ ๐๏ธ</h3>
<p>ูููููโุง ุงุฒ ุฎุฑูุฌ ฺฉู ุฏุณโุงุณูุจูุฑ ูุง ุชููุฏ ุฎูุงูุฏ ฺฉุฑุฏ:</p>
<pre><code>IL_00EB:  ldfld        Disassembler._pos
IL_00F0:  ldloc.2
IL_00F1:  add
IL_00F2:  ldelema      System.Byte
IL_00F7:  ldstr        &quot;Hello world&quot;
IL_00FC:  call         System.Byte.ToString
IL_0101:  ldstr        &quot; &quot;
IL_0106:  call         System.String.Concat
</code></pre>
<p>ุจุฑุง ุจู ุฏุณุช ุขูุฑุฏู ุงู ุฎุฑูุฌุ ุจุงุฏ <strong>ุชูฺฉูโูุง ุจุงูุฑ ุชุดฺฉูโุฏููุฏู IL</strong> ุฑุง ุชุฌุฒู ฺฉูู.</p>
<hr>
<h4>ูุฑุญูู ุงูู: ฺฏุฑูุชู IL ุจู ุตูุฑุช ุขุฑุงู ุจุงุช</h4>
<p>ุจุฑุง ุขุณุงูโุชุฑ ฺฉุฑุฏู ฺฉุงุฑุ ุงู ุฑุง ุฏุฑ ฺฉ ฺฉูุงุณ ูโููุณู:</p>
<pre><code class="language-csharp">public class Disassembler
{
    public static string Disassemble(MethodBase method)
        =&gt; new Disassembler(method).Dis();

    StringBuilder _output;    // ุฎุฑูุฌ ฺฉู ุจู ุขู ุงุถุงูู ูโฺฉูู
    Module _module;           // ุจุนุฏุงู ุจู ฺฉุงุฑ ุฎูุงูุฏ ุขูุฏ
    byte[] _il;               // ฺฉุฏ ุจุงุช ุฎุงู
    int _pos;                 // ูููุนุช ฺฉู ุฏุฑ ฺฉุฏ ุจุงุช ูุณุชู

    Disassembler(MethodBase method)
    {
        _module = method.DeclaringType.Module;
        _il = method.GetMethodBody().GetILAsByteArray();
    }

    string Dis()
    {
        _output = new StringBuilder();
        while (_pos &lt; _il.Length) DisassembleNextInstruction();
        return _output.ToString();
    }
}
</code></pre>
<ul>
<li>ูุชุฏ ุงุณุชุงุชฺฉ <strong>Disassemble</strong> ุชููุง ุนุถู ุนููู ุงู ฺฉูุงุณ ุฎูุงูุฏ ุจูุฏ.</li>
<li>ุจูู ุงุนุถุง ุฎุตูุต ู ูุฎุชุต ูุฑุขูุฏ ุฏุณโุงุณูุจู ูุณุชูุฏ.</li>
<li>ูุชุฏ <strong>Dis</strong> ุญููู ุงุตู ุฑุง ุดุงูู ูโุดูุฏ ฺฉู ูุฑ ุฏุณุชูุฑ ุฑุง ูพุฑุฏุงุฒุด ูโฺฉูุฏ.</li>
</ul>
<hr>
<h4>ุขูุงุฏูโุณุงุฒ ุจุฑุง ุชุฌุฒู ุฏุณุชูุฑุงุช</h4>
<p>ุจุง ุงู ุณุงุฎุชุงุฑุ ุชููุง ฺฉุงุฑ ฺฉู ุจุงู ูโูุงูุฏ ููุดุชู <strong>DisassembleNextInstruction</strong> ุงุณุช.</p>
<p>ุงูุง ูุจู ุงุฒ ุขูุ ุจูุชุฑ ุงุณุช ููู <strong>opcodes</strong> ุฑุง ุฏุฑ ฺฉ ุฏฺฉุดูุฑ ุงุณุชุงุชฺฉ ุจุงุฑฺฏุฐุงุฑ ฺฉูู ุชุง ุจุชูุงูู ุจุฑ ุงุณุงุณ ููุฏุงุฑ ธ ุง ฑถ ุจุช ุจู ุขููุง ุฏุณุชุฑุณ ุฏุงุดุชู ุจุงุดู. ุณุงุฏูโุชุฑู ุฑูุดุ ุงุณุชูุงุฏู ุงุฒ <strong>Reflection</strong> ุจุฑุง ุฏุฑุงูุช ุชูุงู ููุฏูุง ุงุณุชุงุชฺฉ ุงุฒ ฺฉูุงุณ <strong>OpCodes</strong> ุงุณุช ฺฉู ููุน ุขููุง <strong>OpCode</strong> ุจุงุดุฏ:</p>
<pre><code class="language-csharp">static Dictionary&lt;short, OpCode&gt; _opcodes = new Dictionary&lt;short, OpCode&gt;();

static Disassembler()
{
    Dictionary&lt;short, OpCode&gt; opcodes = new Dictionary&lt;short, OpCode&gt;();
    foreach (FieldInfo fi in typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static))
        if (typeof(OpCode).IsAssignableFrom(fi.FieldType))
        {
            OpCode code = (OpCode)fi.GetValue(null);   // ฺฏุฑูุชู ููุฏุงุฑ ููุฏ
            if (code.OpCodeType != OpCodeType.Nternal)
                _opcodes.Add(code.Value, code);
        }
}
</code></pre>
<ul>
<li>ุงู ฺฉุงุฑ ุฏุฑ <strong>ุณุงุฒูุฏู ุงุณุชุงุชฺฉ</strong> ุงูุฌุงู ุดุฏู ุชุง ุชููุง ฺฉ ุจุงุฑ ุงุฌุฑุง ุดูุฏ. โ</li>
</ul>
<h3>ููุดุชู DisassembleNextInstruction ๐๏ธ</h3>
<p>ูุฑ ุฏุณุชูุฑ IL ุงุฒ ฺฉ <strong>opcode ฺฉ ุง ุฏู ุจุงุช</strong> ุชุดฺฉู ุดุฏู ู ูพุณ ุงุฒ ุขู ฺฉ <strong>ุนููููุฏ</strong> ุจุง ุทูู ุตูุฑุ ฺฉุ ุฏูุ ฺูุงุฑ ุง ูุดุช ุจุงุช ูโุขุฏ.
(ุงุณุชุซูุง: <strong>inline switch opcodes</strong> ฺฉู ูพุณ ุงุฒ ุขู ุชุนุฏุงุฏ ูุชุบุฑ ุงุฒ ุนููููุฏูุง ูโุขุฏ.)</p>
<p>ุงูฺฏูุฑุชู ฺฉู ุงู ุงุณุช: ุงุจุชุฏุง opcode ุฑุง ูโุฎูุงููุ ุณูพุณ ุนููููุฏ ุฑุงุ ู ุฏุฑ ููุงุช ูุชุฌู ุฑุง ูโููุณู:</p>
<pre><code class="language-csharp">void DisassembleNextInstruction()
{
    int opStart = _pos;
    OpCode code = ReadOpCode();
    string operand = ReadOperand(code);
    _output.AppendFormat(&quot;IL_{0:X4}:  {1,-12} {2}&quot;, opStart, code.Name, operand);
    _output.AppendLine();
}
</code></pre>
<hr>
<h4>ุฎูุงูุฏู ฺฉ Opcode ๐</h4>
<p>ุจุฑุง ุฎูุงูุฏู ฺฉ <strong>opcode</strong>:</p>
<ol>
<li>ฺฉ ุจุงุช ุฌูู ูโุฑูู ู ุจุฑุฑุณ ูโฺฉูู ุขุง ุฏุณุชูุฑ ูุนุชุจุฑ ุงุณุช.</li>
<li>ุงฺฏุฑ ูุจูุฏุ ฺฉ ุจุงุช ุฏฺฏุฑ ุฌูู ุฑูุชู ู ุจู ุฏูุจุงู ุฏุณุชูุฑ ุฏู ุจุงุช ูโฺฏุฑุฏู:</li>
</ol>
<pre><code class="language-csharp">OpCode ReadOpCode()
{
    byte byteCode = _il[_pos++];
    if (_opcodes.ContainsKey(byteCode)) return _opcodes[byteCode];
    if (_pos == _il.Length) throw new Exception(&quot;Unexpected end of IL&quot;);
    short shortCode = (short)(byteCode * 256 + _il[_pos++]);
    if (!_opcodes.ContainsKey(shortCode))
        throw new Exception(&quot;Cannot find opcode &quot; + shortCode);
    return _opcodes[shortCode];
}
</code></pre>
<hr>
<h4>ุฎูุงูุฏู ุนููููุฏ โ๏ธ</h4>
<p>ุงุจุชุฏุง ุจุงุฏ ุทูู ุนููููุฏ ุฑุง ุชุนู ฺฉูู. ูโุชูุงู ุงู ฺฉุงุฑ ุฑุง ุจุฑ ุงุณุงุณ <strong>ููุน ุนููููุฏ</strong> ุงูุฌุงู ุฏุงุฏ.
ฺูู ุจุดุชุฑ ุนููููุฏูุง ด ุจุงุช ุทูู ุฏุงุฑูุฏุ ุงุณุชุซูุงูุง ุจู ุฑุงุญุช ุฏุฑ ฺฉ ุดุฑุท ููุชุฑ ูโุดููุฏ.</p>
<p>ุณูพุณ ูุชุฏ <strong>FormatOperand</strong> ูุฑุงุฎูุงู ูโุดูุฏ ุชุง ุนููููุฏ ุฑุง ูุงูุจโุจูุฏ ฺฉูุฏ:</p>
<pre><code class="language-csharp">string ReadOperand(OpCode c)
{
    int operandLength =
        c.OperandType == OperandType.InlineNone ? 0 :
        c.OperandType == OperandType.ShortInlineBrTarget ||
        c.OperandType == OperandType.ShortInlineI ||
        c.OperandType == OperandType.ShortInlineVar ? 1 :
        c.OperandType == OperandType.InlineVar ? 2 :
        c.OperandType == OperandType.InlineI8 ||
        c.OperandType == OperandType.InlineR ? 8 :
        c.OperandType == OperandType.InlineSwitch ? 4 * (BitConverter.ToInt32(_il, _pos) + 1) :
        4;  // ุจูู ุนููููุฏูุง 4 ุจุงุช ูุณุชูุฏ

    if (_pos + operandLength &gt; _il.Length)
        throw new Exception(&quot;Unexpected end of IL&quot;);

    string result = FormatOperand(c, operandLength);

    if (result == null)   // ุงฺฏุฑ ูุงูุจโุจูุฏ ุฎุงุต ูุงุฒ ูุจุงุดุฏ
    {
        result = &quot;&quot;;
        for (int i = 0; i &lt; operandLength; i++)
            result += _il[_pos + i].ToString(&quot;X2&quot;) + &quot; &quot;;
    }

    _pos += operandLength;
    return result;
}
</code></pre>
<ul>
<li>ุงฺฏุฑ <strong>FormatOperand</strong> ููุฏุงุฑ <strong>null</strong> ุจุฑฺฏุฑุฏุงูุฏุ ุนู ุนููููุฏ ูุงุฒ ุจู ูุงูุจโุจูุฏ ุฎุงุต ูุฏุงุฑุฏ ู ุจู ุตูุฑุช <strong>ูฺฏุฒุงุฏุณูุงู</strong> ููุดุชู ูโุดูุฏ.</li>
</ul>
<p>ูโุชูุงู ุฏุณโุงุณูุจูุฑ ุฑุง ุฏุฑ ุงู ูุฑุญูู ุชุณุช ฺฉุฑุฏ ุจุง ฺฉ <strong>FormatOperand</strong> ฺฉู ููุดู <strong>null</strong> ุจุฑฺฏุฑุฏุงูุฏ. ุฎุฑูุฌ ุดุจู ุจู ุงู ุฎูุงูุฏ ุจูุฏ:</p>
<pre><code>IL_00A8:  ldfld        98 00 00 04
IL_00AD:  ldloc.2
IL_00AE:  add
IL_00AF:  ldelema      64 00 00 01
IL_00B4:  ldstr        26 04 00 70
IL_00B9:  call         B6 00 00 0A
IL_00BE:  ldstr        11 01 00 70
IL_00C3:  call         91 00 00 0A
</code></pre>
<ul>
<li>ุฏุฑ ุงู ุญุงูุชุ <strong>opcodes</strong> ุฏุฑุณุช ูุณุชูุฏ ุงูุง ุนููููุฏูุง ุจู ุฏุฑุฏ ุฎู ููโุฎูุฑูุฏ.</li>
<li>ูุง ูโุฎูุงูู ุจู ุฌุง ุงุนุฏุงุฏ ูฺฏุฒุงุฏุณูุงูุ <strong>ูุงู ุงุนุถุง ู ุฑุดุชูโูุง</strong> ุฑุง ุจุจูู.</li>
</ul>
<hr>
<h4>ูุงูุจโุจูุฏ ุนููููุฏูุง ๐</h4>
<p>ูุชุฏ <strong>FormatOperand</strong> ุงู ฺฉุงุฑ ุฑุง ุงูุฌุงู ูโุฏูุฏ ู ููุงุฑุฏ ุฎุงุต ฺฉู ูุงุฒ ุจู ูุงูุจโุจูุฏ ุฏุงุฑูุฏุ ุดูุงุณุง ูโฺฉูุฏ. ุงู ุดุงูู ุงฺฉุซุฑ ุนููููุฏูุง ฺูุงุฑ ุจุงุช ู ุฏุณุชูุฑูุง <strong>short branch</strong> ุงุณุช:</p>
<pre><code class="language-csharp">string FormatOperand(OpCode c, int operandLength)
{
    if (operandLength == 0) return &quot;&quot;;
    if (operandLength == 4)
        return Get4ByteOperand(c);
    else if (c.OperandType == OperandType.ShortInlineBrTarget)
        return GetShortRelativeTarget();
    else if (c.OperandType == OperandType.InlineSwitch)
        return GetSwitchTarget(operandLength);
    else
        return null;
}
</code></pre>
<hr>
<p>ุจุง ุงู ุฑูุดุ ุงฺฉููู ูพุงู ุจุฑุง <strong>ฺฉ ุฏุณโุงุณูุจูุฑ IL ฺฉุงูู ู ูุงุจู ุชูุณุนู</strong> ุขูุงุฏู ุงุณุช. โ</p>
<h3>ูพุฑุฏุงุฒุด ุนููููุฏูุง ฺูุงุฑ ุจุงุช ู ุดุงุฎูโูุง ๐งฉ</h3>
<p>ุณู ููุน ุนููููุฏ ฺูุงุฑ ุจุงุช ูุฌูุฏ ุฏุงุฑุฏ ฺฉู ุจุงุฏ ุจู ุดฺฉู ุฎุงุต ูพุฑุฏุงุฒุด ุดููุฏ:</p>
<ol>
<li>
<p><strong>ุงุฑุฌุงุน ุจู ุงุนุถุง ุง ุชุงูพโูุง</strong>
ุจุง ุงู ููุนุ ูุงู ุนุถู ุง ุชุงูพ ุฑุง ุจุง ูุฑุงุฎูุงู <strong>ResolveMember</strong> ุฑู ูุงฺูู ุชุนุฑูโฺฉููุฏู ุงุณุชุฎุฑุงุฌ ูโฺฉูู.</p>
</li>
<li>
<p><strong>ุฑุดุชูโูุง</strong>
ุฑุดุชูโูุง ุฏุฑ <strong>metadata</strong> ูุงฺูู ุงุณูุจู ุฐุฎุฑู ุดุฏูโุงูุฏ ู ุจุง <strong>ResolveString</strong> ุจุงุฒุงุจ ูโุดููุฏ.</p>
</li>
<li>
<p><strong>ุดุงุฎูโูุง (Branch targets)</strong>
ุนููููุฏ ุจู ฺฉ ุขูุณุช ุจุงุช ุฏุฑ IL ุงุดุงุฑู ูโฺฉูุฏ. ุงูโูุง ุฑุง ุจุง ูุญุงุณุจู ุขุฏุฑุณ ูุทูู ุจุนุฏ ุงุฒ ุฏุณุชูุฑ ูุนู (+ ฺูุงุฑ ุจุงุช) ูุงูุจโุจูุฏ ูโฺฉูู.</p>
</li>
</ol>
<p>ูุซุงู ฺฉุฏ:</p>
<pre><code class="language-csharp">string Get4ByteOperand(OpCode c)
{
    int intOp = BitConverter.ToInt32(_il, _pos);
    switch (c.OperandType)
    {
        case OperandType.InlineTok:
        case OperandType.InlineMethod:
        case OperandType.InlineField:
        case OperandType.InlineType:
            MemberInfo mi;
            try { mi = _module.ResolveMember(intOp); }
            catch { return null; }
            if (mi == null) return null;
            if (mi.ReflectedType != null)
                return mi.ReflectedType.FullName + &quot;.&quot; + mi.Name;
            else if (mi is Type)
                return ((Type)mi).FullName;
            else
                return mi.Name;

        case OperandType.InlineString:
            string s = _module.ResolveString(intOp);
            if (s != null) s = &quot;'&quot; + s + &quot;'&quot;;
            return s;

        case OperandType.InlineBrTarget:
            return &quot;IL_&quot; + (_pos + intOp + 4).ToString(&quot;X4&quot;);

        default:
            return null;
    }
}
</code></pre>
<ul>
<li>ููุทูโุง ฺฉู <strong>ResolveMember</strong> ูุฑุงุฎูุงู ูโุดูุฏุ ูพูุฌุฑู ุฎูุจ ุจุฑุง ุงุจุฒุงุฑูุง ุชุญูู ฺฉุฏ ุงุณุช ุชุง ูุงุจุณุชฺฏโูุง ูุชุฏูุง ุฑุง ฺฏุฒุงุฑุด ฺฉููุฏ.</li>
<li>ุจุฑุง ุณุงุฑ opcodes ฺูุงุฑ ุจุงุชุ <strong>null</strong> ุจุฑฺฏุฑุฏุงูุฏู ูโุดูุฏ ุชุง <strong>ReadOperand</strong> ุนููููุฏ ุฑุง ุจู ุตูุฑุช ูฺฏุฒุงุฏุณูุงู ููุงุด ุฏูุฏ.</li>
</ul>
<hr>
<h3>ุดุงุฎูโูุง ฺฉูุชุงู ู inline switch ๐ฆ</h3>
<ul>
<li><strong>ุดุงุฎู ฺฉูุชุงู (Short branch target)</strong>: ุขูุณุช ููุตุฏ ุจู ุตูุฑุช ฺฉ ุจุงุช ุจุง ุนูุงูุช ูุดุงู ุฏุงุฏู ูโุดูุฏ (ุฏุฑ ุงูุชูุง ุฏุณุชูุฑ ูุนูุ + ฺฉ ุจุงุช).</li>
<li><strong>Switch target</strong>: ูพุณ ุงุฒ ุขู ุชุนุฏุงุฏ ูุชุบุฑ ุงุฒ ููุงุตุฏ ฺูุงุฑ ุจุงุช ูุฑุงุฑ ูโฺฏุฑุฏ.</li>
</ul>
<pre><code class="language-csharp">string GetShortRelativeTarget()
{
    int absoluteTarget = _pos + (sbyte)_il[_pos] + 1;
    return &quot;IL_&quot; + absoluteTarget.ToString(&quot;X4&quot;);
}

string GetSwitchTarget(int operandLength)
{
    int targetCount = BitConverter.ToInt32(_il, _pos);
    string[] targets = new string[targetCount];
    for (int i = 0; i &lt; targetCount; i++)
    {
        int ilTarget = BitConverter.ToInt32(_il, _pos + (i + 1) * 4);
        targets[i] = &quot;IL_&quot; + (_pos + ilTarget + operandLength).ToString(&quot;X4&quot;);
    }
    return &quot;(&quot; + string.Join(&quot;, &quot;, targets) + &quot;)&quot;;
}
</code></pre>
<hr>
<p>ุจุง ุงู ฺฉุฏุ ุฏุณโุงุณูุจูุฑ ฺฉุงูู ูโุดูุฏ.
ูโุชูุงู ุขู ุฑุง ุจุง ุฏุณโุงุณูุจู ฺฉุฑุฏู ฺฉ ุงุฒ ูุชุฏูุง ุฎูุฏุด ุชุณุช ฺฉุฑุฏ:</p>
<pre><code class="language-csharp">MethodInfo mi = typeof(Disassembler).GetMethod(
    &quot;ReadOperand&quot;, BindingFlags.Instance | BindingFlags.NonPublic);
Console.WriteLine(Disassembler.Disassemble(mi));
</code></pre>
<ul>
<li>ุงู ุฎุฑูุฌ IL ุฎูุงูุง ู ูุดุงุจู <strong>ildasm</strong> ุชููุฏ ูโฺฉูุฏ. โ</li>
</ul>

  </main>

  <!-- ููุชุฑ ูุดุชุฑฺฉ -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/icone/copyright.svg" alt="ฺฉูพโุฑุงุช" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab โ ุจุฑุง ุชูุณุนูโุฏููุฏฺฏุงู
      </p>
    </div>
  </footer>

  <!-- ุณุงู + ุงุณฺฉุฑูพุช ุชู -->
  <script>
    document.getElementById('y').textContent = new Date().getFullYear();

    (() => {
      const root = document.documentElement;
      const btn = document.getElementById('themeToggle');
      const KEY = 'gitab-theme';
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      const getEffective = s => s === 'auto' ? (media.matches ? 'dark' : 'light') : s;
      function updateTheme(s) {
        root.setAttribute('data-theme', s);
        const mode = getEffective(s);
        root.dataset.colorMode = mode;
        btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
      }
      const saved = localStorage.getItem(KEY) || 'auto';
      updateTheme(saved);
      btn.addEventListener('click', () => {
        const curr = localStorage.getItem(KEY) || 'auto';
        const next = curr === 'auto' ? 'dark' : curr === 'dark' ? 'light' : 'auto';
        localStorage.setItem(KEY, next);
        updateTheme(next);
      });
      media.addEventListener('change', () => {
        if ((localStorage.getItem(KEY) || 'auto') === 'auto') updateTheme('auto');
      });
      window.addEventListener('DOMContentLoaded', () => updateTheme(saved));
    })();
  </script>
</body>
</html>
