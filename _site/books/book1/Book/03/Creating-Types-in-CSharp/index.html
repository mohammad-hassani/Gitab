

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ساخت انواع در سی‌شارپ</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

       <nav class="nav">
         <a href="/Gitab/" >خانه</a>
         <a href="/Gitab/books/list-books" >کتاب‌ها</a>
        <a href="/Gitab/translator.html" >مترجمین</a>
         <a href="/Gitab/giter.html" >گیتر</a>
       </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل سوم : ایجاد Typeها در سی شارپ</h1>
<p>در این فصل، ما وارد مبحث <strong>typeها</strong> و <strong>type memberها</strong> می‌شویم.</p>
<hr>
<h3>📌 کلاس‌ها (Classes)</h3>
<p>یک <strong>class</strong> رایج‌ترین نوع از <strong>reference type</strong> است. ساده‌ترین شکل ممکن برای تعریف یک کلاس به این صورت است:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">YourClassName</span>
{
}
</code></pre>
<p>یک کلاس پیچیده‌تر می‌تواند شامل موارد زیر باشد:</p>
<ul>
<li>
<p><strong>قبل از کلمه کلیدی class</strong> → می‌تواند شامل <strong>attributes</strong> و <strong>class modifiers</strong> باشد.</p>
</li>
<li>
<p><strong>بعد از نام کلاس (YourClassName)</strong> → می‌تواند شامل <strong>generic type parameters</strong> باشد.</p>
</li>
<li>
<p><strong>داخل براکت‌ها { }</strong> → می‌تواند شامل <strong>class members</strong> مانند موارد زیر باشد:</p>
<ul>
<li>fields</li>
<li>constructors</li>
<li>methods</li>
<li>properties</li>
<li>indexers</li>
<li>events</li>
<li>finalizer</li>
<li>overloaded operators</li>
<li>nested types</li>
<li>base class</li>
<li>interfaces</li>
<li>constraints</li>
</ul>
</li>
</ul>
<p>⚠️ در این فصل، همه این ساختارها توضیح داده می‌شوند، <strong>به‌جز</strong> موارد زیر که در فصل ۴ پوشش داده خواهند شد:</p>
<ul>
<li>attributes</li>
<li>operator functions</li>
<li>کلمه کلیدی <code>unsafe</code></li>
</ul>
<p>بخش‌های بعدی، هر یک از <strong>class memberها</strong> را بررسی می‌کنند.</p>
<hr>
<h3>📝 فیلدها (Fields)</h3>
<p>یک <strong>field</strong> در واقع یک متغیر است که به‌عنوان عضوی از یک <strong>class</strong> یا <strong>struct</strong> تعریف می‌شود؛ برای مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Octopus</span>
{
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age = <span class="hljs-number">10</span>;
}
</code></pre>
<hr>
<h4>🔑 فیلدها می‌توانند شامل این modifiers باشند</h4>
<ul>
<li><strong>Static modifier</strong> → <code>static</code></li>
<li><strong>Access modifiers</strong> → <code>public</code>, <code>internal</code>, <code>private</code>, <code>protected</code></li>
<li><strong>Inheritance modifier</strong> → <code>new</code></li>
<li><strong>Unsafe code modifier</strong> → <code>unsafe</code></li>
<li><strong>Read-only modifier</strong> → <code>readonly</code></li>
<li><strong>Threading modifier</strong> → <code>volatile</code></li>
</ul>
<hr>
<h4>🐪 قراردادهای نام‌گذاری (Naming Conventions) برای فیلدهای private</h4>
<p>دو قرارداد پرکاربرد وجود دارد:</p>
<ol>
<li><strong>camelCase</strong> → مثل: <code>firstName</code></li>
<li><strong>camelCase همراه با underscore</strong> → مثل: <code>_firstName</code></li>
</ol>
<p>روش دوم کمک می‌کند که سریعاً فیلدهای private را از <strong>پارامترها</strong> و <strong>متغیرهای محلی</strong> تشخیص دهید.</p>
<hr>
<h4>🔒 کلمه کلیدی <code>readonly</code></h4>
<p>کلمه کلیدی <strong><code>readonly</code></strong> باعث می‌شود یک فیلد پس از ساخت (construction) دیگر قابل تغییر نباشد.<br>
یک فیلد <strong>readonly</strong> فقط می‌تواند در <strong>اعلان آن</strong> یا در <strong>سازنده‌ی (constructor) همان type</strong> مقداردهی شود.</p>
<hr>
<h4>⚙️ مقداردهی اولیه فیلدها (Field Initialization)</h4>
<ul>
<li>
<p>مقداردهی اولیه برای فیلدها <strong>اختیاری</strong> است.</p>
</li>
<li>
<p>اگر یک فیلد مقداردهی نشود، مقدار پیش‌فرض خواهد داشت:</p>
<ul>
<li>عددی‌ها: <code>0</code></li>
<li>کاراکتر: <code>'\0'</code></li>
<li>reference types: <code>null</code></li>
<li>bool: <code>false</code></li>
</ul>
</li>
</ul>
<p>📌 مقداردهی اولیه فیلدها <strong>قبل از constructorها</strong> اجرا می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age = <span class="hljs-number">10</span>;
</code></pre>
<p>مقداردهی اولیه می‌تواند شامل <strong>عبارت‌ها</strong> یا حتی <strong>فراخوانی متدها</strong> باشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> TempFolder = System.IO.Path.GetTempPath();
</code></pre>
<hr>
<h4>📍 اعلان چند فیلد همزمان (Declaring Multiple Fields Together)</h4>
<p>برای راحتی، می‌توانید چندین فیلد از یک نوع را در یک لیست جداشده با کاما تعریف کنید.<br>
این روش باعث می‌شود که همه فیلدها <strong>attributes</strong> و <strong>field modifiers</strong> یکسانی داشته باشند:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> legs = <span class="hljs-number">8</span>,
                   eyes = <span class="hljs-number">2</span>;
</code></pre>
<h3>🌟 ثابت‌ها (Constants)</h3>
<p>یک <strong>constant</strong> در زمان <strong>compile time</strong> به‌صورت ایستا (statically) ارزیابی می‌شود و کامپایلر مقدار آن را در هر جایی که استفاده شود، جایگزین می‌کند (شبیه به <strong>macro</strong> در ++C).</p>
<p>یک <strong>constant</strong> می‌تواند از نوع‌های زیر باشد:</p>
<ul>
<li><code>bool</code></li>
<li><code>char</code></li>
<li><code>string</code></li>
<li>هر یک از نوع‌های عددی <strong>built-in</strong></li>
<li>یا یک <strong>enum type</strong></li>
</ul>
<hr>
<h4>📝 تعریف constant</h4>
<p>یک <strong>constant</strong> با استفاده از کلمه کلیدی <strong><code>const</code></strong> تعریف می‌شود و باید در هنگام اعلان، مقداردهی اولیه شود.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> Message = <span class="hljs-string">&quot;Hello World&quot;</span>;
}
</code></pre>
<hr>
<h4>⚖️ تفاوت با <code>static readonly</code></h4>
<p>یک constant می‌تواند نقشی شبیه به یک <strong>static readonly field</strong> ایفا کند، اما بسیار <strong>محدودتر</strong> است؛ هم از نظر نوع داده‌هایی که قابل استفاده‌اند و هم از نظر قواعد مقداردهی اولیه.</p>
<p>همچنین، تفاوت مهم این است که <strong>constant در زمان compile</strong> ارزیابی می‌شود، در حالی که مقدار یک <strong>static readonly</strong> ممکن است در زمان اجرا تعیین شود.</p>
<p>برای مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Circumference</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * System.Math.PI * radius;
}
</code></pre>
<p>در زمان کامپایل به این تبدیل می‌شود:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Circumference</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-number">6.2831853071795862</span> * radius;
}
</code></pre>
<p>🔹 بنابراین منطقی است که <code>PI</code> به‌صورت یک <strong>constant</strong> تعریف شود چون مقدار آن از قبل مشخص است.</p>
<p>در مقابل:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DateTime StartupTime = DateTime.Now;
</code></pre>
<p>هر بار که برنامه اجرا شود، مقدار متفاوتی خواهد داشت.</p>
<hr>
<h4>⚠️ مشکل نسخه‌ها با constant</h4>
<p>اگر یک <strong>assembly</strong> (مثلاً X) یک constant را expose کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">decimal</span> ProgramVersion = <span class="hljs-number">2.3</span>m;
</code></pre>
<p>و یک <strong>assembly</strong> دیگر (مثلاً Y) از آن استفاده کند، مقدار <code>2.3</code> هنگام کامپایل در assembly Y <strong>ثابت‌سازی (baked in)</strong> می‌شود.<br>
اگر بعدها X با مقدار جدید (مثلاً <code>2.4</code>) دوباره کامپایل شود، Y همچنان مقدار قدیمی <code>2.3</code> را استفاده می‌کند تا زمانی که Y هم دوباره کامپایل شود.</p>
<p>🔹 استفاده از <strong>static readonly field</strong> این مشکل را برطرف می‌کند.</p>
<p>به بیان دیگر: هر مقداری که <strong>ممکن است در آینده تغییر کند</strong>، ذاتاً <strong>constant</strong> نیست و نباید به‌عنوان constant تعریف شود.</p>
<hr>
<h4>📍 ثابت‌های محلی (Local Constants)</h4>
<p>شما می‌توانید داخل یک متد هم constant تعریف کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span>
{
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> twoPI = <span class="hljs-number">2</span> * System.Math.PI;
    ...
}
</code></pre>
<hr>
<h4>🔑 modifiers مجاز برای constantهای غیرمحلی</h4>
<ul>
<li><strong>Access modifiers</strong> → <code>public</code>, <code>internal</code>, <code>private</code>, <code>protected</code></li>
<li><strong>Inheritance modifier</strong> → <code>new</code></li>
</ul>
<hr>
<h3>🔧 متدها (Methods)</h3>
<p>یک <strong>method</strong> عملی را در قالب یک سری <strong>statement</strong>ها اجرا می‌کند.</p>
<ul>
<li>یک متد می‌تواند داده‌های ورودی را از <strong>caller</strong> دریافت کند (با تعریف <strong>parameters</strong>).</li>
<li>و داده خروجی را به <strong>caller</strong> بازگرداند (با تعریف <strong>return type</strong>).</li>
<li>اگر یک متد <strong><code>void</code></strong> باشد، به این معناست که هیچ مقداری را برنمی‌گرداند.</li>
<li>همچنین می‌تواند با استفاده از <strong>ref/out parameters</strong> داده را به caller بازگرداند.</li>
</ul>
<hr>
<h4>📌 امضای متد (Method Signature)</h4>
<ul>
<li>امضای یک متد باید در یک type <strong>منحصر‌به‌فرد</strong> باشد.</li>
<li>امضا شامل <strong>نام متد</strong> و <strong>انواع پارامترها</strong> به‌ترتیب است.</li>
<li>نام پارامترها و نوع بازگشتی (return type) بخشی از امضا نیستند.</li>
</ul>
<hr>
<h4>🔑 modifiers مجاز برای متدها</h4>
<ul>
<li><strong>Static modifier</strong> → <code>static</code></li>
<li><strong>Access modifiers</strong> → <code>public</code>, <code>internal</code>, <code>private</code>, <code>protected</code></li>
<li><strong>Inheritance modifiers</strong> → <code>new</code>, <code>virtual</code>, <code>abstract</code>, <code>override</code>, <code>sealed</code></li>
<li><strong>Partial method modifier</strong> → <code>partial</code></li>
<li><strong>Unmanaged code modifiers</strong> → <code>unsafe</code>, <code>extern</code></li>
<li><strong>Asynchronous code modifier</strong> → <code>async</code></li>
</ul>
<hr>
<h4>➡️ متدهای expression-bodied</h4>
<p>اگر متدی فقط یک <strong>expression</strong> داشته باشد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> { <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>; }
</code></pre>
<p>می‌توان آن را به‌شکل کوتاه‌تری نوشت:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; x * <span class="hljs-number">2</span>;
</code></pre>
<p>حتی اگر متد <strong><code>void</code></strong> باشد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; Console.WriteLine(x);
</code></pre>
<hr>
<h4>📍 متدهای محلی (Local Methods)</h4>
<p>می‌توانید یک متد را داخل متدی دیگر تعریف کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteCubes</span>()</span>
{
    Console.WriteLine(Cube(<span class="hljs-number">3</span>));
    Console.WriteLine(Cube(<span class="hljs-number">4</span>));
    Console.WriteLine(Cube(<span class="hljs-number">5</span>));

    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Cube</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span> =&gt; <span class="hljs-keyword">value</span> * <span class="hljs-keyword">value</span> * <span class="hljs-keyword">value</span>;
}
</code></pre>
<ul>
<li>متد محلی (<code>Cube</code>) فقط در همان متد والد (<code>WriteCubes</code>) قابل مشاهده است.</li>
<li>این کار باعث ساده‌تر شدن type می‌شود و سریعاً نشان می‌دهد که Cube جای دیگری استفاده نمی‌شود.</li>
<li>متدهای محلی می‌توانند به متغیرها و پارامترهای متد والد دسترسی داشته باشند.</li>
</ul>
<p>📌 جزئیات بیشتر در بخش <strong>Capturing Outer Variables</strong> (صفحه ۱۹۰) توضیح داده خواهد شد.</p>
<ul>
<li>متدهای محلی می‌توانند درون دیگر توابع مانند property accessors، constructorها و غیره نیز تعریف شوند.</li>
<li>حتی می‌توان متدهای محلی را داخل دیگر متدهای محلی یا داخل <strong>lambda expression</strong>ها (با statement block) قرار داد.</li>
<li>متدهای محلی می‌توانند <strong>iterator</strong> (فصل ۴) یا <strong>asynchronous</strong> (فصل ۱۴) باشند.</li>
</ul>
<hr>
<h4>⚡ متدهای محلی static (Static Local Methods)</h4>
<p>از <strong>C# 8</strong> به بعد، افزودن <strong>static modifier</strong> به یک متد محلی باعث می‌شود آن متد دیگر به متغیرها و پارامترهای متد والد دسترسی نداشته باشد.</p>
<p>🔹 این کار وابستگی (coupling) را کاهش می‌دهد و جلوی استفاده تصادفی از متغیرهای متد والد را می‌گیرد.</p>
<h3>📍 متدهای محلی و Top-Level Statements</h3>
<p>هر <strong>method</strong> که در <strong>top-level statements</strong> تعریف کنید، در واقع به‌عنوان یک <strong>local method</strong> در نظر گرفته می‌شود.<br>
این یعنی (مگر این‌که با <code>static</code> علامت‌گذاری شود) می‌توانند به متغیرهای تعریف‌شده در top-level دسترسی داشته باشند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">3</span>;
Foo();

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> =&gt; Console.WriteLine(x);
</code></pre>
<hr>
<h3>🔄 Overloading متدها</h3>
<ul>
<li>
<p><strong>Local methods</strong> قابل <strong>overload</strong> شدن نیستند.<br>
بنابراین، متدهایی که در <strong>top-level statements</strong> تعریف می‌شوند (که در واقع همان local methods هستند)، نمی‌توانند overload شوند.</p>
</li>
<li>
<p>اما یک <strong>type</strong> می‌تواند متدها را overload کند؛ یعنی چند متد با نام یکسان داشته باشد، به‌شرطی که <strong>امضای آن‌ها (signature)</strong> متفاوت باشد.</p>
</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">float</span> y</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> x, <span class="hljs-built_in">int</span> y</span>)</span> {...}
</code></pre>
<p>📌 اما مثال‌های زیر <strong>خطای زمان کامپایل</strong> دارند، چون <code>return type</code> و <code>params modifier</code> بخشی از <strong>امضا</strong> محسوب نمی‌شوند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> {...}
<span class="hljs-function"><span class="hljs-built_in">float</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> {...}           <span class="hljs-comment">// Compile-time error</span>

<span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">Goo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] x</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">Goo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] x</span>)</span> {...}  <span class="hljs-comment">// Compile-time error</span>
</code></pre>
<hr>
<h4>📌 پارامترهای ref و out در امضا</h4>
<p>این‌که پارامترها به‌صورت <strong>by-value</strong> یا <strong>by-reference</strong> پاس داده شوند، بخشی از امضا محسوب می‌شود.</p>
<p>✅ بنابراین:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> x</span>)</span> {...}   <span class="hljs-comment">// OK</span>
</code></pre>
<p>❌ اما:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> x</span>)</span> {...}   <span class="hljs-comment">// Compile-time error</span>
</code></pre>
<p>زیرا <code>ref</code> و <code>out</code> به‌طور هم‌زمان نمی‌توانند overload شوند.</p>
<hr>
<h3>🏗️ Instance Constructors</h3>
<p><strong>Constructor</strong>ها کدی برای مقداردهی اولیه (initialization) روی یک <strong>class</strong> یا <strong>struct</strong> اجرا می‌کنند.<br>
یک constructor مانند یک متد تعریف می‌شود، با این تفاوت که <strong>نام متد</strong> همان <strong>نام type والد</strong> است و هیچ <strong>return type</strong> ندارد:</p>
<pre class="hljs"><code>Panda p = <span class="hljs-keyword">new</span> Panda(<span class="hljs-string">&quot;Petey&quot;</span>);   <span class="hljs-comment">// Call constructor</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Panda</span>
{
    <span class="hljs-built_in">string</span> name;                <span class="hljs-comment">// Define field</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Panda</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> n</span>)      <span class="hljs-comment">// Define constructor</span></span>
    {
        name = n;               <span class="hljs-comment">// Initialization code (set up field)</span>
    }
}
</code></pre>
<hr>
<h4>🔑 modifiers مجاز برای constructors</h4>
<ul>
<li><strong>Access modifiers</strong> → <code>public</code>, <code>internal</code>, <code>private</code>, <code>protected</code></li>
<li><strong>Unmanaged code modifiers</strong> → <code>unsafe</code>, <code>extern</code></li>
</ul>
<hr>
<h4>➡️ Expression-bodied constructors</h4>
<p>اگر constructor یک statement ساده داشته باشد، می‌تواند به‌شکل کوتاه نوشته شود:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Panda</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> n</span>)</span> =&gt; name = n;
</code></pre>
<hr>
<h4>📌 رفع ابهام با <code>this</code></h4>
<p>اگر نام پارامتر با نام فیلد یکی باشد، می‌توانید با <strong><code>this</code></strong> فیلد را مشخص کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Panda</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> =&gt; <span class="hljs-keyword">this</span>.name = name;
</code></pre>
<hr>
<h3>🔄 Overloading Constructors</h3>
<p>یک کلاس یا struct می‌تواند <strong>constructorهای overload</strong> داشته باشد.</p>
<p>برای جلوگیری از تکرار کد، یک constructor می‌تواند constructor دیگری را با استفاده از <strong><code>this</code></strong> صدا بزند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Wine</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Price;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Year;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wine</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> price</span>)</span> =&gt; Price = price;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wine</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> price, <span class="hljs-built_in">int</span> year</span>) : <span class="hljs-title">this</span>(<span class="hljs-params">price</span>)</span> =&gt; Year = year;
}
</code></pre>
<p>📌 در این حالت، constructor فراخوانی‌شده <strong>ابتدا</strong> اجرا می‌شود.</p>
<p>می‌توانید یک <strong>عبارت</strong> را نیز به constructor دیگر پاس دهید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wine</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> price, DateTime year</span>) : <span class="hljs-title">this</span>(<span class="hljs-params">price, year.Year</span>)</span> { }
</code></pre>
<p>⚠️ در این مرحله، فقط می‌توان به <strong>اعضای static کلاس</strong> دسترسی داشت، نه اعضای instance؛ چون هنوز شیء توسط constructor مقداردهی نشده است.</p>
<hr>
<h4>🛠️ جایگزین بهتر: پارامتر اختیاری</h4>
<p>مثال بالا را می‌توان با یک constructor ساده‌تر نوشت:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wine</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> price, <span class="hljs-built_in">int</span> year = <span class="hljs-number">0</span></span>)</span>
{
    Price = price;
    Year = year;
}
</code></pre>
<p>📌 راه‌حل دیگری نیز در بخش <strong>Object Initializers</strong> (صفحه ۱۱۱) معرفی خواهد شد.</p>
<hr>
<h3>🆓 Implicit Parameterless Constructors</h3>
<p>برای <strong>class</strong>ها، کامپایلر C# به‌طور خودکار یک <strong>constructor بدون پارامتر public</strong> تولید می‌کند، به‌شرطی که شما هیچ constructor دیگری تعریف نکرده باشید.<br>
اما به محض این‌که حداقل یک constructor تعریف کنید، دیگر این constructor پیش‌فرض ساخته نمی‌شود.</p>
<hr>
<h3>🔄 ترتیب مقداردهی اولیه فیلد و constructor</h3>
<p>همان‌طور که دیدیم، می‌توان فیلدها را هنگام اعلان مقداردهی کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span>
{
    <span class="hljs-built_in">int</span> shields = <span class="hljs-number">50</span>;   <span class="hljs-comment">// Initialized first</span>
    <span class="hljs-built_in">int</span> health = <span class="hljs-number">100</span>;   <span class="hljs-comment">// Initialized second</span>
}
</code></pre>
<p>📌 مقداردهی اولیه فیلدها <strong>قبل از اجرای constructor</strong> انجام می‌شود و به‌ترتیب اعلان فیلدها اجرا می‌گردد.</p>
<h3>🔹 سازنده‌های غیرعمومی (Nonpublic constructors)</h3>
<p>سازنده‌ها الزامی ندارند که عمومی (<strong>public</strong>) باشند. یک دلیل رایج برای داشتن سازنده‌های غیرعمومی این است که ایجاد نمونه‌ها (<strong>instance creation</strong>) فقط از طریق یک متد ایستا (<strong>static method</strong>) کنترل شود.</p>
<p>به‌عنوان مثال، متد ایستا می‌تواند به‌جای ایجاد یک شیء جدید، یک شیء موجود را از <strong>object pool</strong> برگرداند، یا بر اساس ورودی‌های مختلف، زیرکلاس‌های متفاوتی را بازگرداند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span>
{
    Class1() {}   <span class="hljs-comment">// سازنده خصوصی</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class1 <span class="hljs-title">Create</span> (<span class="hljs-params">...</span>)</span>
    {
        <span class="hljs-comment">// اجرای منطق سفارشی برای برگرداندن یک شیء از نوع Class1</span>
        ...
    }
}
</code></pre>
<hr>
<h3>🔹 دیکانستراکتور (Deconstructor)</h3>
<p><strong>دیکانستراکتور</strong> یا <strong>متد deconstructing</strong> تقریباً برعکس یک سازنده عمل می‌کند:</p>
<ul>
<li>سازنده معمولاً مجموعه‌ای از مقادیر ورودی (پارامترها) را گرفته و آن‌ها را به فیلدها نسبت می‌دهد.</li>
<li>دیکانستراکتور برعکس این کار را انجام می‌دهد: فیلدها را به مجموعه‌ای از متغیرها برمی‌گرداند.</li>
</ul>
<p>🔸 قوانین:</p>
<ul>
<li>نام این متد باید دقیقاً <code>Deconstruct</code> باشد.</li>
<li>باید دارای یک یا چند <strong>پارامتر out</strong> باشد.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">float</span> Width, Height;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span> (<span class="hljs-params"><span class="hljs-built_in">float</span> width, <span class="hljs-built_in">float</span> height</span>)</span>
    {
        Width = width;
        Height = height;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deconstruct</span> (<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">float</span> width, <span class="hljs-keyword">out</span> <span class="hljs-built_in">float</span> height</span>)</span>
    {
        width = Width;
        height = Height;
    }
}
</code></pre>
<hr>
<h3>🔹 فراخوانی دیکانستراکتور</h3>
<pre class="hljs"><code><span class="hljs-keyword">var</span> rect = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
(<span class="hljs-built_in">float</span> width, <span class="hljs-built_in">float</span> height) = rect;   <span class="hljs-comment">// دیکانستراکشن</span>
Console.WriteLine(width + <span class="hljs-string">&quot; &quot;</span> + height);   <span class="hljs-comment">// 3 4</span>
</code></pre>
<p>🔹 این فراخوانی معادل است با:</p>
<pre class="hljs"><code><span class="hljs-built_in">float</span> width, height;
rect.Deconstruct(<span class="hljs-keyword">out</span> width, <span class="hljs-keyword">out</span> height);
</code></pre>
<p>یا:</p>
<pre class="hljs"><code>rect.Deconstruct(<span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> width, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> height);
</code></pre>
<hr>
<h3>🔹 نکات مهم در دیکانستراکشن</h3>
<ul>
<li>
<p>امکان استفاده از <strong>implicit typing</strong> وجود دارد:</p>
<pre class="hljs"><code>(<span class="hljs-keyword">var</span> width, <span class="hljs-keyword">var</span> height) = rect;
<span class="hljs-keyword">var</span> (width, height) = rect;
</code></pre>
</li>
<li>
<p>اگر به یکی از متغیرها نیازی ندارید، می‌توانید از نماد <strong>discard (<code>_</code>)</strong> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> (_, height) = rect;
</code></pre>
</li>
<li>
<p>اگر متغیرها قبلاً تعریف شده باشند، می‌توانید <strong>نوع‌ها را حذف کنید</strong>:</p>
<pre class="hljs"><code><span class="hljs-built_in">float</span> width, height;
(width, height) = rect;   <span class="hljs-comment">// دیکانستراکشن assignment</span>
</code></pre>
</li>
<li>
<p>می‌توانید از دیکانستراکشن برای ساده‌سازی سازنده‌ها استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span> (<span class="hljs-params"><span class="hljs-built_in">float</span> width, <span class="hljs-built_in">float</span> height</span>)</span> =&gt;
    (Width, Height) = (width, height);
</code></pre>
</li>
<li>
<p>امکان <strong>overload کردن متد Deconstruct</strong> برای ارائه گزینه‌های بیشتر وجود دارد.</p>
</li>
<li>
<p>متد <code>Deconstruct</code> می‌تواند یک <strong>extension method</strong> هم باشد (برای دیکانستراکشن روی تایپ‌هایی که نویسنده‌ی آن نیستید).</p>
</li>
<li>
<p>از C# 10 به بعد، می‌توانید <strong>متغیرهای موجود و جدید</strong> را با هم ترکیب کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">double</span> x1 = <span class="hljs-number">0</span>;
(x1, <span class="hljs-built_in">double</span> y2) = rect;
</code></pre>
</li>
</ul>
<hr>
<h3>🔹 مقداردهی اولیه شیء (Object Initializers)</h3>
<p>برای ساده‌سازی مقداردهی اولیه، می‌توان <strong>فیلدها یا propertyهای قابل دسترسی</strong> را مستقیماً بعد از سازنده تنظیم کرد.</p>
<p>مثال کلاس:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bunny</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> LikesCarrots, LikesHumans;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bunny</span>()</span> {}
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bunny</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> n</span>)</span> =&gt; Name = n;
}
</code></pre>
<p>📌 نمونه‌سازی با مقداردهی اولیه شیء:</p>
<pre class="hljs"><code><span class="hljs-comment">// سازنده بدون پارامتر می‌تواند پرانتز خالی را حذف کند</span>
Bunny b1 = <span class="hljs-keyword">new</span> Bunny { Name=<span class="hljs-string">&quot;Bo&quot;</span>, LikesCarrots=<span class="hljs-literal">true</span>, LikesHumans=<span class="hljs-literal">false</span> };
Bunny b2 = <span class="hljs-keyword">new</span> Bunny(<span class="hljs-string">&quot;Bo&quot;</span>) { LikesCarrots=<span class="hljs-literal">true</span>, LikesHumans=<span class="hljs-literal">false</span> };
</code></pre>
<p>این کد دقیقاً معادل موارد زیر است (کامپایلر متغیرهای موقت می‌سازد):</p>
<pre class="hljs"><code>Bunny temp1 = <span class="hljs-keyword">new</span> Bunny();
temp1.Name = <span class="hljs-string">&quot;Bo&quot;</span>;
temp1.LikesCarrots = <span class="hljs-literal">true</span>;
temp1.LikesHumans = <span class="hljs-literal">false</span>;
Bunny b1 = temp1;

Bunny temp2 = <span class="hljs-keyword">new</span> Bunny(<span class="hljs-string">&quot;Bo&quot;</span>);
temp2.LikesCarrots = <span class="hljs-literal">true</span>;
temp2.LikesHumans = <span class="hljs-literal">false</span>;
Bunny b2 = temp2;
</code></pre>
<p>🔸 دلیل استفاده از متغیرهای موقت این است که اگر در طول مقداردهی اولیه <strong>exception</strong> رخ دهد، شیء <strong>نیمه‌سازمان‌یافته (half-initialized)</strong> باقی نماند.</p>
<h3>🔹 مقایسه مقداردهی اولیه شیء با پارامترهای اختیاری (Object Initializers Versus Optional Parameters)</h3>
<p>به جای استفاده از <strong>object initializer</strong>، می‌توانیم سازنده‌ی کلاس <code>Bunny</code> را طوری بنویسیم که یک پارامتر اجباری و دو پارامتر اختیاری داشته باشد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bunny</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> name,
              <span class="hljs-built_in">bool</span> likesCarrots = <span class="hljs-literal">false</span>,
              <span class="hljs-built_in">bool</span> likesHumans = <span class="hljs-literal">false</span></span>)</span>
{
    Name = name;
    LikesCarrots = likesCarrots;
    LikesHumans = likesHumans;
}
</code></pre>
<p>📌 این کار به ما اجازه می‌دهد شیء را به شکل زیر بسازیم:</p>
<pre class="hljs"><code>Bunny b1 = <span class="hljs-keyword">new</span> Bunny(name: <span class="hljs-string">&quot;Bo&quot;</span>, likesCarrots: <span class="hljs-literal">true</span>);
</code></pre>
<hr>
<h4>✅ مزیت تاریخی استفاده از سازنده‌ها</h4>
<ul>
<li>در گذشته استفاده از سازنده‌ها برای مقداردهی اولیه مزیت داشت، چون می‌توانستیم فیلدها یا propertyها را <strong>فقط-خواندنی (read-only)</strong> کنیم.</li>
<li>ایجاد فیلد یا property فقط‌خواندنی کار خوبی است وقتی که نیازی به تغییر مقدار آن در طول عمر شیء وجود ندارد.</li>
<li>اما از <strong>C# 9</strong> به بعد، با <strong>init modifier</strong> می‌توانیم همین هدف را با <strong>object initializer</strong> نیز محقق کنیم.</li>
</ul>
<hr>
<h4>❌ معایب پارامترهای اختیاری</h4>
<ol>
<li>
<p><strong>نداشتن پشتیبانی آسان از تغییرات غیرمخرب (nondestructive mutation)</strong></p>
<ul>
<li>سازنده با پارامترهای اختیاری اجازه‌ی تغییر بدون تخریب (immutable-friendly mutation) را به‌سادگی نمی‌دهد.</li>
<li>این مشکل در بخش <strong>Records</strong> (صفحه 227) حل خواهد شد.</li>
</ul>
</li>
<li>
<p><strong>مشکل در backward compatibility (سازگاری عقب‌رو)</strong></p>
<ul>
<li>وقتی از پارامترهای اختیاری در کتابخانه‌های عمومی استفاده شود، افزودن پارامتر اختیاری جدید در آینده باعث می‌شود <strong>سازگاری دودویی (binary compatibility)</strong> با مصرف‌کنندگان قبلی شکسته شود.</li>
<li>به‌خصوص در کتابخانه‌هایی که روی <strong>NuGet</strong> منتشر می‌شوند مشکل‌ساز است.</li>
</ul>
</li>
</ol>
<p>🔹 دلیل: مقدار پارامترهای اختیاری در <strong>کد فراخوانی‌کننده</strong> کامپایل و جایگزین می‌شود.<br>
مثال:</p>
<pre class="hljs"><code>Bunny b1 = <span class="hljs-keyword">new</span> Bunny(<span class="hljs-string">&quot;Bo&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);
</code></pre>
<p>اگر بعداً پارامتر جدیدی مانند <code>likesCats</code> اضافه شود، اسمبلی مصرف‌کننده که دوباره کامپایل نشده همچنان متدی با سه پارامتر را صدا می‌زند که دیگر وجود ندارد → خطا در زمان اجرا.</p>
<p>حتی تغییر مقدار پیش‌فرض یکی از پارامترهای اختیاری نیز مشکل ایجاد می‌کند: مصرف‌کنندگان قدیمی تا زمان بازکامپایل از مقدار قدیمی استفاده می‌کنند.</p>
<hr>
<h4>🔹 ملاحظه دیگر</h4>
<p>سازنده‌ها روی <strong>ارث‌بری (Inheritance)</strong> هم اثر می‌گذارند (بحث در صفحه 126).</p>
<ul>
<li>داشتن چند سازنده با لیست‌های طولانی پارامتر، زیرکلاس‌سازی را سخت می‌کند.</li>
<li>راه‌حل: تعداد و پیچیدگی سازنده‌ها را به حداقل برسانید و از <strong>object initializer</strong> برای جزئیات استفاده کنید.</li>
</ul>
<hr>
<h3>🔹 مرجع <code>this</code></h3>
<p>کلمه‌ی کلیدی <code>this</code> به نمونه‌ی جاری (instance) اشاره می‌کند.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Panda</span>
{
    <span class="hljs-keyword">public</span> Panda Mate;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Marry</span>(<span class="hljs-params">Panda partner</span>)</span>
    {
        Mate = partner;
        partner.Mate = <span class="hljs-keyword">this</span>;
    }
}
</code></pre>
<p>همچنین <code>this</code> برای رفع ابهام میان فیلد و پارامتر/متغیر محلی استفاده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> =&gt; <span class="hljs-keyword">this</span>.name = name;
}
</code></pre>
<p>📌 مرجع <code>this</code> فقط در اعضای <strong>nonstatic</strong> کلاس یا struct معتبر است.</p>
<hr>
<h3>🔹 ویژگی‌ها (Properties)</h3>
<p>ویژگی‌ها (<strong>Properties</strong>) از بیرون شبیه فیلدها به نظر می‌رسند، اما در درون منطق دارند (مثل متدها).</p>
<p>مثال:</p>
<pre class="hljs"><code>Stock msft = <span class="hljs-keyword">new</span> Stock();
msft.CurrentPrice = <span class="hljs-number">30</span>;
msft.CurrentPrice -= <span class="hljs-number">3</span>;
Console.WriteLine(msft.CurrentPrice);
</code></pre>
<p>در ظاهر معلوم نیست که <code>CurrentPrice</code> یک فیلد است یا property.</p>
<p>🔸 تعریف property:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span>
{
    <span class="hljs-built_in">decimal</span> currentPrice;    <span class="hljs-comment">// فیلد خصوصی (backing field)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> CurrentPrice   <span class="hljs-comment">// property عمومی</span>
    {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> currentPrice; }
        <span class="hljs-keyword">set</span> { currentPrice = <span class="hljs-keyword">value</span>; }
    }
}
</code></pre>
<ul>
<li><strong>get accessor</strong> وقتی property خوانده می‌شود اجرا می‌شود.</li>
<li><strong>set accessor</strong> وقتی مقداردهی می‌شود اجرا می‌شود و پارامتر ضمنی <code>value</code> دارد.</li>
</ul>
<p>📌 تفاوت اصلی با فیلدها:</p>
<ul>
<li>property امکان کنترل کامل روی خواندن/نوشتن مقدار را به برنامه‌نویس می‌دهد.</li>
<li>مثلاً می‌توان در setter بررسی کرد که مقدار ورودی در بازه معتبر باشد، و در غیر این صورت خطا پرتاب کرد.</li>
</ul>
<hr>
<h3>🔹 اصلاح‌کننده‌های مجاز روی Properties</h3>
<ul>
<li><strong>Static modifier:</strong> <code>static</code></li>
<li><strong>Access modifiers:</strong> <code>public internal private protected</code></li>
<li><strong>Inheritance modifiers:</strong> <code>new virtual abstract override sealed</code></li>
<li><strong>Unmanaged code modifiers:</strong> <code>unsafe extern</code></li>
</ul>
<hr>
<h3>🔹 ویژگی‌های فقط‌خواندنی و محاسباتی (Read-only and calculated properties)</h3>
<ul>
<li>اگر فقط <strong>get accessor</strong> تعریف شود → property فقط‌خواندنی است.</li>
<li>اگر فقط <strong>set accessor</strong> تعریف شود → property فقط‌نوشتنی است (به ندرت استفاده می‌شود).</li>
<li>property می‌تواند از داده‌های دیگر محاسبه شود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">decimal</span> currentPrice, sharesOwned;
<span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Worth
{
    <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> currentPrice * sharesOwned; }
}
</code></pre>
<hr>
<h3>🔹 ویژگی‌های Expression-Bodied</h3>
<p>برای نوشتن کوتاه‌تر propertyهای فقط‌خواندنی:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Worth =&gt; currentPrice * sharesOwned;
</code></pre>
<p>حتی setter هم می‌تواند expression-bodied باشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Worth
{
    <span class="hljs-keyword">get</span> =&gt; currentPrice * sharesOwned;
    <span class="hljs-keyword">set</span> =&gt; sharesOwned = <span class="hljs-keyword">value</span> / currentPrice;
}
</code></pre>
<hr>
<h3>🔹 ویژگی‌های خودکار (Automatic Properties)</h3>
<p>رایج‌ترین نوع property، ساده‌ترین پیاده‌سازی است: فقط خواندن/نوشتن به یک فیلد خصوصی.</p>
<p>به جای نوشتن دستی، می‌توان از property خودکار استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> CurrentPrice { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<ul>
<li>کامپایلر به طور خودکار یک <strong>backing field خصوصی</strong> تولید می‌کند.</li>
<li>می‌توان setter را <strong>private</strong> یا <strong>protected</strong> کرد تا property برای دیگران فقط‌خواندنی باشد.</li>
</ul>
<p>📌 ویژگی‌های خودکار از C# 3.0 معرفی شدند.</p>
<hr>
<h3>🔹 مقداردهی اولیه property (Property Initializers)</h3>
<p>propertyهای خودکار می‌توانند مستقیماً مقدار اولیه داشته باشند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> CurrentPrice { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">123</span>;
</code></pre>
<ul>
<li>اینجا مقدار اولیه‌ی <code>CurrentPrice</code> برابر با 123 است.</li>
<li>property با initializer می‌تواند <strong>فقط‌خواندنی</strong> هم باشد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Maximum { <span class="hljs-keyword">get</span>; } = <span class="hljs-number">999</span>;
</code></pre>
<p>مانند فیلدهای readonly، propertyهای خودکار readonly نیز می‌توانند در <strong>constructor</strong> مقداردهی شوند.<br>
این قابلیت برای ساختن <strong>انواع immutable (فقط‌خواندنی)</strong> بسیار کاربردی است.</p>
<h3>🔹 دسترسی در get و set (get and set accessibility)</h3>
<p>در C# می‌توان <strong>سطح دسترسی</strong> (accessibility) متدهای <code>get</code> و <code>set</code> یک property را متفاوت تعریف کرد.</p>
<p>📌 کاربرد رایج: داشتن یک property عمومی (<strong>public</strong>) با یک setter خصوصی یا داخلی (<strong>private/internal</strong>).</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">decimal</span> x;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> X
    {
        <span class="hljs-keyword">get</span>         { <span class="hljs-keyword">return</span> x; }
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span> { x = Math.Round(<span class="hljs-keyword">value</span>, <span class="hljs-number">2</span>); }
    }
}
</code></pre>
<p>🔑 دقت کنید: property خودش سطح دسترسی بازتر (اینجا <code>public</code>) دارد، اما setter سطح دسترسی محدودتر (<code>private</code>).</p>
<hr>
<h3>🔹 Setterهای فقط-init (Init-only setters)</h3>
<p>از <strong>C# 9</strong> می‌توان به جای <code>set</code> از <strong>init</strong> استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Note</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Pitch    { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; } = <span class="hljs-number">20</span>;   <span class="hljs-comment">// property فقط-init</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Duration { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; } = <span class="hljs-number">100</span>;  <span class="hljs-comment">// property فقط-init</span>
}
</code></pre>
<ul>
<li>این propertyها مانند read-only عمل می‌کنند، اما می‌توانند با <strong>object initializer</strong> مقداردهی شوند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> note = <span class="hljs-keyword">new</span> Note { Pitch = <span class="hljs-number">50</span> };
</code></pre>
<ul>
<li>بعد از آن دیگر نمی‌توان مقدار را تغییر داد:</li>
</ul>
<pre class="hljs"><code>note.Pitch = <span class="hljs-number">200</span>;   <span class="hljs-comment">// ❌ خطا – setter فقط-init</span>
</code></pre>
<ul>
<li>حتی از داخل کلاس هم قابل تغییر نیستند (مگر در initializer، constructor یا یک accessor دیگر از نوع init).</li>
</ul>
<hr>
<h3>🔹 جایگزین init-only properties</h3>
<p>راه جایگزین، تعریف propertyهای فقط‌خواندنی و مقداردهی آن‌ها در constructor است:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Note</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Pitch    { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Duration { <span class="hljs-keyword">get</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Note</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> pitch = <span class="hljs-number">20</span>, <span class="hljs-built_in">int</span> duration = <span class="hljs-number">100</span></span>)</span>
    {
        Pitch = pitch; Duration = duration;
    }
}
</code></pre>
<p>❗ مشکل: اگر این کلاس در یک <strong>کتابخانه عمومی</strong> باشد، افزودن پارامتر اختیاری جدید به constructor باعث شکستن <strong>سازگاری دودویی (binary compatibility)</strong> می‌شود.<br>
اما افزودن یک <strong>property فقط-init</strong> هیچ مشکلی ایجاد نمی‌کند.</p>
<hr>
<h3>🔹 مزایای init-only properties</h3>
<ul>
<li>پشتیبانی از <strong>nondestructive mutation</strong> وقتی با <strong>records</strong> استفاده شوند (بخش Records، صفحه 227).</li>
<li>امکان پیاده‌سازی setter با منطق داخلی:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Note</span>
{
    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> _pitch;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Pitch { <span class="hljs-keyword">get</span> =&gt; _pitch; <span class="hljs-keyword">init</span> =&gt; _pitch = <span class="hljs-keyword">value</span>; }
}
</code></pre>
<p>💡 نکته: حتی می‌توان فیلدهای <strong>readonly</strong> را در setter فقط-init تغییر داد. این باعث می‌شود کلاس <strong>immutable داخلی</strong> باقی بماند.</p>
<p>⚠ تغییر یک accessor از <code>init</code> به <code>set</code> (یا برعکس) یک <strong>تغییر سازگاری‌شکن (binary breaking change)</strong> است. بنابراین اسمبلی‌های دیگر باید دوباره کامپایل شوند.</p>
<hr>
<h3>🔹 پیاده‌سازی property در CLR</h3>
<p>در سطح CLR، propertyها به متدهایی تبدیل می‌شوند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> get_CurrentPrice {...}
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set_CurrentPrice</span> (<span class="hljs-params"><span class="hljs-built_in">decimal</span> <span class="hljs-keyword">value</span></span>)</span> {...}
</code></pre>
<ul>
<li>یک accessor از نوع <code>init</code> مثل <code>set</code> پردازش می‌شود، اما یک flag اضافه در متادیتا دارد.</li>
<li>propertyهای ساده و غیرمجازی توسط <strong>JIT compiler</strong> inline می‌شوند (یعنی فراخوانی متد با بدنه‌اش جایگزین می‌شود).</li>
<li>در نتیجه، دسترسی به property و فیلد از نظر کارایی <strong>هیچ تفاوتی ندارد</strong>.</li>
</ul>
<hr>
<h3>🔹 ایندکسرها (Indexers)</h3>
<p>ایندکسرها语 🌟 اجازه می‌دهند یک کلاس یا struct مثل آرایه رفتار کند.</p>
<p>📌 <code>string</code> یک ایندکسر دارد که اجازه می‌دهد با استفاده از یک اندیس عددی به هر <code>char</code> دسترسی پیدا کنید:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;hello&quot;</span>;
Console.WriteLine(s[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// h</span>
Console.WriteLine(s[<span class="hljs-number">3</span>]);  <span class="hljs-comment">// l</span>
</code></pre>
<ul>
<li>ایندکسرها مثل property هستند، اما به جای نام، با <strong>اندیس (index argument)</strong> صدا زده می‌شوند.</li>
<li>اندیس می‌تواند از هر نوعی باشد، نه فقط عدد صحیح.</li>
<li>همان modifierهای property را دارند (<code>public, private, static, ...</code>).</li>
<li>می‌توانند به صورت <strong>null-شرطی</strong> استفاده شوند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">string</span> s = <span class="hljs-literal">null</span>;
Console.WriteLine(s?[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// چیزی چاپ نمی‌شود، خطایی هم رخ نمی‌دهد</span>
</code></pre>
<hr>
<h3>🔹 پیاده‌سازی ایندکسر</h3>
<p>برای تعریف ایندکسر، یک property با نام <code>this</code> می‌سازیم و پارامترها را داخل کروشه قرار می‌دهیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Sentence</span>
{
    <span class="hljs-built_in">string</span>[] words = <span class="hljs-string">&quot;The quick brown fox&quot;</span>.Split();
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> wordNum]   <span class="hljs-comment">// ایندکسر</span>
    {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> words[wordNum]; }
        <span class="hljs-keyword">set</span> { words[wordNum] = <span class="hljs-keyword">value</span>; }
    }
}
</code></pre>
<p>مثال استفاده:</p>
<pre class="hljs"><code>Sentence s = <span class="hljs-keyword">new</span> Sentence();
Console.WriteLine(s[<span class="hljs-number">3</span>]);   <span class="hljs-comment">// fox</span>
s[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;kangaroo&quot;</span>;
Console.WriteLine(s[<span class="hljs-number">3</span>]);   <span class="hljs-comment">// kangaroo</span>
</code></pre>
<ul>
<li>یک کلاس می‌تواند چندین ایندکسر با نوع پارامترهای متفاوت داشته باشد.</li>
<li>ایندکسر می‌تواند بیش از یک پارامتر بگیرد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> arg1, <span class="hljs-built_in">string</span> arg2]
{
    <span class="hljs-keyword">get</span> { ... }
    <span class="hljs-keyword">set</span> { ... }
}
</code></pre>
<ul>
<li>اگر setter حذف شود → ایندکسر فقط‌خواندنی می‌شود.</li>
<li>می‌توان با <strong>expression-bodied</strong> نوشت:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> wordNum] =&gt; words[wordNum];
</code></pre>
<hr>
<h3>🔹 پیاده‌سازی ایندکسر در CLR</h3>
<p>ایندکسرها به متدهای زیر کامپایل می‌شوند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">get_Item</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> wordNum</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set_Item</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> wordNum, <span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span> {...}
</code></pre>
<hr>
<h3>🔹 استفاده از Indices و Ranges در ایندکسرها</h3>
<p>می‌توان ایندکسرهایی برای <code>Index</code> و <code>Range</code> تعریف کرد (بخش Indices and Ranges، صفحه 63).</p>
<p>مثال توسعه کلاس Sentence:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">this</span>[Index index] =&gt; words[index];
<span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>[] <span class="hljs-keyword">this</span>[Range range] =&gt; words[range];
</code></pre>
<p>مثال استفاده:</p>
<pre class="hljs"><code>Sentence s = <span class="hljs-keyword">new</span> Sentence();
Console.WriteLine(s[^<span class="hljs-number">1</span>]);          <span class="hljs-comment">// fox</span>
<span class="hljs-built_in">string</span>[] firstTwoWords = s[.<span class="hljs-number">.2</span>];   <span class="hljs-comment">// (The, quick)</span>
</code></pre>
<h3>🔹 سازنده‌های اصلی (Primary Constructors) در #C 12</h3>
<p>از نسخه‌ی <strong>#C 12</strong> می‌توانید یک لیست پارامتر را مستقیماً بعد از تعریف یک کلاس (یا struct) قرار دهید:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> (<span class="hljs-title">string</span> <span class="hljs-title">firstName</span>, <span class="hljs-title">string</span> <span class="hljs-title">lastName</span>)
{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span> =&gt; Console.WriteLine(firstName + <span class="hljs-string">&quot; &quot;</span> + lastName);
}
</code></pre>
<p>این کار به کامپایلر دستور می‌دهد که به‌طور خودکار یک <strong>سازنده‌ی اصلی (primary constructor)</strong> با استفاده از پارامترهای <code>firstName</code> و <code>lastName</code> بسازد. در نتیجه می‌توانیم کلاس خود را به این شکل نمونه‌سازی کنیم:</p>
<pre class="hljs"><code>Person p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Jones&quot;</span>);
p.Print();    <span class="hljs-comment">// Alice Jones</span>
</code></pre>
<p>⚡ سازنده‌های اصلی برای <strong>نمونه‌سازی سریع (prototyping)</strong> و سناریوهای ساده مفید هستند.<br>
روش جایگزین این است که فیلدها را تعریف کرده و یک سازنده معمولی بنویسید:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>    <span class="hljs-comment">// (بدون primary constructor)</span>
{
  <span class="hljs-built_in">string</span> firstName, lastName;   <span class="hljs-comment">// تعریف فیلدها</span>

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> firstName, <span class="hljs-built_in">string</span> lastName</span>)   <span class="hljs-comment">// سازنده</span></span>
  {
    <span class="hljs-keyword">this</span>.firstName = firstName;   <span class="hljs-comment">// انتساب به فیلد</span>
    <span class="hljs-keyword">this</span>.lastName = lastName;     <span class="hljs-comment">// انتساب به فیلد</span>
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span> =&gt; Console.WriteLine(firstName + <span class="hljs-string">&quot; &quot;</span> + lastName);
}
</code></pre>
<p>سازنده‌ای که توسط #C ساخته می‌شود، <strong>اصلی (primary)</strong> نامیده می‌شود، زیرا هر سازنده دیگری که خودتان به‌طور صریح تعریف کنید، <strong>باید آن را فراخوانی کند</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> (<span class="hljs-title">string</span> <span class="hljs-title">firstName</span>, <span class="hljs-title">string</span> <span class="hljs-title">lastName</span>)
{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> firstName, <span class="hljs-built_in">string</span> lastName, <span class="hljs-built_in">int</span> age</span>)
    : <span class="hljs-title">this</span>(<span class="hljs-params">firstName, lastName</span>)   <span class="hljs-comment">// باید primary constructor فراخوانی شود</span></span>
  {
  }
  ...
}
</code></pre>
<p>این باعث می‌شود پارامترهای سازنده‌ی اصلی همیشه مقداردهی شوند ✅.</p>
<hr>
<h3>📝 نکته درباره‌ی <strong>Records</strong></h3>
<p>در #C علاوه بر کلاس‌ها، <strong>Records</strong> هم وجود دارند (در صفحه‌ی 227 توضیح داده شده است).<br>
Records نیز از <strong>primary constructor</strong> پشتیبانی می‌کنند، اما کامپایلر یک مرحله‌ی اضافه انجام می‌دهد: برای هر پارامتر سازنده‌ی اصلی، به‌طور پیش‌فرض یک <strong>property عمومی با init-only</strong> تولید می‌کند.<br>
اگر چنین رفتاری مدنظر شماست، بهتر است از <strong>Record</strong> استفاده کنید.</p>
<hr>
<h3>⚠️ محدودیت‌های Primary Constructor</h3>
<p>این سازنده‌ها بیشتر برای سناریوهای ساده مناسب‌اند، زیرا:</p>
<ol>
<li>نمی‌توانید کد اضافی برای مقداردهی اولیه داخل primary constructor اضافه کنید.</li>
<li>اگر بخواهید پارامترها را به‌عنوان property عمومی منتشر کنید، اضافه کردن <strong>منطق اعتبارسنجی (validation logic)</strong> آسان نیست (مگر property فقط خواندنی باشد).</li>
</ol>
<p>🔸 همچنین سازنده‌ی اصلی جایگزین <strong>سازنده‌ی پیش‌فرض بدون پارامتر</strong> می‌شود که در حالت عادی #C تولید می‌کرد.</p>
<hr>
<h3>📌 رفتار سازنده‌ی اصلی در مقایسه با سازنده معمولی</h3>
<p>در یک سازنده معمولی:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> firstName, <span class="hljs-built_in">string</span> lastName</span>)</span>
  {
    <span class="hljs-comment">// انجام عملیات با firstName, lastName</span>
  }
}
</code></pre>
<p>وقتی کد داخل سازنده تمام شد، پارامترها (<code>firstName</code> و <code>lastName</code>) از محدوده‌ی دید خارج می‌شوند و دیگر قابل دسترسی نیستند.</p>
<p>اما در <strong>primary constructor</strong>، پارامترها از محدوده خارج نمی‌شوند و می‌توان آن‌ها را در کل بدنه‌ی کلاس و طول عمر شیء استفاده کرد.</p>
<hr>
<h3>⚙️ فیلدها و Property‌ها در Primary Constructor</h3>
<p>دسترسی پارامترها به <strong>initializerها</strong> نیز گسترش می‌یابد:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> (<span class="hljs-title">string</span> <span class="hljs-title">firstName</span>, <span class="hljs-title">string</span> <span class="hljs-title">lastName</span>)
{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> FirstName = firstName;  <span class="hljs-comment">// فیلد</span>
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName { <span class="hljs-keyword">get</span>; } = lastName;    <span class="hljs-comment">// Property</span>
}
</code></pre>
<hr>
<h3>🎭 ماسک‌گذاری (Masking) پارامترها</h3>
<p>فیلدها یا Propertyها می‌توانند همان نام پارامترها را بگیرند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> (<span class="hljs-title">string</span> <span class="hljs-title">firstName</span>, <span class="hljs-title">string</span> <span class="hljs-title">lastName</span>)
{
  <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> firstName = firstName;
  <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> lastName = lastName;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span> =&gt; Console.WriteLine(firstName + <span class="hljs-string">&quot; &quot;</span> + lastName);
}
</code></pre>
<p>در این حالت، فیلد یا property بر پارامتر <strong>اولویت دارد</strong> (پارامتر را mask می‌کند)، مگر در سمت راست initializerها.</p>
<hr>
<h3>✨ اعتبارسنجی و پردازش مقادیر</h3>
<p>مثال ذخیره‌سازی FullName با محاسبه در initializer:</p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Jones&quot;</span>).Print();   <span class="hljs-comment">// Alice Jones</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> (<span class="hljs-title">string</span> <span class="hljs-title">firstName</span>, <span class="hljs-title">string</span> <span class="hljs-title">lastName</span>)
{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> FullName = firstName + <span class="hljs-string">&quot; &quot;</span> + lastName;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span> =&gt; Console.WriteLine(FullName);
}
</code></pre>
<p>مثال ذخیره‌ی مقدار uppercase برای <code>lastName</code>:</p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Jones&quot;</span>).Print();   <span class="hljs-comment">// Alice JONES</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> (<span class="hljs-title">string</span> <span class="hljs-title">firstName</span>, <span class="hljs-title">string</span> <span class="hljs-title">lastName</span>)
{
  <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> lastName = lastName.ToUpper();
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span> =&gt; Console.WriteLine(firstName + <span class="hljs-string">&quot; &quot;</span> + lastName);
}
</code></pre>
<hr>
<h3>🚨 اعتبارسنجی با استثنا (Exception)</h3>
<p>می‌توان از <strong>throw expression</strong> در initializer استفاده کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-literal">null</span>);   <span class="hljs-comment">// ArgumentNullException</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> (<span class="hljs-title">string</span> <span class="hljs-title">firstName</span>, <span class="hljs-title">string</span> <span class="hljs-title">lastName</span>)
{
  <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> lastName = (lastName == <span class="hljs-literal">null</span>)
    ? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-string">&quot;lastName&quot;</span>)
    : lastName;
}
</code></pre>
<p>(به یاد داشته باشید: initializerها هنگام ساخته شدن شیء اجرا می‌شوند، نه هنگام دسترسی به فیلد یا property.)</p>
<hr>
<h3>🔄 انتشار پارامتر به‌عنوان Property با set</h3>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> (<span class="hljs-title">string</span> <span class="hljs-title">firstName</span>, <span class="hljs-title">string</span> <span class="hljs-title">lastName</span>)
{
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = lastName;
}
</code></pre>
<p>اما در این حالت اعتبارسنجی ساده نیست، چون باید هم در <strong>set accessor</strong> و هم در <strong>initializer</strong> اعتبارسنجی را پیاده‌سازی کنید (همین مشکل برای init-only هم وجود دارد).<br>
در چنین شرایطی بهتر است از <strong>سازنده‌های معمولی و فیلدهای پشتیبان (backing fields)</strong> استفاده کنید.</p>
<h3>⚡ سازنده‌های استاتیک (Static Constructors)</h3>
<p>🔹 یک <strong>static constructor</strong> فقط یک بار برای هر <strong>نوع (type)</strong> اجرا می‌شود (نه برای هر نمونه).<br>
یک نوع فقط می‌تواند <strong>یک سازنده‌ی استاتیک</strong> داشته باشد، این سازنده باید بدون پارامتر باشد و نام آن دقیقاً همان نام کلاس باشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Test</span>()</span> { Console.WriteLine(<span class="hljs-string">&quot;Type Initialized&quot;</span>); }
}
</code></pre>
<p>زمان اجرا (runtime) این سازنده‌ی استاتیک را <strong>به‌طور خودکار درست قبل از اولین استفاده از نوع</strong> فراخوانی می‌کند. دو چیز این سازنده را فعال می‌کند:</p>
<ol>
<li>نمونه‌سازی از نوع 🆕</li>
<li>دسترسی به یک عضو استاتیک در آن نوع ⚙️</li>
</ol>
<p>🔸 تنها <strong>modifier</strong>هایی که در سازنده‌ی استاتیک مجاز هستند عبارت‌اند از: <code>unsafe</code> و <code>extern</code>.</p>
<p>🚨 اگر یک سازنده‌ی استاتیک استثنای مدیریت‌نشده (unhandled exception) پرتاب کند، آن <strong>نوع تا پایان عمر برنامه غیرقابل‌استفاده می‌شود</strong>.</p>
<hr>
<h3>🏗️ Module Initializers (از #C 9)</h3>
<p>از نسخه‌ی <strong>#C 9</strong> می‌توانید <strong>Module Initializer</strong> تعریف کنید که یک بار برای هر <strong>assembly</strong> و هنگام بارگذاری آن اجرا می‌شود:</p>
<pre class="hljs"><code>[<span class="hljs-meta">System.Runtime.CompilerServices.ModuleInitializer</span>]
<span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitAssembly</span>()</span>
{
  ...
}
</code></pre>
<hr>
<h3>📌 سازنده‌های استاتیک و ترتیب مقداردهی فیلدها</h3>
<ul>
<li>مقداردهی اولیه‌ی فیلدهای استاتیک دقیقاً قبل از فراخوانی سازنده‌ی استاتیک اجرا می‌شود.</li>
<li>اگر نوعی سازنده‌ی استاتیک نداشته باشد، مقداردهی اولیه‌ی فیلدها درست قبل از اولین استفاده از نوع (یا زودتر، بسته به تصمیم runtime) انجام می‌شود.</li>
<li>مقداردهی اولیه‌ی فیلدها به ترتیبی است که تعریف شده‌اند.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> X = Y;   <span class="hljs-comment">// 0</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Y = <span class="hljs-number">3</span>;   <span class="hljs-comment">// 3</span>
}
</code></pre>
<p>اگر جای این دو خط را عوض کنیم، هر دو برابر 3 می‌شوند.</p>
<hr>
<p>مثال دیگر:</p>
<pre class="hljs"><code>Console.WriteLine(Foo.X);    <span class="hljs-comment">// 3</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Foo Instance = <span class="hljs-keyword">new</span> Foo();
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> X = <span class="hljs-number">3</span>;

  Foo() =&gt; Console.WriteLine(X);   <span class="hljs-comment">// 0</span>
}
</code></pre>
<p>در اینجا ابتدا <strong>0</strong> و سپس <strong>3</strong> چاپ می‌شود.<br>
اگر جای دو خط پررنگ را عوض کنیم، خروجی <strong>3 و 3</strong> خواهد بود.</p>
<hr>
<h3>🏷️ کلاس‌های استاتیک (Static Classes)</h3>
<ul>
<li>
<p>کلاسی که با <code>static</code> علامت‌گذاری شده باشد:</p>
<ul>
<li>نمی‌توان از آن نمونه ساخت 🚫</li>
<li>نمی‌تواند زیرکلاس شود 🚫</li>
<li>باید فقط شامل <strong>اعضای استاتیک</strong> باشد.</li>
</ul>
</li>
</ul>
<p>📖 نمونه‌های معروف: <code>System.Console</code> و <code>System.Math</code>.</p>
<hr>
<h3>🗑️ Finalizers</h3>
<p><strong>Finalizer</strong> متدی است که درست قبل از آزاد شدن حافظه‌ی یک شیء توسط <strong>Garbage Collector</strong> اجرا می‌شود.</p>
<p>سینتکس: نام کلاس همراه با <code>~</code></p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span>
{
  ~Class1()
  {
    ...
  }
}
</code></pre>
<p>این در واقع معادل بازنویسی متد <code>Finalize</code> از کلاس <code>Object</code> است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Finalize</span>()</span>
{
  ...
  <span class="hljs-keyword">base</span>.Finalize();
}
</code></pre>
<p>📌 توضیحات کامل درباره‌ی garbage collection و finalizerها در فصل 12 خواهد آمد.</p>
<p>می‌توانید finalizer تک‌خطی هم بنویسید:</p>
<pre class="hljs"><code>~Class1() =&gt; Console.WriteLine(<span class="hljs-string">&quot;Finalizing&quot;</span>);
</code></pre>
<hr>
<h3>🧩 Partial Types و Partial Methods</h3>
<p>🔹 <strong>Partial types</strong> به شما اجازه می‌دهند تعریف یک نوع را به چند بخش (معمولاً در فایل‌های مختلف) تقسیم کنید.</p>
<p>سناریوی رایج:</p>
<ul>
<li>یک فایل auto-generated (مثلاً توسط Visual Studio Designer)</li>
<li>یک فایل دستی برای افزودن کد سفارشی</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// PaymentFormGen.cs - auto-generated</span>
<span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PaymentForm</span> { ... }

<span class="hljs-comment">// PaymentForm.cs - hand-authored</span>
<span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PaymentForm</span> { ... }
</code></pre>
<p>⚠️ هر بخش باید <code>partial</code> باشد. این کد غیرقانونی است:</p>
<pre class="hljs"><code><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PaymentForm</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">PaymentForm</span> {}
</code></pre>
<ul>
<li>اعضای تکراری (مثلاً سازنده با همان پارامترها) مجاز نیستند.</li>
<li><strong>partial types</strong> کاملاً در زمان کامپایل توسط کامپایلر ترکیب می‌شوند.</li>
<li>همه‌ی بخش‌ها باید در <strong>یک assembly</strong> باشند.</li>
<li>می‌توانید در برخی بخش‌ها base class مشخص کنید، به شرطی که یکی باشند.</li>
<li>هر بخش می‌تواند به‌طور مستقل interfaceها را پیاده‌سازی کند.</li>
</ul>
<hr>
<h3>🔧 Partial Methods</h3>
<p>یک <strong>partial type</strong> می‌تواند شامل <strong>partial method</strong> باشد. این‌ها معمولاً برای فراهم کردن hook در کد auto-generated استفاده می‌شوند:</p>
<pre class="hljs"><code><span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PaymentForm</span>    <span class="hljs-comment">// فایل auto-generated</span>
{
  <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ValidatePayment</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> amount</span>)</span>;
}

<span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PaymentForm</span>    <span class="hljs-comment">// فایل دستی</span>
{
  <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ValidatePayment</span>(<span class="hljs-params"><span class="hljs-built_in">decimal</span> amount</span>)</span>
  {
    <span class="hljs-keyword">if</span> (amount &gt; <span class="hljs-number">100</span>)
      ...
  }
}
</code></pre>
<ul>
<li>یک partial method شامل <strong>تعریف (definition)</strong> و <strong>پیاده‌سازی (implementation)</strong> است.</li>
<li>تعریف معمولاً توسط generator نوشته می‌شود؛ پیاده‌سازی دستی اضافه می‌شود.</li>
<li>اگر پیاده‌سازی ارائه نشود، هم تعریف و هم تمام فراخوانی‌های آن حذف می‌شوند ➝ هیچ هزینه‌ای برای کد ندارد ✅.</li>
<li>partial methodها باید <code>void</code> باشند و ذاتاً <code>private</code> هستند.</li>
<li>نمی‌توانند <code>out parameter</code> داشته باشند.</li>
</ul>
<h3>🧩 متدهای partial توسعه‌یافته (Extended Partial Methods)</h3>
<p>🔹 متدهای partial توسعه‌یافته (از C# 9 به بعد) برای سناریوی معکوس تولید کد طراحی شده‌اند؛ جایی که یک برنامه‌نویس <strong>hook</strong>‌هایی تعریف می‌کند که یک <strong>code generator</strong> آن‌ها را پیاده‌سازی می‌کند.<br>
یک نمونه از کاربرد این موضوع، <strong>source generators</strong> هستند (قابلیتی در Roslyn) که به شما اجازه می‌دهند اسمبلی‌ای را به کامپایلر بدهید تا به‌صورت خودکار بخش‌هایی از کد شما را تولید کند.</p>
<hr>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">M1</span>()</span>;    <span class="hljs-comment">// متد partial توسعه‌یافته</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">M2</span>()</span>;   <span class="hljs-comment">// متد partial توسعه‌یافته</span>
}
</code></pre>
<p>📌 اگر یک اعلان متد partial با یک <strong>accessibility modifier</strong> (مثل public یا private) آغاز شود، آن متد به‌عنوان یک متد partial توسعه‌یافته در نظر گرفته می‌شود.</p>
<p>نکات مهم:</p>
<ul>
<li>متدهای partial توسعه‌یافته <strong>حتماً باید پیاده‌سازی داشته باشند</strong>؛ اگر پیاده‌سازی نشوند، از بین نمی‌روند.</li>
<li>در مثال بالا، هم <code>M1</code> و هم <code>M2</code> باید پیاده‌سازی شوند.</li>
<li>این متدها می‌توانند <strong>هر نوع مقداری را برگردانند</strong> و همچنین می‌توانند <strong>پارامترهای out</strong> داشته باشند.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>
{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsValid</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> identifier</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">partial</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryParse</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> number, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> result</span>)</span>;
}
</code></pre>
<hr>
<h3>🏷️ عملگر nameof</h3>
<p>🔹 عملگر <code>nameof</code> نام هر <strong>symbol</strong> (مثل type، member، variable و …) را به‌صورت یک <strong>string</strong> برمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> count = <span class="hljs-number">123</span>;
<span class="hljs-built_in">string</span> name = <span class="hljs-keyword">nameof</span> (count);   <span class="hljs-comment">// مقدار name برابر است با &quot;count&quot;</span>
</code></pre>
<p>📌 مزیت اصلی <code>nameof</code> نسبت به نوشتن مستقیم یک رشته این است که از <strong>static type checking</strong> پشتیبانی می‌کند.<br>
ابزارهایی مثل <strong>Visual Studio</strong> این ارجاع را می‌شناسند، بنابراین اگر شما نام symbol را تغییر دهید، تمام ارجاعات آن نیز به‌طور خودکار تغییر خواهند کرد.</p>
<p>مثال برای <strong>field</strong> یا <strong>property</strong>:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> name = <span class="hljs-keyword">nameof</span> (StringBuilder.Length);  <span class="hljs-comment">// خروجی: &quot;Length&quot;</span>
</code></pre>
<p>اگر بخواهید <code>&quot;StringBuilder.Length&quot;</code> را کامل برگردانید:</p>
<pre class="hljs"><code><span class="hljs-keyword">nameof</span> (StringBuilder) + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-keyword">nameof</span> (StringBuilder.Length);
</code></pre>
<hr>
<h3>🏛️ وراثت (Inheritance)</h3>
<p>🔹 یک کلاس می‌تواند از کلاس دیگری <strong>ارث‌بری (inherit)</strong> کند تا آن را گسترش یا سفارشی‌سازی کند.<br>
با ارث‌بری می‌توان از امکانات یک کلاس استفاده کرد بدون اینکه از صفر همه‌چیز را بسازید.</p>
<ul>
<li>یک کلاس فقط می‌تواند از یک کلاس ارث‌بری کند.</li>
<li>اما خودش می‌تواند توسط چندین کلاس دیگر ارث‌بری شود (تشکیل <strong>class hierarchy</strong>).</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Asset</span>
{
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span> : <span class="hljs-title">Asset</span>     <span class="hljs-comment">// inherits from Asset</span>
{
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> SharesOwned;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">House</span> : <span class="hljs-title">Asset</span>     <span class="hljs-comment">// inherits from Asset</span>
{
  <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Mortgage;
}
</code></pre>
<p>نحوه‌ی استفاده:</p>
<pre class="hljs"><code>Stock msft = <span class="hljs-keyword">new</span> Stock { Name=<span class="hljs-string">&quot;MSFT&quot;</span>, SharesOwned=<span class="hljs-number">1000</span> };
Console.WriteLine (msft.Name);        <span class="hljs-comment">// MSFT</span>
Console.WriteLine (msft.SharesOwned); <span class="hljs-comment">// 1000</span>

House mansion = <span class="hljs-keyword">new</span> House { Name=<span class="hljs-string">&quot;Mansion&quot;</span>, Mortgage=<span class="hljs-number">250000</span> };
Console.WriteLine (mansion.Name);     <span class="hljs-comment">// Mansion</span>
Console.WriteLine (mansion.Mortgage); <span class="hljs-comment">// 250000</span>
</code></pre>
<p>📌 کلاس‌های <code>Stock</code> و <code>House</code> فیلد <code>Name</code> را از کلاس پایه‌ی <code>Asset</code> به ارث می‌برند.</p>
<ul>
<li>کلاس مشتق‌شده = <strong>subclass</strong></li>
<li>کلاس پایه = <strong>superclass</strong></li>
</ul>
<hr>
<h3>🔄 چندریختی (Polymorphism)</h3>
<p>🔹 در C# مراجع (<strong>references</strong>) چندریختی هستند.<br>
این یعنی یک متغیر از نوع <code>x</code> می‌تواند به یک شیء از نوعی که زیرکلاس <code>x</code> است اشاره کند.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span> (<span class="hljs-params">Asset asset</span>)</span>
{
  System.Console.WriteLine (asset.Name);
}

Stock msft    = <span class="hljs-keyword">new</span> Stock { Name=<span class="hljs-string">&quot;MSFT&quot;</span> };
House mansion = <span class="hljs-keyword">new</span> House { Name=<span class="hljs-string">&quot;Mansion&quot;</span> };

Display (msft);     <span class="hljs-comment">// OK</span>
Display (mansion);  <span class="hljs-comment">// OK</span>
</code></pre>
<p>📌 دلیلش این است که کلاس‌های مشتق‌شده (<code>Stock</code> و <code>House</code>) همه‌ی ویژگی‌های کلاس پایه (<code>Asset</code>) را دارند.</p>
<p>اما برعکس درست نیست:</p>
<pre class="hljs"><code>Display (<span class="hljs-keyword">new</span> Asset());   <span class="hljs-comment">// خطای زمان کامپایل</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span> (<span class="hljs-params">House house</span>)</span>
{
  System.Console.WriteLine (house.Mortgage);
}
</code></pre>
<hr>
<h3>🎭 Casting و Reference Conversions</h3>
<p>یک مرجع (object reference) می‌تواند:</p>
<ul>
<li>به‌طور <strong>ضمنی (implicit)</strong> به کلاس پایه <strong>upcast</strong> شود.</li>
<li>به‌طور <strong>صریح (explicit)</strong> به زیرکلاس <strong>downcast</strong> شود.</li>
</ul>
<p>📌 Upcast و Downcast بین انواع سازگار مرجع، درواقع یک <strong>reference conversion</strong> انجام می‌دهند:<br>
یعنی یک مرجع جدید ساخته می‌شود که به همان شیء اشاره می‌کند.</p>
<ul>
<li>Upcast همیشه موفق است ✅</li>
<li>Downcast فقط وقتی موفق است که شیء واقعاً از نوع مناسب باشد ⚠️</li>
</ul>
<hr>
<h4>🔼 Upcasting</h4>
<pre class="hljs"><code>Stock msft = <span class="hljs-keyword">new</span> Stock();
Asset a = msft;     <span class="hljs-comment">// Upcast</span>
</code></pre>
<p>در اینجا، هر دو متغیر <code>a</code> و <code>msft</code> به همان شیء از نوع <code>Stock</code> اشاره می‌کنند:</p>
<pre class="hljs"><code>Console.WriteLine (a == msft);   <span class="hljs-comment">// True</span>
Console.WriteLine (a.Name);      <span class="hljs-comment">// OK</span>
Console.WriteLine (a.SharesOwned); <span class="hljs-comment">// خطای زمان کامپایل</span>
</code></pre>
<p>📌 دلیل خطای آخر: متغیر <code>a</code> از نوع <code>Asset</code> است، بنابراین فقط می‌تواند اعضای <code>Asset</code> را ببیند.<br>
برای دسترسی به <code>SharesOwned</code> باید شیء را به <code>Stock</code> <strong>downcast</strong> کنید.</p>
<h3>🔽 Downcasting</h3>
<p><strong>Downcast</strong> عملیاتی است که یک مرجع کلاس پایه را به مرجع کلاس مشتق‌شده تبدیل می‌کند:</p>
<pre class="hljs"><code>Stock msft = <span class="hljs-keyword">new</span> Stock();
Asset a = msft;        <span class="hljs-comment">// Upcast</span>
Stock s = (Stock)a;    <span class="hljs-comment">// Downcast</span>
Console.WriteLine(s.SharesOwned); <span class="hljs-comment">// بدون خطا</span>
Console.WriteLine(s == a);        <span class="hljs-comment">// True</span>
Console.WriteLine(s == msft);     <span class="hljs-comment">// True</span>
</code></pre>
<ul>
<li>مانند <strong>Upcast</strong>، فقط مرجع تغییر می‌کند و شیء اصلی تغییری نمی‌کند.</li>
<li><strong>Downcast</strong> نیاز به cast صریح دارد، زیرا ممکن است در زمان اجرا شکست بخورد:</li>
</ul>
<pre class="hljs"><code>House h = <span class="hljs-keyword">new</span> House();
Asset a = h;        <span class="hljs-comment">// Upcast همیشه موفق</span>
Stock s = (Stock)a; <span class="hljs-comment">// Downcast شکست می‌خورد، چون a از نوع Stock نیست</span>
</code></pre>
<p>⚠️ اگر Downcast شکست بخورد، یک <strong>InvalidCastException</strong> پرتاب می‌شود.</p>
<hr>
<h3>🔹 عملگر <code>as</code></h3>
<ul>
<li>انجام Downcast بدون پرتاب Exception در صورت شکست:</li>
</ul>
<pre class="hljs"><code>Asset a = <span class="hljs-keyword">new</span> Asset();
Stock s = a <span class="hljs-keyword">as</span> Stock; <span class="hljs-comment">// s برابر null است، بدون Exception</span>
</code></pre>
<ul>
<li>این مفید است وقتی می‌خواهید نتیجه را قبل از استفاده بررسی کنید:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)
    Console.WriteLine(s.SharesOwned);
</code></pre>
<p>💡 تفاوت با cast صریح:</p>
<ul>
<li><code>cast</code> → اطمینان از نوع دارید، اگر اشتباه باشد Exception پرتاب می‌شود.</li>
<li><code>as</code> → نوع مطمئن نیست، می‌توانید بر اساس null تصمیم بگیرید.</li>
</ul>
<p>⚠️ محدودیت‌ها:</p>
<ul>
<li>نمی‌تواند تبدیل سفارشی یا عددی انجام دهد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">long</span> x = <span class="hljs-number">3</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">long</span>; <span class="hljs-comment">// خطای کامپایل</span>
</code></pre>
<hr>
<h3>🔹 عملگر <code>is</code></h3>
<ul>
<li>بررسی می‌کند که یک متغیر با نوع یا الگوی مشخص مطابقت دارد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">is</span> Stock)
    Console.WriteLine(((Stock)a).SharesOwned);
</code></pre>
<ul>
<li>می‌توان همزمان با معرفی یک متغیر استفاده کرد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">is</span> Stock s)
    Console.WriteLine(s.SharesOwned);
</code></pre>
<ul>
<li>این متغیر حتی خارج از شرط نیز در محدوده‌ی قابل دسترسی باقی می‌ماند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">is</span> Stock s &amp;&amp; s.SharesOwned &gt; <span class="hljs-number">100000</span>)
    Console.WriteLine(<span class="hljs-string">&quot;Wealthy&quot;</span>);
<span class="hljs-keyword">else</span>
    s = <span class="hljs-keyword">new</span> Stock();

Console.WriteLine(s.SharesOwned); <span class="hljs-comment">// هنوز در محدوده است</span>
</code></pre>
<hr>
<h3>🔹 Virtual Function Members</h3>
<ul>
<li>متد، پراپرتی، ایندکسر و event می‌توانند <strong>virtual</strong> باشند تا کلاس‌های مشتق آن‌ها را <strong>override</strong> کنند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Asset</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">decimal</span> Liability =&gt; <span class="hljs-number">0</span>; <span class="hljs-comment">// Expression-bodied property</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span> : <span class="hljs-title">Asset</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> SharesOwned;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">House</span> : <span class="hljs-title">Asset</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Mortgage;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">decimal</span> Liability =&gt; Mortgage;
}
</code></pre>
<pre class="hljs"><code>House mansion = <span class="hljs-keyword">new</span> House { Name=<span class="hljs-string">&quot;McMansion&quot;</span>, Mortgage=<span class="hljs-number">250000</span> };
Asset a = mansion;

Console.WriteLine(mansion.Liability); <span class="hljs-comment">// 250000</span>
Console.WriteLine(a.Liability);       <span class="hljs-comment">// 250000</span>
</code></pre>
<p>⚠️ <strong>توجه:</strong> فراخوانی متد virtual از داخل constructor می‌تواند خطرناک باشد، زیرا کلاس مشتق ممکن است هنوز به طور کامل مقداردهی نشده باشد.</p>
<hr>
<h3>🔹 Covariant Return Types (C# 9)</h3>
<ul>
<li>از C# 9 می‌توان متد را override کرد تا نوع بازگشتی <strong>مشتق شده‌تر</strong> داشته باشد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Asset</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Asset <span class="hljs-title">Clone</span>()</span> =&gt; <span class="hljs-keyword">new</span> Asset { Name = Name };
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">House</span> : <span class="hljs-title">Asset</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Mortgage;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> House <span class="hljs-title">Clone</span>()</span> =&gt; <span class="hljs-keyword">new</span> House { Name = Name, Mortgage = Mortgage };
}
</code></pre>
<ul>
<li>قبل از C# 9، نوع بازگشتی باید دقیقاً همان نوع پایه می‌بود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Asset <span class="hljs-title">Clone</span>()</span> =&gt; <span class="hljs-keyword">new</span> House { Name = Name, Mortgage = Mortgage };
</code></pre>
<ul>
<li>برای استفاده از ویژگی‌های House، Downcast لازم بود:</li>
</ul>
<pre class="hljs"><code>House mansion1 = <span class="hljs-keyword">new</span> House { Name=<span class="hljs-string">&quot;McMansion&quot;</span>, Mortgage=<span class="hljs-number">250000</span> };
House mansion2 = (House)mansion1.Clone();
</code></pre>
<h3>🔹 Abstract Classes and Abstract Members</h3>
<ul>
<li>یک کلاس <strong>abstract</strong> هیچ‌گاه نمی‌تواند نمونه‌سازی شود؛ تنها زیرکلاس‌های <strong>concrete</strong> می‌توانند نمونه ایجاد کنند.</li>
<li>کلاس‌های abstract می‌توانند <strong>abstract members</strong> داشته باشند که شبیه virtual هستند، اما پیاده‌سازی پیش‌فرض ندارند. زیرکلاس موظف است آن‌ها را پیاده‌سازی کند مگر اینکه خودش هم abstract باشد.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Asset</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">decimal</span> NetValue { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span> : <span class="hljs-title">Asset</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> SharesOwned;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> CurrentPrice;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">decimal</span> NetValue =&gt; CurrentPrice * SharesOwned;
}
</code></pre>
<hr>
<h3>🔹 Hiding Inherited Members</h3>
<ul>
<li>اگر کلاس پایه و کلاس مشتق <strong>عضوهای هم‌نام</strong> داشته باشند، عضو کلاس مشتق، عضو کلاس پایه را <strong>مخفی می‌کند</strong>.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span> { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Counter = <span class="hljs-number">1</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">A</span> { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Counter = <span class="hljs-number">2</span>; }
</code></pre>
<ul>
<li>کامپایلر هشدار می‌دهد، اما می‌توان با <strong>modifer <code>new</code></strong> به صورت عمدی مخفی‌سازی کرد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">A</span> { <span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> Counter = <span class="hljs-number">2</span>; }
</code></pre>
<ul>
<li><code>new</code> در این زمینه فقط هشدار کامپایلر را حذف می‌کند و قصد برنامه‌نویس را مشخص می‌کند.</li>
</ul>
<hr>
<h3>🔹 <code>new</code> versus <code>override</code></h3>
<ul>
<li><code>override</code> → جایگزینی یک متد virtual در کلاس پایه</li>
<li><code>new</code> → مخفی کردن یک عضو هم‌نام بدون override</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> { Console.WriteLine(<span class="hljs-string">&quot;BaseClass.Foo&quot;</span>); }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Overrider</span> : <span class="hljs-title">BaseClass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> { Console.WriteLine(<span class="hljs-string">&quot;Overrider.Foo&quot;</span>); }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Hider</span> : <span class="hljs-title">BaseClass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> { Console.WriteLine(<span class="hljs-string">&quot;Hider.Foo&quot;</span>); }
}
</code></pre>
<pre class="hljs"><code>Overrider over = <span class="hljs-keyword">new</span> Overrider();
BaseClass b1 = over;
over.Foo(); <span class="hljs-comment">// Overrider.Foo</span>
b1.Foo();   <span class="hljs-comment">// Overrider.Foo</span>

Hider h = <span class="hljs-keyword">new</span> Hider();
BaseClass b2 = h;
h.Foo();    <span class="hljs-comment">// Hider.Foo</span>
b2.Foo();   <span class="hljs-comment">// BaseClass.Foo</span>
</code></pre>
<hr>
<h3>🔹 Sealing Functions and Classes</h3>
<ul>
<li>با <code>sealed</code> می‌توان <strong>یک متد override را مسدود</strong> کرد تا توسط کلاس‌های مشتق دیگر override نشود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">decimal</span> Liability { <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> Mortgage; } }
</code></pre>
<ul>
<li>همچنین می‌توان <strong>یک کلاس را sealed</strong> کرد تا امکان subclassing آن نباشد.</li>
</ul>
<p>⚠️ نمی‌توان یک عضو را در برابر <strong>مخفی شدن با <code>new</code></strong> مسدود کرد.</p>
<hr>
<h3>🔹 The <code>base</code> Keyword</h3>
<ul>
<li>
<p><code>base</code> مشابه <code>this</code> است، اما برای موارد زیر استفاده می‌شود:</p>
<ol>
<li>دسترسی به پیاده‌سازی <strong>overridden</strong> کلاس پایه</li>
<li>فراخوانی <strong>constructor</strong> کلاس پایه</li>
</ol>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">House</span> : <span class="hljs-title">Asset</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Mortgage;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">decimal</span> Liability =&gt; <span class="hljs-keyword">base</span>.Liability + Mortgage;
}
</code></pre>
<ul>
<li>با <code>base</code> به نسخه کلاس پایه دسترسی غیر virtual داریم و در صورت پنهان شدن عضو هم کار می‌کند.</li>
</ul>
<hr>
<h3>🔹 Constructors and Inheritance</h3>
<ul>
<li>زیرکلاس باید <strong>constructor خودش</strong> را تعریف کند. constructor های کلاس پایه به طور خودکار به کلاس مشتق منتقل نمی‌شوند.</li>
<li>برای استفاده از constructor کلاس پایه، از <code>base</code> استفاده می‌کنیم:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Baseclass</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Baseclass</span>()</span> { }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Baseclass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> =&gt; X = x;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subclass</span> : <span class="hljs-title">Baseclass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Subclass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">x</span>)</span> { }
}
</code></pre>
<ul>
<li><strong>Base-class constructors همیشه اول اجرا می‌شوند</strong> تا ابتدا مقداردهی کلاس پایه کامل شود.</li>
</ul>
<h3>🔹 Implicit Calling of the Parameterless Base-Class Constructor</h3>
<ul>
<li>اگر در <strong>زیرکلاس</strong> از <code>base</code> استفاده نکنیم، <strong>constructor بدون پارامتر کلاس پایه</strong> به‌صورت ضمنی فراخوانی می‌شود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Baseclass</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Baseclass</span>()</span> { X = <span class="hljs-number">1</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subclass</span> : <span class="hljs-title">Baseclass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Subclass</span>()</span> { Console.WriteLine(X); }  <span class="hljs-comment">// 1</span>
}
</code></pre>
<ul>
<li>اگر کلاس پایه <strong>constructor بدون پارامتر نداشته باشد</strong>، زیرکلاس مجبور است از <code>base</code> استفاده کند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Baseclass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Baseclass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y, <span class="hljs-built_in">int</span> z, <span class="hljs-built_in">string</span> s, DateTime d</span>)</span> { ... }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subclass</span> : <span class="hljs-title">Baseclass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Subclass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y, <span class="hljs-built_in">int</span> z, <span class="hljs-built_in">string</span> s, DateTime d</span>)
        : <span class="hljs-title">base</span>(<span class="hljs-params">x, y, z, s, d</span>)</span> { ... }
}
</code></pre>
<hr>
<h3>🔹 Required Members (C# 11)</h3>
<ul>
<li>با استفاده از <strong>required members</strong> می‌توان الزام کرد که یک فیلد یا property حتماً هنگام ساخت شیء مقداردهی شود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Asset</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">required</span> <span class="hljs-built_in">string</span> Name;
}

Asset a1 = <span class="hljs-keyword">new</span> Asset { Name=<span class="hljs-string">&quot;House&quot;</span> };  <span class="hljs-comment">// OK</span>
Asset a2 = <span class="hljs-keyword">new</span> Asset();                 <span class="hljs-comment">// Error</span>
</code></pre>
<ul>
<li>می‌توان با <code>[SetsRequiredMembers]</code> این محدودیت را در constructor دور زد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Asset</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">required</span> <span class="hljs-built_in">string</span> Name;

    [<span class="hljs-meta">System.Diagnostics.CodeAnalysis.SetsRequiredMembers</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Asset</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> n</span>)</span> =&gt; Name = n;
}
</code></pre>
<ul>
<li>این امکان اجازه می‌دهد که هم از <strong>object initializer</strong> و هم از constructor استفاده شود.</li>
</ul>
<hr>
<h3>🔹 Constructor and Field Initialization Order</h3>
<p>هنگام نمونه‌سازی، <strong>ترتیب مقداردهی</strong> به شکل زیر است:</p>
<ol>
<li>
<p><strong>از زیرکلاس به کلاس پایه</strong><br>
a. فیلدهای زیرکلاس مقداردهی می‌شوند<br>
b. آرگومان‌های فراخوانی constructor پایه ارزیابی می‌شوند</p>
</li>
<li>
<p><strong>از کلاس پایه به زیرکلاس</strong><br>
a. بدنه constructor کلاس پایه اجرا می‌شود<br>
b. بدنه constructor زیرکلاس اجرا می‌شود</p>
</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B</span>
{
    <span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>;          <span class="hljs-comment">// 3rd</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">B</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> { ... } <span class="hljs-comment">// 4th</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">D</span> : <span class="hljs-title">B</span>
{
    <span class="hljs-built_in">int</span> y = <span class="hljs-number">1</span>;          <span class="hljs-comment">// 1st</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">D</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">x + <span class="hljs-number">1</span></span>) <span class="hljs-comment">// 2nd</span></span>
    {
        ...              <span class="hljs-comment">// 5th</span>
    }
}
</code></pre>
<hr>
<h3>🔹 Inheritance with Primary Constructors</h3>
<ul>
<li>کلاس‌ها با <strong>primary constructors</strong> می‌توانند به شکل زیر subclass شوند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Baseclass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> { ... }
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subclass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>) : <span class="hljs-title">Baseclass</span>(<span class="hljs-params">x</span>)</span> { ... }
</code></pre>
<ul>
<li>این همان کاری است که <code>base(x)</code> در constructor معمولی انجام می‌دهد.</li>
</ul>
<hr>
<h3>🔹 Overloading and Resolution</h3>
<ul>
<li>هنگام فراخوانی <strong>overloaded methods</strong>، <strong>نوع دقیق‌تر</strong> ارجحیت دارد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">Asset a</span>)</span> { }
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">House h</span>)</span> { }

House h = <span class="hljs-keyword">new</span> House(...);
Foo(h);  <span class="hljs-comment">// فراخوانی Foo(House)</span>
</code></pre>
<ul>
<li>اما <strong>تعیین overload</strong> بر اساس نوع <strong>استاتیک</strong> (compile-time) انجام می‌شود:</li>
</ul>
<pre class="hljs"><code>Asset a = <span class="hljs-keyword">new</span> House(...);
Foo(a);  <span class="hljs-comment">// فراخوانی Foo(Asset)</span>
</code></pre>
<ul>
<li>با استفاده از <code>dynamic</code>، تصمیم‌گیری <strong>تا زمان اجرا</strong> به تعویق می‌افتد:</li>
</ul>
<pre class="hljs"><code>Foo((<span class="hljs-built_in">dynamic</span>)a);  <span class="hljs-comment">// فراخوانی Foo(House) در زمان اجرا</span>
</code></pre>
<hr>
<h3>🔹 The <code>object</code> Type</h3>
<ul>
<li><code>object</code> پایه نهایی تمام نوع‌ها است. هر نوعی می‌تواند به <code>object</code> <strong>upcast</strong> شود.</li>
<li>مثال استفاده در یک <strong>Stack ساده</strong>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>
{
    <span class="hljs-built_in">int</span> position;
    <span class="hljs-built_in">object</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[<span class="hljs-number">10</span>];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span> { data[position++] = obj; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-title">Pop</span>()</span> { <span class="hljs-keyword">return</span> data[--position]; }
}

Stack stack = <span class="hljs-keyword">new</span> Stack();
stack.Push(<span class="hljs-string">&quot;sausage&quot;</span>);
<span class="hljs-built_in">string</span> s = (<span class="hljs-built_in">string</span>)stack.Pop();  <span class="hljs-comment">// نیاز به downcast</span>
Console.WriteLine(s);            <span class="hljs-comment">// sausage</span>

stack.Push(<span class="hljs-number">3</span>);
<span class="hljs-built_in">int</span> three = (<span class="hljs-built_in">int</span>)stack.Pop();    <span class="hljs-comment">// boxing/unboxing</span>
</code></pre>
<hr>
<h3>🔹 Boxing and Unboxing</h3>
<ul>
<li><strong>Boxing</strong> → تبدیل یک value type به object (یا interface):</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">9</span>;
<span class="hljs-built_in">object</span> obj = x;  <span class="hljs-comment">// boxing</span>
</code></pre>
<ul>
<li><strong>Unboxing</strong> → تبدیل object به value type (نیازمند cast صریح):</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">int</span> y = (<span class="hljs-built_in">int</span>)obj;  <span class="hljs-comment">// unboxing</span>
</code></pre>
<p>⚠️ نوع اعلام شده باید دقیقاً با نوع واقعی مطابقت داشته باشد، در غیر این صورت <code>InvalidCastException</code> رخ می‌دهد:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span> obj = <span class="hljs-number">9</span>;
<span class="hljs-built_in">long</span> x = (<span class="hljs-built_in">long</span>)obj; <span class="hljs-comment">// InvalidCastException</span>

<span class="hljs-built_in">long</span> x2 = (<span class="hljs-built_in">int</span>)obj; <span class="hljs-comment">// صحیح: unboxing سپس تبدیل عددی</span>
</code></pre>
<ul>
<li><strong>Boxing</strong> و <strong>Unboxing</strong> به نوع سیستم <strong>unified type system</strong> اجازه می‌دهد تا value و reference type ها را با هم کار کند، اما فقط برای <strong>reference conversions</strong> در آرایه‌ها و genericها صادق است:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">object</span>[] a1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">// OK</span>
<span class="hljs-built_in">object</span>[] a2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">3</span>];    <span class="hljs-comment">// Error</span>
</code></pre>
<ul>
<li><strong>Copy semantics</strong>: هنگام boxing/unboxing، مقدار کپی می‌شود، بنابراین تغییر value type اصلی تاثیری بر نسخه boxed ندارد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>;
<span class="hljs-built_in">object</span> boxed = i;
i = <span class="hljs-number">5</span>;
Console.WriteLine(boxed);  <span class="hljs-comment">// 3</span>
</code></pre>
<p>بررسی نوع به‌صورت <strong>استاتیک و زمان اجرا</strong> 🔍🖥️</p>
<p>برنامه‌های C# هم در زمان <strong>کامپایل</strong> (به‌صورت استاتیک) و هم در زمان <strong>اجرای برنامه</strong> (توسط CLR) بررسی نوع می‌شوند.</p>
<h3>بررسی نوع استاتیک</h3>
<p>بررسی نوع استاتیک به کامپایلر اجازه می‌دهد که <strong>درستی برنامه شما را بدون اجرای آن</strong> بررسی کند. برای مثال، کد زیر خطا خواهد داد، زیرا کامپایلر نوع‌دهی استاتیک را اعمال می‌کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-string">&quot;5&quot;</span>;  <span class="hljs-comment">// خطا: نوع صحیح نیست</span>
</code></pre>
<h3>بررسی نوع زمان اجرا</h3>
<p>بررسی نوع در زمان اجرا توسط <strong>CLR</strong> انجام می‌شود، مثلاً وقتی که شما یک <strong>downcast</strong> با استفاده از تبدیل مرجع یا <strong>unboxing</strong> انجام می‌دهید:</p>
<pre class="hljs"><code><span class="hljs-built_in">object</span> y = <span class="hljs-string">&quot;5&quot;</span>;
<span class="hljs-built_in">int</span> z = (<span class="hljs-built_in">int</span>)y;  <span class="hljs-comment">// خطای زمان اجرا، downcast ناموفق</span>
</code></pre>
<p>این بررسی ممکن است، زیرا هر شیء در حافظه heap به‌صورت داخلی <strong>یک توکن نوع کوچک</strong> ذخیره می‌کند. می‌توانید این توکن را با فراخوانی متد <code>GetType</code> از شیء دریافت کنید.</p>
<hr>
<h3>متد GetType و عملگر typeof 🏷️</h3>
<p>تمام انواع در C# در زمان اجرا با نمونه‌ای از <code>System.Type</code> نمایش داده می‌شوند. دو روش اصلی برای دریافت شیء <code>System.Type</code> وجود دارد:</p>
<ul>
<li>فراخوانی <code>GetType</code> روی نمونه</li>
<li>استفاده از عملگر <code>typeof</code> روی نام نوع</li>
</ul>
<p><code>GetType</code> در زمان اجرا ارزیابی می‌شود، اما <code>typeof</code> به‌صورت <strong>استاتیک</strong> در زمان کامپایل ارزیابی می‌شود (وقتی پارامترهای ژنریک در کار باشند، توسط <strong>JIT Compiler</strong> حل می‌شود).</p>
<pre class="hljs"><code>Point p = <span class="hljs-keyword">new</span> Point();
Console.WriteLine(p.GetType().Name);             <span class="hljs-comment">// Point</span>
Console.WriteLine(<span class="hljs-keyword">typeof</span>(Point).Name);          <span class="hljs-comment">// Point</span>
Console.WriteLine(p.GetType() == <span class="hljs-keyword">typeof</span>(Point)); <span class="hljs-comment">// True</span>
Console.WriteLine(p.X.GetType().Name);           <span class="hljs-comment">// Int32</span>
Console.WriteLine(p.Y.GetType().FullName);       <span class="hljs-comment">// System.Int32</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X, Y; }
</code></pre>
<p><code>System.Type</code> همچنین متدهایی دارد که دروازه‌ای به <strong>مدل Reflection زمان اجرا</strong> هستند (که در فصل 18 توضیح داده شده است).</p>
<hr>
<h3>متد ToString 📝</h3>
<p>متد <code>ToString</code> <strong>نمایش متنی پیش‌فرض</strong> یک نمونه از نوع را برمی‌گرداند. این متد در تمام انواع داخلی بازنویسی شده است:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>;
<span class="hljs-built_in">string</span> s = x.ToString(); <span class="hljs-comment">// s برابر با &quot;1&quot;</span>
</code></pre>
<p>می‌توانید <code>ToString</code> را روی انواع سفارشی خود بازنویسی کنید:</p>
<pre class="hljs"><code>Panda p = <span class="hljs-keyword">new</span> Panda { Name = <span class="hljs-string">&quot;Petey&quot;</span> };
Console.WriteLine(p);  <span class="hljs-comment">// Petey</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Panda</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span> =&gt; Name;
}
</code></pre>
<p>اگر <code>ToString</code> بازنویسی نشود، نام نوع را برمی‌گرداند.<br>
هنگام فراخوانی یک عضو بازنویسی‌شده مانند <code>ToString</code> روی نوع مقداری، <strong>boxing رخ نمی‌دهد</strong>، و تنها وقتی تبدیل انجام دهید، boxing اتفاق می‌افتد:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>;
<span class="hljs-built_in">string</span> s1 = x.ToString();    <span class="hljs-comment">// فراخوانی روی مقدار غیر-boxed</span>
<span class="hljs-built_in">object</span> box = x;
<span class="hljs-built_in">string</span> s2 = box.ToString();  <span class="hljs-comment">// فراخوانی روی مقدار boxed</span>
</code></pre>
<hr>
<h3>اعضای کلاس object 📦</h3>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Object</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Object</span>()</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">extern</span> Type <span class="hljs-title">GetType</span>()</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> objA, <span class="hljs-built_in">object</span> objB</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ReferenceEquals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> objA, <span class="hljs-built_in">object</span> objB</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>()</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span>;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Finalize</span>()</span>;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">object</span> <span class="hljs-title">MemberwiseClone</span>()</span>;
}
</code></pre>
<p>متدهای <code>Equals</code>، <code>ReferenceEquals</code> و <code>GetHashCode</code> در فصل &quot;Equality Comparison&quot; توضیح داده شده‌اند.</p>
<hr>
<h3>Struct ها 📐</h3>
<p>یک <code>struct</code> شبیه کلاس است با تفاوت‌های کلیدی زیر:</p>
<ul>
<li><code>struct</code> یک <strong>value type</strong> است، در حالی که کلاس یک <strong>reference type</strong> است.</li>
<li><code>struct</code> از <strong>وراثت</strong> پشتیبانی نمی‌کند (به جز به‌صورت ضمنی از <code>object</code> یا دقیق‌تر <code>System.ValueType</code>).</li>
</ul>
<p>یک struct می‌تواند تمام اعضایی را داشته باشد که کلاس دارد، به جز <strong>finalizer</strong>. همچنین نمی‌توان اعضای آن را <strong>virtual، abstract یا protected</strong> تعریف کرد.</p>
<p>قبل از C# 10، تعریف <strong>field initializer</strong> و <strong>constructor بدون پارامتر</strong> در struct‌ها ممنوع بود، اما حالا این محدودیت برای <strong>record struct</strong>ها برداشته شده است.</p>
<p>Structها برای زمانی مناسب هستند که <strong>رفتار نوع مقداری (value-type)</strong> مد نظر باشد، مانند انواع عددی که <strong>کپی مقدار</strong> به جای کپی مرجع طبیعی‌تر است. هر نمونه struct نیاز به ایجاد شیء در heap ندارد و این باعث صرفه‌جویی در حافظه می‌شود.</p>
<p>همچنین struct نمی‌تواند <code>null</code> باشد و مقدار پیش‌فرض آن، <strong>نمونه‌ای خالی با تمام فیلدها در مقدار پیش‌فرضشان</strong> است.</p>
<hr>
<h3>ساختار ساخت Struct 🏗️</h3>
<p>قبل از C# 11، هر فیلد struct باید به‌صورت <strong>صریح در constructor یا field initializer</strong> مقداردهی می‌شد. حالا این محدودیت برداشته شده است.</p>
<h4>Constructor پیش‌فرض</h4>
<p>علاوه بر constructorهای شما، یک <strong>constructor بدون پارامتر ضمنی</strong> همیشه وجود دارد که فیلدها را به‌صورت <strong>bitwise-zero</strong> مقداردهی می‌کند:</p>
<pre class="hljs"><code>Point p = <span class="hljs-keyword">new</span> Point();  <span class="hljs-comment">// p.X و p.Y برابر 0</span>
<span class="hljs-keyword">struct</span> Point { <span class="hljs-built_in">int</span> x, y; }
</code></pre>
<p>حتی اگر خودتان یک constructor بدون پارامتر تعریف کنید، constructor ضمنی همچنان وجود دارد و می‌توان با استفاده از <strong>default keyword</strong> به آن دسترسی پیدا کرد:</p>
<pre class="hljs"><code>Point p1 = <span class="hljs-keyword">new</span> Point();  <span class="hljs-comment">// p1.x و p1.y برابر 1</span>
Point p2 = <span class="hljs-literal">default</span>;      <span class="hljs-comment">// p2.x و p2.y برابر 0</span>

<span class="hljs-keyword">struct</span> Point
{
    <span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">int</span> y;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>()</span> =&gt; y = <span class="hljs-number">1</span>;
}
</code></pre>
<p>در این مثال، x با <strong>field initializer</strong> و y با <strong>constructor بدون پارامتر</strong> مقداردهی شده است، اما با <code>default</code> می‌توان نمونه‌ای ساخت که هر دو مقداردهی را نادیده بگیرد.</p>
<hr>
<h3>استراتژی پیشنهادی برای Struct</h3>
<p>بهترین روش این است که struct را طوری طراحی کنید که <strong>مقدار پیش‌فرض آن یک حالت معتبر</strong> باشد و نیازی به مقداردهی اضافی نباشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> WebOptions
{
    <span class="hljs-built_in">string</span> protocol;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Protocol
    {
        <span class="hljs-keyword">get</span> =&gt; protocol ?? <span class="hljs-string">&quot;https&quot;</span>;
        <span class="hljs-keyword">set</span> =&gt; protocol = <span class="hljs-keyword">value</span>;
    }
}
</code></pre>
<p>این روش باعث <strong>سادگی و جلوگیری از رفتار گیج‌کننده</strong> هنگام مقداردهی می‌شود. ✅</p>
<p>ساختارهای <strong>خواندنی (Read-Only Structs) و توابع</strong> 📌🖊️</p>
<p>می‌توانید از <strong>modifer <code>readonly</code></strong> روی یک struct استفاده کنید تا اطمینان حاصل شود که <strong>تمام فیلدها فقط خواندنی هستند</strong>. این کار هم نیت شما را واضح می‌کند و هم به کامپایلر اجازه می‌دهد بهینه‌سازی‌های بیشتری انجام دهد:</p>
<pre class="hljs"><code><span class="hljs-keyword">readonly</span> <span class="hljs-keyword">struct</span> Point
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> X, Y;  <span class="hljs-comment">// X و Y باید readonly باشند</span>
}
</code></pre>
<p>اگر نیاز دارید <code>readonly</code> را با جزئیات بیشتری اعمال کنید، از C# 8 به بعد می‌توانید <strong>توابع struct</strong> را با <code>readonly</code> علامت‌گذاری کنید. این کار باعث می‌شود اگر تابع تلاش کند فیلدی را تغییر دهد، <strong>خطای زمان کامپایل</strong> صادر شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> Point
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X, Y;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ResetX</span>()</span> =&gt; X = <span class="hljs-number">0</span>;  <span class="hljs-comment">// خطا!</span>
}
</code></pre>
<p>اگر یک تابع <code>readonly</code>، تابع غیر-readonly دیگری را فراخوانی کند، کامپایلر <strong>هشدار</strong> صادر می‌کند و struct را به‌صورت محافظه‌کارانه کپی می‌کند تا احتمال تغییر ناخواسته جلوگیری شود.</p>
<hr>
<h3>Ref Structs 💎</h3>
<p><strong>Ref struct</strong>ها در C# 7.2 معرفی شدند و ویژگی‌ای خاص برای <strong>Span<T></strong> و <strong>ReadOnlySpan<T></strong> فراهم می‌کنند که در فصل 23 توضیح داده شده‌اند (و همچنین Utf8JsonReader در فصل 11). این structها به <strong>میکروبهینه‌سازی حافظه</strong> کمک می‌کنند.</p>
<ul>
<li>برخلاف <strong>reference type</strong>ها که همیشه روی heap قرار دارند، <strong>value type</strong>ها در همان مکانی که اعلام شده‌اند زندگی می‌کنند.</li>
<li>اگر value type به‌صورت پارامتر یا متغیر محلی باشد، روی <strong>stack</strong> قرار می‌گیرد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SomeMethod</span>()</span>
{
    Point p;  <span class="hljs-comment">// p روی stack قرار می‌گیرد</span>
}
<span class="hljs-keyword">struct</span> Point { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X, Y; }
</code></pre>
<ul>
<li>اگر value type به‌عنوان فیلد یک کلاس باشد، روی <strong>heap</strong> قرار می‌گیرد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>
{
    Point p;  <span class="hljs-comment">// روی heap، زیرا MyClass روی heap است</span>
}
</code></pre>
<ul>
<li>اضافه کردن <code>ref</code> به تعریف struct تضمین می‌کند که struct <strong>تنها روی stack قرار گیرد</strong>. اگر تلاش شود روی heap باشد، خطای زمان کامپایل رخ می‌دهد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> points = <span class="hljs-keyword">new</span> Point[<span class="hljs-number">100</span>];  <span class="hljs-comment">// خطا: کامپایل نمی‌شود</span>
<span class="hljs-keyword">ref</span> <span class="hljs-keyword">struct</span> Point { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X, Y; }
<span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> { Point P; }    <span class="hljs-comment">// خطا: کامپایل نمی‌شود</span>
</code></pre>
<p>Ref structها به دلیل محدودیت در زندگی روی stack، نمی‌توانند در ویژگی‌هایی شرکت کنند که ممکن است باعث قرارگیری روی heap شوند، مانند <strong>lambda expressionها، iteratorها و توابع async</strong>. همچنین نمی‌توانند در structهای غیر-ref باشند و نمی‌توانند interface پیاده‌سازی کنند (چون ممکن است boxing رخ دهد).</p>
<hr>
<h3>Access Modifiers 🔐</h3>
<p>برای <strong>محدود کردن دسترسی</strong> یک نوع یا عضو نوع به سایر نوع‌ها یا اسمبلی‌ها، می‌توان <strong>access modifier</strong> استفاده کرد:</p>
<ul>
<li><code>public</code>: دسترسی کامل. برای اعضای enum یا interface پیش‌فرض است.</li>
<li><code>internal</code>: فقط در اسمبلی جاری یا friend assembly قابل دسترسی است.</li>
<li><code>private</code>: فقط در داخل نوع جاری قابل دسترسی است.</li>
<li><code>protected</code>: فقط در داخل نوع جاری یا subclasses قابل دسترسی است.</li>
<li><code>protected internal</code>: اتحاد <code>protected</code> و <code>internal</code>.</li>
<li><code>private protected</code>: اشتراک <code>protected</code> و <code>internal</code>.</li>
<li><code>file</code> (C# 11): فقط در همان فایل قابل دسترسی است.</li>
</ul>
<p><strong>مثال‌ها:</strong></p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span> {}            <span class="hljs-comment">// internal (پیش‌فرض)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Class2</span> {}     <span class="hljs-comment">// public</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span> { <span class="hljs-built_in">int</span> x; }          <span class="hljs-comment">// x private</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">ClassB</span> { <span class="hljs-keyword">internal</span> <span class="hljs-built_in">int</span> x; } <span class="hljs-comment">// x internal</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> {}           <span class="hljs-comment">// private</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>()</span> {}
}
<span class="hljs-keyword">class</span> <span class="hljs-title">Subclass</span> : <span class="hljs-title">BaseClass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test1</span>()</span> { Foo(); } <span class="hljs-comment">// خطا: نمی‌توان به Foo دسترسی داشت</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test2</span>()</span> { Bar(); } <span class="hljs-comment">// درست</span>
}
</code></pre>
<hr>
<h3>Friend Assemblies 🤝</h3>
<p>می‌توانید اعضای <strong>internal</strong> را به سایر friend assemblyها با استفاده از attribute زیر در سطح اسمبلی در دسترس قرار دهید:</p>
<pre class="hljs"><code>[<span class="hljs-meta">assembly: InternalsVisibleTo(<span class="hljs-string">&quot;Friend&quot;</span>)</span>]
</code></pre>
<p>اگر assembly دارای <strong>strong name</strong> باشد، باید کل کلید عمومی 160 بایتی آن را مشخص کنید:</p>
<pre class="hljs"><code>[<span class="hljs-meta">assembly: InternalsVisibleTo(<span class="hljs-string">&quot;StrongFriend, PublicKey=0024f000048c...&quot;</span>)</span>]
</code></pre>
<hr>
<h3>محدودیت‌ها و Capping دسترسی</h3>
<ul>
<li>نوع، دسترسی اعضای اعلام شده خود را محدود می‌کند. مثلاً یک نوع internal با اعضای public، در عمل اعضای آن را internal می‌کند.</li>
<li>هنگام override کردن یک تابع base، <strong>دسترسی باید یکسان باشد</strong>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span> { <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> {} }
<span class="hljs-keyword">class</span> <span class="hljs-title">Subclass1</span> : <span class="hljs-title">BaseClass</span> { <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> {} } <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Subclass2</span> : <span class="hljs-title">BaseClass</span> { <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> {} }     <span class="hljs-comment">// خطا</span>
</code></pre>
<p>کامپایلر از هرگونه <strong>ناسازگاری در access modifiers</strong> جلوگیری می‌کند. به طور مثال، یک subclass می‌تواند کمتر از base class دسترسی داشته باشد، اما نمی‌تواند بیشتر داشته باشد:</p>
<pre class="hljs"><code><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-title">A</span> {}  <span class="hljs-comment">// خطا</span>
</code></pre>
<p><strong>Interfaces (رابطه‌ها) 🧩</strong></p>
<p>یک <strong>interface</strong> شبیه یک کلاس است، اما تنها رفتار (Behavior) را مشخص می‌کند و <strong>حالت (State)</strong> یا داده نگه نمی‌دارد. بنابراین:</p>
<ul>
<li>یک interface تنها می‌تواند <strong>توابع</strong> تعریف کند و نمی‌تواند <strong>فیلد</strong> داشته باشد.</li>
<li>اعضای interface به‌صورت ضمنی <strong>abstract</strong> هستند. (استثناهایی وجود دارد که در بخش «Default Interface Members» صفحه 151 و «Static Interface Members» صفحه 152 توضیح داده شده‌اند.)</li>
<li>یک کلاس یا struct می‌تواند چندین interface را پیاده‌سازی کند. در مقابل، یک کلاس تنها می‌تواند از یک کلاس دیگر ارث‌بری کند و struct اصلاً نمی‌تواند ارث‌بری کند (به جز از System.ValueType).</li>
</ul>
<p>تعریف یک interface شبیه تعریف کلاس است، اما معمولاً هیچ پیاده‌سازی برای اعضای خود ارائه نمی‌دهد، زیرا اعضای آن به‌صورت ضمنی abstract هستند. این اعضا توسط کلاس‌ها و structهایی که interface را پیاده‌سازی می‌کنند، پیاده‌سازی می‌شوند. یک interface می‌تواند تنها شامل <strong>توابع، متدها، properties، events و indexerها</strong> باشد (که دقیقاً همان اعضای کلاس هستند که می‌توانند abstract باشند).</p>
<p>مثال تعریف interface <code>IEnumerator</code> در System.Collections:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEnumerator</span>
{
    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span>;
    <span class="hljs-built_in">object</span> Current { <span class="hljs-keyword">get</span>; }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span>;
}
</code></pre>
<p>اعضای interface همیشه <strong>ضمنی public</strong> هستند و نمی‌توانند access modifier اعلام کنند. پیاده‌سازی یک interface یعنی <strong>ارائه پیاده‌سازی public</strong> برای تمام اعضای آن:</p>
<pre class="hljs"><code><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Countdown</span> : <span class="hljs-title">IEnumerator</span>
{
    <span class="hljs-built_in">int</span> count = <span class="hljs-number">11</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span> =&gt; count-- &gt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current =&gt; count;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotSupportedException(); }
}
</code></pre>
<p>می‌توانید یک شیء را به هر interface که پیاده‌سازی می‌کند، <strong>به‌صورت ضمنی cast کنید</strong>:</p>
<pre class="hljs"><code>IEnumerator e = <span class="hljs-keyword">new</span> Countdown();
<span class="hljs-keyword">while</span> (e.MoveNext())
    Console.Write(e.Current);  <span class="hljs-comment">// 109876543210</span>
</code></pre>
<p>حتی اگر Countdown یک کلاس internal باشد، اعضای آن که IEnumerator را پیاده‌سازی می‌کنند می‌توانند <strong>به‌صورت public</strong> فراخوانی شوند.</p>
<hr>
<h3>گسترش یک Interface ➕</h3>
<p>Interfaces می‌توانند از سایر interfaceها ارث‌بری کنند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUndoable</span> { <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Undo</span>()</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IRedoable</span> : <span class="hljs-title">IUndoable</span> { <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Redo</span>()</span>; }
</code></pre>
<p>در این مثال، IRedoable تمام اعضای IUndoable را «به ارث می‌برد». یعنی هر نوعی که IRedoable را پیاده‌سازی کند، باید اعضای IUndoable را نیز پیاده‌سازی کند.</p>
<hr>
<h3>پیاده‌سازی صریح Interface 🔒</h3>
<p>پیاده‌سازی چند interface گاهی باعث <strong>تداخل در امضاهای اعضا</strong> می‌شود. می‌توانید این تداخل‌ها را با <strong>پیاده‌سازی صریح</strong> حل کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title">I1</span> { <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title">I2</span> { <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Foo</span>()</span>; }

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> : <span class="hljs-title">I1</span>, <span class="hljs-title">I2</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;Widget&#x27;s implementation of I1.Foo&quot;</span>);
    }
    <span class="hljs-built_in">int</span> I2.Foo()
    {
        Console.WriteLine(<span class="hljs-string">&quot;Widget&#x27;s implementation of I2.Foo&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
    }
}
</code></pre>
<ul>
<li>چون I1 و I2 دارای Foo با امضاهای متفاوت هستند، Widget <strong>صریحاً I2.Foo</strong> را پیاده‌سازی می‌کند.</li>
<li>تنها راه فراخوانی یک عضو پیاده‌سازی صریح، <strong>cast به interface</strong> است:</li>
</ul>
<pre class="hljs"><code>Widget w = <span class="hljs-keyword">new</span> Widget();
w.Foo();         <span class="hljs-comment">// Widget&#x27;s implementation of I1.Foo</span>
((I1)w).Foo();   <span class="hljs-comment">// Widget&#x27;s implementation of I1.Foo</span>
((I2)w).Foo();   <span class="hljs-comment">// Widget&#x27;s implementation of I2.Foo</span>
</code></pre>
<p>یکی دیگر از دلایل پیاده‌سازی صریح، <strong>مخفی کردن اعضای تخصصی و گیج‌کننده</strong> برای استفاده معمولی نوع است، مانند ISerializable.</p>
<hr>
<h3>پیاده‌سازی مجازی Interface Members ⚡</h3>
<p>یک عضو interface که به‌طور ضمنی پیاده‌سازی شده است، به‌صورت پیش‌فرض <strong>sealed</strong> است و برای override شدن باید در کلاس پایه <strong>virtual یا abstract</strong> علامت‌گذاری شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUndoable</span> { <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Undo</span>()</span>; }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TextBox</span> : <span class="hljs-title">IUndoable</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Undo</span>()</span> =&gt; Console.WriteLine(<span class="hljs-string">&quot;TextBox.Undo&quot;</span>);
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RichTextBox</span> : <span class="hljs-title">TextBox</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Undo</span>()</span> =&gt; Console.WriteLine(<span class="hljs-string">&quot;RichTextBox.Undo&quot;</span>);
}
</code></pre>
<p>فراخوانی عضو interface از طریق کلاس پایه یا interface، <strong>پیاده‌سازی subclass</strong> را صدا می‌زند:</p>
<pre class="hljs"><code>RichTextBox r = <span class="hljs-keyword">new</span> RichTextBox();
r.Undo();                <span class="hljs-comment">// RichTextBox.Undo</span>
((IUndoable)r).Undo();   <span class="hljs-comment">// RichTextBox.Undo</span>
((TextBox)r).Undo();     <span class="hljs-comment">// RichTextBox.Undo</span>
</code></pre>
<p>یک عضو پیاده‌سازی صریح <strong>نمی‌تواند virtual باشد</strong> و نمی‌توان آن را به‌طور معمول override کرد، اما می‌توان آن را <strong>reimplement</strong> کرد.</p>
<hr>
<h3>پیاده‌سازی مجدد Interface در Subclass 🔄</h3>
<p>یک subclass می‌تواند هر عضو interface که قبلاً توسط کلاس پایه پیاده‌سازی شده است را <strong>reimplement</strong> کند. پیاده‌سازی مجدد وقتی که از طریق interface صدا زده شود، جایگزین پیاده‌سازی کلاس پایه می‌شود و فرقی ندارد عضو <strong>virtual</strong> باشد یا خیر.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUndoable</span> { <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Undo</span>()</span>; }

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TextBox</span> : <span class="hljs-title">IUndoable</span>
{
    <span class="hljs-keyword">void</span> IUndoable.Undo() =&gt; Console.WriteLine(<span class="hljs-string">&quot;TextBox.Undo&quot;</span>);
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RichTextBox</span> : <span class="hljs-title">TextBox</span>, <span class="hljs-title">IUndoable</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Undo</span>()</span> =&gt; Console.WriteLine(<span class="hljs-string">&quot;RichTextBox.Undo&quot;</span>);
}
</code></pre>
<ul>
<li>فراخوانی عضو reimplemented از طریق interface، پیاده‌سازی subclass را صدا می‌زند:</li>
</ul>
<pre class="hljs"><code>RichTextBox r = <span class="hljs-keyword">new</span> RichTextBox();
r.Undo();                 <span class="hljs-comment">// RichTextBox.Undo      Case 1</span>
((IUndoable)r).Undo();    <span class="hljs-comment">// RichTextBox.Undo      Case 2</span>
</code></pre>
<p>اگر TextBox عضو Undo را به‌صورت <strong>ضمنی پیاده‌سازی</strong> می‌کرد، فراخوانی از طریق کلاس پایه نیز ممکن بود و باعث <strong>ناسازگاری</strong> می‌شد:</p>
<pre class="hljs"><code>((TextBox)r).Undo();      <span class="hljs-comment">// TextBox.Undo</span>
</code></pre>
<p>✅ نکته: پیاده‌سازی مجدد معمولاً <strong>بهترین استراتژی برای override کردن اعضای صریح interface</strong> است، زیرا تنها وقتی که عضو از طریق interface صدا زده شود، اثر می‌کند و از رفتار ناسازگار جلوگیری می‌کند.<br>
<strong>جایگزین‌های پیاده‌سازی مجدد Interface 🔄</strong></p>
<p>حتی با پیاده‌سازی صریح اعضا، پیاده‌سازی مجدد interface می‌تواند مشکل‌ساز باشد به چند دلیل:</p>
<ul>
<li><strong>زیرکلاس هیچ راهی برای فراخوانی متد کلاس پایه ندارد.</strong></li>
<li><strong>نویسنده کلاس پایه ممکن است انتظار نداشته باشد که یک متد reimplement شود</strong> و پیامدهای احتمالی آن را در نظر نگیرد.</li>
</ul>
<p>پیاده‌سازی مجدد می‌تواند به عنوان آخرین راه حل در مواقعی که subclassing پیش‌بینی نشده است مفید باشد. اما گزینه بهتر، طراحی کلاس پایه به گونه‌ای است که <strong>هرگز نیاز به reimplementation نباشد</strong>. دو راه برای این کار وجود دارد:</p>
<ul>
<li>وقتی یک عضو را به‌طور ضمنی پیاده‌سازی می‌کنید، اگر مناسب است آن را <strong>virtual</strong> علامت بزنید.</li>
<li>وقتی یک عضو را صریحاً پیاده‌سازی می‌کنید، اگر پیش‌بینی می‌کنید زیرکلاس‌ها ممکن است نیاز به override داشته باشند، از الگوی زیر استفاده کنید:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TextBox</span> : <span class="hljs-title">IUndoable</span>
{
    <span class="hljs-keyword">void</span> IUndoable.Undo()         =&gt; Undo();    <span class="hljs-comment">// فراخوانی متد زیر</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Undo</span>()</span> =&gt; Console.WriteLine(<span class="hljs-string">&quot;TextBox.Undo&quot;</span>);
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RichTextBox</span> : <span class="hljs-title">TextBox</span>
{
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Undo</span>()</span> =&gt; Console.WriteLine(<span class="hljs-string">&quot;RichTextBox.Undo&quot;</span>);
}
</code></pre>
<p>اگر انتظار subclassing ندارید، می‌توانید کلاس را <strong>sealed</strong> علامت بزنید تا از پیاده‌سازی مجدد جلوگیری شود.</p>
<hr>
<h3>Interface و Boxing 📦</h3>
<p>تبدیل یک <strong>struct</strong> به یک interface باعث <strong>boxing</strong> می‌شود. اما فراخوانی یک عضو ضمنی پیاده‌سازی‌شده روی struct، باعث boxing نمی‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title">I</span> { <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span>; }
<span class="hljs-keyword">struct</span> S : I { <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> {} }

S s = <span class="hljs-keyword">new</span> S();
s.Foo();         <span class="hljs-comment">// بدون boxing</span>
I i = s;         <span class="hljs-comment">// هنگام cast به interface، boxing رخ می‌دهد</span>
i.Foo();
</code></pre>
<hr>
<h3>Default Interface Members 🛠</h3>
<p>از C# 8 به بعد می‌توانید <strong>پیاده‌سازی پیش‌فرض</strong> برای اعضای interface اضافه کنید و اجرای آن را اختیاری کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title">ILogger</span>
{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span> =&gt; Console.WriteLine(text);
}
</code></pre>
<p>این ویژگی مفید است اگر بخواهید یک عضو جدید به interface‌ای که در یک کتابخانه پرکاربرد تعریف شده اضافه کنید، بدون اینکه پیاده‌سازی‌های موجود (احتمالاً هزاران مورد) خراب شوند.</p>
<ul>
<li>پیاده‌سازی پیش‌فرض همیشه <strong>explicit</strong> است، بنابراین اگر کلاس پیاده‌سازی‌کننده ILogger متد Log را تعریف نکند، تنها راه فراخوانی آن از طریق interface است:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> : <span class="hljs-title">ILogger</span> { }
((ILogger)<span class="hljs-keyword">new</span> Logger()).Log(<span class="hljs-string">&quot;message&quot;</span>);
</code></pre>
<ul>
<li>این کار از مشکل <strong>multiple implementation inheritance</strong> جلوگیری می‌کند، یعنی اگر یک عضو پیش‌فرض در دو interface که یک کلاس پیاده‌سازی می‌کند اضافه شود، هیچ ابهامی درباره فراخوانی آن وجود ندارد.</li>
</ul>
<hr>
<h3>Static Interface Members ⚡</h3>
<p>یک interface می‌تواند <strong>اعضای static</strong> نیز داشته باشد. دو نوع static وجود دارد:</p>
<ul>
<li><strong>Static nonvirtual interface members</strong></li>
<li><strong>Static virtual/abstract interface members</strong></li>
</ul>
<p>بر خلاف اعضای instance، اعضای static به‌طور پیش‌فرض nonvirtual هستند. برای virtual کردن یک عضو static، باید آن را با <strong>static abstract</strong> یا <strong>static virtual</strong> علامت بزنید.</p>
<h4>Static nonvirtual interface members</h4>
<p>این اعضا عمدتاً برای نوشتن <strong>default interface members</strong> مفید هستند. توسط کلاس‌ها یا structها پیاده‌سازی نمی‌شوند، بلکه مستقیماً مصرف می‌شوند. می‌توانند شامل <strong>فیلد</strong> نیز باشند که معمولاً در پیاده‌سازی پیش‌فرض اعضا استفاده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title">ILogger</span>
{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span> =&gt; Console.WriteLine(Prefix + text);
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> Prefix = <span class="hljs-string">&quot;&quot;</span>; 
}
ILogger.Prefix = <span class="hljs-string">&quot;File log: &quot;</span>;
</code></pre>
<ul>
<li>اعضای instance هنوز در interface مجاز نیستند، زیرا هدف interface تعریف <strong>رفتار، نه حالت</strong> است.</li>
</ul>
<h4>Static virtual/abstract interface members</h4>
<p>اعضای <strong>static virtual/abstract</strong> (از C# 11) امکان <strong>polymorphism استاتیک</strong> را فراهم می‌کنند، که یک ویژگی پیشرفته است.</p>
<pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title">ITypeDescribable</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">string</span> Description { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> Category =&gt; <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTest</span> : <span class="hljs-title">ITypeDescribable</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> Description =&gt; <span class="hljs-string">&quot;Customer tests&quot;</span>;  <span class="hljs-comment">// الزامی</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> Category    =&gt; <span class="hljs-string">&quot;Unit testing&quot;</span>;    <span class="hljs-comment">// اختیاری</span>
}
</code></pre>
<ul>
<li>علاوه بر متدها، properties، و events، operatorها و conversions نیز می‌توانند عضو static virtual interface باشند.</li>
<li>این اعضا از طریق <strong>constrained type parameter</strong> فراخوانی می‌شوند (در بخش Static Polymorphism و Generic Math توضیح داده خواهد شد).</li>
</ul>
<hr>
<h3>نوشتن Class در مقابل Interface 🏗</h3>
<p>راهنما:</p>
<ul>
<li>برای نوع‌هایی که <strong>به‌طور طبیعی پیاده‌سازی مشترک دارند</strong>، از کلاس و زیرکلاس استفاده کنید.</li>
<li>برای نوع‌هایی که <strong>پیاده‌سازی مستقل دارند</strong>، از interface استفاده کنید.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> {}
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span>           : <span class="hljs-title">Animal</span> {}
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Insect</span>         : <span class="hljs-title">Animal</span> {}
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FlyingCreature</span> : <span class="hljs-title">Animal</span> {}
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Carnivore</span>      : <span class="hljs-title">Animal</span> {}

<span class="hljs-comment">// کلاس‌های Concrete</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Ostrich</span> : <span class="hljs-title">Bird</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Eagle</span>   : <span class="hljs-title">Bird</span>, <span class="hljs-title">FlyingCreature</span>, <span class="hljs-title">Carnivore</span> {}  <span class="hljs-comment">// غیرقانونی</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Bee</span>     : <span class="hljs-title">Insect</span>, <span class="hljs-title">FlyingCreature</span> {}           <span class="hljs-comment">// غیرقانونی</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Flea</span>    : <span class="hljs-title">Insect</span>, <span class="hljs-title">Carnivore</span> {}                <span class="hljs-comment">// غیرقانونی</span>
</code></pre>
<ul>
<li>کلاس‌های Eagle، Bee، و Flea کامپایل نمی‌شوند، زیرا <strong>ارث‌بری چندگانه از کلاس‌ها مجاز نیست</strong>.</li>
<li>راه حل: برخی از نوع‌ها را به interface تبدیل کنیم.</li>
</ul>
<p>قاعده عمومی:</p>
<ul>
<li>Insect و Bird پیاده‌سازی مشترک دارند → کلاس باقی بمانند</li>
<li>FlyingCreature و Carnivore دارای مکانیزم‌های مستقل هستند → تبدیل به interface:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title">IFlyingCreature</span> {}
<span class="hljs-keyword">interface</span> <span class="hljs-title">ICarnivore</span>      {}
</code></pre>
<ul>
<li>مثال واقعی: Bird و Insect می‌توانند معادل Windows control و web control باشند. FlyingCreature و Carnivore می‌توانند معادل IPrintable و IUndoable باشند.<br>
<strong>Enums 🔢</strong></li>
</ul>
<p>یک <strong>enum</strong> نوع ویژه‌ای از value type است که به شما امکان می‌دهد گروهی از <strong>ثابت‌های عددی نام‌گذاری‌شده</strong> را تعریف کنید. به عنوان مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> BorderSide { Left, Right, Top, Bottom }
</code></pre>
<p>می‌توانیم از این enum به این شکل استفاده کنیم:</p>
<pre class="hljs"><code>BorderSide topSide = BorderSide.Top;
<span class="hljs-built_in">bool</span> isTop = (topSide == BorderSide.Top);   <span class="hljs-comment">// true</span>
</code></pre>
<p>هر عضو enum دارای یک <strong>مقدار عددی زمینه‌ای</strong> است. به‌طور پیش‌فرض:</p>
<ul>
<li>مقادیر زمینه‌ای از نوع <code>int</code> هستند.</li>
<li>ثابت‌ها به ترتیب اعلام‌شده، به صورت خودکار 0، 1، 2… اختصاص می‌یابند.</li>
</ul>
<p>می‌توانید نوع عددی جایگزین نیز مشخص کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> BorderSide : <span class="hljs-built_in">byte</span> { Left, Right, Top, Bottom }
</code></pre>
<p>همچنین می‌توانید برای هر عضو مقدار زمینه‌ای صریح تعیین کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> BorderSide : <span class="hljs-built_in">byte</span> { Left=<span class="hljs-number">1</span>, Right=<span class="hljs-number">2</span>, Top=<span class="hljs-number">10</span>, Bottom=<span class="hljs-number">11</span> }
</code></pre>
<p>کامپایلر به شما اجازه می‌دهد تنها برخی از اعضا را مقداردهی کنید؛ اعضای بدون مقدار، از آخرین مقدار صریح افزایشی ادامه می‌یابند.</p>
<hr>
<h3>تبدیل‌های Enum 🔄</h3>
<p>می‌توانید یک نمونه enum را به نوع عددی زمینه‌ای و برعکس تبدیل کنید با <strong>explicit cast</strong>:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>) BorderSide.Left;
BorderSide side = (BorderSide) i;
<span class="hljs-built_in">bool</span> leftOrRight = (<span class="hljs-built_in">int</span>) side &lt;= <span class="hljs-number">2</span>;
</code></pre>
<p>همچنین می‌توانید یک enum را به enum دیگری تبدیل کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> HorizontalAlignment
{
    Left = BorderSide.Left,
    Right = BorderSide.Right,
    Center
}

HorizontalAlignment h = (HorizontalAlignment) BorderSide.Right;
<span class="hljs-comment">// مشابه:</span>
HorizontalAlignment h = (HorizontalAlignment)(<span class="hljs-built_in">int</span>) BorderSide.Right;
</code></pre>
<ul>
<li>عدد 0 در یک عبارت enum به‌طور ویژه‌ای رفتار می‌کند و نیازی به cast ندارد:</li>
</ul>
<pre class="hljs"><code>BorderSide b = <span class="hljs-number">0</span>;    <span class="hljs-comment">// بدون cast</span>
<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) ...
</code></pre>
<p>دلایل ویژه بودن 0:</p>
<ul>
<li>عضو اول enum اغلب به عنوان مقدار <strong>default</strong> استفاده می‌شود.</li>
<li>برای enumهای ترکیبی، 0 به معنای <strong>no flags</strong> است.</li>
</ul>
<hr>
<h3>Flags Enums 🏴</h3>
<p>می‌توانید اعضای enum را با هم ترکیب کنید. برای جلوگیری از ابهام، اعضای <strong>combinable enum</strong> باید مقادیر صریح داشته باشند، معمولاً به صورت توان‌های دو:</p>
<pre class="hljs"><code>[<span class="hljs-meta">Flags</span>]
<span class="hljs-built_in">enum</span> BorderSides { None=<span class="hljs-number">0</span>, Left=<span class="hljs-number">1</span>, Right=<span class="hljs-number">2</span>, Top=<span class="hljs-number">4</span>, Bottom=<span class="hljs-number">8</span> }
</code></pre>
<p>یا:</p>
<pre class="hljs"><code><span class="hljs-built_in">enum</span> BorderSides { None=<span class="hljs-number">0</span>, Left=<span class="hljs-number">1</span>, Right=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>, Top=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>, Bottom=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span> }
</code></pre>
<p>برای کار با مقادیر ترکیبی از <strong>عملگرهای بیتی</strong> مانند <code>|</code> و <code>&amp;</code> استفاده می‌کنیم:</p>
<pre class="hljs"><code>BorderSides leftRight = BorderSides.Left | BorderSides.Right;
<span class="hljs-keyword">if</span> ((leftRight &amp; BorderSides.Left) != <span class="hljs-number">0</span>)
    Console.WriteLine(<span class="hljs-string">&quot;Includes Left&quot;</span>);  <span class="hljs-comment">// Includes Left</span>
</code></pre>
<pre class="hljs"><code><span class="hljs-built_in">string</span> formatted = leftRight.ToString();   <span class="hljs-comment">// &quot;Left, Right&quot;</span>
BorderSides s = BorderSides.Left;
s |= BorderSides.Right;
Console.WriteLine(s == leftRight);   <span class="hljs-comment">// True</span>
s ^= BorderSides.Right;               <span class="hljs-comment">// تعویض BorderSides.Right</span>
Console.WriteLine(s);                 <span class="hljs-comment">// Left</span>
</code></pre>
<ul>
<li>طبق convention، اگر اعضای enum قابل ترکیب هستند، همیشه <strong>Flags attribute</strong> را اضافه کنید.</li>
<li>نام enum ترکیبی معمولاً به <strong>جمع</strong> نام‌گذاری می‌شود.</li>
<li>می‌توانید <strong>اعضای ترکیبی</strong> را در خود declaration تعریف کنید:</li>
</ul>
<pre class="hljs"><code>[<span class="hljs-meta">Flags</span>]
<span class="hljs-built_in">enum</span> BorderSides
{
    None=<span class="hljs-number">0</span>,
    Left=<span class="hljs-number">1</span>, Right=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>, Top=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>, Bottom=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>,
    LeftRight = Left | Right, 
    TopBottom = Top | Bottom,
    All       = LeftRight | TopBottom
}
</code></pre>
<hr>
<h3>عملگرهای Enum ⚙️</h3>
<p>عملگرهایی که با enums کار می‌کنند:</p>
<pre class="hljs"><code>=   ==   !=   &lt;   &gt;   &lt;=   &gt;=   +   -   ^  &amp;  |   ~
+=  -=  ++  --   sizeof
</code></pre>
<ul>
<li>عملگرهای بیتی، محاسباتی و مقایسه‌ای نتیجه را روی مقادیر عددی زمینه‌ای انجام می‌دهند.</li>
<li>جمع بین یک enum و نوع عددی مجاز است، اما بین دو enum مجاز نیست.</li>
</ul>
<hr>
<h3>مسائل Type-Safety ⚠️</h3>
<p>فرض کنید داریم:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> BorderSide { Left, Right, Top, Bottom }
</code></pre>
<p>چون enum می‌تواند به نوع عددی و بالعکس تبدیل شود، ممکن است مقدار آن خارج از محدوده اعضای قانونی باشد:</p>
<pre class="hljs"><code>BorderSide b = (BorderSide)<span class="hljs-number">12345</span>;
Console.WriteLine(b);  <span class="hljs-comment">// 12345</span>
</code></pre>
<p>عملگرهای بیتی و محاسباتی نیز می‌توانند مقادیر نامعتبر تولید کنند:</p>
<pre class="hljs"><code>BorderSide b = BorderSide.Bottom;
b++;  <span class="hljs-comment">// بدون خطا</span>
</code></pre>
<ul>
<li>مقدار نامعتبر می‌تواند کد زیر را خراب کند:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>(<span class="hljs-params">BorderSide side</span>)</span>
{
    <span class="hljs-keyword">if</span>      (side == BorderSide.Left)  {...}
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (side == BorderSide.Right) {...}
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (side == BorderSide.Top)   {...}
    <span class="hljs-keyword">else</span>                               {...} <span class="hljs-comment">// فرض BorderSide.Bottom</span>
}
</code></pre>
<p>راه حل‌ها:</p>
<ol>
<li>اضافه کردن یک else دیگر:</li>
</ol>
<pre class="hljs"><code>...
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (side == BorderSide.Bottom) ...
<span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Invalid BorderSide: &quot;</span> + side, <span class="hljs-string">&quot;side&quot;</span>);
</code></pre>
<ol start="2">
<li>بررسی صریح مقدار enum با <code>Enum.IsDefined</code>:</li>
</ol>
<pre class="hljs"><code>BorderSide side = (BorderSide)<span class="hljs-number">12345</span>;
Console.WriteLine(Enum.IsDefined(<span class="hljs-keyword">typeof</span>(BorderSide), side));   <span class="hljs-comment">// False</span>
</code></pre>
<ul>
<li>متأسفانه، <code>Enum.IsDefined</code> برای <strong>flagged enums</strong> کار نمی‌کند. اما می‌توان از روش کمکی زیر استفاده کرد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsFlagDefined</span>(<span class="hljs-params">Enum e</span>)</span>
{
    <span class="hljs-built_in">decimal</span> d;
    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">decimal</span>.TryParse(e.ToString(), <span class="hljs-keyword">out</span> d);
}
</code></pre>
<hr>
<h3>Nested Types 🏗</h3>
<p>یک <strong>nested type</strong> در داخل محدوده یک نوع دیگر تعریف می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TopLevel</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Nested</span> { }               <span class="hljs-comment">// کلاس تو در تو</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Color { Red, Blue, Tan }  <span class="hljs-comment">// enum تو در تو</span>
}
</code></pre>
<p>ویژگی‌های nested type:</p>
<ul>
<li>می‌تواند به <strong>private members</strong> نوع enclosing دسترسی داشته باشد.</li>
<li>می‌توانید از تمام access modifierها استفاده کنید.</li>
<li>دسترسی پیش‌فرض برای nested type <strong>private</strong> است نه internal.</li>
<li>دسترسی به یک nested type از خارج نیازمند qualification با نام enclosing type است:</li>
</ul>
<pre class="hljs"><code>TopLevel.Color color = TopLevel.Color.Red;
</code></pre>
<ul>
<li>همه نوع‌ها (class، struct، interface، delegate و enum) می‌توانند nested باشند.</li>
</ul>
<p>مثال دسترسی به member خصوصی از nested type:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TopLevel</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> x;
    <span class="hljs-keyword">class</span> <span class="hljs-title">Nested</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> { Console.WriteLine(TopLevel.x); }
    }
}
</code></pre>
<p>مثال استفاده از <code>protected</code> روی nested type:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TopLevel</span>
{
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Nested</span> { }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubTopLevel</span> : <span class="hljs-title">TopLevel</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>()</span> { <span class="hljs-keyword">new</span> TopLevel.Nested(); }
}
</code></pre>
<p>Nested types توسط کامپایلر نیز برای ایجاد <strong>کلاس‌های خصوصی</strong> که state را برای iteratorها و anonymous methods ذخیره می‌کنند، استفاده می‌شوند.</p>
<hr>
<h3>Generics ⚙️</h3>
<p>اگر هدف از استفاده از nested type تنها جلوگیری از شلوغی namespace است، بهتر است از <strong>nested namespace</strong> استفاده کنید.</p>
<p>C# دو مکانیزم برای نوشتن کد قابل استفاده مجدد در نوع‌های مختلف دارد:</p>
<ul>
<li>
<p><strong>Inheritance</strong>: بازگویی قابلیت reuse با base type</p>
</li>
<li>
<p><strong>Generics</strong>: بازگویی قابلیت reuse با template که شامل placeholder typeهاست</p>
</li>
<li>
<p>Generics می‌توانند <strong>type safety</strong> را افزایش دهند و نیاز به casting و boxing را کاهش دهند.</p>
</li>
</ul>
<h4>Generic Types 🧩</h4>
<p>C# generics و C++ templates مشابه هستند اما رفتار متفاوتی دارند.</p>
<p>یک <strong>generic type</strong> پارامترهای نوعی (placeholder) تعریف می‌کند که مصرف‌کننده generic نوع واقعی را جایگزین می‌کند. مثال <strong>Stack<T></strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-built_in">int</span> position;
    T[] data = <span class="hljs-keyword">new</span> T[<span class="hljs-number">100</span>];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params">T obj</span>)</span> =&gt; data[position++] = obj;
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Pop</span>()</span> =&gt; data[--position];
}
</code></pre>
<p>استفاده از Stack<T>:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> stack = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">int</span>&gt;();
stack.Push(<span class="hljs-number">5</span>);
stack.Push(<span class="hljs-number">10</span>);
<span class="hljs-built_in">int</span> x = stack.Pop();  <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">int</span> y = stack.Pop();  <span class="hljs-comment">// 5</span>
</code></pre>
<ul>
<li><code>Stack&lt;int&gt;</code> پارامتر نوعی <code>T</code> را با <code>int</code> جایگزین می‌کند و نوع بسته‌ای ایجاد می‌کند.</li>
<li>تلاش برای push کردن یک <code>string</code> روی <code>Stack&lt;int&gt;</code> باعث خطای compile-time می‌شود.</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// تعریف مشابه Stack&lt;int&gt;</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ###
{
    <span class="hljs-built_in">int</span> position;
    <span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">100</span>];

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> obj</span>)</span> =&gt; data[position++] = obj;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Pop</span>()</span> =&gt; data[--position];
}
</code></pre>
<ul>
<li><code>Stack&lt;T&gt;</code> یک <strong>open type</strong> است، و <code>Stack&lt;int&gt;</code> یک <strong>closed type</strong>.</li>
<li>در زمان اجرا، تمام نمونه‌های generic type بسته هستند و placeholderها پر می‌شوند.</li>
</ul>
<p>مثال نامعتبر:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> stack = <span class="hljs-keyword">new</span> Stack&lt;T&gt;();   <span class="hljs-comment">// غیرقانونی: T چیست؟</span>
</code></pre>
<ul>
<li>اما اگر در یک کلاس یا متدی که خودش T را تعریف کرده باشد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt;
{
    ...
    <span class="hljs-function"><span class="hljs-keyword">public</span> Stack&lt;T&gt; <span class="hljs-title">Clone</span>()</span>
    {
        Stack&lt;T&gt; clone = <span class="hljs-keyword">new</span> Stack&lt;T&gt;();   <span class="hljs-comment">// قانونی</span>
        ...
    }
}
</code></pre>
<h3>Why Generics Exist 🧩</h3>
<p>Generics در C# وجود دارند تا بتوانید کدی <strong>قابل استفاده مجدد برای انواع مختلف</strong> بنویسید.</p>
<p>فرض کنید می‌خواهیم یک stack برای اعداد صحیح داشته باشیم و generic نداریم. دو راه وجود دارد:</p>
<ol>
<li>ایجاد نسخه‌های جداگانه کلاس برای هر نوع مورد نیاز: <code>IntStack</code>, <code>StringStack</code> و غیره → باعث <strong>تکرار زیاد کد</strong> می‌شود.</li>
<li>استفاده از <code>object</code> به عنوان نوع عناصر:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ObjectStack</span>
{
    <span class="hljs-built_in">int</span> position;
    <span class="hljs-built_in">object</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[<span class="hljs-number">10</span>];
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span> =&gt; data[position++] = obj;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-title">Pop</span>()</span> =&gt; data[--position];
}
</code></pre>
<p>اما <strong>ObjectStack</strong> معایبی دارد:</p>
<ul>
<li>نیاز به <strong>boxing</strong> و <strong>downcasting</strong> برای نوع‌های value type.</li>
<li>نوع نادرست می‌تواند وارد شود بدون اینکه کامپایلر خطا بدهد:</li>
</ul>
<pre class="hljs"><code>ObjectStack stack = <span class="hljs-keyword">new</span> ObjectStack();
stack.Push(<span class="hljs-string">&quot;s&quot;</span>);           <span class="hljs-comment">// Wrong type, no compile error</span>
<span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>)stack.Pop();  <span class="hljs-comment">// Runtime error</span>
</code></pre>
<p>راه حل: استفاده از <strong>generics</strong>.</p>
<pre class="hljs"><code>Stack&lt;<span class="hljs-built_in">int</span>&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">int</span>&gt;();
</code></pre>
<ul>
<li>مانند ObjectStack: یکبار نوشته شده و می‌تواند با هر نوع کار کند.</li>
<li>مانند IntStack: برای نوع خاص <code>T</code> تخصصی شده است.</li>
<li>مزیت: <strong>ایمنی نوعی</strong> و کاهش نیاز به cast و boxing.</li>
</ul>
<blockquote>
<p>ObjectStack عملاً معادل <code>Stack&lt;object&gt;</code> است.</p>
</blockquote>
<hr>
<h3>Generic Methods 🔄</h3>
<p>متدهای generic پارامترهای نوعی خود را در <strong>signature متد</strong> معرفی می‌کنند.<br>
مثال: swap دو مقدار از هر نوع T</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> T a, <span class="hljs-keyword">ref</span> T b</span>)</span>
{
    T temp = a;
    a = b;
    b = temp;
}
</code></pre>
<p>استفاده:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">10</span>;
Swap(<span class="hljs-keyword">ref</span> x, <span class="hljs-keyword">ref</span> y);
</code></pre>
<ul>
<li>معمولاً نیازی به مشخص کردن نوع نیست، کامپایلر آن را استنتاج می‌کند.</li>
<li>اگر ابهام باشد:</li>
</ul>
<pre class="hljs"><code>Swap&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-keyword">ref</span> x, <span class="hljs-keyword">ref</span> y);
</code></pre>
<blockquote>
<p>یک متد در داخل generic type، مگر اینکه type parameter جدید معرفی کند، <strong>متد generic</strong> محسوب نمی‌شود.</p>
</blockquote>
<hr>
<h3>Declaring Type Parameters 📦</h3>
<p>پارامترهای نوع می‌توانند در <strong>کلاس‌ها، structها، interfaceها، delegateها و متدها</strong> تعریف شوند.<br>
مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Nullable&lt;T&gt;
{
    <span class="hljs-keyword">public</span> T Value { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">class</span> <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">TKey</span>, <span class="hljs-title">TValue</span>&gt; {...}
<span class="hljs-keyword">var</span> myDict = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">string</span>&gt;();
</code></pre>
<ul>
<li>می‌توان چند پارامتر نوعی داشت: <code>Dictionary&lt;TKey, TValue&gt;</code></li>
<li>نامگذاری: پارامتر تک نوعی → <code>T</code>، چند پارامتر → <code>TKey, TValue</code> و غیره.</li>
</ul>
<h4>typeof و Unbound Generic Types</h4>
<ul>
<li><strong>Open generic types</strong> در زمان اجرا وجود ندارند مگر به شکل <strong>Type object</strong>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;<span class="hljs-title">T</span>&gt; {}
Type a1 = <span class="hljs-keyword">typeof</span>(A&lt;&gt;);   <span class="hljs-comment">// Unbound</span>
Type a2 = <span class="hljs-keyword">typeof</span>(A&lt;,&gt;);  <span class="hljs-comment">// برای چند پارامتر</span>
Type a3 = <span class="hljs-keyword">typeof</span>(A&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;); <span class="hljs-comment">// Closed</span>
</code></pre>
<hr>
<h3>Default Generic Value ⚙️</h3>
<p>کلمه کلیدی <code>default</code> برای گرفتن مقدار پیش‌فرض پارامتر نوعی استفاده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Zap</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] array</span>)</span>
{
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)
        array[i] = <span class="hljs-literal">default</span>(T);
}

<span class="hljs-comment">// C# 7.1 به بعد:</span>
array[i] = <span class="hljs-literal">default</span>;
</code></pre>
<ul>
<li>مقدار پیش‌فرض <strong>reference type</strong> → <code>null</code></li>
<li>مقدار پیش‌فرض <strong>value type</strong> → صفر بیت به بیت (bitwise-zero)</li>
</ul>
<hr>
<h3>Generic Constraints 🛡️</h3>
<p>به‌طور پیش‌فرض می‌توان هر نوعی را جایگزین T کرد، اما <strong>constraints</strong> محدودیت‌هایی اضافه می‌کنند:</p>
<pre class="hljs"><code><span class="hljs-keyword">where</span> T : <span class="hljs-keyword">base</span>-<span class="hljs-keyword">class</span>       <span class="hljs-comment">// Must derive from a base class</span>
<span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">interface</span>        <span class="hljs-comment">// Must implement an interface</span>
<span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-keyword">class</span>            <span class="hljs-comment">// Reference type</span>
<span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">struct</span>           <span class="hljs-comment">// Value type (excludes Nullable)</span>
<span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">unmanaged</span>        <span class="hljs-comment">// Simple value type without references</span>
<span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">new</span>()            <span class="hljs-comment">// Parameterless constructor</span>
<span class="hljs-keyword">where</span> <span class="hljs-title">U</span> : <span class="hljs-title">T</span>                <span class="hljs-comment">// U must derive from T</span>
<span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">notnull</span>          <span class="hljs-comment">// Non-nullable (C# 8+)</span>
</code></pre>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span> {}
<span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span> {}

<span class="hljs-keyword">class</span> <span class="hljs-title">GenericClass</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;
    <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">SomeClass</span>, <span class="hljs-title">Interface1</span>
    <span class="hljs-keyword">where</span> <span class="hljs-title">U</span> : <span class="hljs-title">new</span>()
{
    ...
}
</code></pre>
<ul>
<li>هدف اصلی constraints: <strong>امکان انجام عملیاتی که بدون آن غیرممکن است</strong>.</li>
<li>مثال: <code>T:Foo</code> اجازه می‌دهد T را مثل Foo رفتار دهید، <code>T:new()</code> اجازه ساخت instance از T می‌دهد.</li>
</ul>
<hr>
<h3>Example: Max Method Using Constraints ✅</h3>
<p>استفاده از interface constraint <code>IComparable&lt;T&gt;</code>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> T <span class="hljs-title">Max</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a, T b</span>) <span class="hljs-keyword">where</span> T : IComparable&lt;T&gt;</span>
{
    <span class="hljs-keyword">return</span> a.CompareTo(b) &gt; <span class="hljs-number">0</span> ? a : b;
}

<span class="hljs-built_in">int</span> z = Max(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);               <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">string</span> last = Max(<span class="hljs-string">&quot;ant&quot;</span>, <span class="hljs-string">&quot;zoo&quot;</span>);  <span class="hljs-comment">// &quot;zoo&quot;</span>
</code></pre>
<ul>
<li>C# 11: interface constraint اجازه فراخوانی <strong>static virtual/abstract members</strong> می‌دهد.</li>
</ul>
<hr>
<h3>Other Constraints Examples</h3>
<ul>
<li><strong>class/struct constraint</strong>: مشخص می‌کند T یک reference type یا value type است.</li>
<li><strong>unmanaged constraint</strong>: T باید یک value type ساده یا struct بدون reference types باشد.</li>
<li><strong>new() constraint</strong>: اجازه ساخت instance با <code>new T()</code>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T[] array</span>) <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">new</span>()</span>
{
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)
        array[i] = <span class="hljs-keyword">new</span> T();
}
</code></pre>
<ul>
<li><strong>naked type constraint</strong>: یک type parameter باید از دیگری مشتق شود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt;
{
    <span class="hljs-function"><span class="hljs-title">Stack</span>&lt;<span class="hljs-title">U</span>&gt; <span class="hljs-title">FilteredStack</span>&lt;<span class="hljs-title">U</span>&gt;() <span class="hljs-keyword">where</span> U : T</span> {...}
}
</code></pre>
<h3>Subclassing Generic Types 🧬</h3>
<p>یک کلاس generic می‌تواند مانند کلاس معمولی subclass شود. چند حالت وجود دارد:</p>
<ol>
<li><strong>SubClass با همان پارامتر نوع باز باقی می‌ماند</strong>:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt; { ... }
<span class="hljs-keyword">class</span> <span class="hljs-title">SpecialStack</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt; { ... }
</code></pre>
<ol start="2">
<li><strong>SubClass نوع پارامتر را به یک نوع مشخص می‌بندد</strong>:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">IntStack</span> : <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">int</span>&gt; { ... }
</code></pre>
<ol start="3">
<li><strong>SubClass می‌تواند پارامتر نوع جدید معرفی کند</strong>:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt; { ... }
<span class="hljs-keyword">class</span> <span class="hljs-title">KeyedList</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">TKey</span>&gt; : <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt; { ... }
</code></pre>
<ul>
<li>در واقع، تمام type argumentها در subclass <strong>fresh</strong> هستند و می‌توان نام‌های جدید و معنادارتری برای آنها انتخاب کرد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">KeyedList</span>&lt;<span class="hljs-title">TElement</span>, <span class="hljs-title">TKey</span>&gt; : <span class="hljs-title">List</span>&lt;<span class="hljs-title">TElement</span>&gt; { ... }
</code></pre>
<hr>
<h3>Self-Referencing Generic Declarations 🔄</h3>
<p>یک نوع می‌تواند خودش را به عنوان <strong>concrete type</strong> معرفی کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEquatable</span>&lt;<span class="hljs-title">T</span>&gt; { <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">T obj</span>)</span>; }

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Balloon</span> : <span class="hljs-title">IEquatable</span>&lt;<span class="hljs-title">Balloon</span>&gt;
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Color { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> CC { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params">Balloon b</span>)</span>
    {
        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> b.Color == Color &amp;&amp; b.CC == CC;
    }
}
</code></pre>
<p>همچنین این‌ها قانونی هستند:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">IComparable</span>&lt;<span class="hljs-title">T</span>&gt; { ... }
<span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">Bar</span>&lt;<span class="hljs-title">T</span>&gt; { ... }
</code></pre>
<hr>
<h3>Static Data in Generic Types 💾</h3>
<ul>
<li><strong>Static data</strong> منحصر به هر <strong>closed type</strong> است:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Bob</span>&lt;<span class="hljs-title">T</span>&gt; { <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Count; }

Console.WriteLine(++Bob&lt;<span class="hljs-built_in">int</span>&gt;.Count);    <span class="hljs-comment">// 1</span>
Console.WriteLine(++Bob&lt;<span class="hljs-built_in">int</span>&gt;.Count);    <span class="hljs-comment">// 2</span>
Console.WriteLine(++Bob&lt;<span class="hljs-built_in">string</span>&gt;.Count); <span class="hljs-comment">// 1</span>
Console.WriteLine(++Bob&lt;<span class="hljs-built_in">object</span>&gt;.Count); <span class="hljs-comment">// 1</span>
</code></pre>
<hr>
<h3>Type Parameters and Conversions ⚖️</h3>
<p>C# چند نوع تبدیل را پشتیبانی می‌کند:</p>
<ul>
<li>Numeric</li>
<li>Reference</li>
<li>Boxing/unboxing</li>
<li>Custom (operator overloading)</li>
</ul>
<p>اما با <strong>generic type parameters</strong>، نوع دقیق در زمان کامپایل مشخص نیست، پس ممکن است <strong>ابهام</strong> ایجاد شود.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-function">StringBuilder <span class="hljs-title">Foo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T arg</span>)</span>
{
    <span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">is</span> StringBuilder)
        <span class="hljs-keyword">return</span> (StringBuilder)arg; <span class="hljs-comment">// خطا در کامپایل</span>
}
</code></pre>
<p>راه حل‌ها:</p>
<ol>
<li>استفاده از <code>as</code> (بی‌ابهام):</li>
</ol>
<pre class="hljs"><code>StringBuilder sb = arg <span class="hljs-keyword">as</span> StringBuilder;
<span class="hljs-keyword">if</span> (sb != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> sb;
</code></pre>
<ol start="2">
<li>یا ابتدا cast به <code>object</code> و سپس به نوع مورد نظر:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">return</span> (StringBuilder)(<span class="hljs-built_in">object</span>)arg;
</code></pre>
<blockquote>
<p>Unboxing هم می‌تواند ابهام ایجاد کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Foo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T x</span>)</span> =&gt; (<span class="hljs-built_in">int</span>)x;  <span class="hljs-comment">// خطای کامپایل</span>
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Foo</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T x</span>)</span> =&gt; (<span class="hljs-built_in">int</span>)(<span class="hljs-built_in">object</span>)x; <span class="hljs-comment">// صحیح</span>
</code></pre>
</blockquote>
<hr>
<h3>Covariance &amp; Contravariance 🔁</h3>
<ul>
<li><strong>Covariance</strong>: اگر <code>A</code> به <code>B</code> قابل تبدیل باشد، نوع generic <code>X&lt;A&gt;</code> می‌تواند به <code>X&lt;B&gt;</code> تبدیل شود.</li>
<li>فقط برای <strong>implicit reference conversions</strong> اعمال می‌شود (مثل subclass یا interface implementation).</li>
<li><strong>Classes</strong> پشتیبانی نمی‌کنند، اما <strong>interfaces و delegates</strong> و <strong>arrays</strong> پشتیبانی می‌کنند.</li>
</ul>
<p>مثال عدم covariance:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Bear</span> : <span class="hljs-title">Animal</span> {}
<span class="hljs-keyword">class</span> <span class="hljs-title">Camel</span> : <span class="hljs-title">Animal</span> {}

Stack&lt;Bear&gt; bears = <span class="hljs-keyword">new</span> Stack&lt;Bear&gt;();
Stack&lt;Animal&gt; animals = bears;  <span class="hljs-comment">// خطای کامپایل</span>
animals.Push(<span class="hljs-keyword">new</span> Camel());      <span class="hljs-comment">// اگر مجاز بود، runtime error</span>
</code></pre>
<p>راه حل‌ها:</p>
<ol>
<li>متد generic با constraint بنویسیم:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">ZooCleaner</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Wash</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stack&lt;T&gt; animals</span>) <span class="hljs-keyword">where</span> T : Animal</span> { ... }
}

Stack&lt;Bear&gt; bears = <span class="hljs-keyword">new</span> Stack&lt;Bear&gt;();
ZooCleaner.Wash(bears);
</code></pre>
<ol start="2">
<li>یا Stack<T> را روی interface با <strong>covariant type parameter</strong> تعریف کنیم.</li>
</ol>
<hr>
<h3>Arrays و Covariance ⚠️</h3>
<ul>
<li>Arrayها از نظر تاریخی covariant هستند:</li>
</ul>
<pre class="hljs"><code>Bear[] bears = <span class="hljs-keyword">new</span> Bear[<span class="hljs-number">3</span>];
Animal[] animals = bears;  <span class="hljs-comment">// OK</span>
</code></pre>
<ul>
<li>اما <strong>assignments نادرست ممکن است runtime error بدهد</strong>:</li>
</ul>
<pre class="hljs"><code>animals[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Camel();  <span class="hljs-comment">// Runtime error</span>
</code></pre>
<h3>اعلام یک پارامتر نوع کوواریانت 📐</h3>
<p>پارامترهای نوع در <strong>interfaces</strong> و <strong>delegates</strong> می‌توانند با علامت‌گذاری با <strong>modifer <code>out</code></strong> کوواریانت اعلام شوند. این <strong>modifer</strong> تضمین می‌کند که برخلاف آرایه‌ها، پارامترهای نوع کوواریانت کاملاً <strong>ایمن از نظر نوع (type-safe)</strong> هستند.</p>
<p>می‌توانیم این موضوع را با کلاس <code>Stack&lt;T&gt;</code> خود نشان دهیم، به طوری که آن را به شکل زیر پیاده‌سازی کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPoppable</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">T</span>&gt; { <span class="hljs-function">T <span class="hljs-title">Pop</span>()</span>; }
</code></pre>
<p>علامت <code>out</code> روی <code>T</code> نشان می‌دهد که <code>T</code> تنها در <strong>موقعیت‌های خروجی</strong> (مثلاً نوع بازگشتی متدها) استفاده می‌شود. این علامت، پارامتر نوع را کوواریانت کرده و اجازه می‌دهد کارهای زیر را انجام دهیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> bears = <span class="hljs-keyword">new</span> Stack&lt;Bear&gt;();
bears.Push(<span class="hljs-keyword">new</span> Bear());
<span class="hljs-comment">// Bears پیاده‌سازی IPoppable&lt;Bear&gt; را دارد. می‌توانیم آن را به IPoppable&lt;Animal&gt; تبدیل کنیم:</span>
IPoppable&lt;Animal&gt; animals = bears;   <span class="hljs-comment">// قانونی</span>
Animal a = animals.Pop();
</code></pre>
<p>تبدیل از <code>bears</code> به <code>animals</code> توسط کامپایلر مجاز است، زیرا <strong>پارامتر نوع کوواریانت است</strong>. این تبدیل <strong>ایمن از نظر نوع</strong> است، زیرا موقعیتی که کامپایلر می‌خواهد از آن جلوگیری کند—قرار دادن یک <strong>Camel</strong> در استک—امکان‌پذیر نیست، چرا که هیچ راهی برای فرستادن Camel به یک interface که <code>T</code> تنها در خروجی ظاهر می‌شود، وجود ندارد.</p>
<p>💡 کوواریانس (و کانترکوواریانس) در interfaces معمولاً <strong>مصرف می‌شود</strong> و کمتر پیش می‌آید که نیاز باشد <strong>interfaces کوواریانت بنویسید</strong>.</p>
<p>نکته جالب: پارامترهای متد که با <code>out</code> علامت‌گذاری شده‌اند، به دلیل محدودیت‌های CLR، <strong>قابل کوواریانس نیستند</strong>.</p>
<p>می‌توانیم از قابلیت <strong>cast کوواریانت</strong> برای حل مشکل <strong>قابلیت استفاده مجدد (reusability)</strong> که قبلاً توضیح داده شد، استفاده کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ZooCleaner</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Wash</span>(<span class="hljs-params">IPoppable&lt;Animal&gt; animals</span>)</span> { ... }
}
</code></pre>
<p>💡 <strong>interfaces <code>IEnumerator&lt;T&gt;</code> و <code>IEnumerable&lt;T&gt;</code></strong> که در فصل ۷ توضیح داده شده‌اند، دارای پارامتر نوع کوواریانت <code>T</code> هستند. این باعث می‌شود بتوانید، برای مثال، <code>IEnumerable&lt;string&gt;</code> را به <code>IEnumerable&lt;object&gt;</code> تبدیل کنید.</p>
<p>کامپایلر <strong>خطا ایجاد می‌کند</strong> اگر پارامتر نوع کوواریانت را در یک <strong>موقعیت ورودی</strong> (مثلاً پارامتر متد یا property قابل نوشتن) استفاده کنید.</p>
<hr>
<h3>کوواریانس (و کانترکوواریانس) و محدودیت‌ها ⚠️</h3>
<p>کوواریانس و کانترکوواریانس <strong>فقط برای عناصری با تبدیل مرجع (reference conversion)</strong> کار می‌کند—نه برای تبدیل‌های boxing. این قانون هم برای <strong>variance پارامتر نوع</strong> و هم برای <strong>variance آرایه‌ها</strong> اعمال می‌شود. بنابراین اگر متدی پارامتری از نوع <code>IPoppable&lt;object&gt;</code> بپذیرد، می‌توان آن را با <code>IPoppable&lt;string&gt;</code> فراخوانی کرد اما <strong>نه با <code>IPoppable&lt;int&gt;</code></strong>.</p>
<hr>
<h3>کانترکوواریانس 🔄</h3>
<p>فرض کنید <code>A</code> قابلیت تبدیل مرجع به <code>B</code> را دارد. اگر <code>X&lt;A&gt;</code> قابلیت تبدیل به <code>X&lt;B&gt;</code> را داشته باشد، پارامتر نوع <code>X</code> کوواریانت است.<br>
کانترکوواریانس زمانی است که بتوانید <strong>در جهت معکوس</strong> تبدیل کنید—از <code>X&lt;B&gt;</code> به <code>X&lt;A&gt;</code>. این زمانی امکان‌پذیر است که <strong>پارامتر نوع تنها در موقعیت‌های ورودی استفاده شود</strong> و با <code>in</code> علامت‌گذاری شود.</p>
<p>با گسترش مثال قبلی، فرض کنید کلاس <code>Stack&lt;T&gt;</code> این interface را پیاده‌سازی می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPushable</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>&gt; { <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params">T obj</span>)</span>; }
</code></pre>
<p>اکنون می‌توانیم قانونی عمل کنیم:</p>
<pre class="hljs"><code>IPushable&lt;Animal&gt; animals = <span class="hljs-keyword">new</span> Stack&lt;Animal&gt;();
IPushable&lt;Bear&gt; bears = animals;    <span class="hljs-comment">// قانونی</span>
bears.Push(<span class="hljs-keyword">new</span> Bear());
</code></pre>
<p>هیچ عضوی در <code>IPushable</code> نوع <code>T</code> را خروجی نمی‌دهد، بنابراین نمی‌توانیم با تبدیل <code>animals</code> به <code>bears</code> دچار مشکل شویم (مثلاً راهی برای Pop کردن وجود ندارد).</p>
<p>کلاس <code>Stack&lt;T&gt;</code> ما می‌تواند همزمان <strong><code>IPushable&lt;T&gt;</code> و <code>IPoppable&lt;T&gt;</code></strong> را پیاده‌سازی کند، حتی اگر <code>T</code> در دو interface با <strong>annotaion‌های variance مخالف</strong> باشد! این کار امکان‌پذیر است زیرا <strong>variance باید از طریق interface اعمال شود، نه کلاس</strong>؛ بنابراین، قبل از انجام تبدیل variant، باید از دیدگاه IPoppable یا IPushable متعهد شوید. این دیدگاه سپس شما را به عملیات قانونی تحت قوانین variance محدود می‌کند.</p>
<p>💡 این توضیح می‌دهد چرا <strong>کلاس‌ها اجازه پارامتر نوع variant ندارند</strong>: پیاده‌سازی‌های واقعی معمولاً نیاز دارند داده‌ها <strong>در هر دو جهت جریان داشته باشند</strong>.</p>
<hr>
<h3>مثال دیگر: IComparer<in T> 🧮</h3>
<p>در فضای نام <strong>System</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IComparer</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>&gt;
{
    <span class="hljs-comment">// مقدار نسبت ترتیب a و b را برمی‌گرداند</span>
    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span>(<span class="hljs-params">T a, T b</span>)</span>;
}
</code></pre>
<p>چون این interface دارای پارامتر نوع کانترکوواریانت <code>T</code> است، می‌توانیم از یک <code>IComparer&lt;object&gt;</code> برای مقایسه دو رشته استفاده کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> objectComparer = Comparer&lt;<span class="hljs-built_in">object</span>&gt;.Default; <span class="hljs-comment">// objectComparer پیاده‌سازی IComparer&lt;object&gt;</span>
IComparer&lt;<span class="hljs-built_in">string</span>&gt; stringComparer = objectComparer;
<span class="hljs-built_in">int</span> result = stringComparer.Compare(<span class="hljs-string">&quot;Brett&quot;</span>, <span class="hljs-string">&quot;Jemaine&quot;</span>);
</code></pre>
<p>همانند کوواریانس، کامپایلر <strong>خطا گزارش می‌دهد</strong> اگر پارامتر نوع کانترکوواریانت را در <strong>موقعیت خروجی</strong> (مثلاً مقدار بازگشتی یا property قابل خواندن) استفاده کنید.</p>
<hr>
<h3>C# Generics در مقایسه با C++ Templates ⚙️</h3>
<p><strong>Generics در C#</strong> مشابه <strong>templates در C++</strong> هستند اما به شکل متفاوتی عمل می‌کنند. در هر دو حالت، یک <strong>ترکیب بین تولیدکننده و مصرف‌کننده</strong> صورت می‌گیرد که در آن <strong>placeholder typeهای تولیدکننده</strong> توسط مصرف‌کننده پر می‌شوند.</p>
<p>با این حال، در <strong>C# generics</strong>، تولیدکننده‌ها (open types مانند <code>List&lt;T&gt;</code>) می‌توانند به یک <strong>کتابخانه کامپایل شوند</strong> (مثل <code>mscorlib.dll</code>) چون ترکیب تولیدکننده و مصرف‌کننده که منجر به closed typeها می‌شود، <strong>فقط در زمان اجرا اتفاق می‌افتد</strong>.</p>
<p>در C++ templates، این ترکیب در <strong>زمان کامپایل</strong> انجام می‌شود؛ بنابراین <strong>کتابخانه‌های template به صورت DLL منتشر نمی‌شوند</strong> و فقط به عنوان <strong>کد منبع</strong> وجود دارند. این باعث می‌شود بررسی و ایجاد dynamic نوع‌های پارامتری دشوار باشد.</p>
<hr>
<h3>مثال Max در C# و C++</h3>
<p>در C#:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> T <span class="hljs-title">Max</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a, T b</span>) <span class="hljs-keyword">where</span> T : IComparable&lt;T&gt;</span>
  =&gt; a.CompareTo(b) &gt; <span class="hljs-number">0</span> ? a : b;
</code></pre>
<p>چرا نمی‌توانیم اینطور پیاده کنیم؟</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> T <span class="hljs-title">Max</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a, T b</span>)</span>
  =&gt; (a &gt; b ? a : b); <span class="hljs-comment">// خطای کامپایل</span>
</code></pre>
<p>چون Max باید <strong>یک بار کامپایل شود و برای همه نوع‌های T کار کند</strong>. کامپایل نمی‌تواند موفق شود زیرا عملگر <code>&gt;</code> معنای یکنواختی برای همه نوع‌ها ندارد—در واقع، همه Tها حتی عملگر <code>&gt;</code> ندارند.</p>
<p>در مقابل، در C++:</p>
<pre class="hljs"><code><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; 
<span class="hljs-function">T <span class="hljs-title">Max</span><span class="hljs-params">(T a, T b)</span>
</span>{
    <span class="hljs-keyword">return</span> a &gt; b ? a : b;
}
</code></pre>
<p>این کد <strong>برای هر مقدار T جداگانه کامپایل می‌شود</strong> و معنای <code>&gt;</code> را برای نوع خاص خود می‌گیرد، و اگر نوعی از <code>&gt;</code> پشتیبانی نکند، کامپایل خطا می‌دهد.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
