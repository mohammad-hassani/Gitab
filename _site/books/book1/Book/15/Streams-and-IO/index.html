

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>استریم‌ها و ورودی/خروجی (Streams and I/O)</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

       <nav class="nav">
         <a href="/Gitab/" >خانه</a>
         <a href="/Gitab/books/list-books" >کتاب‌ها</a>
        <a href="/Gitab/translator.html" >مترجمین</a>
         <a href="/Gitab/giter.html" >گیتر</a>
       </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل پانزدهم:  استریم‌ها و ورودی/خروجی (Streams and I/O)</h1>
<p>این فصل، انواع بنیادی برای <strong>ورودی (Input)</strong> و <strong>خروجی (Output)</strong> در .NET را توضیح می‌دهد، با تمرکز ویژه روی موضوعات زیر:</p>
<ul>
<li>معماری <strong>Stream</strong> در .NET و این‌که چطور یک رابط برنامه‌نویسی (Programming Interface) یکپارچه برای <strong>خواندن</strong> و <strong>نوشتن</strong> روی انواع مختلف I/O فراهم می‌کند.</li>
<li>کلاس‌ها برای کار با <strong>فایل‌ها</strong> و <strong>دایرکتوری‌ها</strong> روی دیسک.</li>
<li>استریم‌های تخصصی برای <strong>فشرده‌سازی (Compression)</strong>، <strong>Named Pipes</strong>، و <strong>Memory-Mapped Files</strong>.</li>
</ul>
<p>این فصل بیشتر روی نوع‌هایی در فضای نام <code>System.IO</code> تمرکز دارد؛ جایی که قابلیت‌های سطح پایین I/O قرار گرفته‌اند.</p>
<hr>
<h2>🏗️ معماری Stream</h2>
<p>معماری Stream در .NET حول سه مفهوم اصلی می‌چرخد:</p>
<ul>
<li><strong>Backing Stores</strong></li>
<li><strong>Decorators</strong></li>
<li><strong>Adapters</strong></li>
</ul>
<p>همان‌طور که در شکل 15-1 نشان داده شده است.</p>
<p><strong>Backing Store</strong> همان نقطه انتهایی است که ورودی و خروجی را کاربردی می‌کند، مثل یک فایل یا اتصال شبکه. به‌طور دقیق‌تر، Backing Store می‌تواند یکی یا هر دوی موارد زیر باشد:</p>
<ul>
<li>یک منبع (Source) که بایت‌ها می‌توانند به‌صورت ترتیبی (Sequential) از آن خوانده شوند.</li>
<li>یک مقصد (Destination) که بایت‌ها می‌توانند به‌صورت ترتیبی در آن نوشته شوند.</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>📌 Backing Store</h3>
<p>یک <strong>Backing Store</strong> به‌تنهایی هیچ کاربردی برای برنامه‌نویس ندارد، مگر این‌که در معرض استفاده قرار گیرد. کلاس استاندارد .NET برای این منظور، <strong>Stream</strong> است. این کلاس مجموعه‌ای استاندارد از متدها را برای <strong>خواندن (Reading)</strong>، <strong>نوشتن (Writing)</strong> و <strong>مکان‌یابی (Positioning)</strong> در اختیار قرار می‌دهد.</p>
<p>برخلاف <strong>آرایه (Array)</strong> که همه داده‌های پشتیبان آن به‌طور هم‌زمان در حافظه قرار دارند، <strong>Stream</strong> داده‌ها را به‌صورت <strong>سریالی (Serially)</strong> مدیریت می‌کند—یا یک بایت در هر بار، یا در بلوک‌هایی با اندازه قابل مدیریت. به همین دلیل، یک Stream می‌تواند بدون توجه به اندازه Backing Store، فقط از مقدار کمی حافظه ثابت استفاده کند.</p>
<hr>
<h3>🗂️ دسته‌بندی Streamها</h3>
<p>استریم‌ها به دو دسته تقسیم می‌شوند:</p>
<ol>
<li>
<p><strong>Backing Store Streams</strong><br>
این استریم‌ها به یک نوع خاص از Backing Store متصل هستند، مثل <code>FileStream</code> یا <code>NetworkStream</code>.</p>
</li>
<li>
<p><strong>Decorator Streams</strong><br>
این استریم‌ها روی یک استریم دیگر سوار می‌شوند و داده‌ها را به نوعی تغییر می‌دهند، مثل <code>DeflateStream</code> یا <code>CryptoStream</code>.</p>
</li>
</ol>
<hr>
<h3>🌟 مزایای معماری Decorator Streams</h3>
<ul>
<li>آن‌ها استریم‌های Backing Store را از نیاز به پیاده‌سازی ویژگی‌هایی مثل <strong>فشرده‌سازی (Compression)</strong> و <strong>رمزنگاری (Encryption)</strong> آزاد می‌کنند.</li>
<li>وقتی یک استریم با Decorator پوشانده می‌شود، <strong>رابط (Interface)</strong> آن تغییر نمی‌کند.</li>
<li>شما می‌توانید Decoratorها را <strong>در زمان اجرا (Runtime)</strong> متصل کنید.</li>
<li>می‌توان چند Decorator را به هم زنجیر کرد (مثلاً یک <strong>فشرده‌ساز</strong> و سپس یک <strong>رمزنگار</strong>).</li>
</ul>
<hr>
<h3>🔗 نقش Adapter</h3>
<p>هر دو نوع استریم (Backing Store و Decorator) صرفاً با <strong>بایت‌ها</strong> کار می‌کنند. گرچه این رویکرد انعطاف‌پذیر و کارآمد است، ولی بسیاری از برنامه‌ها در سطوح بالاتر کار می‌کنند—مثل <strong>متن (Text)</strong> یا <strong>XML</strong>.</p>
<p>اینجا است که <strong>Adapter</strong> وارد عمل می‌شود. Adapter با <strong>پوشاندن (Wrapping)</strong> یک استریم، متدهایی تخصصی برای یک فرمت خاص ارائه می‌دهد.</p>
<ul>
<li>یک <strong>TextReader</strong> متدی به نام <code>ReadLine</code> دارد.</li>
<li>یک <strong>XmlWriter</strong> متدی به نام <code>WriteAttributes</code> دارد.</li>
</ul>
<p>Adapter درست مثل یک Decorator، یک استریم را می‌پوشاند. اما بر خلاف Decorator، خود یک استریم نیست و معمولاً متدهای <strong>بایت‌محور</strong> را به‌طور کامل پنهان می‌کند.</p>
<hr>
<h3>📝 خلاصه</h3>
<ul>
<li><strong>Backing Store Streams</strong> داده خام را فراهم می‌کنند.</li>
<li><strong>Decorator Streams</strong> تغییرات باینری شفاف مثل رمزنگاری ارائه می‌دهند.</li>
<li><strong>Adapters</strong> متدهای سطح بالاتر برای کار با انواعی مثل رشته‌ها (Strings) و XML فراهم می‌کنند.</li>
</ul>
<p>📊 شکل 15-1 ارتباط میان این اجزاء را نشان می‌دهد. برای ساخت یک زنجیره، کافی است یک شیء را به سازنده (Constructor) شیء دیگر بدهید.</p>
<hr>
<h2>⚙️ استفاده از Streams</h2>
<p>کلاس <strong>Stream</strong> یک کلاس <strong>Abstract</strong> است که پایه‌ای برای تمام استریم‌ها محسوب می‌شود. این کلاس متدها و ویژگی‌هایی برای سه عملیات بنیادی تعریف می‌کند:</p>
<ul>
<li><strong>خواندن (Reading)</strong></li>
<li><strong>نوشتن (Writing)</strong></li>
<li><strong>جستجو یا مکان‌یابی (Seeking)</strong></li>
</ul>
<p>به‌علاوه، برای کارهای مدیریتی مثل:</p>
<ul>
<li><strong>بستن (Closing)</strong></li>
<li><strong>تخلیه یا Flush کردن</strong></li>
<li><strong>پیکربندی Timeoutها</strong></li>
</ul>
<p>نیز متدها و ویژگی‌هایی در اختیار قرار می‌دهد (جدول 15-1 را ببینید).</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>⚡ نسخه‌های Asynchronous</h3>
<p>متدهای <strong>Read</strong> و <strong>Write</strong> نسخه‌های <strong>Asynchronous</strong> هم دارند که مقدار <strong>Task</strong> برمی‌گردانند و به‌صورت اختیاری یک <strong>CancellationToken</strong> می‌پذیرند. همچنین نسخه‌های Overload برای کار با نوع‌های <code>Span&lt;T&gt;</code> و <code>Memory&lt;T&gt;</code> (که در فصل ۲۳ توضیح داده می‌شوند) وجود دارد.</p>
<hr>
<h3>📂 نمونه کد: خواندن، نوشتن و Seek در FileStream</h3>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.IO;

<span class="hljs-comment">// ایجاد فایلی به نام test.txt در مسیر جاری:</span>
<span class="hljs-keyword">using</span> (Stream s = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;test.txt&quot;</span>, FileMode.Create))
{
    Console.WriteLine(s.CanRead);   <span class="hljs-comment">// True</span>
    Console.WriteLine(s.CanWrite);  <span class="hljs-comment">// True</span>
    Console.WriteLine(s.CanSeek);   <span class="hljs-comment">// True</span>

    s.WriteByte(<span class="hljs-number">101</span>);
    s.WriteByte(<span class="hljs-number">102</span>);

    <span class="hljs-built_in">byte</span>[] block = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
    s.Write(block, <span class="hljs-number">0</span>, block.Length);      <span class="hljs-comment">// نوشتن یک بلوک 5 بایتی</span>

    Console.WriteLine(s.Length);          <span class="hljs-comment">// 7</span>
    Console.WriteLine(s.Position);        <span class="hljs-comment">// 7</span>

    s.Position = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// بازگشت به ابتدای فایل</span>
    Console.WriteLine(s.ReadByte());      <span class="hljs-comment">// 101</span>
    Console.WriteLine(s.ReadByte());      <span class="hljs-comment">// 102</span>

    <span class="hljs-comment">// خواندن داده از استریم و بازنویسی در آرایه block:</span>
    Console.WriteLine(s.Read(block, <span class="hljs-number">0</span>, block.Length));   <span class="hljs-comment">// 5</span>

    <span class="hljs-comment">// چون در انتهای فایل هستیم، بار بعدی خواندن 0 برمی‌گرداند:</span>
    Console.WriteLine(s.Read(block, <span class="hljs-number">0</span>, block.Length));   <span class="hljs-comment">// 0</span>
}
</code></pre>
<hr>
<h3>🌀 نمونه کد: استفاده از متدهای Async</h3>
<p>خواندن یا نوشتن به‌صورت <strong>Asynchronous</strong> فقط به این معنی است که به‌جای <strong>Read/Write</strong>، از <strong>ReadAsync/WriteAsync</strong> استفاده کنید و نتیجه را <code>await</code> کنید (و همچنین باید متد فراخواننده <code>async</code> تعریف شود، همان‌طور که در فصل ۱۴ توضیح داده شد).</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncDemo</span>()</span>
{
    <span class="hljs-keyword">using</span> (Stream s = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;test.txt&quot;</span>, FileMode.Create))
    {
        <span class="hljs-built_in">byte</span>[] block = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };

        <span class="hljs-keyword">await</span> s.WriteAsync(block, <span class="hljs-number">0</span>, block.Length);   <span class="hljs-comment">// نوشتن به‌صورت Async</span>
        s.Position = <span class="hljs-number">0</span>;                               <span class="hljs-comment">// بازگشت به ابتدای فایل</span>

        <span class="hljs-comment">// خواندن دوباره داده‌ها از استریم به آرایه block:</span>
        Console.WriteLine(<span class="hljs-keyword">await</span> s.ReadAsync(block, <span class="hljs-number">0</span>, block.Length));   <span class="hljs-comment">// 5</span>
    }
}
</code></pre>
<p>متدهای Asynchronous کمک می‌کنند برنامه‌های <strong>Responsive</strong> و <strong>Scalable</strong> نوشته شوند که بتوانند با استریم‌های بالقوه کند (به‌ویژه استریم‌های شبکه‌ای) کار کنند، بدون این‌که یک Thread به‌طور کامل مشغول شود.</p>
<blockquote>
<p>برای سادگی، در بیشتر مثال‌های این فصل از متدهای <strong>Synchronous</strong> استفاده می‌کنیم. با این حال، در بیشتر سناریوهای <strong>I/O شبکه‌ای</strong> توصیه می‌شود از متدهای Async استفاده کنید.</p>
</blockquote>
<hr>
<h2>✍️ خواندن و نوشتن (Reading and Writing)</h2>
<p>یک استریم می‌تواند از <strong>خواندن</strong>، <strong>نوشتن</strong> یا هر دو پشتیبانی کند.</p>
<ul>
<li>اگر <code>CanWrite</code> برابر <code>false</code> باشد، استریم <strong>فقط خواندنی</strong> است.</li>
<li>اگر <code>CanRead</code> برابر <code>false</code> باشد، استریم <strong>فقط نوشتنی</strong> است.</li>
</ul>
<p>🔹 متد <code>Read</code> یک بلوک داده از استریم می‌گیرد و آن را درون یک آرایه قرار می‌دهد. این متد تعداد بایت‌های خوانده‌شده را برمی‌گرداند که همیشه <strong>کمتر یا مساوی</strong> با آرگومان <code>count</code> است.</p>
<ul>
<li>اگر مقدار کمتر از <code>count</code> باشد، یعنی یا به انتهای استریم رسیده‌ایم، یا داده‌ها در <strong>قطعات کوچک‌تر</strong> برگردانده می‌شوند (مثل حالت معمول در استریم‌های شبکه‌ای).</li>
<li>در این شرایط، بخش باقی‌مانده از آرایه بدون تغییر باقی می‌ماند.</li>
</ul>
<blockquote>
<p>رسیدن به انتهای استریم فقط زمانی قطعی است که <code>Read</code> مقدار <code>0</code> برگرداند.</p>
</blockquote>
<hr>
<h3>❌ مثال اشتباه</h3>
<p>فرض کنید یک استریم ۱۰۰۰ بایتی داریم:</p>
<pre class="hljs"><code><span class="hljs-comment">// فرض کنید s یک استریم است:</span>
<span class="hljs-built_in">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1000</span>];
s.Read(data, <span class="hljs-number">0</span>, data.Length);
</code></pre>
<p>در این حالت، <code>Read</code> ممکن است هر مقداری بین <strong>۱ تا ۱۰۰۰</strong> برگرداند و بخش باقی‌مانده خوانده نشود.</p>
<hr>
<h3>✅ مثال درست</h3>
<pre class="hljs"><code><span class="hljs-built_in">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1000</span>];
<span class="hljs-comment">// bytesRead در نهایت همیشه 1000 خواهد بود، مگر این‌که طول استریم کمتر باشد:</span>
<span class="hljs-built_in">int</span> bytesRead = <span class="hljs-number">0</span>;
<span class="hljs-built_in">int</span> chunkSize = <span class="hljs-number">1</span>;

<span class="hljs-keyword">while</span> (bytesRead &lt; data.Length &amp;&amp; chunkSize &gt; <span class="hljs-number">0</span>)
    bytesRead += chunkSize = s.Read(data, bytesRead, data.Length - bytesRead);
</code></pre>
<hr>
<h3>🆕 متدهای جدید در .NET 7</h3>
<p>از نسخه .NET 7، کلاس <strong>Stream</strong> متدهای کمکی زیر را دارد:</p>
<ul>
<li><code>ReadExactly</code></li>
<li><code>ReadAtLeast</code></li>
</ul>
<p>(به همراه نسخه‌های Async آن‌ها).</p>
<pre class="hljs"><code><span class="hljs-built_in">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1000</span>];
s.ReadExactly(data);   <span class="hljs-comment">// دقیقاً 1000 بایت می‌خواند</span>
</code></pre>
<p>معادل:</p>
<pre class="hljs"><code>s.ReadExactly(data, offset: <span class="hljs-number">0</span>, count: <span class="hljs-number">1000</span>);
</code></pre>
<hr>
<h3>📦 BinaryReader</h3>
<p>نوع <strong>BinaryReader</strong> راه‌حل دیگری برای این کار است:</p>
<pre class="hljs"><code><span class="hljs-built_in">byte</span>[] data = <span class="hljs-keyword">new</span> BinaryReader(s).ReadBytes(<span class="hljs-number">1000</span>);
</code></pre>
<ul>
<li>اگر طول استریم کمتر از ۱۰۰۰ بایت باشد، اندازه آرایه متناسب با طول واقعی استریم خواهد بود.</li>
<li>اگر استریم قابلیت <code>Seek</code> داشته باشد، می‌توان با جایگزین کردن ۱۰۰۰ با <code>(int)s.Length</code> کل محتوای آن را خواند.</li>
</ul>
<blockquote>
<p>جزئیات بیشتر درباره BinaryReader در بخش <strong>“Stream Adapters”</strong> (صفحه 709) آمده است.</p>
</blockquote>
<hr>
<h3>🔹 ReadByte و WriteByte</h3>
<ul>
<li>
<p>متد <code>ReadByte</code> یک بایت می‌خواند و در صورت رسیدن به انتهای استریم، <code>-1</code> برمی‌گرداند.<br>
(به همین دلیل مقدار بازگشتی آن <code>int</code> است، چون نوع <code>byte</code> نمی‌تواند <code>-1</code> برگرداند).</p>
</li>
<li>
<p>متدهای <code>Write</code> و <code>WriteByte</code> داده را به استریم می‌فرستند. اگر ارسال کامل بایت‌ها ممکن نباشد، یک <strong>Exception</strong> پرتاب می‌شود.</p>
</li>
</ul>
<hr>
<h2>🎯 جستجو در استریم (Seeking)</h2>
<ul>
<li>آرگومان <code>offset</code> در متدهای <strong>Read/Write</strong> به اندیس شروع در آرایه <strong>Buffer</strong> اشاره دارد، نه به موقعیت در خود استریم.</li>
<li>یک استریم <strong>Seekable</strong> است اگر ویژگی <code>CanSeek</code> آن <code>true</code> باشد (مثل FileStream).</li>
</ul>
<p>با یک استریم Seekable می‌توان:</p>
<ul>
<li>مقدار <code>Length</code> را پرسید یا با <code>SetLength</code> تغییر داد.</li>
<li>در هر لحظه <code>Position</code> را تغییر داد و مشخص کرد از کجا بخواند یا بنویسد.</li>
</ul>
<p>🔹 ویژگی <code>Position</code> نسبت به ابتدای استریم است، اما متد <code>Seek</code> اجازه می‌دهد نسبت به موقعیت فعلی یا انتهای استریم حرکت کنید.</p>
<ul>
<li>تغییر <code>Position</code> در FileStream معمولاً فقط چند میکروثانیه طول می‌کشد. اگر قرار است این کار را <strong>میلیون‌ها بار</strong> در یک حلقه انجام دهید، استفاده از <code>MemoryMappedFile</code> انتخاب بهتری نسبت به FileStream خواهد بود (صفحه 736 را ببینید).</li>
<li>در استریم‌های غیرقابل Seek (مثل استریم رمزنگاری)، تنها راه دانستن طول، خواندن کل آن است. همچنین برای خواندن دوباره یک بخش قبلی، باید استریم را ببندید و یک استریم جدید باز کنید.</li>
</ul>
<hr>
<h2>🔒 بستن و Flush کردن استریم‌ها</h2>
<p>استریم‌ها پس از استفاده باید <strong>Dispose</strong> شوند تا منابع زیربنایی مثل <strong>File Handle</strong> و <strong>Socket Handle</strong> آزاد شوند.</p>
<p>🔹 ساده‌ترین راه تضمین این موضوع، قرار دادن استریم درون یک <strong>بلوک using</strong> است.</p>
<p>قوانین کلی مدیریت استریم‌ها:</p>
<ul>
<li>متدهای <strong>Dispose</strong> و <strong>Close</strong> عملکرد یکسانی دارند.</li>
<li>بستن یا Dispose کردن چندباره یک استریم مشکلی ایجاد نمی‌کند.</li>
<li>بستن یک استریم Decorator باعث بسته شدن خودش و <strong>Backing Store</strong> آن می‌شود.</li>
<li>در یک زنجیره از Decoratorها، بستن Decorator بیرونی کل زنجیره را می‌بندد.</li>
</ul>
<p>برخی استریم‌ها داده‌ها را برای بهبود کارایی در حافظه <strong>Buffer</strong> می‌کنند (مثل FileStream). این باعث می‌شود داده‌ای که به استریم می‌نویسید، بلافاصله وارد Backing Store نشود.</p>
<ul>
<li>متد <strong>Flush</strong> باعث می‌شود داده‌های بافر شده فوراً نوشته شوند.</li>
<li><code>Flush</code> به‌صورت خودکار هنگام بسته شدن استریم صدا زده می‌شود، بنابراین هیچ‌وقت نیازی به نوشتن کدی مثل زیر ندارید:</li>
</ul>
<pre class="hljs"><code>s.Flush();
s.Close();
</code></pre>
<h2>⏱️ Timeoutها</h2>
<p>یک استریم زمانی از <strong>Timeout</strong> پشتیبانی می‌کند که ویژگی <code>CanTimeout</code> مقدار <code>true</code> داشته باشد.</p>
<ul>
<li>استریم‌های <strong>شبکه‌ای (Network Streams)</strong> از Timeout پشتیبانی می‌کنند.</li>
<li>استریم‌های <strong>فایل (File Streams)</strong> و <strong>حافظه (Memory Streams)</strong> از Timeout پشتیبانی نمی‌کنند.</li>
</ul>
<p>برای استریم‌هایی که Timeout را پشتیبانی می‌کنند:</p>
<ul>
<li>ویژگی‌های <code>ReadTimeout</code> و <code>WriteTimeout</code> مدت زمان Timeout را بر حسب <strong>میلی‌ثانیه</strong> مشخص می‌کنند.</li>
<li>مقدار <code>0</code> یعنی <strong>بدون Timeout</strong>.</li>
<li>اگر Timeout رخ دهد، متدهای <code>Read</code> و <code>Write</code> یک <strong>Exception</strong> پرتاب می‌کنند.</li>
</ul>
<p>⚠️ متدهای Asynchronous (<code>ReadAsync</code>/<code>WriteAsync</code>) از Timeout پشتیبانی نمی‌کنند. در این حالت، می‌توانید یک <strong>CancellationToken</strong> به این متدها بدهید.</p>
<hr>
<h2>🧵 Thread Safety</h2>
<p>به‌طور کلی، استریم‌ها <strong>Thread-Safe</strong> نیستند؛ یعنی دو Thread نمی‌توانند به‌طور هم‌زمان روی یک استریم بخوانند یا بنویسند، چون احتمال خطا وجود دارد.</p>
<p>کلاس <strong>Stream</strong> یک راهکار ساده ارائه می‌دهد: متد استاتیک <code>Synchronized</code>.</p>
<ul>
<li>این متد یک استریم از هر نوع را می‌پذیرد و یک <strong>Wrapper ایمن برای Thread</strong> برمی‌گرداند.</li>
<li>این Wrapper با گرفتن یک <strong>قفل انحصاری (Exclusive Lock)</strong> در اطراف هر عملیات خواندن، نوشتن یا Seek، تضمین می‌کند که فقط یک Thread در هر لحظه بتواند عمل مورد نظر را انجام دهد.</li>
</ul>
<p>🔹 نتیجه عملی این است که چند Thread می‌توانند به‌طور هم‌زمان داده‌ها را به یک استریم <strong>Append</strong> کنند.<br>
اما سایر فعالیت‌ها (مثل خواندن هم‌زمان) نیازمند قفل‌گذاری اضافی هستند تا مطمئن شوید هر Thread دقیقاً به بخش درستی از استریم دسترسی دارد.</p>
<p>📖 جزئیات کامل‌تر درباره <strong>Thread Safety</strong> در فصل ۲۱ توضیح داده می‌شود.</p>
<hr>
<h3>🚀 ویژگی جدید در .NET 6</h3>
<p>از نسخه .NET 6 به بعد، می‌توانید برای عملیات <strong>File I/O ایمن و کارآمد در برابر Thread</strong> از کلاس <strong>RandomAccess</strong> استفاده کنید.</p>
<ul>
<li>این کلاس امکان <strong>Thread-Safe File I/O</strong> با کارایی بالا را فراهم می‌کند.</li>
<li>همچنین اجازه می‌دهد چندین <strong>Buffer</strong> را برای بهبود عملکرد به‌طور هم‌زمان پاس دهید.</li>
</ul>
<hr>
<h2>🗄️ Backing Store Streams</h2>
<p>📊 شکل 15-2 استریم‌های اصلی <strong>Backing Store</strong> که توسط .NET ارائه می‌شوند را نشان می‌دهد.</p>
<p>🔹 علاوه بر این، یک <strong>Null Stream</strong> هم از طریق فیلد استاتیک <code>Stream.Null</code> در دسترس است.</p>
<p><strong>Null Stream</strong> می‌تواند هنگام نوشتن <strong>Unit Test</strong>ها بسیار مفید باشد.</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h2>📂 FileStream</h2>
<p>در بخش‌های بعدی، به بررسی <strong>FileStream</strong> و <strong>MemoryStream</strong> می‌پردازیم؛ و در بخش پایانی این فصل، <strong>IsolatedStorageStream</strong> را معرفی می‌کنیم. در فصل ۱۶ هم به <strong>NetworkStream</strong> خواهیم پرداخت.</p>
<hr>
<h3>✨ ویژگی‌های FileStream</h3>
<p>پیش‌تر استفاده‌ی پایه‌ای از <strong>FileStream</strong> برای خواندن و نوشتن بایت‌ها را دیدیم. حالا بیایید ویژگی‌های خاص این کلاس را دقیق‌تر بررسی کنیم.</p>
<p>🔹 اگر هنوز از <strong>UWP (Universal Windows Platform)</strong> استفاده می‌کنید، می‌توانید عملیات فایل را با نوع‌های موجود در فضای نام <strong>Windows.Storage</strong> انجام دهید. توضیحات بیشتر در <a href="http://www.albahari.com/nutshell">ضمیمه آنلاین</a> آمده است.</p>
<hr>
<h3>🛠️ ساخت یک FileStream</h3>
<p>ساده‌ترین راه برای نمونه‌سازی <strong>FileStream</strong> استفاده از متدهای استاتیک کلاس <strong>File</strong> است:</p>
<pre class="hljs"><code>FileStream fs1 = File.OpenRead(<span class="hljs-string">&quot;readme.bin&quot;</span>);   <span class="hljs-comment">// فقط خواندن</span>
FileStream fs2 = File.OpenWrite(<span class="hljs-string">&quot;writeme.tmp&quot;</span>); <span class="hljs-comment">// فقط نوشتن</span>
FileStream fs3 = File.Create(<span class="hljs-string">&quot;readwrite.tmp&quot;</span>);  <span class="hljs-comment">// خواندن/نوشتن</span>
</code></pre>
<p>⚠️ تفاوت <code>OpenWrite</code> و <code>Create</code>:</p>
<ul>
<li><code>Create</code> محتوای قبلی فایل را <strong>کامل پاک می‌کند</strong> (truncate).</li>
<li><code>OpenWrite</code> محتوای موجود را نگه می‌دارد و مکان استریم را روی صفر قرار می‌دهد.<br>
اگر کمتر از اندازه‌ی قبلی داده بنویسید، نتیجه ترکیبی از داده‌های قدیمی و جدید خواهد شد.</li>
</ul>
<p>همچنین می‌توانید مستقیم از <strong>سازنده‌ی FileStream</strong> استفاده کنید. سازنده‌ها امکان کنترل کامل روی:</p>
<ul>
<li>نام فایل یا <strong>file handle سطح پایین</strong></li>
<li>حالت‌های ساخت و دسترسی به فایل</li>
<li>گزینه‌های اشتراک‌گذاری (sharing)، بافرینگ و امنیت</li>
</ul>
<p>را فراهم می‌کنند. برای مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> fs = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;readwrite.tmp&quot;</span>, FileMode.Open);
</code></pre>
<p>(کلیدواژه‌ی <code>using</code> تضمین می‌کند که استریم پس از خروج از محدوده dispose شود).</p>
<p>🔎 در ادامه به جزئیات <code>FileMode</code> می‌پردازیم.</p>
<hr>
<h3>⚡ متدهای میان‌بُر کلاس File</h3>
<p>این متدها کل محتوای فایل را در یک مرحله می‌خوانند:</p>
<ul>
<li><code>File.ReadAllText</code> → بازگرداندن یک <strong>string</strong></li>
<li><code>File.ReadAllLines</code> → بازگرداندن یک <strong>آرایه از string</strong></li>
<li><code>File.ReadAllBytes</code> → بازگرداندن یک <strong>آرایه‌ی بایت</strong></li>
</ul>
<p>این متدها کل فایل را در یک مرحله می‌نویسند:</p>
<ul>
<li><code>File.WriteAllText</code></li>
<li><code>File.WriteAllLines</code></li>
<li><code>File.WriteAllBytes</code></li>
<li><code>File.AppendAllText</code> (مناسب برای اضافه‌کردن به فایل‌های لاگ)</li>
</ul>
<p>همچنین متدی به نام <code>File.ReadLines</code> وجود دارد که مانند <code>ReadAllLines</code> است، با این تفاوت که یک <code>IEnumerable&lt;string&gt;</code> <strong>Lazy</strong> بازمی‌گرداند (به‌صورت تدریجی خوانده می‌شود، نه یک‌جا). این کارایی بهتری دارد چون کل فایل یک‌جا در حافظه بارگذاری نمی‌شود.</p>
<p>مثال با LINQ برای شمردن تعداد خطوطی که طول آن‌ها بیشتر از ۸۰ کاراکتر است:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> longLines = File.ReadLines(<span class="hljs-string">&quot;filePath&quot;</span>)
                   .Count(l =&gt; l.Length &gt; <span class="hljs-number">80</span>);
</code></pre>
<hr>
<h3>📁 مشخص‌کردن نام فایل</h3>
<p>نام فایل می‌تواند:</p>
<ul>
<li>
<p><strong>مطلق (Absolute)</strong> باشد → مثل:</p>
<ul>
<li>ویندوز: <code>c:\temp\test.txt</code></li>
<li>یونیکس: <code>/tmp/test.txt</code></li>
</ul>
</li>
<li>
<p><strong>نسبی (Relative)</strong> به دایرکتوری فعلی → مثل:</p>
<ul>
<li><code>test.txt</code></li>
<li><code>temp\test.txt</code></li>
</ul>
</li>
</ul>
<p>🔹 دایرکتوری فعلی برنامه از طریق ویژگی استاتیک:</p>
<pre class="hljs"><code>Environment.CurrentDirectory
</code></pre>
<p>قابل دسترسی و تغییر است.</p>
<p>⚠️ اما دایرکتوری فعلی <strong>ممکن است با مسیر اجرایی برنامه یکی نباشد</strong>. بنابراین <strong>هیچ‌وقت</strong> برای یافتن فایل‌های همراه executable روی آن حساب نکنید.</p>
<p>دایرکتوری پایه‌ی اپلیکیشن از طریق:</p>
<pre class="hljs"><code>AppDomain.CurrentDomain.BaseDirectory
</code></pre>
<p>دریافت می‌شود (معمولاً همان پوشه‌ی فایل اجرایی است).</p>
<p>برای مشخص کردن نام فایل به‌صورت نسبی نسبت به این دایرکتوری:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> baseFolder = AppDomain.CurrentDomain.BaseDirectory;
<span class="hljs-built_in">string</span> logoPath = Path.Combine(baseFolder, <span class="hljs-string">&quot;logo.jpg&quot;</span>);
Console.WriteLine(File.Exists(logoPath));
</code></pre>
<hr>
<h3>🌐 مسیرهای شبکه‌ای (UNC Path)</h3>
<p>در ویندوز می‌توانید فایل‌ها را از طریق مسیر <strong>UNC</strong> بخوانید/بنویسید:</p>
<ul>
<li><code>\\JoesPC\PicShare\pic.jpg</code></li>
<li><code>\\10.1.1.2\PicShare\pic.jpg</code></li>
</ul>
<p>🔹 در macOS یا Unix برای دسترسی به یک Windows File Share باید ابتدا آن را به filesystem خود mount کنید، سپس مانند مسیر معمولی در C# باز کنید.</p>
<hr>
<h3>⚙️ مشخص کردن FileMode</h3>
<p>تمام سازنده‌های <code>FileStream</code> که یک نام فایل می‌پذیرند، نیاز به یک آرگومان از نوع <strong>FileMode enum</strong> دارند.</p>
<p>📊 شکل 15-3 نشان می‌دهد چگونه باید یک FileMode انتخاب کنید. نتایج مشابه فراخوانی متدهای استاتیک کلاس <strong>File</strong> خواهد بود.</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h2>📂 FileStream</h2>
<p>🔹 اگر روی فایل‌های <strong>Hidden</strong> از <code>File.Create</code> یا <code>FileMode.Create</code> استفاده کنید، یک <strong>استثنا (Exception)</strong> پرتاب می‌شود. برای بازنویسی یک فایل مخفی، باید ابتدا آن را <strong>حذف</strong> و سپس دوباره ایجاد کنید:</p>
<pre class="hljs"><code>File.Delete(<span class="hljs-string">&quot;hidden.txt&quot;</span>);
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">file</span> = File.Create(<span class="hljs-string">&quot;hidden.txt&quot;</span>);
</code></pre>
<hr>
<h3>📖 FileAccess</h3>
<p>اگر فقط نام فایل و یک <code>FileMode</code> را به سازنده‌ی <code>FileStream</code> بدهید، نتیجه (با یک استثنا) یک استریم <strong>قابل خواندن/نوشتن</strong> خواهد بود.<br>
اما می‌توانید با مشخص‌کردن آرگومان <strong>FileAccess</strong> دسترسی را محدود کنید:</p>
<pre class="hljs"><code>[<span class="hljs-meta">Flags</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> FileAccess { Read = <span class="hljs-number">1</span>, Write = <span class="hljs-number">2</span>, ReadWrite = <span class="hljs-number">3</span> }
</code></pre>
<p>مثال: ساختن یک استریم فقط-خواندنی (معادل <code>File.OpenRead</code>):</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> fs = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;x.bin&quot;</span>, FileMode.Open, FileAccess.Read);
</code></pre>
<p>⚠️ حالت خاص: <code>FileMode.Append</code> → فقط <strong>Write-only</strong> است.<br>
اگر می‌خواهید داده‌ها را <strong>اضافه (Append)</strong> کنید و همزمان امکان خواندن داشته باشید، باید از <code>FileMode.Open</code> یا <code>FileMode.OpenOrCreate</code> استفاده کنید و سپس مکان استریم را به انتهای فایل ببرید:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> fs = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;myFile.bin&quot;</span>, FileMode.Open);
fs.Seek(<span class="hljs-number">0</span>, SeekOrigin.End);
</code></pre>
<hr>
<h3>⚙️ ویژگی‌های پیشرفته‌ی FileStream</h3>
<p>می‌توانید هنگام ساخت یک FileStream آرگومان‌های اضافی بدهید:</p>
<ul>
<li>
<p><strong>FileShare enum</strong> → میزان دسترسی سایر پردازش‌ها (None، Read، ReadWrite، Write).</p>
</li>
<li>
<p><strong>Buffer size</strong> → اندازه بافر داخلی (به‌صورت پیش‌فرض ۴KB).</p>
</li>
<li>
<p><strong>Async flag</strong> → واگذاری عملیات ناهمگام به سیستم‌عامل.</p>
</li>
<li>
<p><strong>FileOptions flags</strong> → شامل:</p>
<ul>
<li><code>Encrypted</code> → رمزنگاری توسط سیستم‌عامل</li>
<li><code>DeleteOnClose</code> → حذف خودکار فایل هنگام بسته‌شدن</li>
<li><code>RandomAccess</code> → بهینه‌سازی برای دسترسی تصادفی</li>
<li><code>SequentialScan</code> → بهینه‌سازی برای اسکن ترتیبی</li>
<li><code>WriteThrough</code> → غیرفعال کردن کش سیستم‌عامل (برای فایل‌های تراکنشی یا لاگ‌ها)</li>
</ul>
</li>
</ul>
<p>⚠️ فلگ‌هایی که سیستم‌عامل پشتیبانی نکند، بی‌صدا (silently) نادیده گرفته می‌شوند.</p>
<p>اگر با <code>FileShare.ReadWrite</code> فایل را باز کنید، چند پردازش یا کاربر می‌توانند همزمان بخوانند/بنویسند. برای جلوگیری از تداخل، می‌توان بخش‌هایی از فایل را قفل کرد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> position, <span class="hljs-built_in">long</span> length</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> position, <span class="hljs-built_in">long</span> length</span>)</span>;
</code></pre>
<p>متد <code>Lock</code> اگر ناحیه‌ای از فایل قبلاً قفل باشد، استثنا پرتاب می‌کند.</p>
<hr>
<h2>🧠 MemoryStream</h2>
<p><strong>MemoryStream</strong> از یک آرایه در حافظه به‌عنوان <strong>backing store</strong> استفاده می‌کند.<br>
این یعنی تمام داده‌ها باید یک‌جا در حافظه باشند (برخلاف مزیت اصلی Stream).</p>
<p>اما همچنان مفید است، به‌خصوص وقتی:</p>
<ul>
<li>نیاز به دسترسی تصادفی (Random Access) به یک استریم غیرقابل Seek دارید.</li>
<li>داده‌ی اصلی کوچک و قابل مدیریت است.</li>
</ul>
<p>📌 مثال: کپی کردن داده‌ی یک استریم درون MemoryStream:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> ms = <span class="hljs-keyword">new</span> MemoryStream();
sourceStream.CopyTo(ms);
</code></pre>
<ul>
<li>
<p>برای گرفتن داده‌ها:</p>
<ul>
<li><code>ToArray()</code> → یک کپی از داده‌ها بازمی‌گرداند.</li>
<li><code>GetBuffer()</code> → مرجع مستقیم به آرایه‌ی ذخیره‌سازی می‌دهد (کارآمدتر است، اما طول آن معمولاً از داده‌ی واقعی بیشتر است).</li>
</ul>
</li>
</ul>
<p>📍 بستن یا Flush کردن MemoryStream اختیاری است:</p>
<ul>
<li>بعد از <code>Close</code> دیگر نمی‌توانید بخوانید/بنویسید، ولی همچنان <code>ToArray()</code> کار می‌کند.</li>
<li><code>Flush</code> هیچ تأثیری ندارد.</li>
</ul>
<hr>
<h2>🔗 PipeStream</h2>
<p><strong>PipeStream</strong> راهی ساده برای ارتباط بین پردازش‌ها (IPC) از طریق پروتکل <strong>Pipe</strong> سیستم‌عامل است.</p>
<h3>انواع Pipe</h3>
<ol>
<li><strong>Anonymous Pipe (سریع‌تر)</strong> → ارتباط یک‌طرفه بین یک پردازش والد و فرزند (روی همان سیستم).</li>
<li><strong>Named Pipe (انعطاف‌پذیرتر)</strong> → ارتباط دوطرفه بین پردازش‌های مختلف (روی یک سیستم یا بین سیستم‌ها در شبکه).</li>
</ol>
<p>📌 Pipes برای IPC روی یک کامپیوتر عالی هستند:</p>
<ul>
<li>نیازی به پروتکل شبکه ندارند (بدون سربار شبکه).</li>
<li>مشکلی با فایروال‌ها ندارند.</li>
</ul>
<hr>
<h3>کلاس‌ها</h3>
<p>PipeStream یک کلاس انتزاعی است. چهار زیرکلاس اصلی دارد:</p>
<ul>
<li><strong>AnonymousPipeServerStream</strong></li>
<li><strong>AnonymousPipeClientStream</strong></li>
<li><strong>NamedPipeServerStream</strong></li>
<li><strong>NamedPipeClientStream</strong></li>
</ul>
<p>🔹 Named Pipes ساده‌ترند، پس اول آن‌ها را بررسی می‌کنیم.</p>
<hr>
<h3>📡 Named Pipes</h3>
<p>ارتباط از طریق یک نام مشترک برقرار می‌شود. دو نقش اصلی وجود دارد:</p>
<ul>
<li><strong>Server</strong> → نمونه‌ای از <code>NamedPipeServerStream</code> ساخته و <code>WaitForConnection()</code> را صدا می‌زند.</li>
<li><strong>Client</strong> → نمونه‌ای از <code>NamedPipeClientStream</code> ساخته و <code>Connect()</code> را صدا می‌زند.</li>
</ul>
<p>سپس دو طرف از استریم برای خواندن/نوشتن استفاده می‌کنند.</p>
<p>📍 مثال ساده:</p>
<p><strong>Server</strong> → ارسال یک بایت (۱۰۰) و دریافت یک بایت:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> NamedPipeServerStream(<span class="hljs-string">&quot;pipedream&quot;</span>);
s.WaitForConnection();
s.WriteByte(<span class="hljs-number">100</span>);
Console.WriteLine(s.ReadByte());
</code></pre>
<p><strong>Client</strong> → دریافت بایت و ارسال یک بایت (۲۰۰):</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> NamedPipeClientStream(<span class="hljs-string">&quot;pipedream&quot;</span>);
s.Connect();
Console.WriteLine(s.ReadByte());
s.WriteByte(<span class="hljs-number">200</span>);
</code></pre>
<p>🔹 Pipeها به‌طور پیش‌فرض <strong>دوطرفه</strong> هستند. پس باید یک <strong>پروتکل توافقی</strong> بین Client و Server وجود داشته باشد تا هر دو همزمان ننویسند یا نخوانند.</p>
<hr>
<h3>📑 Message Transmission Mode (فقط ویندوز)</h3>
<p>برای پیام‌های طولانی‌تر، Pipeها یک حالت خاص به نام <strong>Message Mode</strong> دارند.<br>
در این حالت می‌توان با ویژگی <code>IsMessageComplete</code> فهمید یک پیام کامل دریافت شده است.</p>
<p>📌 مثال: خواندن کل پیام:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">byte</span>[] <span class="hljs-title">ReadMessage</span>(<span class="hljs-params">PipeStream s</span>)</span>
{
    MemoryStream ms = <span class="hljs-keyword">new</span> MemoryStream();
    <span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">0x1000</span>]; <span class="hljs-comment">// 4KB</span>
    <span class="hljs-keyword">do</span> { ms.Write(buffer, <span class="hljs-number">0</span>, s.Read(buffer, <span class="hljs-number">0</span>, buffer.Length)); }
    <span class="hljs-keyword">while</span> (!s.IsMessageComplete);
    <span class="hljs-keyword">return</span> ms.ToArray();
}
</code></pre>
<hr>
<h3>✨ فعال‌سازی Message Mode</h3>
<p><strong>Server</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> NamedPipeServerStream(
    <span class="hljs-string">&quot;pipedream&quot;</span>, PipeDirection.InOut, <span class="hljs-number">1</span>, PipeTransmissionMode.Message);

s.WaitForConnection();
<span class="hljs-built_in">byte</span>[] msg = Encoding.UTF8.GetBytes(<span class="hljs-string">&quot;Hello&quot;</span>);
s.Write(msg, <span class="hljs-number">0</span>, msg.Length);
Console.WriteLine(Encoding.UTF8.GetString(ReadMessage(s)));
</code></pre>
<p><strong>Client</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> NamedPipeClientStream(<span class="hljs-string">&quot;pipedream&quot;</span>);
s.Connect();
s.ReadMode = PipeTransmissionMode.Message;

Console.WriteLine(Encoding.UTF8.GetString(ReadMessage(s)));
<span class="hljs-built_in">byte</span>[] msg = Encoding.UTF8.GetBytes(<span class="hljs-string">&quot;Hello right back!&quot;</span>);
s.Write(msg, <span class="hljs-number">0</span>, msg.Length);
</code></pre>
<p>⚠️ <strong>Message Mode فقط روی ویندوز پشتیبانی می‌شود.</strong><br>
در سایر سیستم‌عامل‌ها → <code>PlatformNotSupportedException</code> پرتاب می‌شود.</p>
<hr>
<h3><strong>پایپ‌های ناشناس (Anonymous pipes)</strong></h3>
<p>یک <strong>پایپ ناشناس</strong> یک جریان ارتباطی یک‌طرفه بین یک <strong>پردازش والد (parent process)</strong> و یک <strong>پردازش فرزند (child process)</strong> فراهم می‌کند. به‌جای استفاده از یک نام سراسری در سیستم، پایپ‌های ناشناس از طریق یک <strong>هندل خصوصی (private handle)</strong> با هم ارتباط برقرار می‌کنند.</p>
<p>همانند پایپ‌های نام‌دار، در اینجا هم نقش‌های مشخصی برای <strong>کلاینت</strong> و <strong>سرور</strong> وجود دارد. با این حال، شیوه‌ی ارتباط کمی متفاوت است و به‌صورت زیر انجام می‌شود:</p>
<ol>
<li>سرور یک <strong>AnonymousPipeServerStream</strong> می‌سازد و به یک <strong>PipeDirection</strong> (جهت In یا Out) متعهد می‌شود.</li>
<li>سرور متد <strong>GetClientHandleAsString</strong> را صدا می‌زند تا یک شناسه برای پایپ بگیرد، سپس آن را به کلاینت می‌فرستد (معمولاً به‌عنوان آرگومان هنگام راه‌اندازی پردازش فرزند).</li>
<li>پردازش فرزند یک <strong>AnonymousPipeClientStream</strong> می‌سازد و جهت مخالف را مشخص می‌کند.</li>
<li>سرور هندل محلی‌ای که در مرحله‌ی ۲ ساخته شده بود را با متد <strong>DisposeLocalCopyOfClientHandle</strong> آزاد می‌کند.</li>
<li>حالا پردازش والد و فرزند می‌توانند از طریق خواندن/نوشتن استریم با هم ارتباط برقرار کنند.</li>
</ol>
<p>از آنجا که پایپ‌های ناشناس یک‌طرفه هستند، یک سرور برای ارتباط دوطرفه باید <strong>دو پایپ</strong> بسازد.</p>
<p>کد زیر نشان می‌دهد که چطور دو پایپ (ورودی و خروجی) ساخته می‌شوند و سپس یک پردازش فرزند راه‌اندازی می‌شود. در ادامه، یک بایت از سرور به فرزند ارسال شده و یک بایت در پاسخ دریافت می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span>
  {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">args</span>.Length == <span class="hljs-number">0</span>)
      <span class="hljs-comment">// بدون آرگومان = حالت سرور</span>
      AnonymousPipeServer();
    <span class="hljs-keyword">else</span>
      <span class="hljs-comment">// آرگومان‌ها = شناسه‌های پایپ برای حالت کلاینت</span>
      AnonymousPipeClient (<span class="hljs-keyword">args</span> [<span class="hljs-number">0</span>], <span class="hljs-keyword">args</span> [<span class="hljs-number">1</span>]);
  }

  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnonymousPipeClient</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> rxID, <span class="hljs-built_in">string</span> txID</span>)</span>
  {
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> rx = <span class="hljs-keyword">new</span> AnonymousPipeClientStream (PipeDirection.In, rxID);
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> tx = <span class="hljs-keyword">new</span> AnonymousPipeClientStream (PipeDirection.Out, txID);
    Console.WriteLine (<span class="hljs-string">&quot;Client received: &quot;</span> + rx.ReadByte ());
    tx.WriteByte (<span class="hljs-number">200</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnonymousPipeServer</span> ()</span>
  {
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> tx = <span class="hljs-keyword">new</span> AnonymousPipeServerStream (
                     PipeDirection.Out, HandleInheritability.Inheritable);
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> rx = <span class="hljs-keyword">new</span> AnonymousPipeServerStream (
                     PipeDirection.In, HandleInheritability.Inheritable);

    <span class="hljs-built_in">string</span> txID = tx.GetClientHandleAsString ();
    <span class="hljs-built_in">string</span> rxID = rx.GetClientHandleAsString ();

    <span class="hljs-comment">// ایجاد و راه‌اندازی پردازش فرزند</span>
    <span class="hljs-built_in">string</span> thisAssembly = Assembly.GetEntryAssembly().Location;
    <span class="hljs-built_in">string</span> thisExe = Path.ChangeExtension (thisAssembly, <span class="hljs-string">&quot;.exe&quot;</span>);
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">args</span> = <span class="hljs-string">$&quot;<span class="hljs-subst">{txID}</span> <span class="hljs-subst">{rxID}</span>&quot;</span>;
    <span class="hljs-keyword">var</span> startInfo = <span class="hljs-keyword">new</span> ProcessStartInfo (thisExe, <span class="hljs-keyword">args</span>);
    startInfo.UseShellExecute = <span class="hljs-literal">false</span>;   <span class="hljs-comment">// الزامی برای پردازش فرزند</span>
    Process p = Process.Start (startInfo);

    tx.DisposeLocalCopyOfClientHandle ();  <span class="hljs-comment">// آزادسازی منابع</span>
    rx.DisposeLocalCopyOfClientHandle ();

    tx.WriteByte (<span class="hljs-number">100</span>);    <span class="hljs-comment">// ارسال یک بایت به پردازش فرزند</span>
    Console.WriteLine (<span class="hljs-string">&quot;Server received: &quot;</span> + rx.ReadByte ());
    p.WaitForExit ();
  }
}
</code></pre>
<p>📌 همانند پایپ‌های نام‌دار، <strong>کلاینت و سرور باید ارسال و دریافت خود را هماهنگ کنند</strong> و روی طول هر انتقال توافق داشته باشند. متأسفانه پایپ‌های ناشناس از <strong>حالت پیام (message mode)</strong> پشتیبانی نمی‌کنند، بنابراین باید خودتان پروتکل مدیریت طول پیام را پیاده‌سازی کنید.</p>
<p>یکی از راه‌حل‌ها این است که در چهار بایت اول هر انتقال، یک <strong>عدد صحیح (integer)</strong> ارسال شود که طول پیام بعدی را مشخص کند. کلاس <strong>BitConverter</strong> متدهایی برای تبدیل بین یک عدد صحیح و یک آرایه‌ی ۴ بایتی فراهم می‌کند.</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-5.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<hr>
<h3><strong>BufferedStream (استریم بافر شده)</strong></h3>
<p>بافرینگ باعث بهبود کارایی می‌شود چون تعداد دفعات رفت‌وبرگشت به <strong>backing store</strong> (مثل فایل یا شبکه) را کاهش می‌دهد.</p>
<p>در مثال زیر ما یک <strong>FileStream</strong> را داخل یک <strong>BufferedStream</strong> با اندازه‌ی بافر ۲۰ کیلوبایت می‌پیچیم:</p>
<pre class="hljs"><code><span class="hljs-comment">// نوشتن 100K در یک فایل:</span>
File.WriteAllBytes (<span class="hljs-string">&quot;myFile.bin&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">100000</span>]);
<span class="hljs-keyword">using</span> FileStream fs = File.OpenRead (<span class="hljs-string">&quot;myFile.bin&quot;</span>);
<span class="hljs-keyword">using</span> BufferedStream bs = <span class="hljs-keyword">new</span> BufferedStream (fs, <span class="hljs-number">20000</span>);  <span class="hljs-comment">// بافر 20K</span>
bs.ReadByte();
Console.WriteLine (fs.Position);   <span class="hljs-comment">// 20000</span>
</code></pre>
<p>🔍 در این مثال، استریم زیرین (<strong>FileStream</strong>) بعد از خواندن فقط <strong>یک بایت</strong>، به اندازه‌ی ۲۰,۰۰۰ بایت جلو می‌رود؛ این به خاطر <strong>read-ahead buffering</strong> است. ما می‌توانیم متد <code>ReadByte</code> را <strong>۱۹,۹۹۹ بار دیگر</strong> صدا بزنیم، بدون اینکه دوباره <code>FileStream</code> درگیر شود.</p>
<p>✅ در عمل، بستن یک <strong>BufferedStream</strong> به طور خودکار استریم backing store زیرین را هم می‌بندد.</p>
<p>⚠️ ترکیب <strong>BufferedStream</strong> با <strong>FileStream</strong> (مثل این مثال) ارزش محدودی دارد، چون <strong>FileStream خودش بافر داخلی دارد</strong>. تنها کاربرد آن می‌تواند زمانی باشد که بخواهیم بافر یک <strong>FileStream</strong> ساخته‌شده را <strong>بزرگ‌تر کنیم</strong>.</p>
<hr>
<h3><strong>Stream Adapters (آداپتورهای استریم)</strong></h3>
<p>از آنجا که <strong>Stream فقط با بایت‌ها سروکار دارد</strong>، برای خواندن یا نوشتن داده‌هایی مثل <strong>رشته‌ها (string)</strong>، <strong>اعداد صحیح (int)</strong> یا <strong>عناصر XML</strong> باید از <strong>adapter</strong> استفاده کنید.</p>
<p>📌 .NET آداپتورهای زیر را فراهم کرده است:</p>
<ul>
<li>
<p><strong>آداپتورهای متنی (برای داده‌های رشته و کاراکتر):</strong></p>
<ul>
<li><code>TextReader</code>, <code>TextWriter</code></li>
<li><code>StreamReader</code>, <code>StreamWriter</code></li>
<li><code>StringReader</code>, <code>StringWriter</code></li>
</ul>
</li>
<li>
<p><strong>آداپتورهای باینری (برای انواع داده‌های اولیه مثل int, bool, string, float):</strong></p>
<ul>
<li><code>BinaryReader</code>, <code>BinaryWriter</code></li>
</ul>
</li>
<li>
<p><strong>آداپتورهای XML (پوشش داده‌شده در فصل 11):</strong></p>
<ul>
<li><code>XmlReader</code>, <code>XmlWriter</code></li>
</ul>
</li>
</ul>
<p>📖 شکل 15-5 روابط بین این نوع‌ها را نشان می‌دهد.</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-6.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3><strong>آداپتورهای متنی (Text Adapters)</strong></h3>
<p><code>TextReader</code> و <code>TextWriter</code> کلاس‌های پایه‌ی انتزاعی هستند که مخصوص کار با <strong>کاراکترها</strong> و <strong>رشته‌ها</strong> طراحی شده‌اند. هر کدام در .NET دو پیاده‌سازی عمومی دارند:</p>
<ul>
<li>
<p><strong><code>StreamReader</code> / <code>StreamWriter</code></strong><br>
از یک <strong>Stream</strong> به‌عنوان منبع داده‌ی خام استفاده می‌کنند و بایت‌های استریم را به کاراکترها یا رشته‌ها تبدیل می‌کنند.</p>
</li>
<li>
<p><strong><code>StringReader</code> / <code>StringWriter</code></strong><br>
<code>TextReader</code> / <code>TextWriter</code> را با استفاده از <strong>رشته‌های درون حافظه</strong> پیاده‌سازی می‌کنند.</p>
</li>
</ul>
<p>📌 <strong>جدول 15-2</strong> اعضای <code>TextReader</code> را بر اساس دسته‌بندی نشان می‌دهد.</p>
<ul>
<li>
<p>متد <code>Peek</code> کاراکتر بعدی در استریم را <strong>برمی‌گرداند بدون اینکه موقعیت را جلو ببرد</strong>.</p>
</li>
<li>
<p>هم <code>Peek</code> و هم نسخه‌ی بدون پارامتر <code>Read</code> مقدار <strong>-1</strong> را برمی‌گردانند اگر به انتهای استریم رسیده باشند؛ در غیر این صورت یک <strong>عدد صحیح (int)</strong> برمی‌گردانند که می‌توان آن را مستقیم به <code>char</code> تبدیل کرد.</p>
</li>
<li>
<p>نسخه‌ی overload شده‌ی <code>Read</code> که یک <code>char[] buffer</code> می‌گیرد، دقیقاً مشابه متد <code>ReadBlock</code> عمل می‌کند.</p>
</li>
<li>
<p>متد <code>ReadLine</code> می‌خواند تا زمانی که به یکی از این‌ها برسد:</p>
<ul>
<li><strong>CR</strong> (کد کاراکتری 13)</li>
<li><strong>LF</strong> (کد کاراکتری 10)</li>
<li>یا ترکیب <strong>CR+LF</strong><br>
سپس یک <strong>رشته (string)</strong> برمی‌گرداند و کاراکترهای CR/LF را حذف می‌کند.</li>
</ul>
</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-7.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p><code>Environment.NewLine</code> دنباله‌ی <strong>new-line</strong> مناسب برای سیستم‌عامل فعلی را برمی‌گرداند.</p>
<ul>
<li>در <strong>ویندوز</strong>، این مقدار <code>&quot;\r\n&quot;</code> است (به یاد “ReturN” بیفتید) و به صورت تقریبی شبیه یک ماشین تحریر مکانیکی مدل شده: ابتدا <strong>CR</strong> (کاراکتر ۱۳) و سپس <strong>LF</strong> (کاراکتر ۱۰). اگر ترتیب را برعکس کنید، یا دو خط جدید خواهید داشت یا هیچ!</li>
<li>در <strong>Unix</strong> و <strong>macOS</strong>، مقدار تنها <code>&quot;\n&quot;</code> است.</li>
</ul>
<p><code>TextWriter</code> متدهای مشابهی برای نوشتن دارد، همان‌طور که در <strong>جدول 15-3</strong> نشان داده شده است. متدهای <code>Write</code> و <code>WriteLine</code> همچنین <strong>overload</strong> شده‌اند تا همه‌ی نوع‌های اولیه و نوع <strong>object</strong> را قبول کنند. این متدها صرفاً متد <code>ToString</code> را روی مقداری که داده شده صدا می‌زنند (اختیاری از طریق یک <code>IFormatProvider</code> که هنگام صدا زدن متد یا هنگام ساخت <code>TextWriter</code> مشخص شده باشد).</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-8.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>متد <code>WriteLine</code> به‌سادگی متن داده‌شده را با <code>Environment.NewLine</code> الحاق می‌کند. می‌توانید این رفتار را از طریق <strong>خاصیت <code>NewLine</code></strong> تغییر دهید (این می‌تواند برای <strong>تطبیق با فرمت‌های فایل Unix</strong> مفید باشد).</p>
<p>همانند <code>Stream</code>، کلاس‌های <code>TextReader</code> و <code>TextWriter</code> نسخه‌های <strong>آسنکرون مبتنی بر Task</strong> از متدهای خواندن و نوشتن خود را ارائه می‌دهند.</p>
<h3>StreamReader و StreamWriter 📄✍️</h3>
<p>در مثال زیر، یک <code>StreamWriter</code> دو خط متن را در یک فایل می‌نویسد و سپس یک <code>StreamReader</code> فایل را دوباره می‌خواند:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (FileStream fs = File.Create(<span class="hljs-string">&quot;test.txt&quot;</span>))
<span class="hljs-keyword">using</span> (TextWriter writer = <span class="hljs-keyword">new</span> StreamWriter(fs))
{
    writer.WriteLine(<span class="hljs-string">&quot;Line1&quot;</span>);
    writer.WriteLine(<span class="hljs-string">&quot;Line2&quot;</span>);
}
<span class="hljs-keyword">using</span> (FileStream fs = File.OpenRead(<span class="hljs-string">&quot;test.txt&quot;</span>))
<span class="hljs-keyword">using</span> (TextReader reader = <span class="hljs-keyword">new</span> StreamReader(fs))
{
    Console.WriteLine(reader.ReadLine()); <span class="hljs-comment">// Line1</span>
    Console.WriteLine(reader.ReadLine()); <span class="hljs-comment">// Line2</span>
}
</code></pre>
<p>چون <strong>Text adapters</strong> اغلب همراه با فایل‌ها استفاده می‌شوند، کلاس <code>File</code> متدهای <strong>استاتیک</strong> <code>CreateText</code>، <code>AppendText</code> و <code>OpenText</code> را برای کوتاه کردن روند فراهم می‌کند:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (TextWriter writer = File.CreateText(<span class="hljs-string">&quot;test.txt&quot;</span>))
{
    writer.WriteLine(<span class="hljs-string">&quot;Line1&quot;</span>);
    writer.WriteLine(<span class="hljs-string">&quot;Line2&quot;</span>);
}
<span class="hljs-keyword">using</span> (TextWriter writer = File.AppendText(<span class="hljs-string">&quot;test.txt&quot;</span>))
    writer.WriteLine(<span class="hljs-string">&quot;Line3&quot;</span>);

<span class="hljs-keyword">using</span> (TextReader reader = File.OpenText(<span class="hljs-string">&quot;test.txt&quot;</span>))
    <span class="hljs-keyword">while</span> (reader.Peek() &gt; <span class="hljs-number">-1</span>)
        Console.WriteLine(reader.ReadLine()); <span class="hljs-comment">// Line1, Line2, Line3</span>
</code></pre>
<p>این مثال همچنین نشان می‌دهد که چگونه پایان فایل را بررسی کنیم (<code>reader.Peek()</code>). روش دیگر این است که تا وقتی <code>reader.ReadLine</code> مقدار <code>null</code> برگرداند، ادامه دهیم.</p>
<p>می‌توانید انواع دیگری مانند <strong>اعداد صحیح</strong> را نیز بخوانید و بنویسید، اما چون <code>TextWriter</code> متد <code>ToString</code> را روی نوع شما صدا می‌زند، هنگام خواندن باید رشته را <strong>Parse</strong> کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (TextWriter w = File.CreateText(<span class="hljs-string">&quot;data.txt&quot;</span>))
{
    w.WriteLine(<span class="hljs-number">123</span>);      <span class="hljs-comment">// می‌نویسد &quot;123&quot;</span>
    w.WriteLine(<span class="hljs-literal">true</span>);     <span class="hljs-comment">// می‌نویسد &quot;true&quot;</span>
}
<span class="hljs-keyword">using</span> (TextReader r = File.OpenText(<span class="hljs-string">&quot;data.txt&quot;</span>))
{
    <span class="hljs-built_in">int</span> myInt = <span class="hljs-built_in">int</span>.Parse(r.ReadLine());   <span class="hljs-comment">// myInt == 123</span>
    <span class="hljs-built_in">bool</span> yes = <span class="hljs-built_in">bool</span>.Parse(r.ReadLine());   <span class="hljs-comment">// yes == true</span>
}
</code></pre>
<h3>رمزگذاری کاراکترها 🔤</h3>
<p><code>TextReader</code> و <code>TextWriter</code> خودشان تنها کلاس‌های <strong>abstract</strong> هستند و ارتباطی با یک <strong>stream</strong> یا <strong>backing store</strong> ندارند. اما <code>StreamReader</code> و <code>StreamWriter</code> به یک <strong>stream بایت‌محور</strong> متصل‌اند و باید بین <strong>کاراکترها و بایت‌ها</strong> تبدیل انجام دهند. این کار از طریق کلاس <code>Encoding</code> در <strong>System.Text</strong> انجام می‌شود که هنگام ساخت <code>StreamReader</code> یا <code>StreamWriter</code> انتخاب می‌کنید. اگر چیزی انتخاب نکنید، <strong>UTF-8</strong> پیش‌فرض استفاده می‌شود.</p>
<p>اگر به‌طور صریح یک <strong>Encoding</strong> مشخص کنید، <code>StreamWriter</code> به‌طور پیش‌فرض یک پیش‌وند (prefix) برای شناسایی رمزگذاری به ابتدای جریان می‌نویسد. این معمولاً ناخواسته است و می‌توانید با ساخت Encoding به شکل زیر از آن جلوگیری کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> encoding = <span class="hljs-keyword">new</span> UTF8Encoding(
    encoderShouldEmitUTF8Identifier: <span class="hljs-literal">false</span>,
    throwOnInvalidBytes: <span class="hljs-literal">true</span>
);
</code></pre>
<p>آرگومان دوم به <code>StreamWriter</code> یا <code>StreamReader</code> می‌گوید اگر با بایت‌هایی مواجه شد که ترجمه معتبر به رشته ندارند، <strong>Exception</strong> پرتاب کند، که با رفتار پیش‌فرض مطابقت دارد.</p>
<h3>مثال رمزگذاری ASCII و UTF-8</h3>
<p>رمزگذاری ساده <code>ASCII</code> است، چون هر کاراکتر با یک بایت نمایش داده می‌شود. کاراکترهای غیرانگلیسی یا نمادهای ویژه قابل نمایش نیستند و به <code>□</code> تبدیل می‌شوند.</p>
<p>رمزگذاری پیش‌فرض <code>UTF-8</code> می‌تواند تمام کاراکترهای یونیکد را نمایش دهد. کاراکترهای ASCII (127 کاراکتر اول) با یک بایت کدگذاری می‌شوند؛ بقیه کاراکترها با تعداد بایت متغیر (معمولاً دو یا سه) کدگذاری می‌شوند. مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (TextWriter w = File.CreateText(<span class="hljs-string">&quot;but.txt&quot;</span>)) <span class="hljs-comment">// استفاده از UTF-8 پیش‌فرض</span>
    w.WriteLine(<span class="hljs-string">&quot;but-&quot;</span>);

<span class="hljs-keyword">using</span> (Stream s = File.OpenRead(<span class="hljs-string">&quot;but.txt&quot;</span>))
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> b; (b = s.ReadByte()) &gt; <span class="hljs-number">-1</span>;)
        Console.WriteLine(b);
</code></pre>
<p>برای کاراکتر <strong>em dash (—)</strong> که خارج از 127 کاراکتر اول یونیکد است، UTF-8 سه بایت استفاده می‌کند.</p>
<h3>UTF-16</h3>
<p>UTF-16 از دو یا چهار بایت برای هر کاراکتر استفاده می‌کند. نوع <code>char</code> در C# فقط 16 بیت است، پس UTF-16 دقیقاً دو بایت برای هر char استفاده می‌کند. این امکان پرش به ایندکس کاراکتر مشخص در stream را آسان می‌کند.</p>
<p>UTF-16 از یک پیش‌وند دو بایتی برای مشخص کردن <strong>little-endian</strong> یا <strong>big-endian</strong> استفاده می‌کند. ترتیب پیش‌فرض little-endian برای سیستم‌های مبتنی بر ویندوز استاندارد است.</p>
<h3>StringReader و StringWriter</h3>
<p>این‌ها <strong>stream</strong> را wrap نمی‌کنند و از یک <strong>string</strong> یا <strong>StringBuilder</strong> به‌عنوان منبع داده استفاده می‌کنند. بنابراین نیاز به ترجمه بایت نیست و کلاس‌ها تنها بر اساس همان رفتار پایه <code>StreamReader/StreamWriter</code> عمل می‌کنند.</p>
<p>مثال: اگر بخواهید یک رشته حاوی XML را با <code>XmlReader</code> تجزیه کنید:</p>
<pre class="hljs"><code>XmlReader r = XmlReader.Create(<span class="hljs-keyword">new</span> StringReader(myString));
</code></pre>
<h3>Binary Adapters 💾</h3>
<p><code>BinaryReader</code> و <code>BinaryWriter</code> داده‌های native مانند <code>bool</code>، <code>byte</code>، <code>int</code>، <code>double</code>، <code>string</code> و آرایه‌های نوع‌های اولیه را می‌خوانند و می‌نویسند.<br>
بر خلاف <code>StreamReader/StreamWriter</code>، binary adapters داده‌ها را به‌صورت <strong>موثر در حافظه</strong> ذخیره می‌کنند.</p>
<p>مثال تعریف کلاس ساده و ذخیره/بارگذاری با binary adapters:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SaveData</span>(<span class="hljs-params">Stream s</span>)</span>
    {
        <span class="hljs-keyword">var</span> w = <span class="hljs-keyword">new</span> BinaryWriter(s);
        w.Write(Name);
        w.Write(Age);
        w.Write(Height);
        w.Flush(); <span class="hljs-comment">// اطمینان از خالی شدن بافر</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadData</span>(<span class="hljs-params">Stream s</span>)</span>
    {
        <span class="hljs-keyword">var</span> r = <span class="hljs-keyword">new</span> BinaryReader(s);
        Name = r.ReadString();
        Age = r.ReadInt32();
        Height = r.ReadDouble();
    }
}
</code></pre>
<p>همچنین می‌توان با <code>BinaryReader</code> کل محتوای یک <strong>stream seekable</strong> را به آرایه بایت خواند:</p>
<pre class="hljs"><code><span class="hljs-built_in">byte</span>[] data = <span class="hljs-keyword">new</span> BinaryReader(s).ReadBytes((<span class="hljs-built_in">int</span>)s.Length);
</code></pre>
<p>این روش راحت‌تر از خواندن مستقیم از stream است، چون نیاز به loop برای اطمینان از خواندن تمام داده‌ها ندارد.</p>
<h3>بستن و آزادسازی Stream Adapters 🔒</h3>
<p>برای <strong>تخریب (tear down)</strong> stream adapters، چهار گزینه دارید:</p>
<ol>
<li>فقط adapter را ببندید.</li>
<li>adapter را ببندید و سپس stream را ببندید.</li>
<li>(برای writers) adapter را Flush کرده و سپس stream را ببندید.</li>
<li>(برای readers) فقط stream را ببندید.</li>
</ol>
<p>در adapters، متدهای <code>Close</code> و <code>Dispose</code> <strong>هم‌معنی</strong> هستند، همانند رفتارشان در streams.</p>
<p>گزینه‌های 1 و 2 از نظر معنایی <strong>یکسان</strong> هستند، زیرا بستن یک adapter به‌طور خودکار <strong>stream زیرین</strong> را نیز می‌بندد. هر زمان که از <strong>nested using statements</strong> استفاده می‌کنید، عملاً گزینه 2 را انتخاب کرده‌اید:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (FileStream fs = File.Create(<span class="hljs-string">&quot;test.txt&quot;</span>))
<span class="hljs-keyword">using</span> (TextWriter writer = <span class="hljs-keyword">new</span> StreamWriter(fs))
    writer.WriteLine(<span class="hljs-string">&quot;Line&quot;</span>);
</code></pre>
<p>چون dispose به ترتیب از داخل به بیرون انجام می‌شود، ابتدا adapter بسته می‌شود و سپس stream. همچنین اگر در <strong>constructor</strong> adapter استثنایی رخ دهد، stream همچنان بسته می‌شود. استفاده از nested using statements تقریباً همیشه ایمن است.</p>
<blockquote>
<p>هرگز یک stream را قبل از بستن یا Flush کردن writer آن نبندید — در غیر این صورت داده‌های بافر شده در adapter از بین می‌روند.</p>
</blockquote>
<p>گزینه‌های 3 و 4 کار می‌کنند چون adapters در دسته <strong>objects با disposal اختیاری</strong> قرار دارند. یک مثال: ممکن است adapter را تمام کرده باشید ولی بخواهید <strong>stream زیرین</strong> برای استفاده‌های بعدی باز بماند:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (FileStream fs = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;test.txt&quot;</span>, FileMode.Create))
{
    StreamWriter writer = <span class="hljs-keyword">new</span> StreamWriter(fs);
    writer.WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>);
    writer.Flush();
    fs.Position = <span class="hljs-number">0</span>;
    Console.WriteLine(fs.ReadByte());
}
</code></pre>
<p>در اینجا، ابتدا به فایل می‌نویسیم، موقعیت stream را تغییر می‌دهیم و سپس اولین بایت را می‌خوانیم. اگر StreamWriter را dispose می‌کردیم، FileStream نیز بسته می‌شد و خواندن بعدی شکست می‌خورد. شرط این است که <strong>Flush</strong> را صدا بزنیم تا بافر StreamWriter به stream نوشته شود.</p>
<p>Stream adapters با semantics <strong>اختیاری در disposal</strong>، الگوی <strong>extended disposal</strong> که finalizer در آن Dispose را صدا می‌زند، پیاده‌سازی نمی‌کنند. این امکان را می‌دهد که adapter رهاشده هنگام رسیدن <strong>garbage collector</strong> به آن، خودکار dispose نشود.</p>
<p>همچنین یک constructor در StreamReader/StreamWriter وجود دارد که دستور می‌دهد stream بعد از disposal باز بماند. بنابراین می‌توان مثال قبل را به شکل زیر بازنویسی کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> fs = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;test.txt&quot;</span>, FileMode.Create))
{
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> writer = <span class="hljs-keyword">new</span> StreamWriter(fs, <span class="hljs-keyword">new</span> UTF8Encoding(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>), <span class="hljs-number">0x400</span>, <span class="hljs-literal">true</span>))
        writer.WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>);
    fs.Position = <span class="hljs-number">0</span>;
    Console.WriteLine(fs.ReadByte());
    Console.WriteLine(fs.Length);
}
</code></pre>
<hr>
<h3>Compression Streams 📦</h3>
<p>در فضای نام <code>System.IO.Compression</code> دو <strong>compression stream</strong> عمومی وجود دارد: <code>DeflateStream</code> و <code>GZipStream</code>. هر دو از الگوریتم فشرده‌سازی مشابه ZIP استفاده می‌کنند. تفاوتشان این است که <strong>GZipStream</strong> یک پروتکل اضافی در ابتدا و انتها می‌نویسد که شامل CRC برای تشخیص خطا است و با استانداردهای نرم‌افزاری دیگر سازگار است.</p>
<p>.NET همچنین <code>BrotliStream</code> را ارائه می‌دهد که الگوریتم Brotli را پیاده‌سازی می‌کند. <strong>BrotliStream</strong> بیش از 10 برابر کندتر از DeflateStream و GZipStream است اما نسبت فشرده‌سازی بهتری دارد. (این کاهش سرعت فقط برای فشرده‌سازی است؛ دیکامپرشن بسیار سریع است.)</p>
<p>هر سه stream قابلیت خواندن و نوشتن دارند، با این شرایط:</p>
<ul>
<li>هنگام فشرده‌سازی، همیشه روی stream می‌نویسید.</li>
<li>هنگام دیکامپرشن، همیشه از stream می‌خوانید.</li>
</ul>
<p><code>DeflateStream</code>، <code>GZipStream</code> و <code>BrotliStream</code> <strong>decorator</strong> هستند؛ آن‌ها داده‌ها را از stream دیگری که هنگام ساخت ارائه می‌دهید، فشرده یا دیکامپر می‌کنند.</p>
<p>مثال فشرده‌سازی و دیکامپرشن یک سری بایت با استفاده از FileStream:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (Stream s = File.Create(<span class="hljs-string">&quot;compressed.bin&quot;</span>))
<span class="hljs-keyword">using</span> (Stream ds = <span class="hljs-keyword">new</span> DeflateStream(s, CompressionMode.Compress))
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">byte</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
        ds.WriteByte(i);

<span class="hljs-keyword">using</span> (Stream s = File.OpenRead(<span class="hljs-string">&quot;compressed.bin&quot;</span>))
<span class="hljs-keyword">using</span> (Stream ds = <span class="hljs-keyword">new</span> DeflateStream(s, CompressionMode.Decompress))
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">byte</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
        Console.WriteLine(ds.ReadByte()); <span class="hljs-comment">// 0 تا 99</span>
</code></pre>
<p>با DeflateStream، فایل فشرده 102 بایت است: کمی بزرگتر از اصلی. BrotliStream آن را به 73 بایت فشرده می‌کند. فشرده‌سازی با داده‌های باینری <strong>متراکم و غیرتکراری</strong> ضعیف عمل می‌کند و با داده‌های رمزنگاری شده بدتر است. اما برای فایل‌های متنی عملکرد خوبی دارد.</p>
<p>مثال بعدی: فشرده و دیکامپرشن یک متن 1000 کلمه با الگوریتم Brotli:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span>[] words = <span class="hljs-string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>.Split();
Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">0</span>); <span class="hljs-comment">// برای ثبات</span>
<span class="hljs-keyword">using</span> (Stream s = File.Create(<span class="hljs-string">&quot;compressed.bin&quot;</span>))
<span class="hljs-keyword">using</span> (Stream ds = <span class="hljs-keyword">new</span> BrotliStream(s, CompressionMode.Compress))
<span class="hljs-keyword">using</span> (TextWriter w = <span class="hljs-keyword">new</span> StreamWriter(ds))
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)
        <span class="hljs-keyword">await</span> w.WriteAsync(words[rand.Next(words.Length)] + <span class="hljs-string">&quot; &quot;</span>);

Console.WriteLine(<span class="hljs-keyword">new</span> FileInfo(<span class="hljs-string">&quot;compressed.bin&quot;</span>).Length); <span class="hljs-comment">// 808</span>

<span class="hljs-keyword">using</span> (Stream s = File.OpenRead(<span class="hljs-string">&quot;compressed.bin&quot;</span>))
<span class="hljs-keyword">using</span> (Stream ds = <span class="hljs-keyword">new</span> BrotliStream(s, CompressionMode.Decompress))
<span class="hljs-keyword">using</span> (TextReader r = <span class="hljs-keyword">new</span> StreamReader(ds))
    Console.Write(<span class="hljs-keyword">await</span> r.ReadToEndAsync());
</code></pre>
<p>در این حالت، BrotliStream به طور مؤثر فایل را به 808 بایت فشرده می‌کند — کمتر از یک بایت برای هر کلمه. (DeflateStream همان داده‌ها را به 885 بایت فشرده می‌کند.)</p>
<hr>
<h3>فشرده‌سازی در حافظه 🧠💨</h3>
<p>گاهی لازم است فشرده‌سازی کاملاً <strong>در حافظه</strong> انجام شود. نمونه با MemoryStream:</p>
<pre class="hljs"><code><span class="hljs-built_in">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1000</span>]; <span class="hljs-comment">// آرایه خالی برای تست فشرده‌سازی</span>
<span class="hljs-keyword">var</span> ms = <span class="hljs-keyword">new</span> MemoryStream();
<span class="hljs-keyword">using</span> (Stream ds = <span class="hljs-keyword">new</span> DeflateStream(ms, CompressionMode.Compress))
    ds.Write(data, <span class="hljs-number">0</span>, data.Length);

<span class="hljs-built_in">byte</span>[] compressed = ms.ToArray();
Console.WriteLine(compressed.Length); <span class="hljs-comment">// 11</span>

<span class="hljs-comment">// دیکامپرشن دوباره به آرایه داده:</span>
ms = <span class="hljs-keyword">new</span> MemoryStream(compressed);
<span class="hljs-keyword">using</span> (Stream ds = <span class="hljs-keyword">new</span> DeflateStream(ms, CompressionMode.Decompress))
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i += ds.Read(data, i, <span class="hljs-number">1000</span> - i));
</code></pre>
<p>استفاده از <code>using</code> روی DeflateStream آن را به‌طور استاندارد می‌بندد و هر بافر نوشته‌نشده را Flush می‌کند. این همچنین MemoryStream را می‌بندد، بنابراین برای استخراج داده‌ها باید <code>ToArray</code> را صدا بزنیم.</p>
<p>نسخه جایگزین که <strong>MemoryStream را باز نگه می‌دارد</strong> و از متدهای <strong>آسنکرون</strong> استفاده می‌کند:</p>
<pre class="hljs"><code><span class="hljs-built_in">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1000</span>];
MemoryStream ms = <span class="hljs-keyword">new</span> MemoryStream();
<span class="hljs-keyword">using</span> (Stream ds = <span class="hljs-keyword">new</span> DeflateStream(ms, CompressionMode.Compress, <span class="hljs-literal">true</span>))
    <span class="hljs-keyword">await</span> ds.WriteAsync(data, <span class="hljs-number">0</span>, data.Length);

Console.WriteLine(ms.Length); <span class="hljs-comment">// 113</span>
ms.Position = <span class="hljs-number">0</span>;
<span class="hljs-keyword">using</span> (Stream ds = <span class="hljs-keyword">new</span> DeflateStream(ms, CompressionMode.Decompress))
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i += <span class="hljs-keyword">await</span> ds.ReadAsync(data, i, <span class="hljs-number">1000</span> - i));
</code></pre>
<p>فلگ اضافی در constructor به DeflateStream می‌گوید که <strong>stream زیرین را در disposal نبندد</strong>. به این ترتیب MemoryStream باز می‌ماند و می‌توانیم آن را دوباره از موقعیت صفر بخوانیم.</p>
<h3>فشرده‌سازی فایل‌ها در Unix با GZip 🐧📦</h3>
<p>الگوریتم فشرده‌سازی <strong>GZipStream</strong> در سیستم‌های Unix به‌عنوان فرمت فشرده‌سازی فایل محبوب است. هر فایل منبع در یک فایل هدف جداگانه با پسوند <code>.gz</code> فشرده می‌شود.</p>
<p>روش‌های زیر همان کار <strong>gzip</strong> و <strong>gunzip</strong> در خط فرمان Unix را انجام می‌دهند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">GZip</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sourcefile, <span class="hljs-built_in">bool</span> deleteSource = <span class="hljs-literal">true</span></span>)</span>
{
    <span class="hljs-keyword">var</span> gzip = <span class="hljs-string">$&quot;<span class="hljs-subst">{sourcefile}</span>.gz&quot;</span>;
    <span class="hljs-keyword">if</span> (File.Exists(gzip))
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Gzip file already exists&quot;</span>);
    
    <span class="hljs-comment">// فشرده‌سازی</span>
    <span class="hljs-keyword">using</span> (FileStream inStream = File.Open(sourcefile, FileMode.Open))
    <span class="hljs-keyword">using</span> (FileStream outStream = <span class="hljs-keyword">new</span> FileStream(gzip, FileMode.CreateNew))
    <span class="hljs-keyword">using</span> (GZipStream gzipStream = <span class="hljs-keyword">new</span> GZipStream(outStream, CompressionMode.Compress))
        <span class="hljs-keyword">await</span> inStream.CopyToAsync(gzipStream); 

    <span class="hljs-keyword">if</span> (deleteSource) File.Delete(sourcefile);
}

<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">GUnzip</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> gzipfile, <span class="hljs-built_in">bool</span> deleteGzip = <span class="hljs-literal">true</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (Path.GetExtension(gzipfile) != <span class="hljs-string">&quot;.gz&quot;</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Not a gzip file&quot;</span>);

    <span class="hljs-keyword">var</span> uncompressedFile = gzipfile.Substring(<span class="hljs-number">0</span>, gzipfile.Length - <span class="hljs-number">3</span>);
    <span class="hljs-keyword">if</span> (File.Exists(uncompressedFile))
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Destination file already exists&quot;</span>);
    
    <span class="hljs-comment">// دیکامپرشن</span>
    <span class="hljs-keyword">using</span> (FileStream uncompressToStream = File.Open(uncompressedFile, FileMode.Create))
    <span class="hljs-keyword">using</span> (FileStream zipfileStream = File.Open(gzipfile, FileMode.Open))
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> unzipStream = <span class="hljs-keyword">new</span> GZipStream(zipfileStream, CompressionMode.Decompress))
        <span class="hljs-keyword">await</span> unzipStream.CopyToAsync(uncompressToStream);

    <span class="hljs-keyword">if</span> (deleteGzip) File.Delete(gzipfile);
}
</code></pre>
<p>نمونه استفاده:</p>
<pre class="hljs"><code><span class="hljs-keyword">await</span> GZip(<span class="hljs-string">&quot;/tmp/myfile.txt&quot;</span>);        <span class="hljs-comment">// ایجاد /tmp/myfile.txt.gz</span>
<span class="hljs-keyword">await</span> GUnzip(<span class="hljs-string">&quot;/tmp/myfile.txt.gz&quot;</span>);   <span class="hljs-comment">// بازسازی /tmp/myfile.txt</span>
</code></pre>
<hr>
<h3>کار با فایل‌های ZIP 🗜️</h3>
<p>کلاس‌های <strong>ZipArchive</strong> و <strong>ZipFile</strong> در <code>System.IO.Compression</code> از فرمت ZIP پشتیبانی می‌کنند. مزیت ZIP نسبت به <strong>DeflateStream</strong> و <strong>GZipStream</strong> این است که:</p>
<ul>
<li>
<p>می‌تواند چندین فایل را در خود جای دهد.</p>
</li>
<li>
<p>با فایل‌های ZIP ایجاد شده توسط Windows Explorer سازگار است.</p>
</li>
<li>
<p><strong>ZipArchive</strong> با streams کار می‌کند.</p>
</li>
<li>
<p><strong>ZipFile</strong> سناریوی معمول کار با فایل‌ها را پوشش می‌دهد و کلاس کمکی است برای ZipArchive.</p>
</li>
</ul>
<p>نمونه استفاده از <strong>CreateFromDirectory</strong> برای افزودن تمام فایل‌های یک دایرکتوری به ZIP:</p>
<pre class="hljs"><code>ZipFile.CreateFromDirectory(<span class="hljs-string">@&quot;d:\MyFolder&quot;</span>, <span class="hljs-string">@&quot;d:\archive.zip&quot;</span>);
</code></pre>
<p>برای استخراج ZIP به دایرکتوری:</p>
<pre class="hljs"><code>ZipFile.ExtractToDirectory(<span class="hljs-string">@&quot;d:\archive.zip&quot;</span>, <span class="hljs-string">@&quot;d:\MyFolder&quot;</span>);
</code></pre>
<blockquote>
<p>از .NET 8 به بعد می‌توانید به جای مسیر فایل، یک Stream نیز مشخص کنید.</p>
</blockquote>
<p>هنگام فشرده‌سازی، می‌توانید مشخص کنید که بهینه‌سازی برای <strong>حجم فایل یا سرعت</strong> انجام شود و آیا نام دایرکتوری منبع در آرشیو لحاظ شود یا نه.</p>
<p>برای دسترسی به ورودی‌های منفرد ZIP از <strong>Open</strong> استفاده می‌کنیم، که یک <strong>ZipArchive</strong> برمی‌گرداند. می‌توان فایل‌ها را از طریق <strong>Entries</strong> شمارش یا با <strong>GetEntry</strong> به‌صورت خاص یافت:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (ZipArchive zip = ZipFile.Open(<span class="hljs-string">@&quot;d:\zz.zip&quot;</span>, ZipArchiveMode.Read))
    <span class="hljs-keyword">foreach</span> (ZipArchiveEntry entry <span class="hljs-keyword">in</span> zip.Entries)
        Console.WriteLine(entry.FullName + <span class="hljs-string">&quot; &quot;</span> + entry.Length);
</code></pre>
<p><strong>ZipArchiveEntry</strong> همچنین متدهای <code>Delete</code>، <code>ExtractToFile</code> و <code>Open</code> را دارد. برای ایجاد ورودی جدید از <code>CreateEntry</code> یا متد اکستنشن <code>CreateEntryFromFile</code> استفاده می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-built_in">byte</span>[] data = File.ReadAllBytes(<span class="hljs-string">@&quot;d:\foo.dll&quot;</span>); 
<span class="hljs-keyword">using</span> (ZipArchive zip = ZipFile.Open(<span class="hljs-string">@&quot;d:\zz.zip&quot;</span>, ZipArchiveMode.Update))
    zip.CreateEntry(<span class="hljs-string">@&quot;bin\X64\foo.dll&quot;</span>).Open().Write(data, <span class="hljs-number">0</span>, data.Length);
</code></pre>
<p>می‌توان تمام این کارها را کاملاً در حافظه انجام داد با استفاده از <strong>MemoryStream</strong> به جای مسیر فایل.</p>
<hr>
<h3>کار با فایل‌های Tar 📦🐧</h3>
<p>کلاس‌های <code>System.Formats.Tar</code> (.NET 7 به بعد) از فرمت <strong>.tar</strong> پشتیبانی می‌کنند. این فرمت در Unix برای بسته‌بندی چندین فایل محبوب است.</p>
<p>ایجاد یک فایل tar (tarball):</p>
<pre class="hljs"><code>TarFile.CreateFromDirectory(<span class="hljs-string">&quot;/tmp/testfolder&quot;</span>, <span class="hljs-string">&quot;/tmp/test.tar&quot;</span>, <span class="hljs-literal">false</span>);
</code></pre>
<ul>
<li>آرگومان سوم مشخص می‌کند که آیا نام دایرکتوری پایه در ورودی‌های آرشیو لحاظ شود یا خیر.</li>
</ul>
<p>استخراج tarball:</p>
<pre class="hljs"><code>TarFile.ExtractToDirectory(<span class="hljs-string">&quot;/tmp/test.tar&quot;</span>, <span class="hljs-string">&quot;/tmp/testfolder&quot;</span>, <span class="hljs-literal">true</span>);
</code></pre>
<ul>
<li>آرگومان سوم مشخص می‌کند که آیا فایل‌های موجود بازنویسی شوند یا خیر.</li>
</ul>
<p>هر دو متد امکان استفاده از <strong>Stream</strong> به جای مسیر فایل tar را نیز دارند.</p>
<p>نمونه فشرده‌سازی tar به tar.gz با GZipStream:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> ms = <span class="hljs-keyword">new</span> MemoryStream();
TarFile.CreateFromDirectory(<span class="hljs-string">&quot;/tmp/testfolder&quot;</span>, ms, <span class="hljs-literal">false</span>);
ms.Position = <span class="hljs-number">0</span>;

<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> fs = File.Create(<span class="hljs-string">&quot;/tmp/test.tar.gz&quot;</span>))
<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> gz = <span class="hljs-keyword">new</span> GZipStream(fs, CompressionMode.Compress))
    ms.CopyTo(gz);
</code></pre>
<ul>
<li>این کار مفید است چون فرمت tar خودش فشرده‌سازی ندارد، بر خلاف zip.</li>
</ul>
<p>استخراج tar.gz:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> fs = File.OpenRead(<span class="hljs-string">&quot;/tmp/test.tar.gz&quot;</span>))
<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> gz = <span class="hljs-keyword">new</span> GZipStream(fs, CompressionMode.Decompress))
    TarFile.ExtractToDirectory(gz, <span class="hljs-string">&quot;/tmp/testfolder&quot;</span>, <span class="hljs-literal">true</span>);
</code></pre>
<p>همچنین می‌توانید با کلاس‌های <strong>TarReader</strong> و <strong>TarWriter</strong> به سطح API دقیق‌تری دسترسی داشته باشید. نمونه استفاده از <strong>TarReader</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (FileStream archiveStream = File.OpenRead(<span class="hljs-string">&quot;/tmp/test.tar&quot;</span>))
<span class="hljs-keyword">using</span> (TarReader reader = <span class="hljs-keyword">new</span>(archiveStream))
{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
    {
        TarEntry entry = reader.GetNextEntry();
        <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;
        Console.WriteLine(<span class="hljs-string">$&quot;Entry <span class="hljs-subst">{entry.Name}</span> is <span class="hljs-subst">{entry.DataStream.Length}</span> bytes long&quot;</span>);
        entry.ExtractToFile(Path.Combine(<span class="hljs-string">&quot;/tmp/testfolder&quot;</span>, entry.Name), <span class="hljs-literal">true</span>);
    }
}
</code></pre>
<hr>
<h3>عملیات فایل و دایرکتوری 📁⚙️</h3>
<p>فضای نام <code>System.IO</code> مجموعه‌ای از انواع برای انجام عملیات <strong>utility</strong> روی فایل و دایرکتوری ارائه می‌دهد، مانند:</p>
<ul>
<li>کپی و انتقال فایل‌ها</li>
<li>ایجاد دایرکتوری</li>
<li>تنظیم خصوصیات و دسترسی‌های فایل</li>
</ul>
<p>برای اکثر ویژگی‌ها، می‌توانید بین دو کلاس انتخاب کنید:</p>
<ul>
<li><strong>کلاس‌های ایستا (Static):</strong> <code>File</code> و <code>Directory</code></li>
<li><strong>کلاس‌های با متد نمونه:</strong> <code>FileInfo</code> و <code>DirectoryInfo</code> (ساخته شده با نام فایل یا دایرکتوری)</li>
</ul>
<p>علاوه بر این، کلاس ایستای <strong>Path</strong> وجود دارد که هیچ عملی روی فایل یا دایرکتوری انجام نمی‌دهد؛ بلکه متدهایی برای <strong>دستکاری رشته مسیرها و نام فایل‌ها</strong> ارائه می‌کند و همچنین با فایل‌های موقت کمک می‌کند.</p>
<h3>کلاس File 📁💻</h3>
<p>کلاس <strong>File</strong> یک کلاس ایستا (static) است که تمام متدهای آن یک <strong>نام فایل</strong> می‌گیرند. نام فایل می‌تواند نسبی به دایرکتوری جاری یا کامل با مسیر دایرکتوری باشد. متدهای این کلاس (تمامی <strong>public</strong> و <strong>static</strong>) عبارت‌اند از:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">Exists</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;                 <span class="hljs-comment">// اگر فایل موجود باشد true برمی‌گرداند</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;                 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Copy</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sourceFileName, <span class="hljs-built_in">string</span> destFileName</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Move</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sourceFileName, <span class="hljs-built_in">string</span> destFileName</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Replace</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sourceFileName, <span class="hljs-built_in">string</span> destinationFileName,
             <span class="hljs-built_in">string</span> destinationBackupFileName</span>)</span>;
<span class="hljs-function">FileAttributes <span class="hljs-title">GetAttributes</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetAttributes</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path, FileAttributes fileAttributes</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Decrypt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Encrypt</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
<span class="hljs-function">DateTime <span class="hljs-title">GetCreationTime</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;      <span class="hljs-comment">// نسخه UTC نیز وجود دارد</span>
<span class="hljs-function">DateTime <span class="hljs-title">GetLastAccessTime</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;    <span class="hljs-comment">// نسخه UTC نیز وجود دارد</span>
<span class="hljs-function">DateTime <span class="hljs-title">GetLastWriteTime</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetCreationTime</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path, DateTime creationTime</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetLastAccessTime</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path, DateTime lastAccessTime</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetLastWriteTime</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path, DateTime lastWriteTime</span>)</span>;
<span class="hljs-function">FileSecurity <span class="hljs-title">GetAccessControl</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
<span class="hljs-function">FileSecurity <span class="hljs-title">GetAccessControl</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path, AccessControlSections includeSections</span>)</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetAccessControl</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path, FileSecurity fileSecurity</span>)</span>;
</code></pre>
<ul>
<li>متد <strong>Move</strong> اگر فایل مقصد وجود داشته باشد استثنا می‌اندازد؛ اما <strong>Replace</strong> این کار را نمی‌کند.</li>
<li>هر دو متد امکان تغییر نام فایل یا انتقال آن به دایرکتوری دیگر را فراهم می‌کنند.</li>
<li><strong>Delete</strong> اگر فایل <strong>read-only</strong> باشد یا مجوز حذف توسط سیستم‌عامل به فرآیند شما داده نشده باشد، استثنا <code>UnauthorizedAccessException</code> پرتاب می‌کند.</li>
</ul>
<p>تمام اعضای <strong>FileAttributes</strong> که توسط <code>GetAttributes</code> برگردانده می‌شوند:</p>
<pre class="hljs"><code>Archive, Compressed, Device, Directory, Encrypted,
Hidden, IntegritySystem, Normal, NoScrubData, NotContentIndexed, 
Offline, ReadOnly, ReparsePoint, SparseFile, System, Temporary
</code></pre>
<p>این اعضا قابل ترکیب هستند. برای تغییر یک ویژگی فایل بدون تغییر سایر ویژگی‌ها:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> filePath = <span class="hljs-string">&quot;test.txt&quot;</span>;
FileAttributes fa = File.GetAttributes(filePath);
<span class="hljs-keyword">if</span> ((fa &amp; FileAttributes.ReadOnly) != <span class="hljs-number">0</span>)
{
    <span class="hljs-comment">// از عملگر XOR (^) برای تغییر پرچم ReadOnly استفاده می‌کنیم</span>
    fa ^= FileAttributes.ReadOnly;
    File.SetAttributes(filePath, fa);
}

<span class="hljs-comment">// حالا می‌توانیم فایل را حذف کنیم</span>
File.Delete(filePath);
</code></pre>
<p>راه ساده‌تر با <strong>FileInfo</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">new</span> FileInfo(<span class="hljs-string">&quot;test.txt&quot;</span>).IsReadOnly = <span class="hljs-literal">false</span>;
</code></pre>
<hr>
<h3>ویژگی‌های فشرده‌سازی و رمزگذاری 🔒🗜️</h3>
<p>این قابلیت تنها در <strong>Windows</strong> موجود است و نیازمند پکیج NuGet <code>System.Management</code> است.</p>
<ul>
<li>ویژگی‌های <strong>Compressed</strong> و <strong>Encrypted</strong> متناظر با چک‌باکس‌های فشرده‌سازی و رمزگذاری در پنجره Properties فایل یا دایرکتوری در Windows Explorer هستند.</li>
<li>این نوع فشرده‌سازی و رمزگذاری <strong>شفاف</strong> است؛ به طوری که سیستم‌عامل تمام عملیات را انجام می‌دهد و شما می‌توانید داده‌ها را به صورت plain بخوانید و بنویسید.</li>
<li>نمی‌توان با <code>SetAttributes</code> ویژگی‌های <strong>Compressed</strong> یا <strong>Encrypted</strong> را تغییر داد (اگر تلاش کنید، بدون خطا شکست می‌خورد).</li>
</ul>
<p>راه حل: برای رمزگذاری و رمزگشایی از متدهای <code>Encrypt()</code> و <code>Decrypt()</code> در کلاس <strong>File</strong> استفاده کنید.<br>
برای فشرده‌سازی، استفاده از WMI در <code>System.Management</code> راه حل است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">uint</span> <span class="hljs-title">CompressFolder</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> folder, <span class="hljs-built_in">bool</span> recursive</span>)</span>
{
    <span class="hljs-built_in">string</span> path = <span class="hljs-string">&quot;Win32_Directory.Name=&#x27;&quot;</span> + folder + <span class="hljs-string">&quot;&#x27;&quot;</span>;
    <span class="hljs-keyword">using</span> (ManagementObject dir = <span class="hljs-keyword">new</span> ManagementObject(path))
    <span class="hljs-keyword">using</span> (ManagementBaseObject p = dir.GetMethodParameters(<span class="hljs-string">&quot;CompressEx&quot;</span>))
    {
        p[<span class="hljs-string">&quot;Recursive&quot;</span>] = recursive;
        <span class="hljs-keyword">using</span> (ManagementBaseObject result = dir.InvokeMethod(<span class="hljs-string">&quot;CompressEx&quot;</span>, p, <span class="hljs-literal">null</span>))
            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">uint</span>)result.Properties[<span class="hljs-string">&quot;ReturnValue&quot;</span>].Value;
    }
}
</code></pre>
<ul>
<li>برای استخراج، <code>CompressEx</code> را با <code>UncompressEx</code> جایگزین کنید.</li>
</ul>
<p><strong>رمزگذاری شفاف</strong> بر پایه کلیدی ساخته شده از رمز عبور کاربر لاگین شده است. تغییر رمز عبور توسط کاربر معتبر مشکلی ایجاد نمی‌کند، اما اگر رمز توسط مدیر ریست شود، داده‌های فایل‌های رمزگذاری‌شده قابل بازیابی نخواهند بود.</p>
<p><strong>NTFS</strong> این قابلیت‌ها را پشتیبانی می‌کند؛ اما <strong>CDFS</strong> (روی CD-ROM) و <strong>FAT</strong> (روی کارت‌های قابل حمل) پشتیبانی نمی‌کنند.</p>
<p>برای تشخیص پشتیبانی یک حجم از فشرده‌سازی و رمزگذاری:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.IO;
<span class="hljs-keyword">using</span> System.Text;
<span class="hljs-keyword">using</span> System.ComponentModel;
<span class="hljs-keyword">using</span> System.Runtime.InteropServices;

<span class="hljs-keyword">class</span> <span class="hljs-title">SupportsCompressionEncryption</span>
{
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SupportsCompression = <span class="hljs-number">0x10</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SupportsEncryption = <span class="hljs-number">0x20000</span>;

    [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;Kernel32.dll&quot;</span>, SetLastError = true)</span>]
    <span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">GetVolumeInformation</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> vol, StringBuilder name,
        <span class="hljs-built_in">int</span> nameSize, <span class="hljs-keyword">out</span> <span class="hljs-built_in">uint</span> serialNum, <span class="hljs-keyword">out</span> <span class="hljs-built_in">uint</span> maxNameLen, <span class="hljs-keyword">out</span> <span class="hljs-built_in">uint</span> flags,
        StringBuilder fileSysName, <span class="hljs-built_in">int</span> fileSysNameSize</span>)</span>;

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>
    {
        <span class="hljs-built_in">uint</span> serialNum, maxNameLen, flags;
        <span class="hljs-built_in">bool</span> ok = GetVolumeInformation(<span class="hljs-string">@&quot;C:\&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">out</span> serialNum,
                                       <span class="hljs-keyword">out</span> maxNameLen, <span class="hljs-keyword">out</span> flags, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (!ok) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Win32Exception();

        <span class="hljs-built_in">bool</span> canCompress = (flags &amp; SupportsCompression) != <span class="hljs-number">0</span>;
        <span class="hljs-built_in">bool</span> canEncrypt = (flags &amp; SupportsEncryption) != <span class="hljs-number">0</span>;
    }
}
</code></pre>
<hr>
<h3>امنیت فایل در Windows 🔐</h3>
<p>این ویژگی نیز <strong>ویندوزی</strong> است و نیازمند پکیج NuGet <code>System.IO.FileSystem.AccessControl</code> می‌باشد.</p>
<p>کلاس <strong>FileSecurity</strong> اجازه می‌دهد مجوزهای سیستم‌عامل را برای کاربران و نقش‌ها مشاهده و تغییر دهید:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.IO;
<span class="hljs-keyword">using</span> System.Security.AccessControl;
<span class="hljs-keyword">using</span> System.Security.Principal;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowSecurity</span>(<span class="hljs-params">FileSecurity sec</span>)</span>
{
    AuthorizationRuleCollection rules = sec.GetAccessRules(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-keyword">typeof</span>(NTAccount));
    <span class="hljs-keyword">foreach</span> (FileSystemAccessRule r <span class="hljs-keyword">in</span> rules.Cast&lt;FileSystemAccessRule&gt;()
        .OrderBy(rule =&gt; rule.IdentityReference.Value))
    {
        Console.WriteLine(<span class="hljs-string">$&quot;  <span class="hljs-subst">{r.IdentityReference.Value}</span>&quot;</span>);  <span class="hljs-comment">// مثال: MyDomain/Joe</span>
        Console.WriteLine(<span class="hljs-string">$&quot;    <span class="hljs-subst">{r.FileSystemRights}</span>: <span class="hljs-subst">{r.AccessControlType}</span>&quot;</span>); <span class="hljs-comment">// FullControl</span>
    }
}

<span class="hljs-keyword">var</span> <span class="hljs-keyword">file</span> = <span class="hljs-string">&quot;sectest.txt&quot;</span>;
File.WriteAllText(<span class="hljs-keyword">file</span>, <span class="hljs-string">&quot;File security test.&quot;</span>);

<span class="hljs-keyword">var</span> sid = <span class="hljs-keyword">new</span> SecurityIdentifier(WellKnownSidType.BuiltinUsersSid, <span class="hljs-literal">null</span>);
<span class="hljs-built_in">string</span> usersAccount = sid.Translate(<span class="hljs-keyword">typeof</span>(NTAccount)).ToString();
Console.WriteLine(<span class="hljs-string">$&quot;User: <span class="hljs-subst">{usersAccount}</span>&quot;</span>);

FileSecurity sec = <span class="hljs-keyword">new</span> FileSecurity(<span class="hljs-keyword">file</span>,
    AccessControlSections.Owner |
    AccessControlSections.Group |
    AccessControlSections.Access);

Console.WriteLine(<span class="hljs-string">&quot;AFTER CREATE:&quot;</span>);
ShowSecurity(sec); <span class="hljs-comment">// BUILTIN\Users هنوز دسترسی Write ندارد</span>

sec.ModifyAccessRule(AccessControlModification.Add,
    <span class="hljs-keyword">new</span> FileSystemAccessRule(usersAccount, FileSystemRights.Write, AccessControlType.Allow),
    <span class="hljs-keyword">out</span> <span class="hljs-built_in">bool</span> modified);

Console.WriteLine(<span class="hljs-string">&quot;AFTER MODIFY:&quot;</span>);
ShowSecurity(sec); <span class="hljs-comment">// BUILTIN\Users اکنون دسترسی Write دارد</span>
</code></pre>
<p>مثال‌های بیشتری در بخش <strong>Special Folders</strong> صفحه 730 ارائه شده است.</p>
<hr>
<h3>امنیت فایل در Unix 🐧</h3>
<p>از <strong>.NET 7</strong> به بعد، کلاس <strong>File</strong> شامل متدهای <strong>GetUnixFileMode</strong> و <strong>SetUnixFileMode</strong> برای گرفتن و تعیین مجوز فایل‌ها در Unix است.</p>
<p>همچنین متد <strong>Directory.CreateDirectory</strong> اورلود شده تا بتواند مجوز Unix را بپذیرد، و هنگام ایجاد فایل می‌توان مجوز را مشخص کرد:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> fs = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;test.txt&quot;</span>,
    <span class="hljs-keyword">new</span> FileStreamOptions
    {
        Mode = FileMode.Create,
        UnixCreateMode = UnixFileMode.UserRead | UnixFileMode.UserWrite
    });
</code></pre>
<h3>کلاس Directory 📂💻</h3>
<p>کلاس <strong>Directory</strong> یک کلاس ایستا (static) است که مجموعه‌ای از متدها مشابه کلاس <strong>File</strong> ارائه می‌دهد، از جمله: بررسی وجود دایرکتوری (<code>Exists</code>)، جابجایی (<code>Move</code>)، حذف (<code>Delete</code>)، دریافت/تنظیم زمان ایجاد یا آخرین دسترسی، و دریافت/تنظیم مجوزهای امنیتی.</p>
<p>متدهای مهم آن عبارت‌اند از:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetCurrentDirectory</span>()</span>;                 <span class="hljs-comment">// دایرکتوری جاری</span>
<span class="hljs-function"><span class="hljs-keyword">void</span>   <span class="hljs-title">SetCurrentDirectory</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;     <span class="hljs-comment">// تنظیم دایرکتوری جاری</span>
<span class="hljs-function">DirectoryInfo <span class="hljs-title">CreateDirectory</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;  <span class="hljs-comment">// ایجاد دایرکتوری</span>
<span class="hljs-function">DirectoryInfo <span class="hljs-title">GetParent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;        <span class="hljs-comment">// دایرکتوری والد</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetDirectoryRoot</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;        <span class="hljs-comment">// ریشه دایرکتوری</span>
<span class="hljs-function"><span class="hljs-built_in">string</span>[] <span class="hljs-title">GetLogicalDrives</span>()</span>;                 <span class="hljs-comment">// درایوها یا mount points در Unix</span>

<span class="hljs-comment">// بازگرداندن مسیرهای کامل</span>
<span class="hljs-function"><span class="hljs-built_in">string</span>[] <span class="hljs-title">GetFiles</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
<span class="hljs-function"><span class="hljs-built_in">string</span>[] <span class="hljs-title">GetDirectories</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
<span class="hljs-function"><span class="hljs-built_in">string</span>[] <span class="hljs-title">GetFileSystemEntries</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
<span class="hljs-function">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">EnumerateFiles</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
<span class="hljs-function">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">EnumerateDirectories</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
<span class="hljs-function">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">EnumerateFileSystemEntries</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path</span>)</span>;
</code></pre>
<p>نکات مهم:</p>
<ul>
<li>متدهای <code>Enumerate*</code> به صورت <strong>lazy</strong> عمل می‌کنند و داده‌ها را هنگام پیمایش از سیستم فایل دریافت می‌کنند، بنابراین برای <strong>LINQ</strong> بسیار مناسب هستند.</li>
<li>این متدها می‌توانند آرگومان‌های <code>searchPattern</code> و <code>searchOption</code> بگیرند و با <code>SearchOption.SearchAllSubDirectories</code> جستجوی بازگشتی انجام دهند.</li>
<li>متدهای <code>*FileSystemEntries</code> ترکیبی از فایل‌ها و دایرکتوری‌ها هستند.</li>
</ul>
<p>ایجاد یک دایرکتوری تنها در صورت عدم وجود:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (!Directory.Exists(<span class="hljs-string">@&quot;d:\test&quot;</span>))
    Directory.CreateDirectory(<span class="hljs-string">@&quot;d:\test&quot;</span>);
</code></pre>
<hr>
<h3>FileInfo و DirectoryInfo 📝</h3>
<p>متدهای ایستا برای عملیات یکباره مناسب هستند، اما اگر نیاز به مجموعه‌ای از عملیات پشت سر هم دارید، استفاده از کلاس‌های <strong>FileInfo</strong> و <strong>DirectoryInfo</strong> راحت‌تر است.</p>
<ul>
<li><strong>FileInfo</strong> اکثر متدهای کلاس <strong>File</strong> را به صورت instance ارائه می‌دهد و ویژگی‌های اضافی مثل <code>Extension</code>، <code>Length</code>، <code>IsReadOnly</code> و <code>Directory</code> دارد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> TestDirectory =&gt;
    RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
        ? <span class="hljs-string">@&quot;C:\Temp&quot;</span> 
        : <span class="hljs-string">&quot;/tmp&quot;</span>;

Directory.CreateDirectory(TestDirectory);
FileInfo fi = <span class="hljs-keyword">new</span> FileInfo(Path.Combine(TestDirectory, <span class="hljs-string">&quot;FileInfo.txt&quot;</span>));

Console.WriteLine(fi.Exists);          <span class="hljs-comment">// false</span>
<span class="hljs-keyword">using</span> (TextWriter w = fi.CreateText())
    w.Write(<span class="hljs-string">&quot;Some text&quot;</span>);

fi.Refresh();
Console.WriteLine(fi.Exists);          <span class="hljs-comment">// true</span>
Console.WriteLine(fi.Name);            <span class="hljs-comment">// FileInfo.txt</span>
Console.WriteLine(fi.FullName);        <span class="hljs-comment">// c:\temp\FileInfo.txt (Windows) یا /tmp/FileInfo.txt (Unix)</span>
Console.WriteLine(fi.DirectoryName);   <span class="hljs-comment">// c:\temp یا /tmp</span>
Console.WriteLine(fi.Directory.Name);  <span class="hljs-comment">// temp</span>
Console.WriteLine(fi.Extension);       <span class="hljs-comment">// .txt</span>
Console.WriteLine(fi.Length);          <span class="hljs-comment">// 9</span>
fi.Encrypt();
fi.Attributes ^= FileAttributes.Hidden; <span class="hljs-comment">// تغییر پرچم Hidden</span>
fi.IsReadOnly = <span class="hljs-literal">true</span>;
Console.WriteLine(fi.Attributes);      <span class="hljs-comment">// ReadOnly, Archive, Hidden, Encrypted</span>
Console.WriteLine(fi.CreationTime);   <span class="hljs-comment">// زمان ایجاد</span>
fi.MoveTo(Path.Combine(TestDirectory, <span class="hljs-string">&quot;FileInfoX.txt&quot;</span>)); 
</code></pre>
<ul>
<li><strong>DirectoryInfo</strong> برای پیمایش دایرکتوری‌ها و فایل‌ها مناسب است:</li>
</ul>
<pre class="hljs"><code>DirectoryInfo di = <span class="hljs-keyword">new</span> DirectoryInfo(<span class="hljs-string">@&quot;e:\photos&quot;</span>);

<span class="hljs-keyword">foreach</span> (FileInfo fi <span class="hljs-keyword">in</span> di.GetFiles(<span class="hljs-string">&quot;*.jpg&quot;</span>))
    Console.WriteLine(fi.Name);

<span class="hljs-keyword">foreach</span> (DirectoryInfo subDir <span class="hljs-keyword">in</span> di.GetDirectories())
    Console.WriteLine(subDir.FullName);
</code></pre>
<hr>
<h3>کلاس Path 🛤️</h3>
<p>کلاس <strong>Path</strong> به صورت ایستا متدها و فیلدهایی برای کار با مسیرها و نام فایل‌ها ارائه می‌دهد.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> dir  = <span class="hljs-string">@&quot;c:\mydir&quot;</span>;    <span class="hljs-comment">// یا /mydir</span>
<span class="hljs-built_in">string</span> <span class="hljs-keyword">file</span> = <span class="hljs-string">&quot;myfile.txt&quot;</span>;
<span class="hljs-built_in">string</span> path = <span class="hljs-string">@&quot;c:\mydir\myfile.txt&quot;</span>;    <span class="hljs-comment">// یا /mydir/myfile.txt</span>
Directory.SetCurrentDirectory(<span class="hljs-string">@&quot;k:\demo&quot;</span>);  <span class="hljs-comment">// یا /demo</span>
</code></pre>
<p>با این setup می‌توان از متدهای کلاس <strong>Path</strong> برای دستکاری رشته‌های مسیر و نام فایل استفاده کرد، مانند ترکیب مسیر، استخراج نام فایل، استخراج پسوند، و غیره.</p>
<div align="center">
<p><img src="../../../assets/image/15/Table-15-9.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>متدهای کلاس Path و مدیریت پوشه‌های ویژه 🛤️📁</h3>
<h4>۱. <strong>Path.Combine</strong></h4>
<p>متد <strong>Combine</strong> بسیار مفید است؛ زیرا به شما امکان می‌دهد یک دایرکتوری و نام فایل یا دو دایرکتوری را بدون بررسی وجود یا نبودن جداکننده مسیر ترکیب کنید.</p>
<ul>
<li>به‌طور خودکار جداکننده مناسب سیستم عامل را استفاده می‌کند.</li>
<li>اورلودهایی دارد که تا چهار مسیر یا نام فایل را می‌پذیرد.</li>
</ul>
<h4>۲. <strong>GetFullPath</strong></h4>
<p>تبدیل مسیر نسبی به مسیر کامل (Absolute).</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> fullPath = Path.GetFullPath(<span class="hljs-string">@&quot;..\..\file.txt&quot;</span>);
</code></pre>
<h4>۳. <strong>GetRandomFileName و GetTempFileName</strong></h4>
<ul>
<li><code>GetRandomFileName</code> نام فایل ۸.۳ منحصر به‌فرد تولید می‌کند بدون ایجاد فایل واقعی.</li>
<li><code>GetTempFileName</code> نام فایل موقت ایجاد می‌کند و فایل صفر بایتی در دایرکتوری temp می‌سازد.<br>
⚠️ پس از استفاده باید آن را حذف کنید، در غیر این صورت پس از ۶۵۰۰۰ بار فراخوانی استثنا ایجاد می‌شود.</li>
</ul>
<p>اگر مشکل ایجاد شد، می‌توان از ترکیب <code>GetTempPath</code> با <code>GetRandomFileName</code> استفاده کرد، اما مراقب پر شدن هارد باشید.</p>
<hr>
<h3>پوشه‌های ویژه (Special Folders) 🌟</h3>
<p>کلاس <strong>Path</strong> و <strong>Directory</strong> پوشه‌های ویژه مثل <strong>My Documents</strong> یا <strong>Program Files</strong> را پوشش نمی‌دهند. برای این کار از:</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> myDocPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
</code></pre>
<ul>
<li><code>Environment.SpecialFolder</code> یک enum است که تمام پوشه‌های ویژه ویندوز را شامل می‌شود: AdminTools, ApplicationData, Fonts, StartMenu و غیره.</li>
<li>مسیر runtime دات‌نت با:</li>
</ul>
<pre class="hljs"><code>System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()
</code></pre>
<h4>نکات مهم در ویندوز</h4>
<ul>
<li><strong>ApplicationData:</strong> داده‌های کاربر که در شبکه منتقل می‌شوند (روامینگ).</li>
<li><strong>LocalApplicationData:</strong> داده‌های محلی کاربر، بدون رامینگ.</li>
<li><strong>CommonApplicationData:</strong> داده‌های مشترک بین کاربران.</li>
</ul>
<p>رعایت استاندارد: ایجاد یک زیرپوشه با نام برنامه شما برای ذخیره‌سازی داده‌ها.</p>
<pre class="hljs"><code><span class="hljs-built_in">string</span> localAppDataPath = Path.Combine(
    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
    <span class="hljs-string">&quot;MyCoolApplication&quot;</span>
);
<span class="hljs-keyword">if</span> (!Directory.Exists(localAppDataPath))
    Directory.CreateDirectory(localAppDataPath);
</code></pre>
<p>⚠️ نکته: اگر برنامه با سطح دسترسی مدیر اجرا شود و پوشه‌ها در <code>CommonApplicationData</code> ایجاد شوند، کاربران با دسترسی محدود ممکن است نتوانند فایل‌ها را بعداً تغییر دهند. راه‌حل: ایجاد پوشه‌ها با مجوز مناسب در فرآیند نصب.</p>
<hr>
<h3>Querying Volume Information 💽</h3>
<p>برای دریافت اطلاعات درایوها از <strong>DriveInfo</strong> استفاده می‌کنیم:</p>
<pre class="hljs"><code>DriveInfo c = <span class="hljs-keyword">new</span> DriveInfo(<span class="hljs-string">&quot;C&quot;</span>); <span class="hljs-comment">// یا &quot;/&quot; در Unix</span>
<span class="hljs-built_in">long</span> totalSize = c.TotalSize;
<span class="hljs-built_in">long</span> freeBytes = c.TotalFreeSpace;
<span class="hljs-built_in">long</span> freeToMe  = c.AvailableFreeSpace;

<span class="hljs-keyword">foreach</span> (DriveInfo d <span class="hljs-keyword">in</span> DriveInfo.GetDrives())
{
    Console.WriteLine(d.Name);          <span class="hljs-comment">// C:\</span>
    Console.WriteLine(d.DriveType);     <span class="hljs-comment">// Fixed</span>
    Console.WriteLine(d.RootDirectory); <span class="hljs-comment">// C:\</span>
    <span class="hljs-keyword">if</span> (d.IsReady)
    {
        Console.WriteLine(d.VolumeLabel); <span class="hljs-comment">// برچسب درایو</span>
        Console.WriteLine(d.DriveFormat); <span class="hljs-comment">// NTFS, FAT و غیره</span>
    }
}
</code></pre>
<ul>
<li><code>GetDrives</code> همه درایوهای تعریف‌شده، شامل CD-ROM، کارت حافظه و شبکه را بازمی‌گرداند.</li>
<li><code>DriveType</code> enum: <code>Unknown, NoRootDirectory, Removable, Fixed, Network, CDRom, Ram</code>.</li>
</ul>
<hr>
<h3>مانیتور کردن تغییرات فایل و دایرکتوری با FileSystemWatcher 🔔</h3>
<ul>
<li><strong>FileSystemWatcher</strong> امکان مانیتور کردن یک دایرکتوری و زیرشاخه‌های آن برای فعالیت‌ها را فراهم می‌کند.</li>
<li>رویدادهایی دارد که هنگام ایجاد، تغییر، حذف، تغییر نام یا تغییر ویژگی فایل/دایرکتوری فعال می‌شوند.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code>Watch(GetTestDirectory(), <span class="hljs-string">&quot;*.txt&quot;</span>, <span class="hljs-literal">true</span>);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Watch</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> path, <span class="hljs-built_in">string</span> filter, <span class="hljs-built_in">bool</span> includeSubDirs</span>)</span>
{
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> watcher = <span class="hljs-keyword">new</span> FileSystemWatcher(path, filter);
    watcher.Created += FileCreatedChangedDeleted;
    watcher.Changed += FileCreatedChangedDeleted;
    watcher.Deleted += FileCreatedChangedDeleted;
    watcher.Renamed += FileRenamed;
    watcher.Error   += FileError;
    watcher.IncludeSubdirectories = includeSubDirs;
    watcher.EnableRaisingEvents = <span class="hljs-literal">true</span>;

    Console.WriteLine(<span class="hljs-string">&quot;Listening for events - press &lt;enter&gt; to end&quot;</span>);
    Console.ReadLine();
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FileCreatedChangedDeleted</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> o, FileSystemEventArgs e</span>)</span>
    =&gt; Console.WriteLine(<span class="hljs-string">&quot;File {0} has been {1}&quot;</span>, e.FullPath, e.ChangeType);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FileRenamed</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> o, RenamedEventArgs e</span>)</span>
    =&gt; Console.WriteLine(<span class="hljs-string">&quot;Renamed: {0}-&gt;{1}&quot;</span>, e.OldFullPath, e.FullPath);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FileError</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> o, ErrorEventArgs e</span>)</span>
    =&gt; Console.WriteLine(<span class="hljs-string">&quot;Error: &quot;</span> + e.GetException().Message);

<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetTestDirectory</span>()</span> =&gt;
    RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? <span class="hljs-string">@&quot;C:\Temp&quot;</span> : <span class="hljs-string">&quot;/tmp&quot;</span>;
</code></pre>
<p>نکات مهم:</p>
<ul>
<li>رویدادها در یک <strong>Thread جداگانه</strong> اجرا می‌شوند، بنابراین باید مدیریت استثنا داشته باشید.</li>
<li>رویداد <code>Error</code> نشان‌دهنده overflow بافر داخلی است. با <code>InternalBufferSize</code> می‌توان بافر را تغییر داد.</li>
<li><code>IncludeSubdirectories</code> به صورت بازگشتی اعمال می‌شود.</li>
<li>مراقب باشید فایل‌ها را قبل از اینکه کاملاً نوشته شوند، باز نکنید؛ ممکن است نیاز به استراتژی‌هایی مثل نوشتن با پسوند موقت و تغییر نام بعد از تکمیل داشته باشید.</li>
</ul>
<h3>امنیت سیستم‌عامل (OS Security) 🛡️</h3>
<p>همه برنامه‌ها تحت محدودیت‌های سیستم‌عامل اجرا می‌شوند و این محدودیت‌ها بر اساس سطح دسترسی کاربر اعمال می‌شوند. این محدودیت‌ها علاوه بر I/O فایل، بر دسترسی به منابع دیگر مثل <strong>Windows Registry</strong> هم تأثیر دارند.</p>
<hr>
<h4>۱. <strong>انواع حساب کاربری</strong></h4>
<ul>
<li><strong>حساب کاربری ادمین / سوپر یوزر:</strong> بدون محدودیت در دسترسی به کامپیوتر محلی.</li>
<li><strong>حساب با دسترسی محدود:</strong> عملکردهای مدیریتی محدود و دسترسی به داده‌های دیگر کاربران محدود است.</li>
</ul>
<p>در ویندوز، ویژگی <strong>User Account Control (UAC)</strong> باعث می‌شود هنگام ورود، مدیر سیستم دو توکن یا “کلاه” داشته باشد:</p>
<ol>
<li>کلاه مدیر (Administrative)</li>
<li>کلاه کاربر عادی (Ordinary User)</li>
</ol>
<p>به‌طور پیش‌فرض برنامه‌ها با کلاه کاربر عادی اجرا می‌شوند مگر اینکه درخواست دسترسی مدیریتی کنند و کاربر آن را تأیید کند.</p>
<p>در Unix، کاربران معمولاً با حساب محدود وارد می‌شوند و برای اجرای دستورات با دسترسی بالا از <code>sudo</code> استفاده می‌کنند.</p>
<hr>
<h4>۲. <strong>اجرای برنامه با دسترسی محدود</strong></h4>
<ul>
<li>
<p>به‌طور پیش‌فرض، برنامه‌ها با محدودیت کاربر اجرا می‌شوند. بنابراین باید:</p>
<ol>
<li>برنامه را طوری طراحی کنید که بدون دسترسی مدیر کار کند (<strong>گزینه ایمن‌تر و راحت‌تر</strong>)</li>
<li>یا دسترسی مدیریتی را از طریق <strong>Application Manifest</strong> درخواست کنید (ویندوز)</li>
</ol>
</li>
</ul>
<p>برای تشخیص اینکه برنامه با دسترسی مدیر اجرا می‌شود:</p>
<pre class="hljs"><code>[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;libc&quot;</span>)</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">uint</span> <span class="hljs-title">getuid</span>()</span>;

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsRunningAsAdmin</span>()</span>
{
    <span class="hljs-keyword">if</span> (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
    {
        <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> identity = WindowsIdentity.GetCurrent();
        <span class="hljs-keyword">var</span> principal = <span class="hljs-keyword">new</span> WindowsPrincipal(identity);
        <span class="hljs-keyword">return</span> principal.IsInRole(WindowsBuiltInRole.Administrator);
    }
    <span class="hljs-keyword">return</span> getuid() == <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li>در ویندوز، فقط در صورت فعال بودن UAC و Elevation، مقدار true برمی‌گردد.</li>
<li>در لینوکس، true فقط وقتی فرآیند با sudo اجرا شود.</li>
</ul>
<hr>
<h4>۳. <strong>محدودیت‌های حساب کاربر عادی</strong></h4>
<p>کارهایی که نمی‌توان با حساب عادی انجام داد:</p>
<ul>
<li>نوشتن در پوشه‌های سیستم (مثلاً <code>\Windows</code> یا <code>/bin, /sbin</code>) و زیرشاخه‌ها</li>
<li>نوشتن در پوشه Program Files یا <code>/usr/bin, /opt</code></li>
<li>نوشتن در ریشه درایو سیستم (<code>C:\</code> یا <code>/</code>)</li>
<li>نوشتن در شاخه <code>HKEY_LOCAL_MACHINE</code> در Registry ویندوز</li>
<li>خواندن داده‌های Performance Monitoring (WMI در ویندوز)</li>
</ul>
<p>همچنین ممکن است دسترسی به فایل‌ها یا منابع دیگر کاربران محدود باشد. ویندوز از <strong>Access Control List (ACL)</strong> برای محافظت استفاده می‌کند و اگر دسترسی رد شود، CLR استثنای <strong>UnauthorizedAccessException</strong> پرتاب می‌کند.</p>
<p><strong>راهکار مقابله با محدودیت‌ها:</strong></p>
<ul>
<li>فایل‌ها را در مکان‌های توصیه‌شده کاربر ذخیره کنید.</li>
<li>از Registry فقط برای HKEY_CURRENT_USER استفاده کنید.</li>
<li>کامپوننت‌های ActiveX یا COM را در فرآیند نصب ثبت کنید.</li>
</ul>
<hr>
<h4>۴. <strong>مکان‌های پیشنهادی ذخیره‌سازی فایل‌ها</strong></h4>
<pre class="hljs"><code><span class="hljs-built_in">string</span> docsFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
<span class="hljs-built_in">string</span> path = Path.Combine(docsFolder, <span class="hljs-string">&quot;test.txt&quot;</span>);

<span class="hljs-built_in">string</span> configFolder = Path.Combine(
    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), <span class="hljs-comment">// برای کاربر فعلی</span>
    <span class="hljs-string">&quot;MyApp&quot;</span>
);
<span class="hljs-keyword">if</span> (!Directory.Exists(configFolder))
    Directory.CreateDirectory(configFolder);
</code></pre>
<p>⚠️ توجه: استفاده از <code>CommonApplicationData</code> برای دسترسی همه کاربران، باید با تنظیم مجوزها همراه باشد.</p>
<hr>
<h4>۵. <strong>Elevation مدیریتی و Virtualization ویندوز</strong></h4>
<p>با <strong>Application Manifest</strong> می‌توانید درخواست دسترسی مدیر کنید:</p>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">requestedExecutionLevel</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;requireAdministrator&quot;</span> /&gt;</span>
</code></pre>
<ul>
<li><code>asInvoker</code>: برنامه بدون دسترسی مدیر اجرا شود و Virtualization غیرفعال است.</li>
</ul>
<p><strong>Virtualization:</strong> تغییرات در پوشه Program Files یا Windows و HKEY_LOCAL_MACHINE به مکان جداگانه هدایت می‌شود تا از آسیب به سیستم جلوگیری شود.</p>
<hr>
<h4>۶. <strong>Memory-Mapped Files</strong> 🗄️</h4>
<p>مزایا:</p>
<ol>
<li>دسترسی سریع و تصادفی به داده‌های فایل</li>
<li>اشتراک حافظه بین فرآیندهای مختلف</li>
</ol>
<p>در دات‌نت از <strong>System.IO.MemoryMappedFiles</strong> استفاده می‌کنیم که در واقع API سیستم‌عامل برای Memory-Mapped Files را پوشش می‌دهد.</p>
<h3>فایل‌های Memory-Mapped و دسترسی تصادفی به فایل 🗂️💨</h3>
<p>Memory-mapped files برای دسترسی <strong>تصادفی و سریع</strong> به داده‌های فایل و همچنین اشتراک حافظه بین فرآیندها استفاده می‌شوند. در مقایسه با FileStream:</p>
<table>
<thead>
<tr>
<th>نوع دسترسی</th>
<th>FileStream</th>
<th>Memory-Mapped File</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sequential (متوالی)</td>
<td>سریع‌تر (~10×)</td>
<td>کندتر</td>
</tr>
<tr>
<td>Random (تصادفی)</td>
<td>کندتر</td>
<td>سریع‌تر (~10×)</td>
</tr>
</tbody>
</table>
<hr>
<h4>۱. ایجاد یک Memory-Mapped File</h4>
<ol>
<li>یک <code>FileStream</code> معمولی بسازید.</li>
<li>یک <code>MemoryMappedFile</code> بسازید و فایل را به آن بدهید.</li>
<li>از <code>CreateViewAccessor</code> برای ایجاد <strong>View Accessor</strong> استفاده کنید.</li>
</ol>
<pre class="hljs"><code>File.WriteAllBytes(<span class="hljs-string">&quot;long.bin&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">1</span>_000_000]);
<span class="hljs-keyword">using</span> MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile(<span class="hljs-string">&quot;long.bin&quot;</span>);
<span class="hljs-keyword">using</span> MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();

accessor.Write(<span class="hljs-number">500</span>_000, (<span class="hljs-built_in">byte</span>)<span class="hljs-number">77</span>);
Console.WriteLine(accessor.ReadByte(<span class="hljs-number">500</span>_000));  <span class="hljs-comment">// 77</span>
</code></pre>
<ul>
<li>می‌توان نام Map و ظرفیت مشخص کرد تا حافظه به اشتراک گذاشته شود یا اندازه فایل بزرگ‌تر شود.</li>
</ul>
<hr>
<h4>۲. اشتراک حافظه بین فرآیندها (Windows)</h4>
<ul>
<li>یک فرآیند <code>MemoryMappedFile.CreateNew</code> ایجاد می‌کند.</li>
<li>فرآیندهای دیگر با <code>OpenExisting</code> به همان حافظه دسترسی دارند.</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// Writer</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> mmFile = MemoryMappedFile.CreateNew(<span class="hljs-string">&quot;Demo&quot;</span>, <span class="hljs-number">500</span>);
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> accessor = mmFile.CreateViewAccessor();
accessor.Write(<span class="hljs-number">0</span>, <span class="hljs-number">12345</span>);
Console.ReadLine(); <span class="hljs-comment">// حافظه را زنده نگه می‌دارد</span>

<span class="hljs-comment">// Reader (فرآیند دیگر)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> mmFile = MemoryMappedFile.OpenExisting(<span class="hljs-string">&quot;Demo&quot;</span>);
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> accessor = mmFile.CreateViewAccessor();
Console.WriteLine(accessor.ReadInt32(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 12345</span>
</code></pre>
<hr>
<h4>۳. اشتراک حافظه بین فرآیندها در Windows و Unix</h4>
<ul>
<li>فایل را با <code>FileStream</code> باز کنید و اجازه خواندن/نوشتن مشترک بدهید (<code>FileShare.ReadWrite</code>).</li>
<li>سپس <code>MemoryMappedFile.CreateFromFile</code> بسازید.</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">var</span> <span class="hljs-keyword">file</span> = Path.Combine(TestDirectory, <span class="hljs-string">&quot;interprocess.bin&quot;</span>);
File.WriteAllBytes(<span class="hljs-keyword">file</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">100</span>]);

<span class="hljs-keyword">using</span> FileStream fs = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-keyword">file</span>, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite);
<span class="hljs-keyword">using</span> MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile(fs, <span class="hljs-literal">null</span>, fs.Length, MemoryMappedFileAccess.ReadWrite, HandleInheritability.None, <span class="hljs-literal">true</span>);
<span class="hljs-keyword">using</span> MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();
accessor.Write(<span class="hljs-number">0</span>, <span class="hljs-number">12345</span>);
Console.ReadLine();
File.Delete(<span class="hljs-keyword">file</span>);
</code></pre>
<hr>
<h4>۴. کار با View Accessor</h4>
<ul>
<li><code>Read*</code> و <code>Write*</code> برای <strong>نوع‌های عددی، bool، char</strong> و آرایه‌ها/structهای Value Type استفاده می‌شوند.</li>
<li>برای رشته‌ها، باید ابتدا آن‌ها را به آرایه بایت تبدیل کنید.</li>
</ul>
<pre class="hljs"><code><span class="hljs-built_in">byte</span>[] data = Encoding.UTF8.GetBytes(<span class="hljs-string">&quot;This is a test&quot;</span>);
accessor.Write(<span class="hljs-number">0</span>, data.Length);
accessor.WriteArray(<span class="hljs-number">4</span>, data, <span class="hljs-number">0</span>, data.Length);

<span class="hljs-comment">// خواندن مجدد</span>
<span class="hljs-built_in">byte</span>[] readData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[accessor.ReadInt32(<span class="hljs-number">0</span>)];
accessor.ReadArray(<span class="hljs-number">4</span>, readData, <span class="hljs-number">0</span>, readData.Length);
Console.WriteLine(Encoding.UTF8.GetString(readData)); <span class="hljs-comment">// This is a test</span>
</code></pre>
<ul>
<li>کار با struct:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">struct</span> Data { <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X, Y; }
<span class="hljs-keyword">var</span> data = <span class="hljs-keyword">new</span> Data { X = <span class="hljs-number">123</span>, Y = <span class="hljs-number">456</span> };
accessor.Write(<span class="hljs-number">0</span>, <span class="hljs-keyword">ref</span> data);
accessor.Read(<span class="hljs-number">0</span>, <span class="hljs-keyword">out</span> data);
Console.WriteLine(data.X + <span class="hljs-string">&quot; &quot;</span> + data.Y); <span class="hljs-comment">// 123 456</span>
</code></pre>
<hr>
<h4>۵. بهینه‌سازی عملکرد با اشاره‌گرها (Unsafe)</h4>
<ul>
<li>استفاده از <code>SafeMemoryMappedViewHandle.AcquirePointer</code> بسیار سریع‌تر از <code>Read/Write</code> است، مخصوصاً برای داده‌های بزرگ:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">unsafe</span>
{
    <span class="hljs-built_in">byte</span>* pointer = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">try</span>
    {
        accessor.SafeMemoryMappedViewHandle.AcquirePointer(<span class="hljs-keyword">ref</span> pointer);
        <span class="hljs-built_in">int</span>* intPointer = (<span class="hljs-built_in">int</span>*)pointer;
        Console.WriteLine(*intPointer); <span class="hljs-comment">// 123</span>
    }
    <span class="hljs-keyword">finally</span>
    {
        <span class="hljs-keyword">if</span> (pointer != <span class="hljs-literal">null</span>)
            accessor.SafeMemoryMappedViewHandle.ReleasePointer();
    }
}
</code></pre>
<ul>
<li>نیاز به فعال کردن unsafe code در فایل <code>.csproj</code>:</li>
</ul>
<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">AllowUnsafeBlocks</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">AllowUnsafeBlocks</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>دلیل اصلی برتری عملکرد استفاده از <strong>اشاره‌گرها (pointers)</strong> وقتی با ساختارهای بزرگ کار می‌کنیم این است که اشاره‌گرها اجازه می‌دهند مستقیماً با داده‌های خام (raw data) کار کنیم، بدون اینکه مجبور باشیم از متدهای <code>Read</code> و <code>Write</code> برای کپی کردن داده‌ها بین حافظه <strong>مدیریت‌شده (managed)</strong> و <strong>مدیریت‌نشده (unmanaged)</strong> استفاده کنیم.</p>
<p>این کار باعث صرفه‌جویی قابل‌توجهی در زمان و منابع می‌شود، به‌ویژه وقتی حجم داده‌ها زیاد باشد. این موضوع در <strong>فصل ۲۴</strong> کتاب به‌طور کامل بررسی شده است.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
