

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Exception Handling</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

       <nav class="nav">
         <a href="/Gitab/" >خانه</a>
         <a href="/Gitab/books/list-books" >کتاب‌ها</a>
        <a href="/Gitab/translator.html" >مترجمین</a>
         <a href="/Gitab/giter.html" >گیتر</a>
       </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل پنجم:  مدیریت استثناها (Exception Handling) ⚠️</h1>
<p>در فصل قبل، ما به توابع نگاه کردیم. با وجود تلاش‌های برنامه‌نویسان برای نوشتن کدهای مقاوم و پایدار، توابع در مقطعی از اجرا <strong>استثناها (exceptions)</strong> ایجاد خواهند کرد. این استثناها می‌توانند دلایل مختلفی داشته باشند، مانند:</p>
<ul>
<li>فایل یا پوشه‌ای وجود ندارد</li>
<li>مقدار <strong>null</strong> یا خالی است</li>
<li>مکان مورد نظر قابل نوشتن نیست</li>
<li>دسترسی کاربر محدود شده است</li>
</ul>
<p>با در نظر گرفتن این مسائل، در این فصل با روش‌های مناسب برای <strong>مدیریت استثناها</strong> آشنا خواهید شد تا کد C# تمیز و قابل اطمینان بنویسید.</p>
<hr>
<h3>موضوعات این فصل</h3>
<p>1️⃣ بررسی استثناهای <strong>Checked</strong> و <strong>Unchecked</strong>، به‌ویژه در رابطه با <strong>OverflowException</strong></p>
<p>2️⃣ جلوگیری از <strong>NullPointerException</strong></p>
<p>3️⃣ پیاده‌سازی قوانین کسب‌وکار برای انواع خاصی از استثناها (<strong>Business Rule Exceptions</strong>)</p>
<p>4️⃣ اطمینان از اینکه استثناها اطلاعات معنادار ارائه دهند</p>
<p>5️⃣ ساخت <strong>Custom Exceptions</strong></p>
<p>6️⃣ و در نهایت، بررسی اینکه چرا نباید از استثناها برای کنترل جریان برنامه استفاده کنیم</p>
<hr>
<h3>مهارت‌هایی که پس از این فصل کسب خواهید کرد</h3>
<ul>
<li>درک تفاوت استثناهای <strong>Checked و Unchecked</strong> و دلیل وجود آن‌ها در C#</li>
<li>درک <strong>OverflowException</strong> و روش گرفتن آن‌ها در زمان <strong>Compile</strong></li>
<li>شناخت <strong>NullPointerException</strong> و نحوه جلوگیری از آن‌ها</li>
<li>توانایی نوشتن <strong>Custom Exceptions</strong> که اطلاعات معنادار ارائه می‌دهند و به شما و دیگر برنامه‌نویسان کمک می‌کنند مشکلات را به‌سرعت شناسایی و رفع کنید</li>
<li>درک اینکه چرا نباید از استثناها برای کنترل جریان برنامه استفاده کنید</li>
<li>توانایی جایگزین کردن استثناهای قوانین کسب‌وکار با دستورات C# و بررسی‌های Boolean برای کنترل جریان برنامه</li>
</ul>
<hr>
<p>اگر آماده باشی، می‌توانیم فصل را با بخش اول یعنی <strong>استثناهای Checked و Unchecked</strong> شروع کنیم. ⚡</p>
<h3>⚖️ استثناهای Checked و Unchecked</h3>
<p>در <strong>حالت Unchecked</strong>، اگر یک <strong>Overflow</strong> (سرریز) عددی رخ دهد، نادیده گرفته می‌شود. در این حالت، <strong>بیت‌های با ارزش بالا</strong> که نمی‌توانند به نوع مقصد اختصاص داده شوند، از نتیجه حذف می‌شوند.</p>
<p>به‌طور پیش‌فرض، C# هنگام انجام <strong>عبارات غیرثابت (non-constant)</strong> در زمان اجرا، در <strong>context Unchecked</strong> عمل می‌کند. اما <strong>عبارات ثابت در زمان Compile</strong> همیشه به‌صورت پیش‌فرض <strong>Checked</strong> هستند.</p>
<p>وقتی در <strong>حالت Checked</strong> با سرریز عددی مواجه شویم، یک <strong>OverflowException</strong> ایجاد می‌شود. یکی از دلایلی که از حالت Unchecked استفاده می‌شود، <strong>افزایش عملکرد برنامه</strong> است، زیرا بررسی استثناهای Checked می‌تواند کمی عملکرد روش‌ها را کاهش دهد.</p>
<hr>
<h4>✅ قاعده کلی</h4>
<p>همیشه بهتر است که عملیات عددی خود را در <strong>context Checked</strong> انجام دهید. با این کار، هر گونه Overflow به‌صورت <strong>خطا در زمان Compile</strong> شناسایی می‌شود و می‌توانید قبل از انتشار کد، آن را اصلاح کنید. این بسیار بهتر از این است که کد را منتشر کنید و بعد مجبور شوید خطاهای زمان اجرا برای مشتری را اصلاح کنید.</p>
<p>اجرای کد در <strong>حالت Unchecked</strong> خطرناک است زیرا شما بر اساس <strong>فرضیات</strong> عمل می‌کنید، نه حقایق. این فرضیات ممکن است منجر به ایجاد استثنا در زمان اجرا شوند. استثناهای زمان اجرا باعث کاهش رضایت مشتری و ایجاد مشکلات جدی بعدی می‌شوند که می‌توانند تأثیر منفی بر مشتری داشته باشند.</p>
<p>اجازه دادن به برنامه برای ادامه اجرا پس از تجربه <strong>OverflowException</strong> از نظر کسب‌وکار بسیار خطرناک است. دلیل آن این است که داده‌ها ممکن است به <strong>وضعیت غیرقابل بازگشت و نامعتبر</strong> وارد شوند. اگر این داده‌ها داده‌های حساس مشتری باشند، این موضوع می‌تواند هزینه زیادی برای کسب‌وکار داشته باشد، و قطعاً نمی‌خواهید این بار روی دوش شما باشد.</p>
<hr>
<h4>💳 مثال بانکی: خطر سرریز Unchecked</h4>
<p>کد زیر نشان می‌دهد که چقدر یک Overflow <strong>Unchecked</strong> می‌تواند در دنیای بانکداری مشتری خطرناک باشد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UncheckedBankAccountException</span>()</span>
{
    <span class="hljs-keyword">var</span> currentBalance = <span class="hljs-built_in">int</span>.MaxValue;
    Console.WriteLine(<span class="hljs-string">$&quot;Current Balance: <span class="hljs-subst">{currentBalance}</span>&quot;</span>);
    currentBalance = <span class="hljs-keyword">unchecked</span>(currentBalance + <span class="hljs-number">1</span>);
    Console.WriteLine(<span class="hljs-string">$&quot;Current Balance + 1 = <span class="hljs-subst">{currentBalance}</span>&quot;</span>);
    Console.ReadKey();
}
</code></pre>
<p>تصور کنید چقدر ترسناک است وقتی مشتری می‌بیند با افزودن <strong>£1</strong> به موجودی بانک خود که برابر با <strong>£2,147,483,647</strong> است، موجودی او به <strong>-£2,147,483,648</strong> تبدیل می‌شود! 😱</p>
<div align="center">
<p><img src="../../../assets/image/05/Table%205-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>⚠️ مثال عملی از استثناهای Checked و Unchecked</h3>
<p>اکنون وقت آن است که <strong>استثناهای Checked و Unchecked</strong> را با <strong>مثال کد عملی</strong> نشان دهیم.</p>
<hr>
<p>ابتدا یک <strong>Console Application</strong> جدید ایجاد کنید و برخی متغیرها را اعلام کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-built_in">byte</span> y, z;
</code></pre>
<p>کد بالا دو متغیر از نوع <strong>byte</strong> اعلام می‌کند که در مثال‌های محاسباتی بعدی استفاده خواهند شد.</p>
<hr>
<h4>1️⃣ متد CheckedAdd()</h4>
<p>این متد یک <strong>OverflowException</strong> ایجاد می‌کند اگر جمع دو عدد منجر به عددی شود که نتواند در یک <strong>byte</strong> ذخیره شود:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CheckedAdd</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;### Checked Add ###&quot;</span>);
        Console.WriteLine(<span class="hljs-string">$&quot;x = <span class="hljs-subst">{y}</span> + <span class="hljs-subst">{z}</span>&quot;</span>);
        Console.WriteLine(<span class="hljs-string">$&quot;x = <span class="hljs-subst">{checked((<span class="hljs-built_in">byte</span>)(y + z))}</span>&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (OverflowException oex)
    {
        Console.WriteLine(<span class="hljs-string">$&quot;CheckedAdd: <span class="hljs-subst">{oex.Message}</span>&quot;</span>);
    }
}
</code></pre>
<hr>
<h4>2️⃣ متد CheckedMultiplication()</h4>
<p>این متد نیز در صورت سرریز هنگام ضرب دو عدد، یک <strong>OverflowException</strong> ایجاد می‌کند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CheckedMultiplication</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;### Checked Multiplication ###&quot;</span>);
        Console.WriteLine(<span class="hljs-string">$&quot;x = <span class="hljs-subst">{y}</span> x <span class="hljs-subst">{z}</span>&quot;</span>);
        Console.WriteLine(<span class="hljs-string">$&quot;x = <span class="hljs-subst">{checked((<span class="hljs-built_in">byte</span>)(y * z))}</span>&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (OverflowException oex)
    {
        Console.WriteLine(<span class="hljs-string">$&quot;CheckedMultiplication: <span class="hljs-subst">{oex.Message}</span>&quot;</span>);
    }
}
</code></pre>
<hr>
<h4>3️⃣ متد UncheckedAdd()</h4>
<p>این متد هرگونه Overflow را نادیده می‌گیرد و <strong>هیچ استثنایی ایجاد نمی‌شود</strong>. نتیجه نادرست خواهد بود، اما برنامه ادامه می‌یابد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UncheckedAdd</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;### Unchecked Add ###&quot;</span>);
        Console.WriteLine(<span class="hljs-string">$&quot;x = <span class="hljs-subst">{y}</span> + <span class="hljs-subst">{z}</span>&quot;</span>);
        Console.WriteLine(<span class="hljs-string">$&quot;x = <span class="hljs-subst">{<span class="hljs-keyword">unchecked</span>((<span class="hljs-built_in">byte</span>)(y + z))}</span>&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (OverflowException oex)
    {
        Console.WriteLine(<span class="hljs-string">$&quot;CheckedAdd: <span class="hljs-subst">{oex.Message}</span>&quot;</span>);
    }
}
</code></pre>
<hr>
<h4>4️⃣ متد UncheckedMultiplication()</h4>
<p>این متد نیز هنگام Overflow نتیجه ضرب را نادیده می‌گیرد و <strong>مقدار نادرست در byte ذخیره می‌شود</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UncheckedMultiplication</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;### Unchecked Multiplication ###&quot;</span>);
        Console.WriteLine(<span class="hljs-string">$&quot;x = <span class="hljs-subst">{y}</span> x <span class="hljs-subst">{z}</span>&quot;</span>);
        Console.WriteLine(<span class="hljs-string">$&quot;x = <span class="hljs-subst">{<span class="hljs-keyword">unchecked</span>((<span class="hljs-built_in">byte</span>)(y * z))}</span>&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (OverflowException oex)
    {
        Console.WriteLine(<span class="hljs-string">$&quot;CheckedMultiplication: <span class="hljs-subst">{oex.Message}</span>&quot;</span>);
    }
}
</code></pre>
<hr>
<h4>5️⃣ متد Main()</h4>
<p>در نهایت، متد Main را به‌گونه‌ای تغییر دهید که متغیرها مقداردهی اولیه شوند و همه متدها اجرا شوند:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span>
{
    y = <span class="hljs-built_in">byte</span>.MaxValue; <span class="hljs-comment">// بیشترین مقدار ممکن برای byte</span>
    z = <span class="hljs-number">2</span>;
    CheckedAdd();
    CheckedMultiplication();
    UncheckedAdd();
    UncheckedMultiplication();
    Console.WriteLine(<span class="hljs-string">&quot;Press any key to exit.&quot;</span>);
    Console.ReadLine();
}
</code></pre>
<p>در این مثال:</p>
<ul>
<li>متدهای <strong>CheckedAdd</strong> و <strong>CheckedMultiplication</strong> منجر به <strong>OverflowException</strong> می‌شوند زیرا y بیشترین مقدار برای byte است.</li>
<li>متدهای <strong>UncheckedAdd</strong> و <strong>UncheckedMultiplication</strong> Overflow را نادیده می‌گیرند و نتیجه اشتباه محاسبه می‌شود، بدون اینکه استثنایی رخ دهد.</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/05/Table%205-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>همان‌طور که مشاهده می‌کنید، وقتی از <strong>checked exceptions</strong> استفاده می‌کنیم، در مواجهه با <strong>OverflowException</strong> استثنا ایجاد می‌شود. اما وقتی از <strong>unchecked exceptions</strong> استفاده می‌کنیم، هیچ استثنایی ایجاد نمی‌شود. ⚠️</p>
<p>مشخص است که مشکلات می‌توانند از مقادیر غیرمنتظره به وجود آیند و برخی رفتارهای ناخواسته هنگام استفاده از <strong>unchecked exceptions</strong> ایجاد شوند. بنابراین، قانون کلی هنگام انجام عملیات‌های حسابی این است که همیشه از <strong>checked exceptions</strong> استفاده کنید. ✅</p>
<p>حالا به سراغ یک استثنای بسیار رایج می‌رویم که برنامه‌نویسان اغلب با آن مواجه می‌شوند، به نام <strong>NullPointerException</strong>.</p>
<hr>
<h3>جلوگیری از <strong>NullPointerExceptions</strong> 🛡️</h3>
<p><strong>NullReferenceException</strong> یک استثنای رایج است که اکثر برنامه‌نویسان تجربه کرده‌اند. این استثنا زمانی رخ می‌دهد که سعی شود به یک <strong>property</strong> یا <strong>method</strong> روی یک <strong>null object</strong> دسترسی پیدا شود.</p>
<p>برای جلوگیری از کرش برنامه، معمولاً برنامه‌نویسان از بلوک‌های <code>try { ... } catch (NullReferenceException nre) { ... }</code> استفاده می‌کنند.<br>
این بخشی از <strong>برنامه‌نویسی دفاعی (Defensive Programming)</strong> است. اما مشکل این است که اغلب اوقات خطا فقط <strong>لاگ</strong> می‌شود و دوباره پرتاب می‌گردد. علاوه بر این، محاسبات اضافی و بیهوده‌ای انجام می‌شود که قابل اجتناب بود.</p>
<p>راه بسیار بهتر برای مدیریت <strong>ArgumentNullExceptions</strong>، پیاده‌سازی <strong>ArgumentNullValidator</strong> است. پارامترهای یک متد معمولاً منبع یک <strong>null object</strong> هستند. بنابراین منطقی است که قبل از استفاده، پارامترهای متد را بررسی کنیم و اگر نامعتبر بودند، یک <strong>Exception</strong> مناسب پرتاب کنیم. در مورد <strong>ArgumentNullValidator</strong>، این اعتبارسنج را در ابتدای متد قرار می‌دهیم و هر پارامتر را بررسی می‌کنیم. اگر هر پارامتری <strong>null</strong> بود، <strong>NullReferenceException</strong> پرتاب می‌شود. این کار باعث صرفه‌جویی در محاسبات و حذف نیاز به استفاده از بلوک <code>try...catch</code> می‌شود.</p>
<hr>
<p>برای روشن شدن موضوع، <strong>ArgumentNullValidator</strong> را پیاده‌سازی می‌کنیم و آن را در یک متد برای بررسی پارامترهای متد استفاده می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>
    {
         Name = name;
    }
}
</code></pre>
<p>در کد بالا، ما کلاس <strong>Person</strong> را با یک <strong>property</strong> فقط خواندنی به نام <strong>Name</strong> ایجاد کرده‌ایم. این شیء را به متدهای نمونه می‌دهیم تا <strong>NullReferenceException</strong> ایجاد شود.</p>
<p>سپس <strong>Attribute</strong> مربوط به اعتبارسنج را ایجاد می‌کنیم به نام <strong>ValidatedNotNullAttribute</strong>:</p>
<pre class="hljs"><code>[<span class="hljs-meta">AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)</span>]
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ValidatedNotNullAttribute</span> : <span class="hljs-title">Attribute</span> { }
</code></pre>
<p>حالا زمان نوشتن <strong>validator</strong> است:</p>
<pre class="hljs"><code><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ArgumentNullValidator</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotNull</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, [ValidatedNotNull] <span class="hljs-built_in">object</span> <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
        {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(name);
        }
    }
}
</code></pre>
<p><strong>ArgumentNullValidator</strong> دو آرگومان می‌گیرد:</p>
<ol>
<li>نام شیء</li>
<li>خود شیء</li>
</ol>
<p>شیء بررسی می‌شود که <strong>null</strong> باشد یا نه. اگر <strong>null</strong> باشد، <strong>ArgumentNullException</strong> با نام شیء پرتاب می‌شود.</p>
<hr>
<p>متد نمونه <strong>try/catch</strong> به صورت زیر است. توجه کنید که پیام <strong>log</strong> می‌شود و استثنا پرتاب می‌گردد. اما پارامتر استثنا استفاده نمی‌شود، و در واقع این پارامتر باید حذف شود. چنین مواردی در کدها اغلب دیده می‌شود و غیرضروری است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TryCatchExample</span>(<span class="hljs-params">Person person</span>)</span>
{
    <span class="hljs-keyword">try</span>
    {
        Console.WriteLine(<span class="hljs-string">$&quot;Person&#x27;s Name: <span class="hljs-subst">{person.Name}</span>&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (NullReferenceException nre)
    {
        Console.WriteLine(<span class="hljs-string">&quot;Error: The person argument cannot be null.&quot;</span>);
        <span class="hljs-keyword">throw</span>;
    }
}
</code></pre>
<hr>
<p>حالا متد نمونه‌ای می‌نویسیم که از <strong>ArgumentNullValidator</strong> استفاده می‌کند، به نام <strong>ArgumentNullValidatorExample</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ArgumentNullValidatorExample</span>(<span class="hljs-params">Person person</span>)</span>
{
    ArgumentNullValidator.NotNull(<span class="hljs-string">&quot;Person&quot;</span>, person);
    Console.WriteLine(<span class="hljs-string">$&quot;Person&#x27;s Name: <span class="hljs-subst">{person.Name}</span>&quot;</span>);
    Console.ReadKey();
}
</code></pre>
<p>توجه کنید که از نه خط کد شامل آکولادها، به فقط دو خط رسیده‌ایم. همچنین دیگر تلاش نمی‌کنیم تا قبل از اعتبارسنجی، مقدار را استفاده کنیم. تنها کاری که اکنون لازم است، اصلاح <strong>Main method</strong> برای اجرای این متدها است.</p>
<p>هر متد را می‌توان با کامنت کردن یکی از متدها و اجرای برنامه، تست کرد و بهترین کار این است که قدم‌به‌قدم کد را بررسی کنید تا روند کار را مشاهده کنید.</p>
<p>خروجی اجرای متد <strong>TryCatchExample</strong> به شکل زیر خواهد بود:</p>
<div align="center">
<p><img src="../../../assets/image/05/Table%205-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>خروجی اجرای متد ArgumentNullValidatorExample به شکل زیر خواهد بود:</p>
<div align="center">
<p><img src="../../../assets/image/05/Table%205-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>همان‌طور که در مثال قبلی مشاهده کردید، وقتی از <strong>ArgumentNullValidatorExample</strong> استفاده می‌کنیم، خطا فقط یک‌بار ثبت می‌شود. اما هنگام استفاده از <strong>TryCatchExample</strong>، خطا دو بار ثبت می‌شود.<br>
بار اول پیام خطا معنی‌دار است، اما بار دوم پیام مبهم و نامفهوم است. با این حال، استثنایی که توسط متد فراخوان <strong>Main</strong> ثبت می‌شود، اصلاً مبهم نیست و کاملاً مفید است، زیرا نشان می‌دهد که مقدار پارامتر <strong>Person</strong> نمی‌تواند <strong>null</strong> باشد. ✅</p>
<p>این بخش نشان داد که بررسی پارامترها در سازنده‌ها و متدها قبل از استفاده از آن‌ها چقدر ارزشمند است. با استفاده از <strong>Argument Validators</strong>، کد شما کاهش یافته، خواناتر و ایمن‌تر می‌شود. 💡</p>
<hr>
<h3>استثناهای قانون کسب‌وکار (Business Rule Exceptions) 🏦</h3>
<p>استثناهای فنی (Technical Exceptions) ناشی از اشتباهات برنامه‌نویس یا مشکلات محیطی مانند کمبود فضای دیسک هستند. اما <strong>استثناهای قانون کسب‌وکار</strong> متفاوتند. این نوع استثناها برای کنترل جریان برنامه استفاده می‌شوند، در حالی که در واقع استثناها باید <strong>استثنا</strong> باشند و نه خروجی پیش‌بینی‌شده یک متد.</p>
<p>برای مثال، فرض کنید شخصی از <strong>ATM</strong> مبلغ 100 پوند برداشت می‌کند، اما حساب او 0 پوند دارد و امکان برداشت بیش از موجودی (Overdrawn) وجود ندارد. اگر کد از استثنا استفاده کند، متد <strong>Withdraw(100)</strong> اجرا شده، موجودی کم است و <strong>InsufficientFundsException()</strong> پرتاب می‌شود.</p>
<p>ممکن است فکر کنید این روش خوب است چون صریح و قابل شناسایی است، اما واقعیت این است که چنین کاری ایده مناسبی نیست. ✅</p>
<p>در چنین سناریویی، بهترین روش این است که قبل از انجام تراکنش، <strong>اعتبارسنجی</strong> شود که برداشت امکان‌پذیر است یا خیر. اگر امکان‌پذیر بود، تراکنش انجام شود، وگرنه جریان برنامه به صورت معمول ادامه یافته، تراکنش لغو شده و کاربر مطلع شود بدون اینکه استثنایی پرتاب شود.</p>
<p>این روش باعث می‌شود برنامه <strong>درست و منطقی</strong> و با استفاده از <strong>چک‌های Boolean</strong> جریان برنامه را کنترل کند و تراکنش‌های مجاز و غیرمجاز به‌درستی مدیریت شوند.</p>
<hr>
<h3>پیاده‌سازی دو سناریو</h3>
<p>ما دو سناریو را پیاده‌سازی می‌کنیم:</p>
<ol>
<li><strong>استفاده از Business Rule Exceptions (BREs)</strong></li>
<li><strong>استفاده از جریان برنامه معمول (Program Flow)</strong></li>
</ol>
<p>ابتدا یک برنامه کنسول جدید بسازید و دو فولدر ایجاد کنید:</p>
<ul>
<li><code>BankAccountUsingExceptions</code></li>
<li><code>BankAccountUsingProgramFlow</code></li>
</ul>
<p>سپس متد <strong>Main</strong> را به شکل زیر به‌روزرسانی کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span>
{
    <span class="hljs-keyword">var</span> usingBrExceptions = <span class="hljs-keyword">new</span> UsingBusinessRuleExceptions();
    usingBrExceptions.Run();
    
    <span class="hljs-keyword">var</span> usingPflow = <span class="hljs-keyword">new</span> UsingProgramFlow();
    usingPflow.Run();
}
</code></pre>
<ul>
<li><code>UsingBusinessRuleExceptions()</code> سناریویی را نشان می‌دهد که استثناها به عنوان خروجی پیش‌بینی‌شده برای کنترل جریان برنامه استفاده می‌شوند.</li>
<li><code>UsingProgramFlow()</code> جریان برنامه تمیز و بدون شرایط استثنایی را نشان می‌دهد. ✅</li>
</ul>
<hr>
<h3>کلاس حساب جاری (CurrentAccount) 💳</h3>
<p>یک کلاس به نام <strong>CurrentAccount</strong> برای نگهداری اطلاعات حساب ایجاد کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentAccount</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> CustomerId { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> AgreedOverdraft { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsAllowedToGoOverdrawn { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> CurrentBalance { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> AvailableBalance { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> AtmDailyLimit { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> AtmWithdrawalAmountToday { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>ویژگی‌های این کلاس فقط از طریق <strong>سازنده</strong> یا درون کلاس قابل مقداردهی هستند.</p>
<p>سازنده کلاس را اضافه کنید که تنها پارامترش <strong>customerId</strong> باشد:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CurrentAccount</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> customerId</span>)</span>
{
    CustomerId = customerId;
    AgreedOverdraft = GetAgreedOverdraftLimit();
    IsAllowedToGoOverdrawn = GetIsAllowedToGoOverdrawn();
    CurrentBalance = GetCurrentBalance();
    AvailableBalance = GetAvailableBalance();
    AtmDailyLimit = GetAtmDailyLimit();
    AtmWithdrawalAmountToday = <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<h3>پیاده‌سازی متدهای کمکی</h3>
<ul>
<li>محدودیت برداشت توافق‌شده:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">decimal</span> <span class="hljs-title">GetAgreedOverdraftLimit</span>()</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li>امکان برداشت بیش از موجودی:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">GetIsAllowedToGoOverdrawn</span>()</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<ul>
<li>موجودی فعلی حساب:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">decimal</span> <span class="hljs-title">GetCurrentBalance</span>()</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-number">250.00</span>M;
}
</code></pre>
<ul>
<li>موجودی قابل برداشت:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">decimal</span> <span class="hljs-title">GetAvailableBalance</span>()</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-number">173.64</span>M;
}
</code></pre>
<ul>
<li>محدودیت روزانه ATM:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetAtmDailyLimit</span>()</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-number">250</span>;
}
</code></pre>
<hr>
<p>در مرحله بعد، کد دو سناریو را پیاده‌سازی خواهیم کرد: یکی با استفاده از <strong>Business Rule Exceptions</strong> و دیگری با جریان برنامه معمول برای مدیریت شرایط مختلف در برنامه. ✅</p>
<h3>مثال ۱ – مدیریت شرایط با استثناهای قانون کسب‌وکار 🏦💥</h3>
<p>یک کلاس جدید به نام <strong>UsingBusinessRuleExceptions</strong> به پروژه اضافه کنید و متد زیر را در آن بنویسید:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UsingBusinessRuleExceptions</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span>
    {
        ExceedAtmDailyLimit();
        ExceedAvailableBalance();
    }
}
</code></pre>
<p>متد <strong>Run()</strong> دو متد را فراخوانی می‌کند:<br>
1️⃣ <strong>ExceedAtmDailyLimit()</strong>: این متد به صورت عمدی مقدار برداشت روزانه مجاز از ATM را بیش از حد تعیین می‌کند و باعث پرتاب <strong>ExceededAtmDailyLimitException</strong> می‌شود.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExceedAtmDailyLimit</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">var</span> customerAccount = <span class="hljs-keyword">new</span> CurrentAccount(<span class="hljs-number">1</span>);
        customerAccount.Withdraw(<span class="hljs-number">300</span>);
        Console.WriteLine(<span class="hljs-string">&quot;Request accepted. Take cash and card.&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (ExceededAtmDailyLimitException eadlex)
    {
        Console.WriteLine(eadlex.Message);
    }
}
</code></pre>
<p>2️⃣ <strong>ExceedAvailableBalance()</strong>: این متد نیز به صورت عمدی باعث <strong>InsufficientFundsException</strong> می‌شود، زیرا موجودی قابل برداشت کمتر از مقدار درخواست‌شده است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExceedAvailableBalance</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">var</span> customerAccount = <span class="hljs-keyword">new</span> CurrentAccount(<span class="hljs-number">1</span>);
        customerAccount.Withdraw(<span class="hljs-number">180</span>);
        Console.WriteLine(<span class="hljs-string">&quot;Request accepted. Take cash and card.&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (InsufficientFundsException ifex)
    {
        Console.WriteLine(ifex.Message);
    }
}
</code></pre>
<p>با این کار، مشاهده می‌کنیم که چگونه می‌توان شرایط مختلف را با استفاده از <strong>Business Rule Exceptions (BREs)</strong> مدیریت کرد. ✅</p>
<hr>
<h3>مثال ۲ – مدیریت شرایط با جریان برنامه معمول 🏦🟢</h3>
<p>یک کلاس به نام <strong>UsingProgramFlow</strong> ایجاد کنید و کد زیر را در آن قرار دهید:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UsingProgramFlow</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _requestedAmount;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> CurrentAccount _currentAccount;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsingProgramFlow</span>()</span>
    {
        _currentAccount = <span class="hljs-keyword">new</span> CurrentAccount(<span class="hljs-number">1</span>);
    }
}
</code></pre>
<p>در سازنده کلاس، یک <strong>CurrentAccount</strong> ایجاد شده و شناسه مشتری به آن پاس داده می‌شود.</p>
<p>سپس متد <strong>Run()</strong> را اضافه کنید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>()</span>
{
    _requestedAmount = <span class="hljs-number">300</span>;
    Console.WriteLine(<span class="hljs-string">$&quot;Request: Withdraw <span class="hljs-subst">{_requestedAmount}</span>&quot;</span>);
    WithdrawMoney();

    _requestedAmount = <span class="hljs-number">180</span>;
    Console.WriteLine(<span class="hljs-string">$&quot;Request: Withdraw <span class="hljs-subst">{_requestedAmount}</span>&quot;</span>);
    WithdrawMoney();

    _requestedAmount = <span class="hljs-number">20</span>;
    Console.WriteLine(<span class="hljs-string">$&quot;Request: Withdraw <span class="hljs-subst">{_requestedAmount}</span>&quot;</span>);
    WithdrawMoney();
}
</code></pre>
<p>متد <strong>Run()</strong> سه بار مقدار <strong>_requestedAmount</strong> را تعیین می‌کند و هر بار، پیامی در کنسول چاپ می‌شود قبل از فراخوانی متد <strong>WithdrawMoney()</strong>.</p>
<hr>
<h3>بررسی محدودیت‌ها با متدهای Boolean ✅</h3>
<ul>
<li>بررسی حد برداشت روزانه ATM:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ExceedsDailyLimit</span>()</span>
{
    <span class="hljs-keyword">return</span> (_requestedAmount &gt; _currentAccount.AtmDailyLimit)
        || (_requestedAmount + _currentAccount.AtmWithdrawalAmountToday &gt;
            _currentAccount.AtmDailyLimit);
}
</code></pre>
<ul>
<li>بررسی موجودی قابل برداشت:</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ExceedsAvailableBalance</span>()</span>
{
    <span class="hljs-keyword">return</span> _requestedAmount &gt; _currentAccount.AvailableBalance;
}
</code></pre>
<hr>
<h3>متد نهایی WithdrawMoney() 💳</h3>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WithdrawMoney</span>()</span>
{
    <span class="hljs-keyword">if</span> (ExceedsDailyLimit())
        Console.WriteLine(<span class="hljs-string">&quot;Cannot exceed ATM Daily Limit. Request denied.&quot;</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ExceedsAvailableBalance())
        Console.WriteLine(<span class="hljs-string">&quot;Cannot exceed available balance. You have no agreed overdraft facility. Request denied.&quot;</span>);
    <span class="hljs-keyword">else</span>
        Console.WriteLine(<span class="hljs-string">&quot;Request granted. Take card and cash.&quot;</span>);
}
</code></pre>
<p>در این روش، جریان برنامه بدون استفاده از <strong>BREs</strong> مدیریت می‌شود. روش منطقی و خواناتر است، زیرا:</p>
<ul>
<li>اگر مقدار درخواست‌شده بیش از حد برداشت روزانه باشد، درخواست رد می‌شود.</li>
<li>اگر مقدار درخواست‌شده بیش از موجودی قابل برداشت باشد، باز هم رد می‌شود.</li>
<li>در غیر این صورت، تراکنش با موفقیت انجام می‌شود. ✅</li>
</ul>
<hr>
<p>می‌بینید که کنترل جریان برنامه با <strong>منطق موجود</strong> بسیار تمیزتر و درست‌تر است تا اینکه انتظار داشته باشیم <strong>استثناها</strong> پرتاب شوند. استثناها باید تنها برای شرایط <strong>استثنایی و غیرعادی</strong> استفاده شوند.</p>
<p>وقتی استثناها به درستی پرتاب می‌شوند، مهم است که <strong>اطلاعات معنی‌دار</strong> ارائه کنند. پیام‌های خطای مبهم هیچ کمکی نمی‌کنند و می‌توانند استرس غیرضروری برای کاربران یا توسعه‌دهندگان ایجاد کنند. 💡</p>
<p>در بخش بعدی، به نحوه ارائه <strong>اطلاعات مفید و معنی‌دار</strong> در استثناهای پرتاب‌شده خواهیم پرداخت.</p>
<h3>استثناها باید اطلاعات معنی‌دار ارائه کنند ⚠️💡</h3>
<p>خطاهای بحرانی که پیام می‌دهند «هیچ خطایی وجود ندارد» و سپس برنامه را متوقف می‌کنند، اصلاً مفید نیستند. من شخصاً با چنین خطای بحرانی روبرو شده‌ام: خطایی که برنامه را متوقف می‌کند، اما پیام می‌دهد که هیچ خطایی وجود ندارد! 🤯</p>
<p>اگر هیچ خطایی نیست، پس چرا هشدار خطای بحرانی روی صفحه ظاهر شده و چرا نمی‌توانم از برنامه استفاده کنم؟ واضح است که برای پرتاب این استثنا، باید خطای بحرانی واقعی رخ داده باشد، اما <strong>کجا و چرا؟</strong></p>
<p>این نوع استثناها زمانی آزاردهنده‌تر می‌شوند که در <strong>فریمورک یا کتابخانه‌ای</strong> رخ دهند که شما کنترل آن را ندارید و به سورس‌کد آن دسترسی ندارید. چنین استثناهایی باعث می‌شوند برنامه‌نویسان از سر ناامیدی حرف‌های منفی بزنند. یکی از دلایل اصلی ناامیدی این است که <strong>کد خطا داده، اما هیچ اطلاعات مفیدی برای فهم مشکل یا اقدام اصلاحی ارائه نمی‌کند.</strong></p>
<p>استثناها باید اطلاعاتی <strong>کاربرپسند و قابل فهم</strong> ارائه دهند، مخصوصاً برای کسانی که از نظر فنی تجربه کمی دارند. در تجربه من در توسعه نرم‌افزارهای آزمون و ارزیابی دیسکلسی، بسیاری از معلمان و تکنسین‌های IT هنگام مواجهه با پیام‌های استثنا، اغلب گیج می‌شدند.</p>
<p>مثالی که بسیاری از کاربران نرم‌افزار با آن سردرگم شدند:<br>
<strong>Error 76: Path not found</strong> 🗂️❌<br>
این یک استثنای قدیمی مایکروسافت است که از زمان Windows 95 وجود داشته و هنوز هم وجود دارد. پیام خطا برای کاربر نهایی کاملاً بی‌فایده است. برای کاربر مفید خواهد بود که بداند <strong>کدام فایل و مسیر پیدا نشده</strong> و چه اقداماتی برای رفع مشکل انجام دهد.</p>
<p>راه‌حل پیشنهادی:<br>
1️⃣ بررسی وجود مسیر یا فایل<br>
2️⃣ اگر مسیر وجود ندارد یا دسترسی denied است، نمایش دیالوگ save/open فایل<br>
3️⃣ ذخیره مسیر انتخاب‌شده توسط کاربر در یک فایل تنظیمات برای استفاده بعدی<br>
4️⃣ در اجراهای بعدی همان کد، از مسیر انتخاب‌شده توسط کاربر استفاده شود</p>
<p>اگر همچنان پیام خطا را نگه دارید، حداقل نام فایل یا مسیر گمشده را نشان دهید.</p>
<hr>
<h3>ایجاد استثناهای سفارشی 🛠️✨</h3>
<p>فریمورک <strong>Microsoft .NET</strong> تعداد زیادی استثنا دارد که می‌توانید از آن‌ها استفاده کنید، اما گاهی نیاز است یک <strong>استثنای سفارشی</strong> بسازید که اطلاعات دقیق‌تر و کاربرپسندتری ارائه دهد.</p>
<p>برای ایجاد استثنای سفارشی کافی است:</p>
<ul>
<li>نام کلاس با <strong>Exception</strong> ختم شود</li>
<li>از <strong>System.Exception</strong> ارث‌بری کند</li>
<li>سه سازنده داشته باشد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TickerListNotFoundException</span> : <span class="hljs-title">Exception</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TickerListNotFoundException</span>() : <span class="hljs-title">base</span>()</span> { }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TickerListNotFoundException</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)
        : <span class="hljs-title">base</span>(<span class="hljs-params">message</span>)</span> { }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TickerListNotFoundException</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, Exception innerException</span>)
        : <span class="hljs-title">base</span>(<span class="hljs-params">message, innerException</span>)</span> { }
}
</code></pre>
<p><strong>TickerListNotFoundException</strong> از کلاس <strong>System.Exception</strong> ارث‌بری می‌کند و سه سازنده اجباری دارد:<br>
1️⃣ سازنده پیش‌فرض<br>
2️⃣ سازنده‌ای که پیام متنی استثنا را می‌پذیرد<br>
3️⃣ سازنده‌ای که پیام متنی و یک استثنای داخلی (<strong>InnerException</strong>) می‌پذیرد</p>
<hr>
<h3>اجرای سازنده‌های استثنای سفارشی 💻</h3>
<p>در متد <strong>Main</strong> سه متد برای آزمایش سازنده‌ها اجرا می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] <span class="hljs-keyword">args</span></span>)</span>
{
    ThrowCustomExceptionA();
    ThrowCustomExceptionB();
    ThrowCustomExceptionC();
}
</code></pre>
<ul>
<li><strong>ThrowCustomExceptionA()</strong>: استفاده از سازنده پیش‌فرض</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThrowCustomExceptionA</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;throw new TickerListNotFoundException();&quot;</span>);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TickerListNotFoundException();
    }
    <span class="hljs-keyword">catch</span> (Exception tlnfex)
    {
        Console.WriteLine(tlnfex.Message);
    }
}
</code></pre>
<ul>
<li><strong>ThrowCustomExceptionB()</strong>: استفاده از سازنده با پیام متنی</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThrowCustomExceptionB</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;throw new TickerListNotFoundException(Message);&quot;</span>);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TickerListNotFoundException(<span class="hljs-string">&quot;Ticker list not found.&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (Exception tlnfex)
    {
        Console.WriteLine(tlnfex.Message);
    }
}
</code></pre>
<ul>
<li><strong>ThrowCustomExceptionC()</strong>: استفاده از سازنده با پیام متنی و استثنای داخلی</li>
</ul>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThrowCustomExceptionC</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        Console.WriteLine(<span class="hljs-string">&quot;throw new TickerListNotFoundException(Message, InnerException);&quot;</span>);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TickerListNotFoundException(
            <span class="hljs-string">&quot;Ticker list not found for this exchange.&quot;</span>,
            <span class="hljs-keyword">new</span> FileNotFoundException(
                <span class="hljs-string">&quot;Ticker list file not found.&quot;</span>,
                <span class="hljs-string">@&quot;F:\TickerFiles\LSE\AimTickerList.json&quot;</span>
            )
        );
    }
    <span class="hljs-keyword">catch</span> (Exception tlnfex)
    {
        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">{tlnfex.Message}</span>\n<span class="hljs-subst">{tlnfex.InnerException}</span>&quot;</span>);
    }
}
</code></pre>
<p>در این مثال، پیام <strong>معنادار</strong> و استثنای داخلی جزئیات بیشتری درباره فایل پیدا نشده ارائه می‌کند. 📝</p>
<hr>
<h3>نکات بهترین شیوه در مدیریت استثناها در C# ✅</h3>
<ul>
<li>از بلوک‌های <strong>try/catch/finally</strong> برای بازیابی خطا یا آزادسازی منابع استفاده کنید.</li>
<li>شرایط معمول را بدون پرتاب استثنا مدیریت کنید.</li>
<li>کلاس‌ها را طوری طراحی کنید که امکان جلوگیری از استثنا وجود داشته باشد.</li>
<li>به جای بازگرداندن کد خطا، استثنا پرتاب کنید.</li>
<li>از انواع استثنای از پیش تعریف‌شده .NET استفاده کنید.</li>
<li>نام کلاس‌های استثنا با <strong>Exception</strong> خاتمه یابد.</li>
<li>سه سازنده در کلاس‌های استثنای سفارشی درج شود.</li>
<li>داده‌های استثنا در اجرای راه دور نیز قابل دسترسی باشند.</li>
<li>پیام‌های خطا از نظر دستوری صحیح باشند.</li>
<li>پیام‌های محلی‌سازی‌شده در هر استثنا درج شود.</li>
<li>ویژگی‌های اضافی لازم در استثناهای سفارشی ارائه شود.</li>
<li>مکان پرتاب استثنا طوری باشد که <strong>StackTrace</strong> مفید باشد.</li>
<li>از متدهای سازنده استثنا استفاده کنید.</li>
<li>هنگام ناتمام ماندن متدها به دلیل استثنا، وضعیت را بازگردانید.</li>
</ul>
<p>اکنون زمان آن است که خلاصه‌ای از آنچه درباره <strong>مدیریت استثناها</strong> آموخته‌ایم ارائه دهیم.</p>
<h3>خلاصه 📚✨</h3>
<p>در این فصل، شما با <strong>استثناهای چک‌شده (checked exceptions)</strong> و <strong>استثناهای چک‌نشده (unchecked exceptions)</strong> آشنا شدید.</p>
<ul>
<li><strong>Checked exceptions</strong> از ورود شرایط overflow حسابی به کد تولید جلوگیری می‌کنند، زیرا این خطاها در <strong>زمان کامپایل</strong> شناسایی می‌شوند.</li>
<li><strong>Unchecked exceptions</strong> در زمان کامپایل شناسایی نمی‌شوند و ممکن است وارد کد تولید شوند، که می‌تواند باعث ایجاد باگ‌های سخت برای ردیابی و حتی کرش برنامه شود. ⚠️</li>
</ul>
<p>سپس با <strong>NullPointerException</strong> و نحوه اعتبارسنجی پارامترهای ورودی با استفاده از <strong>Attribute</strong> و <strong>Validator</strong> سفارشی آشنا شدید که در بالای متدها قرار می‌گیرند. این روش به شما اجازه می‌دهد بازخورد معنی‌دار ارائه دهید و برنامه‌های مقاوم‌تری بسازید. ✅</p>
<p>بعد از آن، استفاده از <strong>BREs (Business Rule Exceptions)</strong> برای کنترل جریان برنامه بررسی شد. دیدید چگونه جریان برنامه با انتظار خروجی استثنایی کنترل می‌شود و سپس نشان داده شد که با استفاده از <strong>چک‌های شرطی (conditional checks)</strong> می‌توان کنترل بهتری بر جریان برنامه داشت، بدون اینکه نیاز به استفاده از استثناها باشد.</p>
<p>بحث بعدی درباره اهمیت ارائه <strong>پیام‌های استثنایی معنی‌دار</strong> بود و اینکه چگونه می‌توان این کار را با نوشتن <strong>استثناهای سفارشی</strong> انجام داد که از کلاس Exception ارث‌بری کرده و سه سازنده ضروری را پیاده‌سازی می‌کنند.</p>
<p>از طریق مثال‌های ارائه‌شده، یاد گرفتید چگونه از استثناهای سفارشی استفاده کنید و چگونه به <strong>دیباگ بهتر و رفع مشکلات سریع‌تر</strong> کمک می‌کنند. 🛠️</p>
<p>اکنون زمان آن است که آنچه آموخته‌اید را با پاسخ به چند سؤال تمرین کنید. همچنین منابع پیشنهادی برای مطالعه بیشتر ارائه شده است.</p>
<hr>
<h3>سؤالات ❓</h3>
<p>1️⃣ استثنای چک‌شده (checked exception) چیست؟<br>
2️⃣ استثنای چک‌نشده (unchecked exception) چیست؟<br>
3️⃣ استثنای overflow حسابی (arithmetic overflow exception) چیست؟<br>
4️⃣ NullPointerException چیست؟<br>
5️⃣ چگونه می‌توان پارامترهای null را اعتبارسنجی کرد تا کیفیت کد بهبود یابد؟<br>
6️⃣ BRE مخفف چیست؟<br>
7️⃣ آیا استفاده از BREها روش خوبی است یا بد؟ چرا؟<br>
8️⃣ جایگزین BREها چیست، آیا خوب است یا بد؟ چرا؟<br>
9️⃣ چگونه می‌توان پیام‌های استثنایی معنی‌دار ارائه داد؟<br>
🔟 الزامات نوشتن استثناهای سفارشی چیست؟</p>
<hr>
<h3>منابع پیشنهادی برای مطالعه بیشتر 📖</h3>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/exceptions/">Documentation رسمی Microsoft برای مدیریت استثناها در .NET</a></li>
<li><a href="https://reflectoring.io/business-exceptions/">مقاله‌ای درباره دلایل منفی بودن BREها</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions">بهترین شیوه‌های Microsoft برای مدیریت استثناها در C#</a></li>
</ul>
<p>این منابع به شما کمک می‌کنند درک عمیق‌تری از مدیریت استثناها و بهترین شیوه‌ها در C# پیدا کنید.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
