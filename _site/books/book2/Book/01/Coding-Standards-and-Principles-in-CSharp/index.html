

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>استانداردها و اصول کدنویسی</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

       <nav class="nav">
         <a href="/Gitab/" >خانه</a>
         <a href="/Gitab/books/list-books" >کتاب‌ها</a>
        <a href="/Gitab/translator.html" >مترجمین</a>
         <a href="/Gitab/giter.html" >گیتر</a>
       </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل اول:  استانداردها و اصول کدنویسی در سی شارپ 🖥️</h1>
<p>هدف اصلی <strong>استانداردها و اصول کدنویسی در C#</strong> این است که برنامه‌نویسان در حرفه خود پیشرفت کنند و کدی بنویسند که <strong>کارایی بالاتری داشته باشد</strong> و <strong>نگهداری آن آسان‌تر باشد</strong>.</p>
<p>در این فصل، به بررسی نمونه‌هایی از <strong>کدهای خوب</strong> در مقایسه با <strong>کدهای بد</strong> می‌پردازیم. این موضوع ما را به سمت بحث در مورد اینکه <strong>چرا به استانداردهای کدنویسی، اصول و متدولوژی‌ها نیاز داریم</strong>، هدایت می‌کند. سپس به <strong>قراردادهای نام‌گذاری، نوشتن توضیحات (Comments)</strong> و <strong>فرمت‌بندی سورس کد</strong> (شامل کلاس‌ها، متدها و متغیرها) می‌پردازیم.</p>
<p>یک برنامه بزرگ ممکن است <strong>درک و نگهداری آن دشوار</strong> باشد. برای <strong>برنامه‌نویسان تازه‌کار</strong>، شناخت کد و درک عملکرد آن می‌تواند <strong>کاری دلهره‌آور</strong> باشد. همچنین <strong>کار گروهی</strong> روی چنین پروژه‌هایی سخت‌تر می‌شود و از دیدگاه <strong>تست نرم‌افزار</strong> نیز مشکلاتی ایجاد می‌شود.</p>
<p>به همین دلیل، بررسی خواهیم کرد که چگونه با استفاده از <strong>ماژولار بودن (Modularity)</strong> می‌توان برنامه‌ها را به <strong>ماژول‌های کوچک‌تر</strong> تقسیم کرد که همگی با هم کار کنند تا یک <strong>راه‌حل کامل، قابل تست، قابل توسعه توسط تیم‌های مختلف به‌صورت هم‌زمان و به‌راحتی خواندنی و قابل مستندسازی</strong> ارائه دهند.</p>
<p>در پایان فصل، با برخی از <strong>راهنماهای طراحی نرم‌افزار</strong> آشنا می‌شویم، از جمله:<br>
<strong>KISS، YAGNI، DRY، SOLID</strong> و <strong>تیغ اوکام (Occam's Razor)</strong>.</p>
<hr>
<h3>موضوعات تحت پوشش در این فصل:</h3>
<ul>
<li>ضرورت <strong>استانداردهای کدنویسی، اصول و متدولوژی‌ها</strong></li>
<li><strong>قراردادهای نام‌گذاری و روش‌ها</strong></li>
<li><strong>توضیحات و فرمت‌بندی کد</strong></li>
<li><strong>ماژولار بودن</strong></li>
<li><strong>KISS (Keep It Simple, Stupid)</strong></li>
<li><strong>YAGNI (You Aren't Gonna Need It)</strong></li>
<li><strong>DRY (Don't Repeat Yourself)</strong></li>
<li><strong>SOLID (اصول طراحی شی‌گرا)</strong></li>
<li><strong>تیغ اوکام (Occam's Razor)</strong></li>
</ul>
<hr>
<h3>اهداف آموزشی این فصل:</h3>
<ul>
<li>درک اینکه <strong>کد بد چگونه بر پروژه‌ها تأثیر منفی می‌گذارد</strong>.</li>
<li>درک اینکه <strong>کد خوب چه تأثیر مثبتی بر پروژه‌ها دارد</strong>.</li>
<li>درک اینکه <strong>چگونه استانداردهای کدنویسی کیفیت کد را بهبود می‌دهند</strong> و <strong>چگونه می‌توان آن‌ها را اعمال کرد</strong>.</li>
<li>درک اینکه <strong>اصول کدنویسی چگونه کیفیت نرم‌افزار را ارتقا می‌دهند</strong>.</li>
<li>درک اینکه <strong>متدولوژی‌ها چگونه به توسعه کد تمیز کمک می‌کنند</strong>.</li>
<li><strong>پیاده‌سازی استانداردهای کدنویسی</strong>.</li>
<li><strong>انتخاب راه‌حل‌هایی با حداقل فرضیات ممکن</strong>.</li>
<li><strong>کاهش تکرار کد و نوشتن کد بر اساس اصول SOLID</strong>.</li>
</ul>
<h3>الزامات فنی 🔧</h3>
<p>برای کار با کدهای این فصل، باید <strong>Visual Studio 2019 Community Edition یا نسخه‌های بالاتر</strong> را دانلود و نصب کنید. می‌توانید این <strong>IDE</strong> را از لینک زیر دریافت کنید:<br>
<a href="https://visualstudio.microsoft.com/">https://visualstudio.microsoft.com/</a></p>
<p>کدهای این کتاب در لینک زیر قرار دارند:<br>
<a href="https://github.com/PacktPublishing/Clean-Code-in-C-">https://github.com/PacktPublishing/Clean-Code-in-C-</a></p>
<p>تمام کدها در قالب یک <strong>سولوشن (Solution)</strong> قرار داده شده‌اند و هر فصل به‌صورت یک <strong>پوشه در همان سولوشن</strong> است. کدهای مربوط به هر فصل در پوشه همان فصل قرار دارند.</p>
<blockquote>
<p><strong>نکته:</strong> هنگام اجرای یک پروژه، فراموش نکنید که آن را به‌عنوان <strong>Startup Project</strong> تنظیم کنید.</p>
</blockquote>
<hr>
<h3>کد خوب در مقابل کد بد ⚖️</h3>
<p>هر دو نوع <strong>کد خوب</strong> و <strong>کد بد</strong> <strong>کامپایل می‌شوند</strong>؛ این اولین نکته مهم است که باید بدانید. نکته دوم این است که <strong>کد بد به دلیل خاصی بد است</strong> و به همان ترتیب <strong>کد خوب نیز به دلیل خاصی خوب است</strong>.</p>
<p>بیایید در جدول زیر به برخی از این دلایل نگاه کنیم:</p>
<div align="center">
<p><img src="../../../assets/image/01/Table%201-1.png" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>این فهرست مفصل نیست؟ 🤔</h3>
<p>بله، واقعاً فهرست کاملی است، درست است؟ در بخش‌های بعدی، به بررسی این ویژگی‌ها و تفاوت‌های بین <strong>کد خوب</strong> و <strong>کد بد</strong> و تأثیر آن‌ها بر <strong>عملکرد کد شما</strong> می‌پردازیم.</p>
<hr>
<h3>کد بد 🚨</h3>
<p>در ادامه، نگاهی کوتاه به هر یک از <strong>روش‌های بد کدنویسی</strong> که پیش‌تر لیست کردیم می‌اندازیم و توضیح می‌دهیم که هر یک از این روش‌ها چگونه بر کیفیت کد شما تأثیر می‌گذارد.</p>
<hr>
<h4><strong>تورفتگی (Indentation) نامناسب</strong></h4>
<p>تورفتگی نامناسب باعث می‌شود که کد به‌سختی خوانده شود، به‌خصوص زمانی که متدها بزرگ باشند. برای اینکه <strong>کد برای انسان‌ها خوانا باشد</strong>، نیاز به <strong>تورفتگی درست</strong> داریم.</p>
<p>وقتی کد تورفتگی مناسبی ندارد، تشخیص اینکه <strong>کدام بخش کد به کدام بلوک تعلق دارد</strong> بسیار دشوار می‌شود.</p>
<ul>
<li><strong>نکته:</strong> به‌صورت پیش‌فرض، <strong>Visual Studio 2019</strong> هنگام بستن پرانتزها و آکولادها، <strong>کد شما را به‌درستی فرمت و تورفتگی‌دهی می‌کند</strong>. اما گاهی به‌طور عمدی کد را اشتباه فرمت می‌کند تا توجه شما را به یک استثنا یا خطا جلب کند.</li>
<li>اگر از یک <strong>ویرایشگر متنی ساده</strong> استفاده کنید، باید این کار را <strong>دستی</strong> انجام دهید.</li>
</ul>
<p>کدی که به‌طور نادرست تورفتگی دارد، زمان زیادی برای اصلاح می‌گیرد و باعث <strong>هدررفت وقت برنامه‌نویس</strong> می‌شود؛ در حالی که می‌توانست به‌آسانی از این مشکل جلوگیری شود.</p>
<p>مثال زیر را ببینید:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span>
{
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)
{
<span class="hljs-keyword">var</span> productCode = <span class="hljs-string">$&quot;PRC000<span class="hljs-subst">{i}</span>&quot;</span>;
<span class="hljs-comment">//...implementation</span>
}
}
</code></pre>
<p>کد بالا ظاهر چندان خوبی ندارد، اما هنوز خوانا است. با این حال، هر چه تعداد خطوط بیشتر شود، <strong>خواندن و درک آن سخت‌تر</strong> خواهد شد.</p>
<p>همچنین، وقتی تورفتگی درست نباشد، <strong>پیدا کردن آکولاد یا پرانتز بسته نشده</strong> بسیار سخت می‌شود چون به‌راحتی نمی‌توان فهمید <strong>کدام بلوک بسته نشده است</strong>.</p>
<hr>
<h4><strong>کامنت‌هایی که بدیهیات را بیان می‌کنند</strong></h4>
<p>بعضی از برنامه‌نویس‌ها از کامنت‌هایی که بدیهیات را بیان می‌کنند واقعاً <strong>عصبانی می‌شوند</strong> چون آن‌ها را بیهوده یا حتی توهین‌آمیز می‌دانند.</p>
<p>در بحث‌های برنامه‌نویسی که حضور داشته‌ام، بارها شنیده‌ام که برنامه‌نویس‌ها می‌گویند <strong>کامنت‌گذاری را دوست ندارند</strong> و معتقدند که <strong>کد باید خودش گویا باشد</strong>.</p>
<p>من کاملاً این احساس را درک می‌کنم؛ اگر بتوانید <strong>کدی بنویسید که بدون کامنت مثل یک کتاب خوانا باشد</strong>، آن کد واقعاً خوب است.</p>
<p>به‌عنوان مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> _value; <span class="hljs-comment">// This is used for storing integer values.</span>
</code></pre>
<p>در اینجا <strong>نیازی نیست</strong> بنویسید این متغیر برای ذخیره مقادیر عدد صحیح (int) استفاده می‌شود، چون <strong>نوع داده</strong> خودش این موضوع را مشخص کرده است.</p>
<p><strong>چنین کامنت‌هایی فقط وقت و انرژی را هدر می‌دهند و باعث شلوغی بی‌مورد در کد می‌شوند.</strong></p>
<h3>کامنت‌هایی که کد بد را توجیه می‌کنند ⚠️</h3>
<p>ممکن است <strong>زمان محدودی</strong> برای انجام یک کار داشته باشید، اما کامنت‌هایی مانند:</p>
<pre class="hljs"><code><span class="hljs-comment">// I know this code sucks but hey at least it works!</span>
</code></pre>
<p>کاملاً <strong>غیرحرفه‌ای و غیرقابل قبول</strong> هستند. این نوع کامنت‌ها <strong>بی‌توجهی به حرفه‌ای بودن</strong> را نشان می‌دهند و می‌توانند <strong>همکاران برنامه‌نویس را ناراضی کنند</strong>.</p>
<p>اگر واقعاً مجبور هستید چیزی سریع آماده شود، بهتر است یک <strong>تیکت بازآرایی (Refactor Ticket)</strong> ایجاد کنید و آن را در قالب یک کامنت <strong>TODO</strong> اضافه کنید:</p>
<pre class="hljs"><code><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> PBI23154 Refactor Code to meet company coding practices</span>
</code></pre>
<p>سپس شما یا دیگر برنامه‌نویسانی که روی <strong>Technical Debt</strong> کار می‌کنند، می‌توانید این مورد را بررسی و کد را بازآرایی کنید.</p>
<p>مثال دیگر:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = GetDataValue(); <span class="hljs-comment">// This sometimes causes a divide by zero error. Don&#x27;t know why!</span>
</code></pre>
<p>این کامنت واقعاً بد است. ممنون که اطلاع دادید خطا رخ می‌دهد، اما <strong>آیا تیکت باگ ایجاد کرده‌اید؟ آیا تلاش کرده‌اید مشکل را پیدا و اصلاح کنید؟</strong> اگر هیچ‌کس روی آن کد کار نکند، چگونه متوجه وجود <strong>کد مشکل‌دار</strong> خواهند شد؟</p>
<p>حداقل کاری که باید انجام دهید این است که یک کامنت <strong>TODO</strong> اضافه کنید تا در <strong>Task List</strong> ظاهر شود و توسعه‌دهندگان از آن مطلع شده و روی آن کار کنند.</p>
<hr>
<h3>خطوط کد کامنت‌شده ❌</h3>
<p>اگر خطوطی از کد را <strong>برای آزمایش</strong> کامنت می‌کنید، مشکلی ندارد. اما اگر قرار است <strong>کد جایگزین</strong> استفاده شود، قبل از <strong>Check-in</strong>، خطوط کامنت‌شده را <strong>حذف کنید</strong>.</p>
<p>یک یا دو خط کامنت‌شده مشکلی ایجاد نمی‌کند، اما <strong>چندین خط کامنت‌شده</strong> حواس‌پرت‌کننده است و <strong>نگهداری کد را دشوار می‌کند</strong> و حتی می‌تواند باعث <strong>سردرگمی</strong> شود:</p>
<pre class="hljs"><code><span class="hljs-comment">/* No longer used as has been replaced by DoSomethingElse().
public void DoSomething()
{
   // ...implementation...
}
*/</span>
</code></pre>
<p>اگر کد <strong>جایگزین شده و دیگر نیاز نیست، آن را حذف کنید</strong>. اگر از <strong>کنترل نسخه (Version Control)</strong> استفاده می‌کنید و نیاز دارید دوباره به متد دسترسی پیدا کنید، همیشه می‌توانید <strong>تاریخچه فایل</strong> را بررسی کرده و متد را بازیابی کنید.</p>
<hr>
<h3>سازمان‌دهی نادرست <strong>Namespaceها</strong> 📂</h3>
<p>هنگام استفاده از <strong>Namespace</strong>ها، کدهایی را که باید در جای دیگری باشند، اضافه نکنید. این کار یافتن کد درست را <strong>سخت یا غیرممکن</strong> می‌کند، به‌خصوص در کدهای بزرگ.</p>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyProject.TextFileMonitor</span>
{
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> { ... }
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DateTime</span> { ... }
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FileMonitorService</span> { ... }
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cryptography</span> { ... }
}
</code></pre>
<p>در مثال بالا، همه کلاس‌ها در یک <strong>Namespace</strong> قرار دارند، اما می‌توان با افزودن سه <strong>Namespace جدید</strong> کد را بهتر سازمان‌دهی کرد:</p>
<ul>
<li><strong>MyProject.TextFileMonitor.Core:</strong> کلاس‌های اصلی که اعضای پرکاربرد را تعریف می‌کنند، مانند کلاس <code>DateTime</code>.</li>
<li><strong>MyProject.TextFileMonitor.Services:</strong> تمام کلاس‌هایی که نقش <strong>سرویس</strong> دارند، مانند <code>FileMonitorService</code>.</li>
<li><strong>MyProject.TextFileMonitor.Security:</strong> تمام کلاس‌های مربوط به <strong>امنیت</strong>، شامل کلاس <code>Cryptography</code>.</li>
</ul>
<h3>قراردادهای نام‌گذاری نامناسب 🚫</h3>
<p>در گذشته و در دوران <strong>Visual Basic 6</strong>، از <strong>Hungarian Notation</strong> استفاده می‌کردیم. من آن را وقتی به Visual Basic 1.0 مهاجرت کردم، به‌کار بردم. اما امروزه <strong>استفاده از Hungarian Notation ضروری نیست</strong> و حتی باعث می‌شود <strong>کد زشت به نظر برسد</strong>.</p>
<p>به‌جای نام‌هایی مانند:</p>
<pre class="hljs"><code>lblName, txtName, btnSave
</code></pre>
<p>روش مدرن استفاده از نام‌هایی مانند:</p>
<pre class="hljs"><code>NameLabel, NameTextBox, SaveButton
</code></pre>
<p>است.</p>
<ul>
<li>
<p>استفاده از <strong>نام‌های رمزی یا نام‌هایی که با هدف کد همخوانی ندارند</strong>، خواندن کد را دشوار می‌کند.<br>
مثال: <code>ihridx</code> به معنای <strong>Human Resources Index</strong> و نوع داده آن <strong>integer</strong> است!</p>
</li>
<li>
<p>از نام‌هایی مانند <code>mystring</code>, <code>myint</code>, و <code>mymethod</code> اجتناب کنید؛ این نام‌ها واقعاً <strong>هیچ کارایی ندارند</strong>.</p>
</li>
<li>
<p>از <strong>خط فاصله (_) بین کلمات</strong> مانند <code>Bad_Programmer</code> استفاده نکنید. این کار باعث <strong>استرس بصری برای توسعه‌دهندگان</strong> می‌شود و خواندن کد را سخت می‌کند. کافیست <strong>خط فاصله را حذف کنید</strong>.</p>
</li>
<li>
<p>از یک <strong>قرارداد نام‌گذاری یکسان برای متغیرهای سطح کلاس و سطح متد</strong> استفاده نکنید؛ این کار تشخیص <strong>دامنه متغیرها</strong> را دشوار می‌کند.</p>
<ul>
<li><strong>متغیرها:</strong> از <strong>Camel Case</strong> استفاده کنید، مثال: <code>alienSpawn</code></li>
<li><strong>متد، کلاس، Struct و Interface:</strong> از <strong>Pascal Case</strong> استفاده کنید، مثال: <code>EnemySpawnGenerator</code></li>
</ul>
</li>
<li>
<p>برای تمایز بین <strong>متغیرهای محلی</strong> (داخل Constructor یا متد) و <strong>متغیرهای عضو کلاس</strong> (قرار گرفته در بالای کلاس خارج از متدها)، <strong>متغیرهای عضو را با یک underscore (_) پیشوندگذاری کنید</strong>. این روش در محل کار من نیز به‌خوبی جواب داده و توسعه‌دهندگان آن را دوست دارند.</p>
</li>
</ul>
<hr>
<h3>کلاس‌هایی که چند کار انجام می‌دهند ❌</h3>
<p>یک کلاس <strong>باید تنها یک وظیفه داشته باشد</strong>.</p>
<p>کلاسی که هم به <strong>دیتابیس وصل می‌شود، داده می‌گیرد، آن را پردازش می‌کند، گزارش تولید می‌کند، داده‌ها را به گزارش اختصاص می‌دهد، گزارش را نمایش می‌دهد، ذخیره و چاپ می‌کند و خروجی می‌گیرد</strong>، <strong>بیش از حد کار انجام می‌دهد</strong>. این کلاس باید <strong>به کلاس‌های کوچکتر و منظم‌تر تقسیم شود</strong>.</p>
<p>کلاس‌های چندوظیفه‌ای <strong>خواندن را دشوار و دلهره‌آور می‌کنند</strong>. اگر با چنین کلاس‌هایی برخورد کردید:</p>
<ol>
<li>عملکردها را در <strong>Regions</strong> مرتب کنید.</li>
<li>سپس کد داخل آن Regions را به کلاس‌های جدید منتقل کنید که <strong>تنها یک کار انجام دهند</strong>.</li>
</ol>
<p>مثال یک کلاس چندوظیفه‌ای:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DbAndFileManager</span>
{
    <span class="hljs-meta">#<span class="hljs-keyword">region</span> Database Operations</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OpenDatabaseConnection</span>()</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CloseDatabaseConnection</span>()</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">ExecuteSql</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sql</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlDataReader <span class="hljs-title">SelectSql</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sql</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">UpdateSql</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sql</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">DeleteSql</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sql</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">InsertSql</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sql</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span>

    <span class="hljs-meta">#<span class="hljs-keyword">region</span> File Operations</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ReadText</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filename</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filename, <span class="hljs-built_in">string</span> text</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[] <span class="hljs-title">ReadFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filename</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filename, <span class="hljs-built_in">byte</span>[] binaryData</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span>
}
</code></pre>
<ul>
<li>همان‌طور که مشاهده می‌کنید، این کلاس <strong>دو وظیفه اصلی</strong> دارد: عملیات دیتابیس و عملیات فایل.</li>
<li>کد داخل <strong>Regions</strong> مرتب و نامگذاری شده است، اما <strong>اصل Single Responsibility Principle (SRP)</strong> نقض شده است.</li>
</ul>
<hr>
<h3>بازآرایی کلاس‌ها 🔄</h3>
<ol>
<li><strong>کد دیتابیس</strong> را استخراج و به کلاس جداگانه‌ای به نام <code>DatabaseManager</code> منتقل می‌کنیم:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Data.SqlClient;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">CH01_CodingStandardsAndPrinciples.GoodCode.Data</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseManager</span>
    {
        <span class="hljs-meta">#<span class="hljs-keyword">region</span> Database Operations</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OpenDatabaseConnection</span>()</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CloseDatabaseConnection</span>()</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">ExecuteSql</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sql</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-function"><span class="hljs-keyword">public</span> SqlDataReader <span class="hljs-title">SelectSql</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sql</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">UpdateSql</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sql</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">DeleteSql</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sql</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">InsertSql</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> sql</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span>
    }
}
</code></pre>
<ol start="2">
<li><strong>کد فایل سیستم</strong> نیز به کلاس <code>FileManager</code> در Namespace مناسب منتقل می‌شود:</li>
</ol>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">CH01_CodingStandardsAndPrinciples.GoodCode.FileSystem</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FileManager</span>
    {
        <span class="hljs-meta">#<span class="hljs-keyword">region</span> File Operations</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ReadText</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filename</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filename, <span class="hljs-built_in">string</span> text</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[] <span class="hljs-title">ReadFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filename</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> filename, <span class="hljs-built_in">byte</span>[] binaryData</span>)</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); }
        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span>
    }
}
</code></pre>
<p>با این کار، <strong>کلاس‌هایی که بیش از حد کار انجام می‌دهند شناسایی و بازآرایی شدند</strong> تا هر کلاس <strong>تنها یک وظیفه مشخص</strong> داشته باشد.</p>
<hr>
<p>در ادامه، <strong>همین فرآیند را برای متدهایی که چند کار انجام می‌دهند</strong> نیز تکرار خواهیم کرد.</p>
<h3>متدهایی که چند کار انجام می‌دهند ⚠️</h3>
<p>من بارها خودم را در متدهایی با <strong>سطوح متعدد تورفتگی</strong> گم کرده‌ام، جایی که متد چندین کار مختلف را در همان تورفتگی‌ها انجام می‌دهد. ترکیب‌های ممکن واقعاً <strong>سردرگم‌کننده</strong> بودند.</p>
<p>می‌خواستم کد را بازآرایی کنم تا <strong>نگهداری آسان‌تر</strong> شود، اما برنامه‌نویس ارشد مانع شد. به وضوح می‌توانستم ببینم که متد می‌توانست <strong>کوچکتر شود</strong> اگر کد به متدهای مختلف منتقل می‌شد.</p>
<hr>
<h4>مثال</h4>
<p>در این مثال، متد یک <strong>رشته (string)</strong> دریافت می‌کند، سپس آن رشته را <strong>رمزگذاری و رمزگشایی</strong> می‌کند. طول متد زیاد است تا نشان دهد چرا <strong>متدها باید کوتاه باشند</strong>:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">security</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> plainText</span>)</span>
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-built_in">byte</span>[] encrypted;
        <span class="hljs-keyword">using</span> (AesManaged aes = <span class="hljs-keyword">new</span> AesManaged())
        {
            ICryptoTransform encryptor = aes.CreateEncryptor(Key, IV);
            <span class="hljs-keyword">using</span> (MemoryStream ms = <span class="hljs-keyword">new</span> MemoryStream())
                <span class="hljs-keyword">using</span> (CryptoStream cs = <span class="hljs-keyword">new</span> CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                {
                    <span class="hljs-keyword">using</span> (StreamWriter sw = <span class="hljs-keyword">new</span> StreamWriter(cs))
                        sw.Write(plainText);
                    encrypted = ms.ToArray();
                }
        }
        Console.WriteLine(<span class="hljs-string">$&quot;Encrypted data: <span class="hljs-subst">{System.Text.Encoding.UTF8.GetString(encrypted)}</span>&quot;</span>);

        <span class="hljs-keyword">using</span> (AesManaged aesm = <span class="hljs-keyword">new</span> AesManaged())
        {
            ICryptoTransform decryptor = aesm.CreateDecryptor(Key, IV);
            <span class="hljs-keyword">using</span> (MemoryStream ms = <span class="hljs-keyword">new</span> MemoryStream(encrypted))
            {
                <span class="hljs-keyword">using</span> (CryptoStream cs = <span class="hljs-keyword">new</span> CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                {
                    <span class="hljs-keyword">using</span> (StreamReader reader = <span class="hljs-keyword">new</span> StreamReader(cs))
                        plainText = reader.ReadToEnd();
                }
            }
        }
        Console.WriteLine(<span class="hljs-string">$&quot;Decrypted data: <span class="hljs-subst">{plainText}</span>&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (Exception exp)
    {
        Console.WriteLine(exp.Message);
    }
    Console.ReadKey();
    <span class="hljs-keyword">return</span> plainText;
}
</code></pre>
<p>همان‌طور که می‌بینید، این متد <strong>10 خط کد</strong> دارد و <strong>خواندن آن دشوار است</strong>. همچنین <strong>بیش از یک کار انجام می‌دهد</strong>.</p>
<p>این کد می‌تواند به <strong>دو متد جداگانه</strong> تقسیم شود:</p>
<ol>
<li>متدی برای <strong>رمزگذاری رشته</strong></li>
<li>متدی برای <strong>رمزگشایی رشته</strong></li>
</ol>
<p>این مثال نشان می‌دهد <strong>چرا متدها نباید بیش از 10 خط باشند</strong>.</p>
<hr>
<h3>متدهای بیش از 10 خط 📝</h3>
<ul>
<li>متدهای بزرگ <strong>خواندن و درک را دشوار می‌کنند</strong> و می‌توانند باعث <strong>خطاهای سخت‌ پیدا شدن</strong> شوند.</li>
<li>مشکل دیگر این است که ممکن است متد <strong>هدف اصلی خود را از دست بدهد</strong>.</li>
<li>شرایط بدتر زمانی رخ می‌دهد که متدهای بزرگ دارای <strong>قسمت‌های جداشده با کامنت‌ها</strong> و <strong>Regions</strong> باشند.</li>
</ul>
<p>اگر برای خواندن متد نیاز به <strong>اسکرول کردن زیاد</strong> دارید، یعنی متد <strong>خیلی طولانی است</strong> و می‌تواند باعث <strong>استرس برنامه‌نویس و سوءتفاهم</strong> شود، که در نهایت ممکن است <strong>کد یا هدف آن را خراب کند</strong>.</p>
<p><strong>روش مناسب:</strong></p>
<ul>
<li>متدها را تا حد امکان <strong>کوچک نگه دارید</strong>.</li>
<li>با این حال، <strong>حس مشترک</strong> را به‌کار ببرید تا از <strong>کوتاهی بیش از حد متدها</strong> جلوگیری شود.</li>
<li>کلید تعادل مناسب این است که <strong>هدف متد واضح و به‌صورت مختصر پیاده‌سازی شود</strong>.</li>
</ul>
<hr>
<p>کد قبلی نمونه‌ای عالی است که نشان می‌دهد <strong>چرا متدها باید کوچک باشند</strong>.</p>
<ul>
<li>متدهای کوچک <strong>خواندن و درک آسانی</strong> دارند.</li>
<li>معمولاً اگر کد شما <strong>بیش از 10 خط</strong> شود، احتمالاً <strong>بیش از هدف خود کار انجام می‌دهد</strong>.</li>
<li>اطمینان حاصل کنید که <strong>نام متدها هدفشان را بیان کند</strong>، مانند:</li>
</ul>
<pre class="hljs"><code>OpenDatabaseConnection()
CloseDatabaseConnection()
</code></pre>
<p>و متدها <strong>از هدفشان منحرف نشوند</strong>.</p>
<hr>
<p>در ادامه، به بررسی <strong>پارامترهای متدها</strong> می‌پردازیم.</p>
<h3>متدهایی با بیش از دو پارامتر ⚠️</h3>
<p>متدهایی که <strong>پارامترهای زیادی دارند</strong> معمولاً کمی دشوار و دست و پا گیر می‌شوند.</p>
<ul>
<li>علاوه بر سخت بودن خواندن، <strong>به راحتی ممکن است مقداری به پارامتر اشتباه ارسال شود</strong> و <strong>امنیت نوع داده‌ها (type safety)</strong> نقض شود.</li>
<li>تست این متدها <strong>پیچیده‌تر</strong> می‌شود، زیرا <strong>ترکیب‌های بیشتری برای تست وجود دارد</strong> و ممکن است یک سناریو را از دست بدهید که در محیط تولید مشکل ایجاد کند.</li>
</ul>
<hr>
<h3>استفاده از Exception برای کنترل جریان برنامه 🚫</h3>
<p>استفاده از <strong>Exceptionها برای کنترل جریان برنامه</strong> می‌تواند <strong>هدف کد را پنهان کند</strong> و به <strong>نتایج غیرمنتظره</strong> منجر شود.</p>
<p>اگر کد شما برای انتظار یک یا چند Exception برنامه‌ریزی شده است، یعنی <strong>طراحی شما اشتباه است</strong>.</p>
<p>مثالی رایج: <strong>Business Rule Exceptions (BREs)</strong></p>
<ul>
<li>یک متد عملی را انجام می‌دهد و انتظار دارد که Exception پرتاب شود.</li>
<li>جریان برنامه براساس <strong>پر شدن یا نشدن Exception</strong> تعیین می‌شود.</li>
</ul>
<p>مثال استفاده از BRE برای کنترل جریان برنامه:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BreFlowControlExample</span>(<span class="hljs-params">BusinessRuleException bre</span>)</span>
{
    <span class="hljs-keyword">switch</span> (bre.Message)
    {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;OutOfAcceptableRange&quot;</span>:
            DoOutOfAcceptableRangeWork();
            <span class="hljs-keyword">break</span>;
        <span class="hljs-literal">default</span>:
            DoInAcceptableRangeWork();
            <span class="hljs-keyword">break</span>;
    }
}
</code></pre>
<ul>
<li>متد <strong>BusinessRuleException</strong> می‌گیرد.</li>
<li>بسته به پیام داخل Exception، یا متد <code>DoOutOfAcceptableRangeWork()</code> و یا <code>DoInAcceptableRangeWork()</code> فراخوانی می‌شود.</li>
</ul>
<hr>
<h3>کنترل جریان با منطق Boolean ✅</h3>
<p>یک روش بهتر استفاده از <strong>Boolean</strong> برای کنترل جریان است. مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BetterFlowControlExample</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isInAcceptableRange</span>)</span>
{
    <span class="hljs-keyword">if</span> (isInAcceptableRange)
        DoInAcceptableRangeWork();
    <span class="hljs-keyword">else</span>
        DoOutOfAcceptableRangeWork();
}
</code></pre>
<ul>
<li>
<p>در این متد، <strong>یک مقدار Boolean</strong> به آن ارسال می‌شود.</p>
</li>
<li>
<p>این مقدار تعیین می‌کند <strong>کدام مسیر اجرا شود</strong>:</p>
<ul>
<li>اگر شرط در محدوده قابل قبول باشد، <code>DoInAcceptableRangeWork()</code> فراخوانی می‌شود.</li>
<li>در غیر این صورت، <code>DoOutOfAcceptableRangeWork()</code> اجرا می‌شود.</li>
</ul>
</li>
</ul>
<hr>
<h3>کدی که سخت خوانده می‌شود 📜</h3>
<p>کدهایی مانند <strong>Lasagna</strong> و <strong>Spaghetti</strong> واقعاً <strong>خواندن و دنبال کردن آن‌ها دشوار است</strong>.</p>
<ul>
<li><strong>متدهای با نام نامناسب</strong> نیز می‌توانند هدف متد را پنهان کنند.</li>
<li>اگر متدها <strong>بزرگ</strong> باشند و متدهای مرتبط با آن‌ها توسط <strong>متدهای نامرتبط جدا شوند</strong>، فهم کد دشوارتر می‌شود.</li>
</ul>
<h4>Lasagna code 🥘</h4>
<ul>
<li>به آن <strong>Indirection</strong> هم گفته می‌شود و به معنی <strong>لایه‌های انتزاعی</strong> است، جایی که چیزی <strong>با نام به جای عمل</strong> اشاره می‌شود.</li>
<li>این لایه‌بندی در <strong>Object-Oriented Programming (OOP)</strong> زیاد استفاده می‌شود و مؤثر است.</li>
<li>اما هر چه <strong>indirection بیشتر شود، کد پیچیده‌تر و فهم آن برای برنامه‌نویسان جدید دشوارتر</strong> می‌شود.</li>
<li>باید <strong>تعادل بین لایه‌بندی و سهولت درک کد</strong> برقرار شود.</li>
</ul>
<h4>Spaghetti code 🍝</h4>
<ul>
<li>به معنی <strong>کد درهم و به هم پیچیده با اتصال زیاد و چسبندگی کم</strong> است.</li>
<li>چنین کدی <strong>نگهداری، بازآرایی، گسترش و طراحی مجدد را دشوار</strong> می‌کند.</li>
<li>مزیت آن این است که <strong>خواندن آن نسبتاً آسان است</strong> زیرا برنامه به روش رویه‌ای نوشته شده است.</li>
</ul>
<p>مثال شخصی:</p>
<ul>
<li>من به عنوان یک برنامه‌نویس تازه‌کار، روی یک برنامه GIS در <strong>VB6</strong> کار می‌کردم که به شرکت‌ها فروخته می‌شد.</li>
<li>کد بسیار <strong>پیچیده و بزرگ</strong> بود و گروه قبلی تلاش کرده بودند آن را بازطراحی کنند و موفق نشده بودند.</li>
<li>درس من: هنگام بازطراحی نرم‌افزار، <strong>به هیچ عنوان کد موجود را نگاه نکنید</strong>.</li>
</ul>
<p><strong>روش درست:</strong></p>
<ol>
<li>همه کارهایی که برنامه انجام می‌دهد را <strong>روی کاغذ بنویسید</strong>.</li>
<li>ویژگی‌ها را <strong>گروه‌بندی کنید</strong>.</li>
<li>یک لیست از <strong>نیازمندی‌ها، وظایف، تست‌ها و معیارهای پذیرش</strong> بسازید.</li>
<li>سپس برنامه را <strong>براساس مشخصات نوشته شده</strong> پیاده‌سازی کنید.</li>
</ol>
<hr>
<h3>کدی که به شدت به هم وابسته است 🔗</h3>
<p>کدی که <strong>تنگاتنگ به هم وابسته</strong> است:</p>
<ul>
<li><strong>تست کردن آن دشوار است</strong>،</li>
<li><strong>گسترش یا تغییر آن سخت است</strong>،</li>
<li>و <strong>استفاده مجدد از کدی که به بخش‌های دیگر وابسته است، دشوار</strong> می‌شود.</li>
</ul>
<p>مثال <strong>tight coupling</strong>:</p>
<ul>
<li>وقتی در پارامتر یک کلاس <strong>Concrete</strong> را مستقیماً ارجاع می‌دهید به جای ارجاع به یک <strong>Interface</strong>.</li>
<li>تغییرات در کلاس Concrete، کلاس ارجاع‌دهنده را مستقیم تحت تأثیر قرار می‌دهد.</li>
</ul>
<p>مثال عملی:</p>
<ul>
<li>یک کلاس اتصال به دیتابیس برای مشتری‌ای که از <strong>SQL Server</strong> استفاده می‌کند، دارید.</li>
<li>اگر مشتری جدید بخواهد از <strong>Oracle</strong> استفاده کند، کلاس Concrete باید برای آن مشتری خاص تغییر کند.</li>
<li>در نتیجه، دو نسخه از کد ایجاد می‌شود و هر چه تعداد مشتریان بیشتر شود، نگهداری کد تقریباً غیرممکن و بسیار پرهزینه می‌شود.</li>
</ul>
<p>راه‌حل:</p>
<ul>
<li>به جای ارجاع مستقیم به کلاس Concrete، از <strong>Interface</strong> استفاده کنید و یک <strong>Database Factory</strong> بسازید که Object اتصال مورد نیاز را تولید کند.</li>
<li>رشته اتصال (<strong>Connection String</strong>) توسط مشتری در فایل پیکربندی تنظیم شده و به Factory داده می‌شود.</li>
<li>Factory کلاس Concrete مناسب را تولید می‌کند که Interface اتصال به دیتابیس را پیاده‌سازی می‌کند.</li>
</ul>
<p>مثال بد از کد tightly coupled:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Database</span>
{
    <span class="hljs-keyword">private</span> SqlServerConnection _databaseConnection;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Database</span>(<span class="hljs-params">SqlServerConnection databaseConnection</span>)</span>
    {
        _databaseConnection = databaseConnection;
    }
}
</code></pre>
<ul>
<li>همان‌طور که می‌بینید، کلاس Database <strong>مستقیماً وابسته به SQL Server</strong> است و برای استفاده از هر نوع دیتابیس دیگری نیاز به تغییر سخت‌کد دارد.</li>
<li>در فصل‌های بعدی <strong>Refactoring</strong> کد با مثال‌های عملی پوشش داده خواهد شد.</li>
</ul>
<hr>
<h3>چسبندگی کم (Low Cohesion) 🧩</h3>
<ul>
<li>Low cohesion شامل <strong>کدی نامرتبط است که وظایف مختلف را با هم انجام می‌دهد</strong>.</li>
<li>مثال: یک کلاس Utility که متدهای متفاوتی برای کار با <strong>تاریخ، متن، اعداد، ورودی/خروجی فایل، اعتبارسنجی داده و رمزگذاری/رمزگشایی</strong> دارد.</li>
</ul>
<hr>
<h3>اشیایی که در حافظه باقی می‌مانند 🕸️</h3>
<ul>
<li>اشیایی که در حافظه باقی می‌مانند می‌توانند <strong>Memory Leak</strong> ایجاد کنند.</li>
</ul>
<h4>دلایل رایج:</h4>
<ol>
<li>
<p><strong>Static variables</strong></p>
<ul>
<li>متغیرهای استاتیک که به اشیایی ارجاع می‌دهند، توسط <strong>Garbage Collector</strong> جمع‌آوری نمی‌شوند.</li>
<li>هر چیزی که <strong>GC Root</strong> باشد، توسط جمع‌آورنده زباله علامت‌گذاری می‌شود که جمع‌آوری نشود.</li>
</ul>
</li>
<li>
<p><strong>Anonymous methods</strong></p>
<ul>
<li>وقتی یک متد ناشناس، اعضای کلاس را Capture می‌کند، <strong>Instance کلاس زنده می‌ماند</strong> تا متد ناشناس وجود دارد.</li>
</ul>
</li>
<li>
<p><strong>کد unmanaged (COM)</strong></p>
<ul>
<li>اگر اشیای managed و unmanaged آزاد نشوند و حافظه به طور صریح آزاد نشود، <strong>Memory Leak</strong> ایجاد می‌شود.</li>
</ul>
</li>
<li>
<p><strong>Cache بدون محدودیت</strong></p>
<ul>
<li>کدی که <strong>Cache را بدون weak references یا حذف موارد استفاده نشده ذخیره می‌کند</strong>، نهایتاً باعث اتمام حافظه می‌شود.</li>
</ul>
</li>
<li>
<p><strong>Threadهای بدون پایان</strong></p>
<ul>
<li>اگر ارجاعات به اشیاء در <strong>Thread</strong>ی ایجاد شود که هرگز پایان نمی‌یابد، حافظه هدر می‌رود.</li>
</ul>
</li>
<li>
<p><strong>Event subscriptions غیر ناشناس</strong></p>
<ul>
<li>وقتی Eventها هنوز به کلاس‌ها متصل هستند، اشیاء در حافظه باقی می‌مانند.</li>
<li><strong>لغو ثبت (unsubscribe)</strong> ضروری است تا <strong>Memory Leak</strong> رخ ندهد.</li>
</ul>
</li>
</ol>
<hr>
<h3>استفاده از متد <code>Finalize()</code> ⚰️</h3>
<ul>
<li>
<p><strong>Finalizers</strong> می‌توانند منابعی که توسط اشیاء به درستی آزاد نشده‌اند را آزاد کنند و از <strong>Memory Leak</strong> جلوگیری کنند.</p>
</li>
<li>
<p>اما چند مشکل دارند:</p>
<ol>
<li>
<p><strong>زمان اجرای آن‌ها مشخص نیست.</strong></p>
<ul>
<li>Garbage Collector آن‌ها را همراه با تمام وابستگانشان به نسل بعدی ارتقا می‌دهد و تا زمانی که GC تصمیم بگیرد، جمع‌آوری نمی‌شوند.</li>
<li>این ممکن است باعث شود اشیاء برای مدت طولانی در حافظه باقی بمانند.</li>
</ul>
</li>
<li>
<p>استفاده از finalizers می‌تواند باعث <strong>Out-of-Memory Exception</strong> شود، مخصوصاً اگر اشیاء سریع‌تر از سرعت Garbage Collection ساخته شوند.</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3>Over-engineering 🏗️</h3>
<ul>
<li><strong>Over-engineering</strong> می‌تواند یک کابوس واقعی باشد.</li>
<li>دلیل اصلی: وقتی شما یک سیستم بزرگ را می‌بینید و سعی می‌کنید آن را درک کنید، بفهمید چه چیزی کجا قرار می‌گیرد و چگونه از آن استفاده کنید، فرآیندی زمان‌بر و گیج‌کننده است.</li>
<li>این موضوع وقتی شدیدتر می‌شود که <strong>مستندات وجود ندارد</strong>، شما تازه وارد سیستم شده‌اید و حتی افرادی که مدت طولانی‌تری از سیستم استفاده کرده‌اند، نمی‌توانند به سوالات شما پاسخ دهند.</li>
<li>می‌تواند باعث <strong>استرس زیاد</strong> شود، به خصوص وقتی برای کار روی پروژه <strong>مهلت مشخصی</strong> دارید.</li>
</ul>
<hr>
<h3>یادگیری اصل KISS 🧩</h3>
<ul>
<li>
<p>مثالی از تجربه شخصی:</p>
<ul>
<li>مجبور بودم <strong>تست یک وب اپلیکیشن</strong> را بنویسم که JSON را از یک سرویس می‌گیرد، اجازه می‌دهد کودک تستی انجام دهد و سپس نمره را به سرویس دیگری ارسال می‌کند.</li>
<li>به جای استفاده از <strong>OOP، SOLID یا DRY</strong> طبق سیاست شرکت، از <strong>KISS و برنامه‌نویسی رویه‌ای با Events</strong> استفاده کردم و کار را در زمان بسیار کوتاهی انجام دادم.</li>
<li>به دلیل این کار <strong>مجازات شدم</strong> و مجبور شدم با استفاده از سیستم تست داخلی شرکت دوباره بازنویسی کنم.</li>
</ul>
</li>
<li>
<p>توضیح:</p>
<ul>
<li>نسخه اول من نیازهای کسب‌وکار را برآورده می‌کرد و مستقل بود.</li>
<li>نسخه دوم مطابق با نیازهای فنی تیم توسعه بود و زمان ساخت آن <strong>هفته‌ها طول کشید</strong>، چون اجازه تغییر آن را نداشتم.</li>
<li>هر پروژه‌ای که از <strong>مهلت مقرر فراتر رود، هزینه بیشتری برای کسب‌وکار ایجاد می‌کند</strong>.</li>
<li>نکته مهم: نسخه اول ساده‌تر و راحت‌تر برای درک بود، در حالی که نسخه بازنویسی شده پیچیده‌تر شد.</li>
</ul>
</li>
</ul>
<p>💡 <strong>نتیجه‌گیری:</strong> همیشه لازم نیست که <strong>OOP، SOLID و DRY</strong> را به‌صورت سختگیرانه دنبال کنید. گاهی ساده بودن و استفاده از KISS بهترین راه است. در نهایت، حتی زیباترین سیستم OOP در پشت صحنه به <strong>کد رویه‌ای (Procedural)</strong> تبدیل می‌شود که کامپیوتر راحت‌تر می‌فهمد!</p>
<hr>
<h3>نبود Region در کلاس‌های بزرگ 📚</h3>
<ul>
<li>کلاس‌های بزرگ با <strong>Regionهای زیاد</strong> سخت خوانده می‌شوند، مخصوصاً وقتی <strong>متدهای مرتبط کنار هم قرار نگرفته‌اند</strong>.</li>
<li>Region برای گروه‌بندی اعضای مشابه در یک کلاس بزرگ بسیار مفید است.</li>
<li>اما اگر از آن‌ها استفاده نکنید، فایده‌ای ندارد!</li>
</ul>
<h3>کد با <strong>هدف گمشده (Lost-intention code)</strong> ❌</h3>
<ul>
<li>وقتی یک کلاس چندین کار مختلف انجام می‌دهد، <strong>چطور می‌توان فهمید هدف اصلی آن چیست؟</strong></li>
<li>مثال: اگر دنبال یک متد تاریخ هستید و آن را در کلاس فایل در فضای نام <strong>I/O</strong> پیدا می‌کنید، آیا آنجا جای درستش است؟ خیر.</li>
<li>این کار برای سایر توسعه‌دهندگان که با کد شما آشنا نیستند، <strong>سختی پیدا کردن متدها</strong> را ایجاد می‌کند.</li>
</ul>
<p>مثال کد بد:</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span>
    {
        <span class="hljs-comment">// ...implementation...</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> DateTime <span class="hljs-title">AddDates</span>(<span class="hljs-params">DateTime date1, DateTime date2</span>)</span>
    {
        <span class="hljs-comment">//...implementation...</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">GetData</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span>
    {
        <span class="hljs-comment">//...implementation...</span>
    }
}
</code></pre>
<p>مشکلات:</p>
<ol>
<li>
<p>نام کلاس چیزی نمی‌گوید و <strong>هدف کلاس مشخص نیست</strong>.</p>
</li>
<li>
<p>متد <code>MyMethod</code> مشخص نیست چه کاری انجام می‌دهد.</p>
</li>
<li>
<p>کلاس هم تاریخ‌ها را مدیریت می‌کند و هم داده‌های محصول را دریافت می‌کند – <strong>عدم رعایت اصل تک مسئولیتی (SRP)</strong>.</p>
<ul>
<li><code>AddDates</code> باید در کلاس مدیریت تاریخ باشد.</li>
<li><code>GetData</code> باید در ViewModel مربوط به محصول باشد.</li>
</ul>
</li>
</ol>
<hr>
<h3>افشای مستقیم اطلاعات (Directly exposing information) ⚠️</h3>
<ul>
<li>کلاس‌هایی که اطلاعات را به صورت مستقیم در معرض می‌گذارند، <strong>کد را به شدت به هم وابسته می‌کنند</strong> و احتمال بروز خطا را بالا می‌برند.</li>
<li>اگر بخواهید نوع داده‌ای را تغییر دهید، مجبورید آن را در همه جا تغییر دهید.</li>
<li>مثال بد:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Product</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Name;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Description;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> ProductCode;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Price;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> UnitsInStock;
}
</code></pre>
<p>مشکلات:</p>
<ol>
<li>تغییر نوع <code>UnitsInStock</code> از <code>long</code> به <code>int</code> نیازمند تغییر در همه جا است.</li>
<li>اگر بخواهید قوانین اعتبارسنجی برای <code>ProductCode</code> اضافه کنید، نمی‌توانید چون مقدار مستقیماً توسط کلاس فراخوانده شده تغییر می‌کند.</li>
</ol>
<hr>
<h3>کد خوب (Good Code) ✅</h3>
<h4><strong>Indentation مناسب (Proper indentation)</strong></h4>
<ul>
<li><strong>Indentation مناسب باعث می‌شود کد راحت‌تر خوانده شود</strong>.</li>
<li>با توجه به تورفتگی‌ها مشخص است که بلوک‌ها کجا شروع و تمام می‌شوند.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span>
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)
    {
        <span class="hljs-keyword">var</span> productCode = <span class="hljs-string">$&quot;PRC000<span class="hljs-subst">{i}</span>&quot;</span>;
        <span class="hljs-comment">//...implementation</span>
    }
}
</code></pre>
<ul>
<li>در این مثال ساده، کد <strong>خوانا و مرتب</strong> است و شروع و پایان هر بلوک مشخص است.</li>
<li>رعایت تورفتگی صحیح باعث کاهش اشتباهات و افزایش <strong>خوانایی و نگهداری آسان‌تر</strong> کد می‌شود.</li>
</ul>
<h3>کامنت‌های معنادار (Meaningful Comments) 📝</h3>
<ul>
<li>کامنت‌های معنادار <strong>هدف برنامه‌نویس را بیان می‌کنند</strong>.</li>
<li>چنین کامنت‌هایی زمانی مفید هستند که کد درست است اما ممکن است برای برنامه‌نویس جدید یا حتی همان برنامه‌نویس بعد از چند هفته <strong>به سختی قابل فهم باشد</strong>.</li>
<li>این کامنت‌ها به فهم سریع‌تر و کاهش اشتباهات کمک می‌کنند.</li>
</ul>
<hr>
<h3>کامنت‌های مستندسازی API (API Documentation Comments) 📄</h3>
<ul>
<li>یک API خوب، <strong>مستندسازی واضح و قابل پیگیری</strong> دارد.</li>
<li>کامنت‌های XML می‌توانند برای <strong>تولید مستندات HTML</strong> استفاده شوند.</li>
<li>مستندات خوب باعث می‌شود <strong>توسعه‌دهندگان بیشتری از API شما استفاده کنند</strong>.</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Create a new <span class="hljs-doctag">&lt;see cref=&quot;KustoCode&quot;/&gt;</span> instance from the text and globals.</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Does not perform semantic analysis.</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;text&quot;&gt;</span>The code text<span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;globals&quot;&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span>   The globals to use for parsing and semantic analysis. </span>
<span class="hljs-comment"><span class="hljs-doctag">///</span>   Defaults to <span class="hljs-doctag">&lt;see cref=&quot;GlobalState.Default&quot;/&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/param&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> KustoCode <span class="hljs-title">Parse</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text, GlobalState globals = <span class="hljs-literal">null</span></span>)</span> {
    <span class="hljs-comment">// ...implementation...</span>
}
</code></pre>
<ul>
<li>این مثال از پروژه <strong>Kusto Query Language</strong>، نمونه‌ای عالی از کامنت مستندسازی API است.</li>
</ul>
<hr>
<h3>سازماندهی مناسب با استفاده از Namespaceها 📂</h3>
<ul>
<li>
<p><strong>کد مرتب و قرار گرفته در Namespaceهای مناسب</strong> باعث صرفه‌جویی زمان توسعه‌دهندگان می‌شود.</p>
</li>
<li>
<p>مثال: اگر دنبال کلاس‌ها و متدهای مرتبط با تاریخ و زمان هستید:</p>
<ul>
<li>Namespace: <code>DateTime</code></li>
<li>کلاس: <code>Time</code> → متدهای مرتبط با زمان</li>
<li>کلاس: <code>Date</code> → متدهای مرتبط با تاریخ</li>
</ul>
</li>
<li>
<p>این روش کمک می‌کند تا <strong>کد قابل فهم، قابل نگهداری و سریع‌تر پیدا شود</strong>.</p>
</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/01/Table%201-2.png" alt="Conventions-UsedThis-Book"></p>
</div>
<h3>قوانین نام‌گذاری خوب (Good Naming Conventions) ✨</h3>
<ul>
<li><strong>رعایت قراردادهای نام‌گذاری مایکروسافت برای C# توصیه می‌شود.</strong></li>
<li><strong>PascalCase</strong> برای: Namespaceها، کلاس‌ها، اینترفیس‌ها، Enumها، و متدها</li>
<li><strong>camelCase</strong> برای: نام متغیرها و آرگومان‌ها</li>
<li>پیشوند <strong>_</strong> برای متغیرهای عضو کلاس</li>
</ul>
<p>مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Text.RegularExpressions;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">CompanyName.ProductName.RegEx</span>
{
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> An extension class for providing regular expression extensions methods.</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RegularExpressions</span>
    {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> _preprocessed;
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> RegularExpression { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsValidEmail</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> email</span>)</span>
        {
            <span class="hljs-comment">// Email address: RFC 2822 Format.</span>
            <span class="hljs-comment">// Matches a normal email address. Does not check the top-level domain.</span>
            <span class="hljs-comment">// Requires the &quot;case insensitive&quot; option to be ON.</span>
            <span class="hljs-keyword">var</span> exp = <span class="hljs-string">@&quot;\A(?:[a-z0-9!#$%&amp;&#x27;*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;&#x27;*+/=?^_`{|}~-]+)@(?:[a-z0-9](?:[a-z0-9-][a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?)\Z&quot;</span>;
            <span class="hljs-built_in">bool</span> isEmail = Regex.IsMatch(email, exp, RegexOptions.IgnoreCase);
            <span class="hljs-keyword">return</span> isEmail;
        }
    }
}
</code></pre>
<ul>
<li>این مثال نشان‌دهنده <strong>نام‌گذاری مناسب برای Namespace، کلاس‌ها، متغیرهای عضو، پارامترها و متغیرهای محلی</strong> است.</li>
</ul>
<hr>
<h3>کلاس‌ها و متدهای تک‌وظیفه‌ای 🎯</h3>
<ul>
<li><strong>کلاس خوب:</strong> فقط یک کار انجام می‌دهد و هدف آن واضح است.</li>
<li><strong>متد خوب:</strong> فقط یک کار انجام می‌دهد، مثال: نه رمزنگاری و جایگزینی رشته همزمان.</li>
<li>متدهای تک‌وظیفه‌ای معمولاً <strong>کوتاه، قابل خواندن و هدفمند</strong> هستند.</li>
</ul>
<hr>
<h3>طول متدها و تعداد پارامترها 📏</h3>
<ul>
<li><strong>متدها:</strong> بهتر است کمتر از 10 خط و ترجیحاً زیر 4 خط باشند.</li>
<li><strong>پارامترها:</strong> ایده‌آل بدون پارامتر، ولی 1 یا 2 پارامتر قابل قبول است.</li>
<li>اگر بیش از دو پارامتر نیاز است، بهتر است یک <strong>شیء</strong> پاس داده شود تا کد <strong>خوانا و قابل پیگیری</strong> باشد.</li>
</ul>
<h3>استفاده صحیح از Exceptionها ⚠️</h3>
<ul>
<li>
<p><strong>از Exception برای کنترل جریان برنامه استفاده نکنید.</strong></p>
</li>
<li>
<p>شرایط معمول که ممکن است Exception ایجاد کنند، باید به گونه‌ای مدیریت شوند که Exception رخ ندهد.</p>
</li>
<li>
<p>برای بازیابی یا آزادسازی منابع، از <strong>try/catch/finally</strong> استفاده کنید.</p>
</li>
<li>
<p>هنگام گرفتن Exception، از نوع خاص آن Exception استفاده کنید تا اطلاعات دقیق‌تری برای لاگ یا مدیریت خطا داشته باشید.</p>
</li>
<li>
<p>در مواقعی که نمی‌توان از Exceptionهای پیش‌فرض .NET استفاده کرد، <strong>Exception سفارشی</strong> بسازید:</p>
<ul>
<li>
<p>پسوند کلاس Exception با <code>Exception</code> ختم شود.</p>
</li>
<li>
<p>سه سازنده داشته باشد:</p>
<ol>
<li><code>Exception()</code> – استفاده از مقادیر پیش‌فرض</li>
<li><code>Exception(string)</code> – دریافت پیام</li>
<li><code>Exception(string, Exception)</code> – دریافت پیام و Inner Exception</li>
</ol>
</li>
</ul>
</li>
<li>
<p>اگر لازم است Exception پرتاب شود، <strong>کدهای خطا برنگردانید</strong>، بلکه Exception با اطلاعات معنی‌دار بازگردانید.</p>
</li>
</ul>
<hr>
<h3>کد قابل خواندن 📝</h3>
<ul>
<li>
<p>هر چه کد قابل خواندن‌تر باشد، کار توسعه‌دهندگان راحت‌تر است.</p>
</li>
<li>
<p>کد خوانا:</p>
<ul>
<li>یادگیری و توسعه را آسان می‌کند</li>
<li>نگهداری توسط افراد جدید ساده‌تر است</li>
<li>احتمال خطا و ناامن بودن کد کمتر است</li>
</ul>
</li>
</ul>
<hr>
<h3>کد کم‌وابسته (Loosely Coupled) 🔗</h3>
<ul>
<li>کد کم‌وابسته راحت‌تر تست، بازسازی و استفاده مجدد می‌شود.</li>
<li>مثال اصلاح شده از کلاس Database با Interface:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Database</span>
{
    <span class="hljs-keyword">private</span> IDatabaseConnection _databaseConnection;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Database</span>(<span class="hljs-params">IDatabaseConnection databaseConnection</span>)</span>
    {
        _databaseConnection = databaseConnection;
    }
}
</code></pre>
<ul>
<li>مزیت: فقط کلاس‌های مربوط به یک نوع پایگاه داده تحت تاثیر تغییرات قرار می‌گیرند و هزینه نگهداری کاهش می‌یابد.</li>
</ul>
<hr>
<h3>انسجام بالا (High Cohesion) 🎯</h3>
<ul>
<li>عملکردهای مرتبط باید در یک مکان گروه‌بندی شوند.</li>
<li>مثال: <code>System.Diagnostics</code> فقط شامل کدهای مربوط به تشخیص خطا است، و نه Collections یا FileSystem.</li>
</ul>
<hr>
<h3>آزادسازی تمیز منابع (Clean Disposal) 🧹</h3>
<ul>
<li>کلاس‌های disposable باید همیشه با <code>Dispose()</code> منابع خود را آزاد کنند.</li>
<li>استفاده از <strong>using statement</strong> بهترین روش است، چون پس از خروج از بلوک، شیء به‌صورت خودکار Dispose می‌شود:</li>
</ul>
<pre class="hljs"><code><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> unitOfWork = <span class="hljs-keyword">new</span> UnitOfWork())
{
    <span class="hljs-comment">// Perform unit of work here.</span>
}
<span class="hljs-comment">// unitOfWork به‌صورت خودکار Dispose شده است</span>
</code></pre>
<ul>
<li>نیازی به فراخوانی دستی <code>Dispose()</code> نیست؛ <code>using</code> این کار را خودکار انجام می‌دهد.</li>
</ul>
<h3>اجتناب از استفاده از Finalize() ☢️</h3>
<ul>
<li>هنگام کار با منابع unmanaged، بهتر است <strong>اینترفیس IDisposable را پیاده‌سازی کنید</strong> و از <code>Finalize()</code> استفاده نکنید.</li>
<li><strong>Finalize() تضمینی برای زمان اجرا ندارد</strong> و ممکن است به ترتیب یا زمان مورد انتظار اجرا نشود.</li>
<li>بهتر و قابل اعتمادتر است که منابع unmanaged را در متد <code>Dispose()</code> آزاد کنید.</li>
</ul>
<hr>
<h3>سطح مناسب انتزاع (Abstraction) 🎛️</h3>
<ul>
<li>سطح مناسب انتزاع زمانی است که تنها بخش‌هایی که نیاز به نمایش دارند، برای لایه بالاتر افشا شوند و جزئیات پیاده‌سازی گم نشوند.</li>
<li>اگر در جزئیات پیاده‌سازی گم می‌شوید → <strong>Over-abstracted</strong></li>
<li>اگر چند نفر باید همزمان روی یک کلاس کار کنند → <strong>Under-abstracted</strong></li>
<li>در هر دو حالت، <strong>بازسازی (Refactoring)</strong> لازم است تا سطح انتزاع درست شود.</li>
</ul>
<hr>
<h3>استفاده از Regions در کلاس‌های بزرگ 📂</h3>
<ul>
<li>Regions برای گروه‌بندی اعضا و متدها در کلاس‌های بزرگ بسیار مفید هستند و می‌توان آن‌ها را Collapse/Expand کرد.</li>
<li>مزیت: خواندن کلاس‌های بزرگ ساده‌تر می‌شود و نیازی به پرش مداوم بین متدها نیست.</li>
<li>روش پیشنهادی: متدهایی که با هم مرتبط هستند را در یک Region قرار دهید تا هنگام کار با کد، راحت بتوانید آن‌ها را باز و بسته کنید.</li>
</ul>
<hr>
<h3>ضرورت استانداردها، اصول و متدولوژی‌ها 🏗️</h3>
<ul>
<li>
<p>اکثر نرم‌افزارهای امروز توسط تیم‌های چند نفره توسعه داده می‌شوند.</p>
</li>
<li>
<p>هر برنامه‌نویس سبک و ایدئولوژی خاص خود را دارد، اما <strong>رعایت استانداردها و اصول مشترک، کار تیمی را ساده می‌کند</strong>.</p>
</li>
<li>
<p><strong>Coding standards</strong>: قوانین «باید» و «نباید» که باید رعایت شوند.</p>
<ul>
<li>ابزارهایی مثل FxCop یا بررسی دستی توسط هم‌تیمی‌ها قابل اجرا هستند.</li>
<li>در عمل، وقتی فشار زمان‌بندی زیاد است، ممکن است استانداردها کنار گذاشته شوند و مشکلات بعداً به عنوان <strong>Technical Debt</strong> در لیست باگ‌ها اصلاح شوند.</li>
</ul>
</li>
<li>
<p><strong>مزیت رعایت استانداردها</strong>:</p>
<ul>
<li>کد یکپارچه و خوانا</li>
<li>راحتی در گسترش و نگهداری</li>
<li>کاهش احتمال خطا و پیدا کردن سریع‌تر خطاها</li>
</ul>
</li>
<li>
<p>نمونه منابع استانداردهای مایکروسافت و عمومی:</p>
<ul>
<li><a href="https://www.c-sharpcorner.com/UploadFile/ankurmalik123/C-Sharp-coding-standards/">C# Coding Standards by C# Corner</a></li>
<li><a href="https://www.dofactory.com/reference/csharp-coding-standards">C# Coding Standards by DoFactory</a></li>
<li><a href="https://blog.submain.com/coding-standards-c-developers-need/">SubMain Blog – Coding Standards</a></li>
</ul>
</li>
</ul>
<p>رعایت استانداردها باعث می‌شود <strong>کد یکپارچه، قابل خواندن و کمتر خطادار</strong> باشد.</p>
<h3>اصول کدنویسی 🧩</h3>
<ul>
<li><strong>Coding principles</strong> مجموعه‌ای از دستورالعمل‌ها برای نوشتن کد با کیفیت، تست و دیباگ آن و نگهداری کد هستند.</li>
<li>اصول می‌توانند بین برنامه‌نویسان و تیم‌ها متفاوت باشند، اما حتی برای یک برنامه‌نویس تنها، تعریف و پایبندی به اصول شخصی مفید است.</li>
<li>اگر در تیم کار می‌کنید، توافق روی یک مجموعه اصول و استانداردها باعث می‌شود <strong>کار با کد مشترک آسان‌تر شود</strong>.</li>
</ul>
<h4>برخی اصول رایج:</h4>
<ul>
<li>
<p><strong>SOLID</strong>:</p>
<ul>
<li>Single Responsibility Principle</li>
<li>Open-Closed Principle</li>
<li>Liskov Substitution</li>
<li>Interface Segregation Principle</li>
<li>Dependency Inversion Principle</li>
</ul>
</li>
<li>
<p><strong>YAGNI</strong>: You Ain’t Gonna Need It</p>
</li>
<li>
<p><strong>KISS</strong>: Keep It Simple, Stupid</p>
</li>
<li>
<p><strong>DRY</strong>: Don’t Repeat Yourself</p>
</li>
</ul>
<hr>
<h3>متدولوژی‌های کدنویسی 🛠️</h3>
<ul>
<li>
<p><strong>Coding methodologies</strong> فرایند توسعه نرم‌افزار را به فازهای از پیش تعریف‌شده تقسیم می‌کنند، هر فاز شامل مراحل مشخصی است.</p>
</li>
<li>
<p>هدف: <strong>ساده‌سازی مسیر از مفهوم اولیه تا استقرار و نگهداری</strong>.</p>
</li>
<li>
<p>مثال‌هایی که در این کتاب آموزش داده می‌شوند:</p>
<ul>
<li>Test-Driven Development (TDD)</li>
<li>Behavioral-Driven Development (BDD) با SpecFlow</li>
<li>Aspect-Oriented Programming (AOP) با PostSharp</li>
</ul>
</li>
</ul>
<hr>
<h3>استانداردهای کدنویسی 📏</h3>
<ul>
<li>
<p>بهتر است از <strong>Coding Conventions مایکروسافت برای C#</strong> استفاده شود:<br>
<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions">Microsoft C# Coding Conventions</a></p>
</li>
<li>
<p>رعایت این استانداردها باعث می‌شود:</p>
<ul>
<li>کد یک فرمت رسمی و پذیرفته‌شده داشته باشد</li>
<li>تمرکز برنامه‌نویسان روی خواندن کد باشد نه روی چیدمان آن</li>
<li>بهترین شیوه‌ها (Best Practices) رعایت شود</li>
</ul>
</li>
</ul>
<hr>
<h3>مدولار بودن کد (Modularity) 🧱</h3>
<ul>
<li>
<p>برنامه‌های بزرگ را به ماژول‌های کوچک تقسیم کنید:</p>
<ul>
<li>آسان‌تر برای تست و نگهداری</li>
<li>قابل استفاده مجدد</li>
<li>مستقل از سایر ماژول‌ها</li>
</ul>
</li>
<li>
<p>مدولار کردن شامل <strong>اسم‌فیس‌ها (Namespaces) و فولدرها</strong> می‌شود:</p>
<ul>
<li>
<p>یک Namespace فقط شامل کد مرتبط با نام خود باشد. مثال:</p>
<ul>
<li><code>FileSystem</code> → کلاس‌ها و تایپ‌های مربوط به فایل و دایرکتوری</li>
<li><code>Data</code> → فقط تایپ‌های مربوط به داده و منابع داده</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>مزیت: <strong>کد کوچک و مدولار راحت‌تر خوانده و درک می‌شود</strong> و باعث فهم بهتر و استفاده آسان‌تر توسط توسعه‌دهندگان می‌شود.</p>
<hr>
<h3>KISS – Keep It Simple, Stupid ⚡</h3>
<ul>
<li>
<p>حتی اگر شما برنامه‌نویس نابغه‌ای هستید، کد باید ساده و <strong>قابل فهم برای انسان</strong> باشد.</p>
</li>
<li>
<p>کد پیچیده باعث می‌شود حتی برنامه‌نویسان با تجربه دچار سردرگمی شوند و زمان زیادی برای فهم آن صرف کنند.</p>
</li>
<li>
<p>هنگام طراحی سیستم‌ها، همیشه از خود بپرسید:</p>
<ul>
<li>آیا واقعاً نیاز به پیچیدگی مانند Microservices داریم؟</li>
<li>آیا پروژه موجود بیش از حد پیچیده شده است؟</li>
<li>کمترین تعداد اجزای لازم برای نوشتن یک راهکار پایدار، قابل نگهداری و مقیاس‌پذیر چیست؟</li>
</ul>
</li>
</ul>
<p>سادگی کد به <strong>خوانایی، نگهداری آسان و کاهش فشار ذهنی توسعه‌دهندگان</strong> کمک می‌کند.</p>
<h3>YAGNI 🛑</h3>
<ul>
<li>
<p><strong>YAGNI (You Ain’t Gonna Need It)</strong> یک اصل در دنیای برنامه‌نویسی چابک است.</p>
</li>
<li>
<p>برنامه‌نویس نباید هیچ کدی را اضافه کند مگر آنکه واقعاً نیاز باشد.</p>
</li>
<li>
<p>روش کار:</p>
<ol>
<li>نوشتن تست‌های شکست‌خورده بر اساس طراحی</li>
<li>نوشتن حداقل کد برای پاس شدن تست‌ها</li>
<li>ریفکتور کردن کد برای حذف تکرار و بهبود ساختار</li>
</ol>
</li>
<li>
<p>هدف اصلی: جلوگیری از <strong>Over-engineering</strong> و اضافه کردن پیچیدگی غیرضروری به نرم‌افزار.</p>
</li>
<li>
<p>نکته مهم: کد آموزشی و آزمایشی را در پروژه‌های جداگانه نگه دارید، نه در پروژه اصلی.</p>
</li>
</ul>
<hr>
<h3>DRY 🔄</h3>
<ul>
<li><strong>Don’t Repeat Yourself</strong> یعنی از تکرار کد جلوگیری کنید.</li>
<li>اگر یک قطعه کد در چند جای سیستم تکرار شده، باید آن را ریفکتور کنید و در یک <strong>Helper Class یا Library</strong> قرار دهید.</li>
<li>مزیت: کاهش احتمال خطا و جلوگیری از اصلاح ناقص کد در مکان‌های مختلف.</li>
</ul>
<hr>
<h3>SOLID ⚖️</h3>
<p>مجموعه‌ای از ۵ اصل طراحی برای ساخت نرم‌افزار قابل فهم و قابل نگهداری:</p>
<ol>
<li><strong>Single Responsibility Principle (SRP)</strong>: هر کلاس یا متد فقط یک مسئولیت داشته باشد و عناصر مرتبط با آن در کنار هم باشند.</li>
<li><strong>Open/Closed Principle (OCP)</strong>: کلاس‌ها باید برای توسعه باز و برای تغییر بسته باشند.</li>
<li><strong>Liskov Substitution Principle (LSP)</strong>: هر شیء پایه باید بتواند هر کلاس مشتق‌شده‌ای را بدون تغییر رفتار جایگزین کند.</li>
<li><strong>Interface Segregation Principle (ISP)</strong>: به جای یک اینترفیس بزرگ، چند اینترفیس کوچک بسازید تا کلاس‌ها فقط متدهای مورد نیازشان را پیاده‌سازی کنند.</li>
<li><strong>Dependency Inversion Principle (DIP)</strong>: ماژول‌های سطح بالا نباید به ماژول‌های سطح پایین وابسته باشند؛ هر دو باید به انتزاع‌ها وابسته باشند.</li>
</ol>
<p>نکته: همیشه متغیرها را با نوع انتزاعی (Interface یا Abstract Class) تعریف کنید، نه کلاس‌های Concrete.</p>
<hr>
<h3>Occam’s Razor 🔍</h3>
<ul>
<li>
<p>اصل <strong>تیغ اوکام</strong> می‌گوید: موجودیت‌ها را بدون ضرورت تکثیر نکنید.</p>
</li>
<li>
<p>ساده‌ترین راه‌حل معمولاً درست‌ترین است.</p>
</li>
<li>
<p>در توسعه نرم‌افزار:</p>
<ul>
<li>از فرضیات غیرضروری پرهیز کنید</li>
<li>راه‌حل با کمترین فرضیات و کوچک‌ترین تعداد عناصر را انتخاب کنید</li>
</ul>
</li>
<li>
<p>مزیت: کاهش خطا، پیچیدگی کمتر و پروژه‌های قابل نگهداری‌تر.</p>
</li>
</ul>
<h3>خلاصه فصل ۱ 📘</h3>
<p>در این فصل، با <strong>کد خوب و کد بد</strong> آشنا شدیم و اهمیت نوشتن کد خوب را بررسی کردیم. همچنین، به لینک <strong>Microsoft C# Coding Conventions</strong> اشاره شد تا بتوانید بهترین استانداردهای مایکروسافت را دنبال کنید.</p>
<p>همچنین به طور خلاصه با برخی <strong>متدولوژی‌ها و اصول برنامه‌نویسی</strong> آشنا شدید:</p>
<ul>
<li><strong>DRY</strong>: از تکرار کد جلوگیری کنید</li>
<li><strong>KISS</strong>: کد ساده و قابل فهم بنویسید</li>
<li><strong>SOLID</strong>: اصول طراحی برای کد قابل نگهداری</li>
<li><strong>YAGNI</strong>: تنها کد لازم را بنویسید</li>
<li><strong>Occam’s Razor</strong>: ساده‌ترین راه‌حل معمولاً درست‌ترین است</li>
</ul>
<p><strong>مزایای مدولار کردن کد</strong> با استفاده از namespace و assembly:</p>
<ul>
<li>تیم‌های مستقل می‌توانند روی ماژول‌های مستقل کار کنند</li>
<li>افزایش قابلیت نگهداری و بازاستفاده کد</li>
</ul>
<p>در فصل بعد، به <strong>Peer Code Reviews</strong> پرداخته خواهد شد که با وجود اینکه گاهی ناخوشایند است، به حفظ کیفیت کد و رعایت استانداردهای شرکت کمک می‌کند.</p>
<hr>
<h3>سوالات پیشنهادی برای مرور ✏️</h3>
<ol>
<li>نتایج کد بد چیست؟</li>
<li>نتایج کد خوب چیست؟</li>
<li>مزایای نوشتن کد مدولار چیست؟</li>
<li>کد DRY چیست؟</li>
<li>چرا باید هنگام نوشتن کد KISS رعایت کرد؟</li>
<li>مخفف SOLID چیست؟</li>
<li>YAGNI را توضیح دهید.</li>
<li>Occam’s Razor چیست؟</li>
</ol>
<hr>
<h3>منابع پیشنهادی برای مطالعه بیشتر 📚</h3>
<ul>
<li><em>Adaptive Code: Agile coding with design patterns and SOLID principles</em> – Gary McLean Hall</li>
<li><em>Hands-On Design Patterns with C# and .NET Core</em> – Jeffrey Chilberto &amp; Gaurav Aroraa</li>
<li><em>Building Maintainable Software, C# Edition</em> – Rob van der Leek, Pascal van Eck, Gijs Wijnholds, Sylvan Rigal, Joost Visser</li>
<li>فهرست Anti-Patterns در ویکی‌بوک: <a href="https://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Architecture/Anti-Patterns">Anti-Patterns</a></li>
<li>اطلاعات و مثال‌های Design Patterns: <a href="https://en.wikipedia.org/wiki/Software_design_pattern">Software Design Patterns</a></li>
</ul>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
