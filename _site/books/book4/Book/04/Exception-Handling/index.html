

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Exception Handling</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

      <nav class="nav">
        <a href="/Gitab/" aria-current="page">خانه</a>
        <a href="/Gitab/books/list-books">کتاب‌ها</a>
       <a href="/Gitab/translator.html">مترجمین</a>
        <a href="/Gitab/giter.html">گیتر</a>
      </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل چهارم: مدیریت استثناها (Exception Handling) ⚠️</h1>
<p>تعجبی ندارد که وظایف (tasks) ممکن است با <strong>استثناها (exceptions)</strong> مواجه شوند. همچنین درست است که <strong>وظایف مختلف ممکن است استثناهای متفاوتی</strong> ایجاد کنند. در یک محیط <strong>چندنخی (multithreaded)</strong>، مدیریت این استثناها هم می‌تواند <strong>پیچیده و چالش‌برانگیز</strong> باشد.</p>
<p>برنامه شما باید به آن‌ها به‌طور <strong>ملایم و کنترل‌شده</strong> پاسخ دهد تا از <strong>کرش‌های ناخواسته</strong> جلوگیری کرده و <strong>پایداری</strong> خود را حفظ کند. به همین دلیل، <strong>مدیریت استثناها برای ساخت برنامه‌های قابل اعتماد و مقاوم ضروری است</strong>. این فصل بر روی این موضوع تمرکز دارد.</p>
<hr>
<h3>درک چالش 🧩</h3>
<p>از آنجا که شما در حال مطالعه مفاهیم پیشرفته برنامه‌نویسی هستید، فرض می‌کنم با <strong>مبانی استثناها و نحوه مدیریت آن‌ها در برنامه‌های C#</strong> آشنا هستید. بنابراین، در این کتاب به <strong>مباحث پایه‌ای پرداخته نمی‌شود</strong>. تمرکز ما بر روی <strong>سناریوهای استثنایی احتمالی</strong> است که هنگام برنامه‌نویسی وظیفه‌ای در محیط چندنخی ممکن است رخ دهد.</p>
<hr>
<h3>برنامه‌ای که استثنا را نشان نمی‌دهد 🚫</h3>
<p>اگر علائم واضح باشند، پزشک می‌تواند <strong>مشکل بیمار را به راحتی تشخیص دهد</strong>. اما مشکلات <strong>مشاهده‌نشده</strong> به سختی شناسایی می‌شوند.</p>
<p>همین موضوع در برنامه‌نویسی نیز صادق است: <strong>یک استثنای مشاهده‌نشده می‌تواند مشکلات زیادی ایجاد کند</strong>.</p>
<p>برای مثال، برنامه زیر را در نظر بگیرید که <strong>نخ اصلی (main thread)</strong> یک وظیفه ایجاد می‌کند که <strong>استثنایی ایجاد می‌کند، اما در خروجی نمایش داده نمی‌شود</strong>.</p>
<p>📌 توجه: بسته به تنظیمات <strong>Visual Studio</strong> شما، ممکن است خطی که استثنا ایجاد می‌کند، <strong>هایلایت شود</strong>. با این حال، اگر ادامه اجرای برنامه را با <strong>F5 یا دکمه Continue</strong> انجام دهید، هیچ اطلاعاتی درباره این استثنا در خروجی مشاهده نخواهید کرد.</p>
<div align="center">
<p><img src="../../../assets/image/04/Table%204-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>اگر شما کاربر <strong>Visual Studio</strong> هستید و برنامه‌هایی می‌نویسید که با <strong>چندین درخواست لغو (cancellation)</strong> سر و کار دارند، لازم است نکته زیر از مایکروسافت را به یاد داشته باشید (منبع: <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/how-to-listen-for-multiple-cancellation-requests">Microsoft Docs</a>):</p>
<blockquote>
<p>زمانی که گزینه <strong>“Just My Code”</strong> فعال است، در برخی موارد Visual Studio روی خطی که <strong>استثنا ایجاد می‌کند</strong> متوقف می‌شود و پیغام خطایی نمایش می‌دهد که می‌گوید:<br>
“exception not handled by user code.”<br>
این خطا <strong>ضرری ندارد</strong> و می‌توانید با فشردن <strong>F5</strong> ادامه دهید.<br>
برای جلوگیری از توقف Visual Studio روی اولین خطا، کافی است گزینه <strong>“Just My Code”</strong> را از مسیر <strong>Tools → Options → Debugging → General</strong> غیرفعال کنید.</p>
</blockquote>
<hr>
<h3>مثال عملی ۱ 🖥️</h3>
<p>بیایید برنامه زیر را اجرا کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;

WriteLine(<span class="hljs-string">&quot;The main thread starts executing.&quot;</span>);

<span class="hljs-keyword">try</span>
{
    <span class="hljs-keyword">var</span> validateUserTask = Task.Run(() =&gt;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnauthorizedAccessException(<span class="hljs-string">&quot;Unauthorized user.&quot;</span>)
    );
}
<span class="hljs-keyword">catch</span> (Exception e)
{
    WriteLine(<span class="hljs-string">$&quot;Caught error: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
}

WriteLine(<span class="hljs-string">&quot;End of the program.&quot;</span>);
</code></pre>
<h4>خروجی</h4>
<p>با اجرای این برنامه، خروجی زیر مشاهده می‌شود:</p>
<pre class="hljs"><code>The main thread starts executing.
End of the program.
</code></pre>
<p>🔹 نکته: خروجی هیچ اطلاعاتی درباره <strong>استثنا</strong> نشان نمی‌دهد. چرا؟<br>
زیرا در این برنامه، <strong>نخ اصلی (main thread)</strong> با استثنا مواجه نشد؛ بلکه این استثنا توسط <strong>validateUserTask</strong> که توسط نخ اصلی ایجاد شده بود، رخ داده است.</p>
<p>چون استثناهای <strong>مشاهده‌نشده (unobserved)</strong> می‌توانند در مراحل بعدی مشکل ایجاد کنند، بهتر است آن‌ها را مشاهده و <strong>مدیریت</strong> کنیم.</p>
<hr>
<h3>معرفی AggregateException ⚡</h3>
<p>چطور می‌توان اطلاعات مربوط به استثنا را به دست آورد؟<br>
یک روش واضح، <strong>مدیریت استثنا در داخل همان Task</strong> است. مثال:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> validateUserTask = Task.Run(() =&gt;
{
    <span class="hljs-built_in">string</span> msg = <span class="hljs-built_in">string</span>.Empty;
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnauthorizedAccessException(<span class="hljs-string">&quot;Unauthorized user.&quot;</span>);
    }
    <span class="hljs-keyword">catch</span> (Exception e)
    {
        WriteLine(<span class="hljs-string">$&quot;Caught error inside the task: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
    }
    <span class="hljs-keyword">return</span> msg;
});
</code></pre>
<p>اما اگر <strong>Task استثناها را مدیریت نکند</strong>، چگونه می‌توان جزئیات خطا را دریافت کرد؟</p>
<hr>
<h3>مثال عملی ۲ 📌</h3>
<p>در <strong>برنامه‌نویسی مبتنی بر Task</strong>، استثناها <strong>درون شیء Task ذخیره می‌شوند</strong> و <strong>به محض وقوع، پرتاب نمی‌شوند</strong>.</p>
<p>اگر استثنایی در داخل یک Task رخ دهد، درون یک <strong>AggregateException</strong> قرار می‌گیرد که شامل <strong>تمام استثناهایی است که طی اجرای آن Task ایجاد شده‌اند</strong>.<br>
این ویژگی به شما امکان می‌دهد تا استثناها را <strong>به‌صورت جمعی یا جداگانه مدیریت کنید</strong>.</p>
<div align="center">
<p><img src="../../../assets/image/04/Table%204-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>⚠️ <strong>نکته مهم</strong></p>
<p>کلاس <strong>AggregateException</strong> به <strong>namespace System</strong> تعلق دارد و از کلاس <strong>Exception</strong> ارث‌بری می‌کند.</p>
<p>AggregateException می‌تواند در هر یک از سناریوهای زیر پرتاب شود:<br>
• وقتی که شما سعی می‌کنید <strong>نتیجه یک Task</strong> را دریافت کنید.<br>
• وقتی که به‌طور صریح متد <strong>Wait</strong> را روی Task فراخوانی می‌کنید.<br>
• وقتی که Task را با <strong>await</strong> اجرا می‌کنید (از آن‌جا که این کتاب به <strong>async/await</strong> نمی‌پردازد، فعلاً آن را بررسی نمی‌کنیم).</p>
<p>اکنون متوجه هستید که در مثال قبلی، اگر یکی از خطوط زیر را داخل <strong>try block</strong> استفاده کنید، می‌توانید استثنا را مشاهده کنید:</p>
<pre class="hljs"><code>WriteLine(validateUserTask.Result);
</code></pre>
<p>یا</p>
<pre class="hljs"><code>validateUserTask.Wait();
</code></pre>
<hr>
<h3>مثال عملی 🖥️</h3>
<p>در این نمونه، از دستور <strong>validateUserTask.Wait();</strong> داخل try block استفاده شده است (تغییرات با <strong>bold</strong> مشخص شده‌اند):</p>
<pre class="hljs"><code><span class="hljs-comment">// کد قبلی بدون تغییر</span>
<span class="hljs-keyword">try</span>
{
    <span class="hljs-keyword">var</span> validateUserTask = Task.Run(() =&gt;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnauthorizedAccessException(<span class="hljs-string">&quot;Unauthorized user.&quot;</span>)
    );
    validateUserTask.Wait(); <span class="hljs-comment">// مشاهده استثنا</span>
}
<span class="hljs-comment">// بقیه کد بدون تغییر</span>
</code></pre>
<h4>خروجی</h4>
<p>با اجرای مجدد برنامه، خروجی زیر مشاهده می‌شود:</p>
<pre class="hljs"><code>The main thread starts executing.
Caught error: One or more errors occurred. (Unauthorized user.)
End of the program.
</code></pre>
<p>🔹 نکته: حالا خطا نمایش داده می‌شود، اما اطلاعات خطا <strong>“Unauthorized user.”</strong> به‌عنوان یک <strong>InnerException</strong> در AggregateException بسته‌بندی شده است.</p>
<hr>
<h3>جلسه پرسش و پاسخ ❓</h3>
<p><strong>Q4.1</strong> چرا اطلاعات خطا “Unauthorized user.” به‌صورت InnerException نمایش داده شد؟</p>
<p>این برنامه یک <strong>AggregateException</strong> را گرفته است، که برای <strong>تجمیع چندین خطا</strong> در یک شیء استثنای قابل پرتاب استفاده می‌شود. چنین استثنایی در <strong>برنامه‌نویسی مبتنی بر Task</strong> بسیار رایج است.</p>
<p>برای بررسی، می‌توانید <strong>catch block</strong> را به شکل زیر تغییر دهید:</p>
<pre class="hljs"><code><span class="hljs-keyword">catch</span> (Exception e)
{
    WriteLine(<span class="hljs-string">$&quot;Caught error: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
    WriteLine(<span class="hljs-string">$&quot;Exception name: <span class="hljs-subst">{e.GetType().Name}</span>&quot;</span>);
}
</code></pre>
<p>با اجرای مجدد برنامه، خروجی به صورت زیر خواهد بود:</p>
<pre class="hljs"><code>The main thread starts executing.
Caught error: One or more errors occurred. (Unauthorized user.)
Exception name: AggregateException
End of the program.
</code></pre>
<p>📌 همان‌طور که مشاهده می‌کنید، برنامه یک <strong>AggregateException</strong> را گرفته است.<br>
مطابق مستندات رسمی مایکروسافت:</p>
<blockquote>
<p>برای بازگرداندن تمام استثناها به نخ فراخوان، زیرساخت Task آن‌ها را در یک نمونه AggregateException بسته‌بندی می‌کند.<br>
خاصیت <strong>InnerExceptions</strong> این کلاس امکان شمارش و بررسی همه استثناهای اصلی را فراهم می‌کند، تا بتوانید هر کدام را به‌صورت جداگانه مدیریت (یا نادیده) کنید.</p>
</blockquote>
<p>بنابراین، همان‌طور که در خروجی قبل مشاهده شد، خطای واقعی <strong>Unauthorized user.</strong> به‌عنوان یک <strong>InnerException</strong> بسته‌بندی شده بود.</p>
<div align="center">
<p><img src="../../../assets/image/04/Table%204-3.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>⚠️ <strong>نکته مهم</strong></p>
<p>از آن‌جا که <strong>AggregateException</strong> به شما امکان می‌دهد چندین خطا یا شکست را در محیط‌های هم‌زمان تجمیع کنید، در <strong>برنامه‌نویسی مبتنی بر Task</strong> بسیار پرکاربرد است. از این پس، من همواره از <strong>AggregateException</strong> داخل بلوک‌های <strong>catch</strong> استفاده خواهم کرد.</p>
<hr>
<h3>استراتژی‌های مدیریت استثناها 🛠️</h3>
<p>تا این مرحله، فقط یک استثنا را مدیریت کرده‌ایم. بدیهی است که برنامه شما با چندین Task مختلف سروکار خواهد داشت و هرکدام ممکن است استثنای متفاوتی پرتاب کنند. بنابراین، بیایید روی نحوه مدیریت استثناهایی تمرکز کنیم که می‌توانند توسط یک یا چند Task ایجاد شوند.</p>
<p>پیش از شروع، لازم است بدانید که <strong>مدل‌های برنامه‌نویسی مختلف</strong> استراتژی‌های متفاوتی برای مدیریت استثنا دارند.<br>
به عنوان مثال:</p>
<ul>
<li>در <strong>Object-Oriented Programming (OOP)</strong> معمولاً از بلوک‌های <strong>try, catch, finally</strong> استفاده می‌کنیم.</li>
<li>اما در <strong>Functional Programming (FP)</strong> چنین بلوک‌هایی معمولاً وجود ندارند.</li>
</ul>
<p>در اینجا تمرکز ما روی OOP خواهد بود و استراتژی‌ها را در دو دسته ساده می‌کنیم:<br>
• مدیریت استثناها در یک مکان 🏠<br>
• مدیریت استثناها در چند مکان 🏢</p>
<hr>
<h3>مدیریت استثناها در یک مکان 🏠</h3>
<p>بیایید با اولین دسته شروع کنیم، یعنی <strong>چگونگی مدیریت استثناها در یک نقطه واحد</strong>.</p>
<h4>مثال عملی – Demonstration 3 🖥️</h4>
<p>این برنامه دو Task مختلف را داخل Thread اصلی ایجاد می‌کند و هر کدام یک استثنا پرتاب می‌کنند. در اینجا با پیمایش <strong>InnerExceptions</strong>، جزئیات خطا نمایش داده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;
WriteLine(<span class="hljs-string">&quot;Exception handling demo.&quot;</span>);

<span class="hljs-keyword">try</span>
{
    <span class="hljs-keyword">var</span> validateUserTask = Task.Run(
        () =&gt;
        {
            <span class="hljs-comment">// کد Task اول</span>
        }
    );
    <span class="hljs-comment">// سایر کدها، در صورت وجود</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnauthorizedAccessException(<span class="hljs-string">&quot;Unauthorized user.&quot;</span>);

    <span class="hljs-keyword">var</span> storeDataTask = Task.Run(
        () =&gt;
        {
            <span class="hljs-comment">// کد Task دوم</span>
        }
    );
    <span class="hljs-comment">// سایر کدها، در صورت وجود</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InsufficientMemoryException(<span class="hljs-string">&quot;Insufficient memory.&quot;</span>);

    Task.WaitAll(validateUserTask, storeDataTask);
}
<span class="hljs-keyword">catch</span> (AggregateException ae)
{
    <span class="hljs-keyword">foreach</span> (Exception e <span class="hljs-keyword">in</span> ae.InnerExceptions)
    {
        WriteLine(<span class="hljs-string">$&quot;Caught error: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
    }
}
</code></pre>
<h4>خروجی نمونه</h4>
<pre class="hljs"><code>Exception handling demo.
Caught error: Unauthorized user.
Caught error: Insufficient memory.
</code></pre>
<p>این یک روش بسیار رایج برای مدیریت استثناها در <strong>برنامه‌نویسی مبتنی بر Task</strong> است.</p>
<hr>
<h3>روش جایگزین ۱ 🔄</h3>
<p>به بلوک <strong>catch</strong> در مثال قبل توجه کنید. در آن از <strong>ae.InnerExceptions</strong> برای نمایش خطاها استفاده شد.<br>
در روش جایگزین، ابتدا <strong>InnerExceptions</strong> را <strong>Flatten</strong> می‌کنیم و سپس استثناها را پیمایش می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">catch</span> (AggregateException ae)
{
    <span class="hljs-comment">// روش جایگزین ۱</span>
    <span class="hljs-keyword">var</span> exceptions = ae.Flatten().InnerExceptions;
    <span class="hljs-keyword">foreach</span> (Exception e <span class="hljs-keyword">in</span> exceptions)
    {
        WriteLine(<span class="hljs-string">$&quot;Caught error: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
    }
}
</code></pre>
<p>این روش به شما امکان می‌دهد تا <strong>استثناهای تو در تو</strong> را به صورت یک لیست مسطح بررسی کنید و به راحتی مدیریت نمایید.</p>
<h3>روش جایگزین ۲ 🔄</h3>
<p>در کلاس <strong>AggregateException</strong> متدی به نام <strong>Handle</strong> وجود دارد که شکل آن به صورت زیر است:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">Func&lt;Exception, <span class="hljs-built_in">bool</span>&gt; predicate</span>)</span>
{
    <span class="hljs-comment">// بدنه متد نمایش داده نشده است</span>
}
</code></pre>
<p>با استفاده از این متد، می‌توانید یک <strong>Handler</strong> برای هر استثنای موجود در <strong>AggregateException</strong> فراخوانی کنید.<br>
برای مثال، بیایید بلوک <strong>catch</strong> در <strong>Demonstration 3</strong> را به شکل زیر بازنویسی کنیم (روش‌های قبلی داخل کامنت برای مرجع سریع شما باقی مانده‌اند):</p>
<pre class="hljs"><code><span class="hljs-keyword">catch</span> (AggregateException ae)
{
    <span class="hljs-comment"><span class="hljs-doctag">///</span>/ روش اولیه</span>
    <span class="hljs-comment">//foreach (Exception e in ae.InnerExceptions)</span>
    <span class="hljs-comment">//{</span>
    <span class="hljs-comment">//    </span>
    <span class="hljs-comment">//}</span>

    <span class="hljs-comment"><span class="hljs-doctag">///</span>/ روش جایگزین ۱</span>
    <span class="hljs-comment">//var exceptions = ae.Flatten().InnerExceptions;</span>
    <span class="hljs-comment">//foreach (Exception e in exceptions)</span>
    <span class="hljs-comment">//{</span>
    <span class="hljs-comment">//    </span>
    <span class="hljs-comment">//}</span>

    <span class="hljs-comment">// روش جایگزین ۲</span>
    ae.Handle(e =&gt;
    {
        WriteLine(<span class="hljs-string">$&quot;Caught error: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    });
}
</code></pre>
<p>با اجرای این برنامه، خروجی مشابه روش‌های قبلی دریافت خواهد شد.</p>
<p>💡 <strong>نکته:</strong> در پروژه <strong>Chapter4_Demo3</strong> تمامی روش‌های مختلف که تاکنون بحث شد موجود است و کدهای جایگزین داخل کامنت برای مقایسه سریع قرار دارند. با دانلود این پروژه می‌توانید این روش‌ها را عملی کنید و تست کنید.</p>
<hr>
<h3>پرسش و پاسخ 📝</h3>
<p><strong>Q4.2:</strong> من دو استثنا از دو Task مختلف پرتاب کرده‌ام. چگونه می‌توانم آن‌ها را از هم تشخیص دهم؟</p>
<p>✅ ساده است. می‌توانید <strong>ID</strong> Task یا یک پیام مناسب را در <strong>Source</strong> استثنا قرار دهید.<br>
نمونه برنامه با تغییرات کوچک نسبت به <strong>Demonstration 3</strong>:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;
WriteLine(<span class="hljs-string">&quot;Exception handling demo.&quot;</span>);

<span class="hljs-keyword">try</span>
{
    <span class="hljs-keyword">var</span> validateUserTask = Task.Run(
        () =&gt;
        {
            <span class="hljs-comment">// کد Task اول</span>
        }
    );
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnauthorizedAccessException(<span class="hljs-string">&quot;Unauthorized user.&quot;</span>)
    { Source = <span class="hljs-string">&quot;validateUserTask&quot;</span> };

    <span class="hljs-keyword">var</span> storeDataTask = Task.Run(
        () =&gt;
        {
            <span class="hljs-comment">// کد Task دوم</span>
        }
    );
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InsufficientMemoryException(<span class="hljs-string">&quot;Insufficient memory.&quot;</span>)
    { Source = <span class="hljs-string">&quot;storeDataTask&quot;</span> };

    Task.WaitAll(validateUserTask, storeDataTask);
}
<span class="hljs-keyword">catch</span> (AggregateException ae)
{
    <span class="hljs-keyword">foreach</span> (Exception e <span class="hljs-keyword">in</span> ae.InnerExceptions)
    {
        WriteLine(<span class="hljs-string">$&quot;The task: <span class="hljs-subst">{e.Source}</span> raised <span class="hljs-subst">{e.GetType()}</span>: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
    }
}
</code></pre>
<h4>خروجی نمونه</h4>
<pre class="hljs"><code>Exception handling demo.
The task: validateUserTask raised System.UnauthorizedAccessException: Unauthorized user.
The task: storeDataTask raised System.InsufficientMemoryException: Insufficient memory.
</code></pre>
<p><strong>Q4.3:</strong> آیا می‌توانم همین رویکرد را وقتی چندین Task یک استثنا مشابه پرتاب می‌کنند هم استفاده کنم؟</p>
<p>✅ بله، کاملاً درست است. این روش برای مدیریت همزمان چندین استثنا حتی از یک نوع یکسان نیز کاربرد دارد.</p>
<h3>مدیریت استثناها در چندین مکان 🛠️</h3>
<p>فرض می‌کنم که تا اینجا با ایده‌ی مدیریت چندین استثنا آشنا شده‌اید. این روش کاملاً پذیرفته‌شده و احتمالاً رایج‌ترین رویکرد است.</p>
<p>در ادامه، روشی را نشان می‌دهم که بخشی از <strong>AggregateException</strong> را در یک مکان مدیریت می‌کنید و بخش باقی‌مانده را به سطح بالاتر منتقل کرده و در آنجا مدیریت می‌کنید. به بیان دیگر، می‌خواهیم اثربخشی متد <strong>Handle</strong> را ببینیم.</p>
<p>ابتدا به قطعه کد زیر توجه کنید (این کد از <strong>Demonstration 4</strong> گرفته شده است). این کد نشان می‌دهد که تنها می‌خواهید <strong>InsufficientMemoryException</strong> را در این مکان مدیریت کنید و بقیه استثناها به سلسله‌مراتب بالاتر منتقل می‌شوند. به همین دلیل <strong>if block</strong> مقدار <strong>true</strong> را بازمی‌گرداند:</p>
<pre class="hljs"><code><span class="hljs-comment">// Some code before</span>
<span class="hljs-keyword">catch</span> (AggregateException ae)
{
    <span class="hljs-comment">//  Handling only InsufficientMemoryException, other</span>
    <span class="hljs-comment">// exceptions will be propagated up to the hierarchy</span>
    ae.Handle(e =&gt;
    {
        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">is</span> InsufficientMemoryException)
        {
            WriteLine(<span class="hljs-string">$&quot;Caught error inside InvokeTasks(): <span class="hljs-subst">{e.Message}</span>&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    });
}
</code></pre>
<hr>
<h3>Demonstration 4 🖥️</h3>
<p>در این برنامه، <strong>Main thread</strong> متد <strong>InvokeTasks</strong> را فراخوانی می‌کند که به نوبه خود سه Task ایجاد و اجرا می‌کند:</p>
<ul>
<li><strong>validateUserTask</strong></li>
<li><strong>storeDataTask</strong></li>
<li><strong>useDllTask</strong> (برای بحث اضافه شده است تا نشان دهد لازم نیست تعداد مساوی Task در هر مکان داشته باشیم)</li>
</ul>
<p>تمام استثناهای ممکن داخل <strong>InvokeTasks</strong> گرفته می‌شوند، اما تنها <strong>InsufficientMemoryException</strong> مدیریت می‌شود. بنابراین بقیه استثناها به سطح بالاتر منتقل می‌شوند و در <strong>Main thread</strong> مدیریت می‌شوند.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;
WriteLine(<span class="hljs-string">&quot;Exception handling demo.&quot;</span>);

<span class="hljs-keyword">try</span>
{
    InvokeTasks();
}
<span class="hljs-keyword">catch</span> (AggregateException ae)
{
    ae.Handle(e =&gt;
    {
        WriteLine(<span class="hljs-string">$&quot;Caught error inside Main(): <span class="hljs-subst">{e.Message}</span>&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    });
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InvokeTasks</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">var</span> validateUserTask = Task.Run(
            () =&gt;
            {
                <span class="hljs-comment">// Some other code, if any</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnauthorizedAccessException(<span class="hljs-string">&quot;Unauthorized user.&quot;</span>);
            }
        );

        <span class="hljs-keyword">var</span> storeDataTask = Task.Run(
            () =&gt;
            {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InsufficientMemoryException(<span class="hljs-string">&quot;Insufficient memory.&quot;</span>);
            }
        );

        <span class="hljs-keyword">var</span> useDllTask = Task.Run(
            () =&gt;
            {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DllNotFoundException(<span class="hljs-string">&quot;The required dll is missing!&quot;</span>);
            }
        );

        Task.WaitAll(validateUserTask, storeDataTask, useDllTask);
    }
    <span class="hljs-comment">// catch block داخل InvokeTasks برای جلوگیری از تکرار نمایش داده نشده است</span>
}
</code></pre>
<p>💡 <strong>نکته:</strong> برای دیدن کد کامل پروژه می‌توانید از وب‌سایت <strong>Apress</strong> پروژه را دانلود کنید.</p>
<hr>
<h3>خروجی نمونه 📄</h3>
<pre class="hljs"><code>Exception handling demo.
Caught error inside InvokeTasks(): Insufficient memory.
Caught error inside Main(): Unauthorized user.
Caught error inside Main(): The required dll is missing!
</code></pre>
<hr>
<h3>پرسش و پاسخ 📝</h3>
<p><strong>Q4.4:</strong> می‌دانم که می‌توان استثناها را به روش‌های مختلف مدیریت کرد، اما آیا دستورالعمل کلی برای مدیریت استثناها در محیط‌های همزمان وجود دارد؟</p>
<p>✅ معمولاً متخصصان پیشنهاد می‌کنند اگر استثناها را داخل Task مدیریت نمی‌کنید، آن‌ها را در نزدیک‌ترین مکان به جایی که <strong>منتظر تکمیل Task</strong> هستید یا <strong>نتیجه Task</strong> را دریافت می‌کنید، مدیریت کنید. این راهنمایی را من هم رعایت می‌کنم.</p>
<hr>
<h3>خلاصه فصل 📚</h3>
<p>این فصل ادامه بحث <strong>Task Programming</strong> بود، اما این بار تمرکز بر <strong>مدیریت استثناها</strong> با مثال‌ها و مطالعه‌های موردی متفاوت بود. در خلاصه، پاسخ این سوالات داده شد:</p>
<ul>
<li>AggregateException چیست و چرا در Task Programming مهم است؟</li>
<li>چگونه می‌توان استثناهای مختلف Task‌ها را نمایش داد؟</li>
<li>چگونه می‌توان InnerExceptions را <strong>Flatten</strong> کرد؟</li>
<li>چگونه می‌توان تمام استثناهای ممکن را با هم مدیریت کرد؟</li>
<li>چگونه می‌توان استثناهای ممکن را در مکان‌های جداگانه مدیریت کرد؟<br>
تمرین‌ها 📝</li>
</ul>
<p>برای سنجش درک خود، سعی کنید تمرین‌های زیر را انجام دهید:</p>
<div align="center">
<p><img src="../../../assets/image/04/Table%204-4.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>یادآوری 🔔<br>
همان‌طور که پیش‌تر گفته شد، می‌توانید با اطمینان فرض کنید که تمام namespace‌های مورد نیاز برای این قطعات کد در دسترس هستند. این نکته برای همه تمرین‌های این کتاب نیز صدق می‌کند.</p>
<hr>
<p><strong>تمرین‌های فصل ۴: مدیریت استثناها</strong></p>
<p><strong>E4.1</strong><br>
اگر کد زیر را اجرا کنید، آیا می‌توانید خروجی آن را پیش‌بینی کنید؟</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;
WriteLine(<span class="hljs-string">&quot;Exercise 4.1&quot;</span>);
<span class="hljs-keyword">try</span>
{
    <span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>;
    Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">value</span> = Task.Run(() =&gt; <span class="hljs-number">25</span> / b);
}
<span class="hljs-keyword">catch</span> (Exception e)
{
    WriteLine(<span class="hljs-string">$&quot;Caught: <span class="hljs-subst">{e.GetType()}</span>, Message: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
}
WriteLine(<span class="hljs-string">&quot;End&quot;</span>);
</code></pre>
<hr>
<p><strong>E4.2</strong><br>
اگر کد زیر را اجرا کنید، آیا می‌توانید خروجی آن را پیش‌بینی کنید؟</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;
WriteLine(<span class="hljs-string">&quot;Exercise 4.2 and Exercise 4.3&quot;</span>);
<span class="hljs-keyword">try</span>
{
    DoSomething();
}
<span class="hljs-keyword">catch</span> (AggregateException ae)
{
    ae.Handle(
        e =&gt;
        {
            WriteLine(<span class="hljs-string">$&quot;Caught inside main: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    );
}

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span>
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">var</span> task1 = Task.Run(() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidDataException(<span class="hljs-string">&quot;invalid data&quot;</span>));
        <span class="hljs-keyword">var</span> task2 = Task.Run(() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryException(<span class="hljs-string">&quot;insufficient memory&quot;</span>));
        <span class="hljs-comment">// For Exercise 4.2</span>
        Task.WaitAll(task1, task2);
        <span class="hljs-comment">// For Exercise 4.3</span>
        <span class="hljs-comment">// task1.Wait();</span>
        <span class="hljs-comment">// task2.Wait();</span>
    }
    <span class="hljs-keyword">catch</span> (AggregateException ae)
    {
        ae.Handle(
            e =&gt;
            {
                <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">is</span> InvalidDataException)
                {
                    WriteLine(<span class="hljs-string">$&quot;The DoSomething method encounters: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
        );
    }
}
</code></pre>
<hr>
<p><strong>E4.3</strong><br>
در برنامه قبلی، خط زیر:</p>
<pre class="hljs"><code>Task.WaitAll(task1, task2);
</code></pre>
<p>را با خطوط زیر جایگزین کنید:</p>
<pre class="hljs"><code>task1.Wait();
task2.Wait();
</code></pre>
<p>آیا می‌توانید خروجی آن را پیش‌بینی کنید؟</p>
<hr>
<p><strong>E4.4</strong><br>
اگر کد زیر را اجرا کنید، آیا می‌توانید خروجی آن را پیش‌بینی کنید؟</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;
WriteLine(<span class="hljs-string">&quot;Exercise 4.4&quot;</span>);
<span class="hljs-keyword">try</span>
{
    <span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> task1 = Task.Run(() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">&quot;invalid operation&quot;</span>));
    <span class="hljs-keyword">var</span> task2 = Task.Run(() =&gt; <span class="hljs-number">5</span>/b);
    Task.WaitAny(task1, task2);
    WriteLine(<span class="hljs-string">&quot;End&quot;</span>);
}
<span class="hljs-keyword">catch</span> (AggregateException ae)
{
    ae.Handle(e =&gt;
    {
        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">is</span> InvalidOperationException || e <span class="hljs-keyword">is</span> DivideByZeroException)
        {
            WriteLine(<span class="hljs-string">$&quot;Caught error: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    });
}
</code></pre>
<hr>
<p><strong>E4.5</strong><br>
آیا می‌توانید خروجی برنامه زیر را پیش‌بینی کنید؟</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;
WriteLine(<span class="hljs-string">&quot;Exercise 4.5&quot;</span>);
<span class="hljs-keyword">var</span> errorTask = Task.Run(() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;unwanted situation&quot;</span>));
<span class="hljs-keyword">var</span> outerTask = Task.Factory.StartNew(() =&gt; errorTask);
<span class="hljs-keyword">while</span> (!outerTask.IsCompleted) { Thread.Sleep(<span class="hljs-number">10</span>); }
WriteLine(<span class="hljs-string">$&quot;The status of the outer task is: <span class="hljs-subst">{outerTask.Status}</span>&quot;</span>);
<span class="hljs-keyword">while</span> (!outerTask.Unwrap().IsCompleted) { Thread.Sleep(<span class="hljs-number">10</span>); }
WriteLine(<span class="hljs-string">$&quot;The status of the inner task is: <span class="hljs-subst">{outerTask.Unwrap().Status}</span>&quot;</span>);
</code></pre>
<p>راه‌حل تمرین‌ها 📝<br>
در ادامه، نمونه پاسخ تمرین‌های فصل ۴ آورده شده است:</p>
<hr>
<p><strong>E4.1</strong><br>
این برنامه خروجی زیر را تولید می‌کند:</p>
<pre class="hljs"><code>Exercise 4.1
End
</code></pre>
<p>💡 <strong>توضیح نویسنده:</strong> شما استثنا را مشاهده نمی‌کنید چون نخ اصلی (main thread) با آن مواجه نشده؛ استثنا توسط تسکی که این نخ ایجاد کرده بود رخ داده است.</p>
<p>برای مشاهده استثنا، می‌توانید بلوک <code>try</code> را به شکل زیر تغییر دهید (تغییرات با <strong>پررنگ</strong> نشان داده شده است):</p>
<pre class="hljs"><code><span class="hljs-comment">// There is no change in the previous code</span>
<span class="hljs-keyword">try</span>
{
}
<span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>;
Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">value</span> = Task.Run(() =&gt; <span class="hljs-number">25</span> / b);
WriteLine(<span class="hljs-keyword">value</span>.Result);  <span class="hljs-comment">// تغییر پررنگ</span>
<span class="hljs-comment">// There is no change in the remaining code as well</span>
</code></pre>
<p>خروجی برنامه پس از تغییر:</p>
<pre class="hljs"><code>Exercise 4.1
Caught: System.AggregateException, Message: One or more errors occurred. (Attempted to divide by zero.)
End
</code></pre>
<p>⚠️ توجه کنید که به جای مشاهده <code>System.DivideByZeroException</code>، <code>System.AggregateException</code> دیده می‌شود. این نتیجه‌ی مورد انتظار این برنامه است.</p>
<hr>
<p><strong>E4.2</strong><br>
خروجی برنامه به شکل زیر است:</p>
<pre class="hljs"><code>Exercise 4.2 and Exercise 4.3
The DoSomething method encounters: invalid data
Caught inside main: insufficient memory
</code></pre>
<hr>
<p><strong>E4.3</strong><br>
وقتی از <code>task1.Wait();</code> استفاده می‌کنید، <code>InvalidDataException</code> رخ می‌دهد و کنترل از بلوک <code>try</code> خارج می‌شود. خروجی به شکل زیر خواهد بود:</p>
<pre class="hljs"><code>Exercise 4.2 and Exercise 4.3
The DoSomething method encounters: invalid data
</code></pre>
<hr>
<p><strong>E4.4</strong><br>
این برنامه خروجی زیر را تولید می‌کند:</p>
<pre class="hljs"><code>Exercise 4.4
End
</code></pre>
<p>💡 دلیل عدم مشاهده استثناها در خروجی: وقتی از <code>WaitAny</code> استفاده می‌کنید، استثنای تسک‌ها به <code>AggregateException</code> منتقل نمی‌شود.</p>
<p>🔗 پیشنهاد مطالعه: بلاگ استیفن کلری در مورد تفاوت <code>WaitAny</code> و <code>WaitAll</code><br>
<a href="https://blog.stephencleary.com/2014/10/a-tour-of-task-part-5-wait.html">https://blog.stephencleary.com/2014/10/a-tour-of-task-part-5-wait.html</a></p>
<p>خلاصه تفاوت:</p>
<ul>
<li><code>WaitAny</code> فقط منتظر اولین تسک تکمیل می‌ماند و استثنا را به <code>AggregateException</code> منتقل نمی‌کند.</li>
<li>باید خطاهای هر تسک را بعد از بازگشت <code>WaitAny</code> بررسی کنید.</li>
</ul>
<p>برای مشاهده جزئیات استثنا در خروجی، بلوک <code>try</code> را به شکل زیر تغییر دهید:</p>
<pre class="hljs"><code><span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> task1 = Task.Run(() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">&quot;invalid operation&quot;</span>));
<span class="hljs-keyword">var</span> task2 = Task.Run(() =&gt; <span class="hljs-number">5</span> / b);
<span class="hljs-comment">// Task.WaitAny(task1, task2);</span>
<span class="hljs-keyword">var</span> tasks = <span class="hljs-keyword">new</span>[]{ task1, task2 };
<span class="hljs-built_in">int</span> taskIndex = Task.WaitAny(tasks);
tasks[taskIndex].Wait();
WriteLine(<span class="hljs-string">&quot;End&quot;</span>);
</code></pre>
<p>خروجی نمونه پس از تغییر:</p>
<pre class="hljs"><code>Exercise 4.4
Caught error: invalid operation
</code></pre>
<hr>
<p><strong>E4.5</strong><br>
خروجی برنامه به شکل زیر است:</p>
<pre class="hljs"><code>Exercise 4.5
The status of the outer task is: RanToCompletion
The status of the inner task is: Faulted
</code></pre>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
