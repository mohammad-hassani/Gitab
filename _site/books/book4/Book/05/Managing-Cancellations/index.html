

<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8">
  <link rel="icon" type="image/png" href="/Gitab/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Cancellations</title>
  <meta name="description" content="ترجمه‌های فارسی کتاب‌های فنی — سریع، مینیمال و قابل اتکا.">

  <!-- استایل‌ها -->
  <link rel="stylesheet" href="/Gitab/styles/main.css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <style>
  @font-face {
    font-family: 'Vazir';
    src: url('/Gitab/fonts/Vazir-FD-WOL.ttf') format('truetype');
    font-display: swap;
  }
  body {
    font-family: 'Vazir', sans-serif;
  }
  </style>
</head>

<body>
  <!-- هدر مشترک -->
  <header class="header">
    <div class="container nav-wrap">
      <a href="/Gitab/" class="brand">
        <img src="/Gitab/icone/logo.svg" alt="Gitab logo" width="26" height="26">
        <span>Gitab</span>
      </a>

       <nav class="nav">
         <a href="/Gitab/" >خانه</a>
         <a href="/Gitab/books/list-books" >کتاب‌ها</a>
        <a href="/Gitab/translator.html" >مترجمین</a>
         <a href="/Gitab/giter.html" >گیتر</a>
       </nav>

      <div class="nav-actions">
        <button id="themeToggle" class="icon-btn theme-btn" data-icon="moon" aria-label="تغییر تم">
          <img src="/Gitab/icone/sun.svg" class="icon-sun" alt="روشن">
          <img src="/Gitab/icone/moon.svg" class="icon-moon" alt="تاریک">
        </button>

        <a class="icon-btn" href="https://github.com/hheydarian/Gitab" target="_blank" title="GitHub">
          <img src="/Gitab/icone/github.svg" alt="GitHub">
        </a>

        <!-- دکمه منو برای موبایل -->
        <button class="menu-toggle" aria-label="منو">
          <img src="/Gitab/icone/menu.svg" alt="menu">
        </button>
      </div>
    </div>
  </header>

  
  <main class="site-main book-page">
    <h1>فصل پنجم: 📌 <strong>مدیریت لغو عملیات (Cancellations)</strong></h1>
<p>لغو عملیات یک مکانیزم حیاتی در برنامه‌نویسی با تسک‌ها است. این ویژگی در موارد زیر بسیار مفید است:<br>
• متوقف کردن یک تسک در حال اجرا به‌طور ایمن وقتی دیگر مورد نیاز نیست ⏹️<br>
• آزادسازی منابع حیاتی 🗄️<br>
• بهبود پاسخ‌دهی برنامه ⚡</p>
<p>به همین دلیل، یک تسک طولانی‌مدت ممکن است به‌طور مرتب بررسی کند که آیا درخواست لغو ارسال شده است یا خیر. اگر چنین درخواستی وجود داشته باشد، تسک باید مطابق با آن واکنش نشان دهد.</p>
<p>با این حال، داشتن قابلیت لغو تسک به این معنا نیست که باید تسک را به‌طور ناگهانی متوقف کنید، زیرا این کار می‌تواند برنامه را در وضعیت ناپایدار قرار دهد. در عوض، شما یک مدل <strong>همکاری‌کننده (cooperative)</strong> ایجاد می‌کنید که در آن تسک و کدی که لغو را آغاز می‌کند می‌توانند با هم کار کنند.</p>
<p>این فصل به بررسی این موضوع می‌پردازد.</p>
<p>پیش‌نیازها 📚</p>
<p>برای مدیریت لغو تسک‌ها در C#، باید با موارد زیر آشنا باشید:</p>
<p>• <strong>CancellationTokenSource</strong>: این کلاس مسئول <strong>اعلام درخواست لغو</strong> است. این کلاس یک <strong>CancellationToken</strong> تولید می‌کند که به تسک داده می‌شود تا وضعیت درخواست لغو را بررسی کند. ⏳</p>
<p>• <strong>CancellationToken</strong>: این یک ساختار (struct) است که به تسک داده می‌شود و راهی برای بررسی اینکه آیا لغو درخواست شده وجود دارد یا خیر فراهم می‌کند. این توکن برای <strong>انتشار اطلاعیه لغو تسک</strong> استفاده می‌شود.</p>
<p>بیایید ببینیم چگونه از این‌ها در برنامه استفاده کنیم. ابتدا از کد زیر استفاده می‌کنیم:</p>
<pre class="hljs"><code>CancellationTokenSource tokenSource = <span class="hljs-keyword">new</span>();
CancellationToken token = tokenSource.Token;
</code></pre>
<p>البته، با استفاده از کلیدواژه <code>var</code> می‌توانید کد معادل زیر را بنویسید:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-keyword">var</span> token = tokenSource.Token;
</code></pre>
<p>سپس این توکن را به تسک موردنظر می‌دهیم. همان‌طور که قبلاً در فصل ۲ و شکل ۲-۱ دیدید، سازنده Task چندین نسخه <strong>overload</strong> دارد و برخی از آن‌ها یک نمونه <strong>CancellationToken</strong> را به‌عنوان پارامتر می‌پذیرند. مثال:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span>(<span class="hljs-params">Action action, CancellationToken cancellationToken</span>)</span>;
</code></pre>
<p>همچنین، متدهای <code>StartNew</code> در کلاس <code>TaskFactory</code> و <code>Run</code> در کلاس <code>Task</code> نیز overloadهای مشابهی دارند. چند نمونه دیگر:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">StartNew</span>(<span class="hljs-params">Action action, CancellationToken cancellationToken</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Task <span class="hljs-title">Run</span>(<span class="hljs-params">Action action, CancellationToken cancellationToken</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Task</span>&lt;<span class="hljs-title">TResult</span>&gt; <span class="hljs-title">Run</span>&lt;<span class="hljs-title">TResult</span>&gt;(<span class="hljs-params">Func&lt;TResult&gt; function, CancellationToken cancellationToken</span>)
</span></code></pre>
<p>این ساختارها به شما ایده می‌دهند که چگونه یک <strong>توکن لغو</strong> را به تسک منتقل کنید. برای مثال، کد زیر در نمونه بعدی استفاده می‌شود:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> printTask = Task.Run(
    () =&gt;
    {
        <span class="hljs-comment">// برخی کدها که نشان داده نشده</span>
    }, token
);
</code></pre>
<p>اما باید نکات زیر از مایکروسافت را به خاطر بسپارید:</p>
<blockquote>
<p><strong>رشته فراخوانی‌کننده (calling thread)</strong> تسک را به‌صورت اجباری نمی‌بندد؛ تنها <strong>اعلام می‌کند که لغو درخواست شده است</strong>. اگر تسک در حال اجرا باشد، بر عهده کاربر است که این درخواست را مشاهده کرده و به آن پاسخ دهد.<br>
منبع: <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-cancel-a-task-and-its-children">Cancel a task and its children</a></p>
</blockquote>
<p>این نکته نشان می‌دهد که ممکن است وقتی رشته فراخوانی‌کننده درخواست لغو را اعلام می‌کند، تسک در حال اجرا قبلاً به پایان رسیده باشد. بنابراین، اگر می‌خواهید یک تسک در حال اجرا را لغو کنید، <strong>باید درخواست لغو را هر چه سریع‌تر ارسال کنید</strong>. ⚡</p>
<h3>لغو توسط کاربر (User-Initiated Cancellations)</h3>
<p>در اغلب موارد، <strong>درخواست لغو توسط کاربران</strong> ایجاد می‌شود. همچنین می‌توان لغو را به‌صورت <strong>خودکار بعد از یک بازه زمانی مشخص</strong> انجام داد.<br>
بیایید بحث را با <strong>لغو توسط کاربر</strong> شروع کنیم. 🧑‍💻<br>
رویکرد اولیه 🔹</p>
<p>در اولین رویکرد، قبل از ارسال درخواست لغو، یک شرط <strong>if</strong> بررسی می‌شود. در صورت نیاز، می‌توانید قبل از لغو تسک، کارهای اضافی انجام دهید. برای مثال، می‌توانید پیامی چاپ کنید که نشان دهد این تسک قرار است لغو شود. همچنین می‌توانید منابع لازم را قبل از لغو تسک <strong>پاکسازی (cleanup)</strong> کنید. در نهایت، با استفاده از <strong>break</strong> یا <strong>return</strong> از بلوک کد مربوطه خارج می‌شوید. احتمالاً اکثر ما با این نوع مکانیزم <strong>خروج نرم (soft exit)</strong> آشنا هستیم. بیایید یک مثال ببینیم. 🛑</p>
<h3>نمونه عملی – Demonstration 1 🖥️</h3>
<p>در این نمونه، یک تسک ایجاد شده که می‌تواند اعداد ۰ تا ۹۹ را چاپ کند. برای اینکه امکان لغو وجود داشته باشد، یک <strong>CancellationTokenSource</strong> ساخته شده تا <strong>توکن لغو</strong> ایجاد کرده و به تسک منتقل شود تا در صورت نیاز درخواست لغو ارسال شود.</p>
<p><strong>توجه:</strong> امروزه پردازنده‌های کامپیوتر بسیار سریع هستند، بنابراین این تسک ممکن است خیلی سریع اجرا شود. برای جلوگیری از این موضوع، پس از چاپ هر عدد، یک تأخیر کوتاه اعمال شده است.</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;

WriteLine(<span class="hljs-string">&quot;Simple cancellation demonstration.&quot;</span>);

<span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-keyword">var</span> token = tokenSource.Token;

<span class="hljs-keyword">var</span> printTask = Task.Run(
    () =&gt;
    {
        <span class="hljs-comment">// حلقه‌ای که 100 بار اجرا می‌شود</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
        {
            <span class="hljs-comment">// رویکرد شماره 1</span>
            <span class="hljs-keyword">if</span> (token.IsCancellationRequested)
            {
                WriteLine(<span class="hljs-string">&quot;Cancelling the print activity.&quot;</span>);
                <span class="hljs-comment">// انجام برخی پاکسازی‌ها، در صورت نیاز</span>
                <span class="hljs-keyword">return</span>;
            }
            WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">{i}</span>&quot;</span>);
            <span class="hljs-comment">// ایجاد تأخیر کوتاه بعد از چاپ هر عدد</span>
            Thread.Sleep(<span class="hljs-number">500</span>);
        }
    }, token
);

WriteLine(<span class="hljs-string">&quot;Enter c to cancel the task.&quot;</span>);
<span class="hljs-built_in">char</span> ch = ReadKey().KeyChar;

<span class="hljs-keyword">if</span> (ch.Equals(<span class="hljs-string">&#x27;c&#x27;</span>))
{
    WriteLine(<span class="hljs-string">&quot;\nRaising the cancellation request.&quot;</span>);
    tokenSource.Cancel();
}

<span class="hljs-keyword">try</span>
{
    printTask.Wait();
    <span class="hljs-comment">//printTask.Wait(token); // این خط در ادامه استفاده خواهد شد</span>
}
<span class="hljs-keyword">catch</span> (OperationCanceledException oce)
{
    WriteLine(<span class="hljs-string">$&quot;Operation canceled. Message: <span class="hljs-subst">{oce.Message}</span>&quot;</span>);
}
<span class="hljs-keyword">catch</span> (AggregateException ae)
{
    <span class="hljs-keyword">foreach</span> (Exception e <span class="hljs-keyword">in</span> ae.InnerExceptions)
    {
        WriteLine(<span class="hljs-string">$&quot;Caught: <span class="hljs-subst">{e.GetType()}</span>, Message: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
    }
}

WriteLine(<span class="hljs-string">$&quot;The final status of printTask is: <span class="hljs-subst">{printTask.Status}</span>&quot;</span>);
WriteLine(<span class="hljs-string">&quot;End of the main thread.&quot;</span>);
</code></pre>
<p>در این برنامه، شما مشاهده می‌کنید که تسک به‌صورت <strong>همکارانه (cooperative)</strong> لغو می‌شود و وضعیت نهایی آن در پایان گزارش می‌شود. ✅</p>
<h3>توضیح خروجی و Q&amp;A 📝</h3>
<p>در <strong>Demonstration 1</strong>، حتی وقتی تسک لغو شد، وضعیت نهایی آن <strong>RanToCompletion</strong> بود و نه <strong>Canceled</strong>. این به این دلیل است که ما تسک را با <strong>return</strong> ساده خاتمه دادیم، نه با پرتاب <strong>OperationCanceledException</strong>.</p>
<p>Microsoft در مستندات خود توضیح می‌دهد:</p>
<ul>
<li><strong>راه اول:</strong> بازگشت از delegate کافی است، اما در این حالت تسک به وضعیت <code>RanToCompletion</code> می‌رود.</li>
<li><strong>راه دوم (ترجیحی):</strong> پرتاب <strong>OperationCanceledException</strong> با پاس دادن توکن لغو. در این حالت تسک به وضعیت <strong>Canceled</strong> می‌رود و می‌توان از آن در کد فراخوان برای بررسی پاسخ‌دهی تسک به درخواست لغو استفاده کرد.</li>
</ul>
<h3>Alternative Approach – Demonstration 2 🔄</h3>
<p>در این روش، داخل تسک، به جای return ساده، یک <strong>OperationCanceledException</strong> پرتاب می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> printTask = Task.Run(
    () =&gt;
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
        {
            <span class="hljs-comment">// Approach-2</span>
            <span class="hljs-keyword">if</span> (token.IsCancellationRequested)
            {
                WriteLine(<span class="hljs-string">&quot;Cancelling the print activity.&quot;</span>);
                <span class="hljs-comment">// انجام پاکسازی‌های لازم</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(token);
            }
            WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">{i}</span>&quot;</span>);
            Thread.Sleep(<span class="hljs-number">500</span>);
        }
    }, token
);
</code></pre>
<h3>نمونه خروجی با این رویکرد</h3>
<pre class="hljs"><code>Simple cancellation demonstration.
Enter c to cancel the task.
0
1
2
c
Raising the cancellation request.
Cancelling the print activity.
Caught: System.Threading.Tasks.TaskCanceledException, Message: A task was canceled.
The final status of printTask is: Canceled
End of the main thread.
</code></pre>
<p>✅ همان‌طور که مشاهده می‌کنید، حالا وضعیت نهایی تسک <strong>Canceled</strong> است و استثناء <code>TaskCanceledException</code> دریافت می‌شود.</p>
<p>این روش برای مواقعی مناسب است که می‌خواهید مطمئن شوید تسک به صورت رسمی به حالت <strong>لغو شده</strong> منتقل شده و کد فراخوان بتواند آن را تشخیص دهد.</p>
<h3>کوتاه‌سازی کد با <code>ThrowIfCancellationRequested</code> ⏱️</h3>
<p>Microsoft توصیه می‌کند که به جای نوشتن دستی این خطوط:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (token.IsCancellationRequested)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(token);
</code></pre>
<p>می‌توانید از متد <strong><code>ThrowIfCancellationRequested</code></strong> استفاده کنید که معادل عملکرد بالا است و هم بررسی می‌کند که آیا درخواست لغو شده و هم در صورت نیاز استثناء مناسب را پرتاب می‌کند.</p>
<h3>مثال کوتاه‌شده – Approach-3</h3>
<pre class="hljs"><code><span class="hljs-keyword">var</span> printTask = Task.Run(
    () =&gt;
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
        {
            <span class="hljs-comment">// Approach-3</span>
            token.ThrowIfCancellationRequested();
            WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">{i}</span>&quot;</span>);
            Thread.Sleep(<span class="hljs-number">500</span>);
        }
    }, token
);
</code></pre>
<p>این روش نه تنها کوتاه‌تر و تمیزتر است، بلکه استاندارد <strong>پرکاربرد</strong> در برنامه‌های واقعی محسوب می‌شود. ✅</p>
<hr>
<h3>نکات مهم Q&amp;A</h3>
<p><strong>Q5.2 – تفاوت RanToCompletion و Canceled:</strong></p>
<ul>
<li>اگر فقط از <code>return</code> برای خروج استفاده کنید، وضعیت تسک <strong>RanToCompletion</strong> می‌شود.</li>
<li>اگر <code>OperationCanceledException</code> پرتاب کنید (Approach-2 یا Approach-3)، وضعیت تسک <strong>Canceled</strong> می‌شود.</li>
<li>در برنامه‌های سازمانی، حالت دوم ترجیح داده می‌شود چون امکان بررسی و ثبت لاگ تسک‌های لغو شده فراهم می‌شود.</li>
</ul>
<p><strong>Q5.3 – انجام پاکسازی قبل از لغو تسک:</strong><br>
می‌توانید از ترکیب بررسی <code>IsCancellationRequested</code> و سپس <code>ThrowIfCancellationRequested</code> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (token.IsCancellationRequested)
{
    <span class="hljs-comment">// انجام پاکسازی‌های لازم</span>
    token.ThrowIfCancellationRequested();
}
</code></pre>
<hr>
<h3>نکته منابع و Dispose 💡</h3>
<ul>
<li>همیشه پس از پایان کار با <code>CancellationTokenSource</code>، باید <strong><code>Dispose()</code></strong> را فراخوانی کنید تا منابع آزاد شوند:</li>
</ul>
<pre class="hljs"><code>tokenSource.Dispose();
</code></pre>
<ul>
<li>این کلاس <code>IDisposable</code> را پیاده‌سازی می‌کند و در غیر این صورت منابع تا فراخوانی Garbage Collector آزاد نمی‌شوند.</li>
</ul>
<hr>
<h3>نمونه‌های دیگر <code>OperationCanceledException</code></h3>
<table>
<thead>
<tr>
<th>Constructor</th>
<th>توضیح</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OperationCanceledException(CancellationToken)</code></td>
<td>استفاده همراه با توکن لغو (مثل Demonstration 2)</td>
</tr>
<tr>
<td><code>OperationCanceledException(String)</code></td>
<td>ایجاد استثناء با پیام دلخواه</td>
</tr>
<tr>
<td><code>OperationCanceledException()</code></td>
<td>پیام پیش‌فرض سیستم</td>
</tr>
</tbody>
</table>
<p>این انعطاف به شما امکان می‌دهد هنگام لغو تسک، جزئیات دلخواه را ثبت کنید و مدیریت بهتری روی عملیات لغو داشته باشید.</p>
<h3>بررسی تأثیر تغییر نحوه پرتاب و مدیریت استثناء لغو</h3>
<hr>
<h3><strong>Case Study 1 – تغییر تعریف تسک</strong></h3>
<p>در Demonstration 2 (Approach-2)، اگر <code>OperationCanceledException</code> را بدون پاس دادن <strong>CancellationToken</strong> بسازید، مانند این:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (token.IsCancellationRequested)
{
    WriteLine(<span class="hljs-string">&quot;Cancelling the print activity.&quot;</span>);
    <span class="hljs-comment">// Do some cleanups, if required</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(<span class="hljs-string">&quot;The operation is canceled.&quot;</span>);
}
</code></pre>
<p><strong>خروجی نمونه:</strong></p>
<pre class="hljs"><code>Simple cancellation demonstration.
Enter c to cancel the task.
0
1
2
c
Raising the cancellation request.
Cancelling the print activity.
Caught: System.OperationCanceledException, Message: The operation is canceled.
The final status of printTask is: Faulted
End of the main thread.
</code></pre>
<p>✅ <strong>توضیح:</strong></p>
<ul>
<li>وقتی <code>OperationCanceledException</code> بدون توکن ایجاد شود، یا توکن آن با تسک مطابقت نداشته باشد، <strong>تسک به جای حالت Canceled، به حالت Faulted می‌رود</strong>.</li>
<li>این رفتار توسط طراحی .NET تعیین شده است. منبع رسمی: <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-cancellation">Task cancellation</a></li>
</ul>
<blockquote>
<p>خلاصه: برای داشتن وضعیت <code>Canceled</code>، باید <strong>توکن همان تسک</strong> به استثناء داده شود.</p>
</blockquote>
<hr>
<h3><strong>Case Study 2 – تغییر نحوه صدا زدن Wait</strong></h3>
<p>اگر از <code>Wait(token)</code> به جای <code>Wait()</code> استفاده کنید:</p>
<pre class="hljs"><code><span class="hljs-comment">// printTask.Wait();</span>
printTask.Wait(token);
</code></pre>
<p><strong>تأثیر:</strong></p>
<ul>
<li>این بار، <code>OperationCanceledException</code> داخل <code>AggregateException</code> قرار نمی‌گیرد.</li>
<li>بنابراین، لازم است catch مجزا برای <code>OperationCanceledException</code> داشته باشید تا آن را مدیریت کنید.</li>
</ul>
<p><strong>خروجی نمونه:</strong></p>
<pre class="hljs"><code>Simple cancellation demonstration.
Enter c to cancel the task.
0
1
2
c
Raising the cancellation request.
Operation canceled. Message: The operation was canceled.
The final status of printTask is: Running
End of the main thread.
</code></pre>
<p>✅ <strong>نکات کلیدی:</strong></p>
<ol>
<li>پرتاب استثناء با توکن مناسب → تسک وضعیت <code>Canceled</code> می‌گیرد.</li>
<li>پرتاب استثناء بدون توکن → تسک وضعیت <code>Faulted</code> می‌گیرد.</li>
<li>استفاده از <code>Wait(token)</code> → استثناء لغو مستقیماً مدیریت می‌شود و در <code>AggregateException</code> جمع‌آوری نمی‌شود.</li>
</ol>
<hr>
<p>این دو مطالعه موردی نشان می‌دهد که <strong>نحوه پرتاب و مدیریت استثناء لغو و همچنین توکن مورد استفاده، تأثیر مستقیم روی وضعیت نهایی تسک دارند</strong>.</p>
<h3><strong>Q5.5 – چرا وضعیت نهایی تسک Running نشان داده شد؟</strong></h3>
<p>در مثال قبلی که از <code>Wait(token)</code> استفاده شد، خروجی نهایی تسک <code>Running</code> بود، نه <code>Canceled</code> یا <code>Faulted</code>.</p>
<p>✅ <strong>توضیح:</strong></p>
<ul>
<li>وقتی از <code>Wait(token)</code> استفاده می‌کنید، انتظار اصلی تسک به وسیله <strong>توکن لغو</strong> کنترل می‌شود.</li>
<li>اگر کاربر قبل از اتمام تسک، لغو را درخواست کند، <strong>main thread سریعاً از Wait خارج می‌شود</strong> و بنابراین هنوز تسک ممکن است در حال اجرا باشد.</li>
<li>در نتیجه، اگر بلافاصله وضعیت تسک را بررسی کنید، مقدار <code>Running</code> دیده می‌شود چون تسک هنوز کامل نشده است.</li>
</ul>
<p>💡 <strong>راه حل برای دیدن وضعیت واقعی تسک:</strong></p>
<p>می‌توانید قبل از بررسی وضعیت، <strong>منتظر شوید تا تسک واقعاً کامل شود</strong>:</p>
<pre class="hljs"><code><span class="hljs-comment">// Wait till the task finishes the execution</span>
<span class="hljs-keyword">while</span> (!printTask.IsCompleted) { }

WriteLine(<span class="hljs-string">$&quot;The final status of printTask is: <span class="hljs-subst">{printTask.Status}</span>&quot;</span>);
</code></pre>
<p><strong>خروجی نمونه پس از این تغییر:</strong></p>
<pre class="hljs"><code>Simple cancellation demonstration.
Enter c to cancel the task.
0
1
2
c
Raising the cancellation request.
Operation canceled. Message: The operation was canceled.
Cancelling the print activity.
The final status of printTask is: Faulted
End of the main thread.
</code></pre>
<p>✅ <strong>نکته کلیدی:</strong></p>
<ul>
<li><code>Wait(token)</code> باعث خروج زودهنگام main thread می‌شود، اما تسک ممکن است هنوز کامل نشده باشد.</li>
<li>برای مشاهده وضعیت نهایی دقیق، باید تا اتمام تسک صبر کنید (<code>IsCompleted</code>).</li>
</ul>
<div align="center">
<p><img src="../../../assets/image/05/Table%205-1.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>نکات مهم 📝</p>
<p>می‌خواهم به نکات زیر توجه کنید:</p>
<p>1️⃣ با بررسی دقیق خواهید دید که متد <code>Wait()</code> تنها می‌تواند <code>AggregateException</code> ایجاد کند، در حالی که <code>Wait(CancellationToken cancellationToken)</code> قابل لغو است و می‌تواند <code>OperationCanceledException</code> را ایجاد کند. اگر علاقه‌مند هستید، می‌توانید بحث آنلاین ما در این مورد را در لینک زیر مشاهده کنید:<br>
<a href="https://stackoverflow.com/questions/77833724/why-the-catch-block-of-aggregateexception-was-not-sufficient-to-handle-cancellat/77833858#77833858">StackOverflow Discussion</a></p>
<p>2️⃣ برای پاسخ به سؤال Q5.5، من از خط <code>while (!printTask.IsCompleted) { }</code> استفاده کردم. با این حال، مایکروسافت توصیه می‌کند (لینک آنلاین: <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library">Microsoft Documentation</a>) که از چنین polling در کدهای تولیدی خودداری کنید، زیرا بسیار ناکارآمد است.</p>
<p>3️⃣ در خروجی قبلی، وضعیت نهایی تسک (<code>task</code>) به صورت <code>Faulted</code> نمایش داده شد. دلیل آن این است که من در آن دمو از خط زیر استفاده کردم:</p>
<pre class="hljs"><code><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(<span class="hljs-string">&quot;The operation is canceled.&quot;</span>);
</code></pre>
<p>با این حال، اگر این خط را با</p>
<pre class="hljs"><code><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(token);
</code></pre>
<p>جایگزین کنید، وضعیت نهایی <code>Canceled</code> خواهد بود و نه <code>Faulted</code>.</p>
<p>⏱️ لغو با تایم‌اوت (Timeout Cancellation)</p>
<p>شما می‌توانید یک درخواست لغو را پس از یک بازه زمانی مشخص ایجاد کنید. به عنوان مثال، در یک عملیات شبکه معمولی، ممکن است نخواهید بی‌نهایت منتظر بمانید. در چنین حالتی، برنامه شما می‌تواند به‌صورت خودکار درخواست لغو را صادر کند.</p>
<p>برای پیاده‌سازی این ایده، می‌توانید از خط زیر استفاده کنید:</p>
<pre class="hljs"><code>tokenSource.CancelAfter(<span class="hljs-number">2000</span>);
</code></pre>
<p>در دمو قبلی (Demonstration 2) به شکل زیر:</p>
<pre class="hljs"><code><span class="hljs-comment">// هیچ تغییری در کد قبلی نیست</span>
<span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-keyword">var</span> token = tokenSource.Token;
tokenSource.CancelAfter(<span class="hljs-number">2000</span>);
<span class="hljs-comment">// هیچ تغییر دیگری در کد باقی‌مانده نیست</span>
</code></pre>
<p>اکنون با اجرای برنامه‌ی اصلاح‌شده، برنامه می‌تواند پس از ۲۰۰۰ میلی‌ثانیه به‌صورت خودکار درخواست لغو را صادر کند.</p>
<p>💡 توجه: از آنجا که من بقیه کد را تغییر نداده‌ام، این برنامه همچنان می‌تواند به لغوهای ایجادشده توسط کاربر نیز پاسخ دهد. در این حالت، کاربر باید قبل از فعال شدن لغو خودکار، درخواست لغو را صادر کند. در واقع، برنامه تا دریافت ورودی از کاربر منتظر می‌ماند قبل از اینکه بسته شود. می‌توانید پروژه <code>Chapter5_TimeoutCancellation</code> را از وب‌سایت Apress دانلود کنید تا برنامه کامل را ببینید.</p>
<p>🖥️ نظارت بر لغو تسک (Monitoring Task Cancellation)</p>
<p>در خروجی برخی از دموهای قبلی (مثلاً خروجی Demonstration2، Chapter5_Demo2_CaseStudy1، یا پاسخ به Q5.5)، شما خط زیر را مشاهده کردید:</p>
<pre class="hljs"><code>Cancelling the print activity.
</code></pre>
<p>من از این خط برای نظارت بر تسک لغو شده قبل از عملیات لغو استفاده کردم. جالب است که روش‌های جایگزین دیگری نیز وجود دارد. بیایید برخی از آن‌ها را ببینیم.</p>
<p>🔔 استفاده از Register</p>
<p>شما می‌توانید در یک رویداد ثبت‌نام کنید. به عنوان مثال، در کد زیر یک delegate ثبت می‌کنیم که هنگام لغو شدن token فراخوانی می‌شود:</p>
<pre class="hljs"><code>token.Register(
    () =&gt;
    {
        WriteLine(<span class="hljs-string">&quot;Cancelling the print activity. [Using event subscription]&quot;</span>);
        <span class="hljs-comment">// اگر خواستید کار دیگری انجام دهید</span>
    }
);
</code></pre>
<p>استفاده از <code>WaitHandle.WaitOne</code> ⏳</p>
<p>اجازه دهید یک روش دیگر را نشان دهم که نسبت به روش قبلی کمی پیچیده‌تر است. با این حال، این روش نیز می‌تواند ایده‌ای درباره‌ی نظارت بر لغو تسک به شما بدهد. لینک آنلاین <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.waithandle.waitone?view=net-8.0">Microsoft Documentation</a> متد <code>WaitOne</code> کلاس <code>WaitHandle</code> را به صورت زیر توضیح می‌دهد:</p>
<blockquote>
<p>بلوک کردن ترد فعلی تا زمانی که <code>WaitHandle</code> فعلی سیگنالی دریافت کند.</p>
</blockquote>
<p>متد <code>WaitOne</code> چندین اورلود دارد. در دمو پیش‌رو، ساده‌ترین شکل آن را نشان می‌دهم که نیازی به ارسال هیچ آرگومانی ندارد. ایده اصلی این است که ترد فعلی یک token را در نظر می‌گیرد و منتظر می‌ماند تا کسی این token را لغو کند. به محض اینکه کسی عملیات لغو را فراخوانی کند، تماس بلاک‌شده آزاد می‌شود. به همین دلیل می‌توانم یک تسک دیگر از ترد فراخواننده به شکل زیر اجرا کنم:</p>
<pre class="hljs"><code>Task.Run(
    () =&gt;
    {
        token.WaitHandle.WaitOne();
        WriteLine(<span class="hljs-string">&quot;Cancelling the print activity. [Using WaitHandle]&quot;</span>);
        <span class="hljs-comment">// اگر خواستید کار دیگری انجام دهید</span>
    }
);
</code></pre>
<p>توجه کنید که این روش بسیار شبیه به ثبت در رویداد (event subscription) است، زیرا در اینجا نیز منتظر وقوع لغو هستید. به همین دلیل من یک دستور مشابه در این بلاک کد نوشتم.</p>
<hr>
<p>📌 <strong>Demonstration 3</strong></p>
<p>وقت آن است که دمو دیگری را ببینیم که در آن روش‌های بحث‌شده برای نظارت بر عملیات لغو را نشان می‌دهد. تغییرات کلیدی با <strong>بولد</strong> مشخص شده‌اند:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;

WriteLine(<span class="hljs-string">&quot;Monitoring the cancellation operation.&quot;</span>);

<span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-keyword">var</span> token = tokenSource.Token;

token.Register(
    () =&gt;
    {
        WriteLine(<span class="hljs-string">&quot;Cancelling the print activity.[Using event subscription]&quot;</span>);
        <span class="hljs-comment">// اگر خواستید کار دیگری انجام دهید</span>
    }
);

<span class="hljs-keyword">var</span> printTask = Task.Run
(
    () =&gt;
    {
        <span class="hljs-comment">// حلقه‌ای که 100 بار اجرا می‌شود</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
        {
            <span class="hljs-comment">// Approach-3</span>
            token.ThrowIfCancellationRequested();
            WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">{i}</span>&quot;</span>);
            <span class="hljs-comment">// اضافه کردن تاخیر برای مشاهده بهتر</span>
            Thread.Sleep(<span class="hljs-number">500</span>);
        }
    }, token
);

Task.Run(
    () =&gt;
    {
        token.WaitHandle.WaitOne();
        WriteLine(<span class="hljs-string">&quot;Cancelling the print activity.[Using WaitHandle]&quot;</span>);
        <span class="hljs-comment">// اگر خواستید کار دیگری انجام دهید</span>
    }
);

WriteLine(<span class="hljs-string">&quot;Enter c to cancel the task.&quot;</span>);
<span class="hljs-built_in">char</span> ch = ReadKey().KeyChar;
<span class="hljs-keyword">if</span> (ch.Equals(<span class="hljs-string">&#x27;c&#x27;</span>))
{
    WriteLine(<span class="hljs-string">&quot;\nTask cancellation requested.&quot;</span>);
    tokenSource.Cancel();
}

<span class="hljs-comment">// تا پایان اجرای تسک منتظر بمانید</span>
<span class="hljs-keyword">while</span> (!printTask.IsCompleted) { }
WriteLine(<span class="hljs-string">$&quot;The final status of printTask is: <span class="hljs-subst">{printTask.Status}</span>&quot;</span>);
WriteLine(<span class="hljs-string">&quot;End of the main thread.&quot;</span>);
</code></pre>
<hr>
<p>📤 <strong>خروجی نمونه</strong></p>
<p>توجه کنید تغییرات بولد شده‌اند:</p>
<pre class="hljs"><code>Monitoring the cancellation operation.
Enter c to cancel the task.
0
1
2
c
Task cancellation requested.
Cancelling the print activity.[Using WaitHandle]
Cancelling the print activity.[Using event subscription]
The final status of printTask is: Canceled
End of the main thread.
</code></pre>
<hr>
<p>🌐 <strong>استفاده از چندین Cancellation Token</strong></p>
<p>یک برنامه می‌تواند به دلایل مختلف لغو شود. در چنین حالتی، می‌توانید از چندین token استفاده کنید و منطق لازم را اعمال کنید. در این زمینه می‌توانید از متد <code>CreateLinkedTokenSource</code> استفاده کنید.</p>
<p>در دمو زیر، دو token مختلف ایجاد می‌کنیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> normalCancellation = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-keyword">var</span> tokenNormal = normalCancellation.Token;

<span class="hljs-keyword">var</span> unexpectedCancellation = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-keyword">var</span> tokenUnexpected = unexpectedCancellation.Token;
</code></pre>
<p>پس از ایجاد، آن‌ها را به متد <code>CreateLinkedTokenSource</code> می‌دهیم:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> compositeToken = CancellationTokenSource.CreateLinkedTokenSource(tokenNormal, tokenUnexpected);
</code></pre>
<p>ایده این است که شما می‌توانید با لغو هر یک از <code>normalCancellation</code> یا <code>unexpectedCancellation</code>، تسک نهایی را لغو کنید.</p>
<p>توجه داشته باشید که متد <code>CreateLinkedTokenSource</code> اورلودهای مختلفی دارد و در صورت نیاز می‌توانید تعداد بیشتری token ارسال کنید. نکته‌ی اصلی همان است: می‌توانید هر یک از این token‌ها را لغو کنید تا وضعیت نهایی تسک <code>Canceled</code> شود.<br>
📌 <strong>Demonstration 4 – دمو چهارم</strong></p>
<p>در برنامه‌ی زیر، کاربر می‌تواند یک لغو معمولی (normal cancellation) را فعال کند. با این حال، شما می‌توانید یک لغو غیرمنتظره/اضطراری (unexpected/emergency cancellation) را نیز مشاهده کنید.</p>
<p>برای شبیه‌سازی لغو اضطراری، من از یک تولیدکننده‌ی عدد تصادفی استفاده می‌کنم. اگر عدد تصادفی برابر ۵ باشد، لغو اضطراری فعال خواهد شد.</p>
<p>کد کامل برنامه برای نمایش این ایده به شکل زیر است:</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;

WriteLine(<span class="hljs-string">&quot;Monitoring the cancellation operation.&quot;</span>);

<span class="hljs-keyword">var</span> normalCancellation = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-keyword">var</span> tokenNormal = normalCancellation.Token;

<span class="hljs-keyword">var</span> unexpectedCancellation = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-keyword">var</span> tokenUnexpected = unexpectedCancellation.Token;

tokenNormal.Register(
    () =&gt;
    {
        WriteLine(<span class="hljs-string">&quot;Processing a normal cancellation.&quot;</span>);
        <span class="hljs-comment">// اگر خواستید کار دیگری انجام دهید</span>
    }
);

tokenUnexpected.Register(
    () =&gt;
    {
        WriteLine(<span class="hljs-string">&quot;Processing an unexpected cancellation.&quot;</span>);
        <span class="hljs-comment">// اگر خواستید کار دیگری انجام دهید</span>
    }
);

<span class="hljs-keyword">var</span> compositeToken = CancellationTokenSource.CreateLinkedTokenSource(tokenNormal, tokenUnexpected);

<span class="hljs-keyword">var</span> printTask = Task.Run
(
    () =&gt;
    {
        <span class="hljs-comment">// حلقه‌ای که 100 بار اجرا می‌شود</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
        {
            compositeToken.Token.ThrowIfCancellationRequested();
            WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">{i}</span>&quot;</span>);
            <span class="hljs-comment">// اضافه کردن تاخیر برای مشاهده بهتر</span>
            Thread.Sleep(<span class="hljs-number">500</span>);
        }
    }, compositeToken.Token
);

<span class="hljs-comment">// منطق ساده برای شبیه‌سازی لغو اضطراری</span>
<span class="hljs-built_in">int</span> random = <span class="hljs-keyword">new</span> Random().Next(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>);
<span class="hljs-keyword">if</span> (random == <span class="hljs-number">5</span>)
    unexpectedCancellation.Cancel();

WriteLine(<span class="hljs-string">&quot;Enter a key (type c for a normal cancellation)&quot;</span>);
<span class="hljs-built_in">char</span> ch = ReadKey().KeyChar;
<span class="hljs-keyword">if</span> (ch.Equals(<span class="hljs-string">&#x27;c&#x27;</span>))
{
    WriteLine(<span class="hljs-string">&quot;\nTask cancellation requested.&quot;</span>);
    normalCancellation.Cancel();
}

<span class="hljs-comment">// تا پایان اجرای تسک منتظر بمانید</span>
<span class="hljs-keyword">while</span> (!printTask.IsCompleted) { }

WriteLine(<span class="hljs-string">$&quot;The final status of printTask is: <span class="hljs-subst">{printTask.Status}</span>&quot;</span>);
WriteLine(<span class="hljs-string">&quot;End of the main thread.&quot;</span>);
</code></pre>
<hr>
<p>📤 <strong>خروجی نمونه – لغو معمولی</strong><br>
زمانی که کاربر “c” را فشار می‌دهد:</p>
<pre class="hljs"><code>Monitoring the cancellation operation.
Enter a key (type c for a normal cancellation)
0
1
2
c
Task cancellation requested.
Processing a normal cancellation.
The final status of printTask is: Canceled
End of the main thread.
</code></pre>
<p>📤 <strong>خروجی نمونه – لغو اضطراری</strong><br>
زمانی که لغو اضطراری به‌صورت خودکار فعال می‌شود:</p>
<pre class="hljs"><code>Monitoring the cancellation operation.
Processing an unexpected cancellation.
The final status of printTask is: Canceled
End of the main thread.
</code></pre>
<p>📌 <strong>خلاصه – Summary</strong></p>
<p>لغو (Cancellation) یک مکانیزم اساسی در برنامه‌نویسی Task است. با این حال، به جای متوقف کردن ناگهانی یک تسک، شما یک مدل همکاری ایجاد می‌کنید که در آن تسک و کدی که لغو را آغاز می‌کند (calling code) با هم کار می‌کنند تا سلامت برنامه شما حفظ شود.</p>
<p>این فصل به این موضوع پرداخت و به سؤالات زیر پاسخ داد:</p>
<ul>
<li>چگونه می‌توان لغوهای مبتنی بر کاربر (user-initiated cancellations) را پشتیبانی کرد؟ 🤚</li>
<li>چگونه می‌توان لغوهای مبتنی بر زمان (timeout cancellations) را پشتیبانی کرد؟ ⏱️</li>
<li>چگونه می‌توان لغوها را در برنامه خود مانیتور کرد؟ 👀</li>
<li>چگونه می‌توان از چندین CancellationToken در برنامه خود استفاده کرد؟ 🔗</li>
<li></li>
</ul>
<p>📝 <strong>تمرین‌ها – Exercises</strong></p>
<p>برای سنجش درک خود، تمرین‌های زیر را انجام دهید:</p>
<div align="center">
<p><img src="../../../assets/image/05/Table%205-2.jpeg" alt="Conventions-UsedThis-Book"></p>
</div>
<p>🔔 <strong>یادآوری – Reminder</strong></p>
<p>همان‌طور که قبلاً گفته شد، می‌توانید با اطمینان فرض کنید که همه‌ی namespaceهای لازم برای این قطعه‌های کد در دسترس هستند. این نکته برای همه‌ی تمرین‌های کتاب نیز صادق است.</p>
<hr>
<p>📝 <strong>تمرین‌ها – Exercises</strong></p>
<p><strong>E5.1</strong><br>
اگر کد زیر را اجرا کنید، آیا می‌توانید خروجی آن را پیش‌بینی کنید؟</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;

<span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-keyword">var</span> token = tokenSource.Token;

<span class="hljs-keyword">var</span> printTask = Task.Run(
    () =&gt;
    {
        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i != <span class="hljs-number">10</span>)
        {
            <span class="hljs-keyword">if</span> (token.IsCancellationRequested)
            {
                WriteLine(<span class="hljs-string">&quot;Cancelling the print activity.&quot;</span>);
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">// در صورت نیاز، انجام کارهای دیگر</span>
            Thread.Sleep(<span class="hljs-number">1000</span>);
            i++;
        }
    }, token
);

Thread.Sleep(<span class="hljs-number">500</span>);
WriteLine(<span class="hljs-string">&quot;The cancellation is initiated.&quot;</span>);
tokenSource.Cancel();

<span class="hljs-comment">// منتظر بمانید تا Task کامل شود</span>
<span class="hljs-keyword">while</span> (!printTask.IsCompleted) { }

WriteLine(<span class="hljs-string">$&quot;The final status of printTask is: <span class="hljs-subst">{printTask.Status}</span>&quot;</span>);
WriteLine(<span class="hljs-string">&quot;End of the main thread.&quot;</span>);
</code></pre>
<hr>
<p><strong>E5.2</strong><br>
در تمرین قبلی، قطعه کد زیر:</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (token.IsCancellationRequested)
{
    WriteLine(<span class="hljs-string">&quot;Cancelling the print activity.&quot;</span>);
    <span class="hljs-keyword">return</span>;
}
</code></pre>
<p>را با این خط جایگزین کنید:</p>
<pre class="hljs"><code>token.ThrowIfCancellationRequested();
</code></pre>
<p>آیا تغییر خروجی اتفاق می‌افتد؟ 🤔</p>
<hr>
<p><strong>E5.3</strong><br>
برنامه‌ی زیر یک Task والد و یک Task تو در تو (nested) ایجاد می‌کند. همچنین امکان لغو این Taskها با فشار دادن کلید “c” فراهم شده است. آیا می‌توانید خروجی آن را پیش‌بینی کنید؟</p>
<pre class="hljs"><code><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> System.Console;
WriteLine(<span class="hljs-string">&quot;Exercise 5.3&quot;</span>);

<span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();
<span class="hljs-keyword">var</span> token = tokenSource.Token;
Task child = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">var</span> parent = Task.Factory.StartNew(
    () =&gt;
    {
        Thread.Sleep(<span class="hljs-number">1000</span>);
        <span class="hljs-keyword">if</span> (token.IsCancellationRequested)
        {
            WriteLine(<span class="hljs-string">&quot;The cancellation request is raised too early.&quot;</span>);
            token.ThrowIfCancellationRequested();
        }

        WriteLine(<span class="hljs-string">&quot;The parent task is running.&quot;</span>);
        <span class="hljs-comment">// ایجاد Task تو در تو</span>
        child = Task.Factory.StartNew(
            () =&gt;
            {
                WriteLine(<span class="hljs-string">&quot;The child task has started.&quot;</span>);
                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
                {
                    token.ThrowIfCancellationRequested();
                    WriteLine(<span class="hljs-string">$&quot;\tThe nested task prints:<span class="hljs-subst">{i}</span>&quot;</span>);
                    Thread.Sleep(<span class="hljs-number">200</span>);
                }
                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The child task has finished too&quot;</span>;
            },
            token,
            TaskCreationOptions.AttachedToParent,
            TaskScheduler.Default
        );

        child.Wait(token);
    }, token
);

WriteLine(<span class="hljs-string">&quot;Enter c to cancel the nested task.&quot;</span>);
<span class="hljs-built_in">char</span> ch = ReadKey().KeyChar;

<span class="hljs-keyword">if</span> (ch.Equals(<span class="hljs-string">&#x27;c&#x27;</span>))
{
    WriteLine(<span class="hljs-string">&quot;\nTask cancellation requested.&quot;</span>);
    tokenSource.Cancel();
}

<span class="hljs-keyword">try</span>
{
    parent.Wait();
}
<span class="hljs-keyword">catch</span> (AggregateException ae)
{
    <span class="hljs-keyword">foreach</span> (Exception e <span class="hljs-keyword">in</span> ae.InnerExceptions)
    {
        WriteLine(<span class="hljs-string">$&quot;Caught error: <span class="hljs-subst">{e.Message}</span>&quot;</span>);
    }
}

WriteLine(<span class="hljs-string">$&quot;The current state of the parent task: <span class="hljs-subst">{parent.Status}</span>&quot;</span>);
<span class="hljs-built_in">string</span> childStatus = child != <span class="hljs-literal">null</span> ? child.Status.ToString() : <span class="hljs-string">&quot;not created&quot;</span>;
WriteLine(<span class="hljs-string">$&quot;The current state of the child task: <span class="hljs-subst">{childStatus}</span>&quot;</span>);
WriteLine(<span class="hljs-string">&quot;End of the main thread.&quot;</span>);
</code></pre>
<hr>
<p><strong>E5.4</strong> – درست/نادرست:<br>
i) کلاس <code>CancellationTokenSource</code> یک کلاس است که اینترفیس <code>IDisposable</code> را پیاده‌سازی می‌کند. ✅ / ❌<br>
ii) ویژگی <code>Token</code> از کلاس <code>CancellationTokenSource</code> برای ایجاد نمونه‌ی <code>CancellationToken</code> استفاده می‌شود. ✅ / ❌</p>
<hr>
<p><strong>E5.5</strong><br>
در فصل ۳، شما تمرین E3.2 را حل کرده‌اید. اکنون با توجه به اینکه با سناریوهای استثنا (Exception) و لغو Task (Cancellation) آشنا شده‌اید، آیا می‌توانید همان تمرین را دوباره با در نظر گرفتن این سناریوها حل کنید؟ 💡</p>
<p>💡 <strong>راه‌حل تمرین‌ها – Solutions to Exercises</strong></p>
<hr>
<h3><strong>E5.1</strong></h3>
<p>برنامه به‌طور خودکار لغو (cancellation) را اجرا می‌کند. یک خروجی احتمالی به شکل زیر است (توجه کنید که وضعیت نهایی Task برابر <strong>RanToCompletion</strong> است و نه <strong>Canceled</strong>):</p>
<pre class="hljs"><code>The cancellation is initiated.
Cancelling the print activity.
The final status of printTask is: RanToCompletion
End of the main thread.
</code></pre>
<hr>
<h3><strong>E5.2</strong></h3>
<p>این بار وضعیت نهایی Task باید به صورت <strong>Canceled</strong> نمایش داده شود. نمونه خروجی:</p>
<pre class="hljs"><code>The cancellation is initiated.
The final status of printTask is: Canceled
End of the main thread.
</code></pre>
<hr>
<h3><strong>E5.3</strong></h3>
<p>همان‌طور که می‌دانید، این برنامه یک Task والد و یک Task تو در تو (nested) ایجاد می‌کند و به شما اجازه می‌دهد با فشار دادن کلید “c” Task تو در تو را لغو کنید. بنابراین، بسته به زمان لغو، خروجی متفاوت خواهد بود:</p>
<p><strong>اگر لغو انجام نشود و در پایان Enter بزنید، خروجی ممکن است به شکل زیر باشد:</strong></p>
<pre class="hljs"><code>Exercise 5.3
Enter c to cancel the nested task.
The parent task is running.
The child task has started.
The nested task prints:0
The nested task prints:1
The nested task prints:2
The nested task prints:3
The nested task prints:4
The nested task prints:5
The nested task prints:6
The nested task prints:7
The nested task prints:8
The nested task prints:9
The current state of the parent task: RanToCompletion
The current state of the child task: RanToCompletion
End of the main thread.
</code></pre>
<p><strong>اگر کلید “c” تقریباً در ابتدای برنامه فشار داده شود، خروجی ممکن است چنین باشد:</strong></p>
<pre class="hljs"><code>Exercise 5.3
Enter c to cancel the nested task.
c
Task cancellation requested.
The cancellation request is raised too early.
Caught error: A task was canceled.
The current state of the parent task: Canceled
The current state of the child task: not created
End of the main thread.
</code></pre>
<p><strong>و یا یک لغو عادی که به شکل زیر است:</strong></p>
<pre class="hljs"><code>Exercise 5.3
Enter c to cancel the nested task.
The parent task is running.
The child task has started.
The nested task prints:0
The nested task prints:1
c
Task cancellation requested.
Caught error: A task was canceled.
The current state of the parent task: Canceled
The current state of the child task: Canceled
End of the main thread.
</code></pre>
<hr>
<h3><strong>E5.4</strong> – درست/نادرست ✅❌</h3>
<p>i) کلاس <code>CancellationTokenSource</code> یک کلاس است که اینترفیس <code>IDisposable</code> را پیاده‌سازی می‌کند. <strong>[True ✅]</strong><br>
ii) ویژگی <code>Token</code> از کلاس <code>CancellationTokenSource</code> برای ایجاد نمونه‌ی <code>CancellationToken</code> استفاده می‌شود. <strong>[True ✅]</strong></p>
<hr>
<h3><strong>E5.5</strong></h3>
<p>این تمرین را هم‌اکنون به خودتان واگذار می‌کنم. موفق باشید! 🍀</p>
<p>💡 <strong>توجه اضافی:</strong> از این به بعد، هنگام حل تمرین‌ها، می‌توانید مکانیزم‌های لغو (cancellation) و مدیریت استثنا (exception) را هم اعمال کنید. همین نکته برای تمرین‌هایی که در فصل‌های قبلی حل کرده‌اید نیز صادق است.</p>

  </main>

  <!-- فوتر مشترک -->
  <footer class="footer">
    <div class="container">
      <p>
        <img src="/Gitab/icone/copyright.svg" alt="کپی‌رایت" width="14" height="14"
             style="vertical-align:middle;margin-inline:4px">
        <span id="y"></span> Gitab — برای توسعه‌دهندگان
      </p>
    </div>
  </footer>

  <!-- سال و اسکریپت تغییر تم -->
  <script>
  (() => {
    const root = document.documentElement;
    const btn = document.getElementById('themeToggle');
    const KEY = 'gitab-theme';

    function updateTheme(s) {
      root.setAttribute('data-theme', s);
      const mode = s;  // فقط `dark` یا `light` خواهد بود
      root.dataset.colorMode = mode;
      btn.dataset.icon = mode === 'dark' ? 'moon' : 'sun';
    }

    // وضعیت تم ذخیره شده از localStorage
    let saved = localStorage.getItem(KEY) || 'light'; // پیش‌فرض روشن
    updateTheme(saved);

    // تنظیم مجدد تم هنگام تغییر وضعیت دکمه
    btn.addEventListener('click', () => {
      const current = localStorage.getItem(KEY) || 'light';
      const next = current === 'dark' ? 'light' : 'dark';  // فقط دو حالت: تاریک و روشن
      localStorage.setItem(KEY, next);
      updateTheme(next);
    });

    // هنگام بارگذاری صفحه
    document.addEventListener('DOMContentLoaded', () => {
      updateTheme(localStorage.getItem(KEY) || 'light');
    });
  })();
</script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <script>
  document.querySelectorAll('pre code').forEach(block => {
    const btn = document.createElement('button');
    btn.className = 'copy-btn';

    const icon = document.createElement('img');
    icon.src = "/Gitab/icone/copy.svg";
    icon.alt = 'Copy';
    btn.appendChild(icon);

    block.parentNode.insertBefore(btn, block);

    btn.addEventListener('click', async () => {
      await navigator.clipboard.writeText(block.textContent);
      btn.classList.add('copied');
      setTimeout(() => btn.classList.remove('copied'), 1500);
    });
  });
  </script>

  <script>
  document.body.dataset.page = window.location.pathname;

  const menuBtn = document.querySelector(".menu-toggle");
  const nav = document.querySelector(".nav");

  if (menuBtn && nav) {
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      nav.classList.toggle("show");
    });

    document.addEventListener("click", (e) => {
      const clickedInsideNav = nav.contains(e.target);
      const clickedMenuButton = menuBtn.contains(e.target);
      if (!clickedInsideNav && !clickedMenuButton) {
        nav.classList.remove("show");
      }
    });
  }
  </script>

  <script>
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
  <script>
document.getElementById("openDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "block";
});
document.getElementById("closeDonate").addEventListener("click", () => {
  document.getElementById("donateModal").style.display = "none";
});
document.querySelectorAll(".copy-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(btn.dataset.copy);
    btn.textContent = "✅ کپی شد!";
    setTimeout(() => (btn.textContent = "کپی"), 2000);
  });
});
</script>

</body>
</html>
