# ۱

# استانداردهای کدنویسی و اصول در سی‌شارپ

هدف اصلی استانداردهای کدنویسی و اصول در C# این است که برنامه‌نویسان با تولید کدی که هم عملکرد بهتری دارد و هم نگهداری آن آسان‌تر است، در حرفه خود ارتقا یابند. در این فصل، به بررسی نمونه‌هایی از کدهای خوب در مقابل کدهای بد خواهیم پرداخت. این موضوع ما را به بحث درباره اینکه چرا به استانداردهای کدنویسی، اصول و متدولوژی‌ها نیاز داریم، سوق می‌دهد. سپس به بررسی قراردادهای نام‌گذاری، کامنت‌گذاری و فرمت‌بندی کد منبع، شامل کلاس‌ها، متدها و متغیرها خواهیم پرداخت.

یک برنامه بزرگ می‌تواند برای درک و نگهداری بسیار پیچیده و دشوار باشد. برای برنامه‌نویسان تازه‌کار، شناخت کد و درک عملکرد آن می‌تواند چشم‌اندازی دلهره‌آور باشد. تیم‌ها ممکن است در کار گروهی روی چنین پروژه‌هایی با مشکل مواجه شوند. و از دیدگاه تست، می‌تواند کارها را بسیار دشوار کند. به همین دلیل، بررسی خواهیم کرد که چگونه از ماژولار بودن (modularity) استفاده می‌کنید تا برنامه‌ها را به ماژول‌های کوچک‌تر تقسیم کنید که همگی با هم کار می‌کنند تا یک راه‌حل کاملاً کارآمد و قابل تست را ارائه دهند، که می‌تواند به صورت همزمان توسط چندین تیم روی آن کار شود و خواندن، درک و مستندسازی آن بسیار آسان‌تر است.

در پایان این فصل، به بررسی برخی از دستورالعمل‌های طراحی برنامه‌نویسی، شامل KISS، YAGNI، DRY، SOLID و تیغ اوکام (Occam's Razor) خواهیم پرداخت.

#### استانداردهای کدنویسی و اصول در سی‌شارپ

فصل ۱

مباحث زیر در این فصل پوشش داده خواهند شد:

+ نیاز به استانداردهای کدنویسی، اصول و متدولوژی‌ها

+ قراردادهای نام‌گذاری و متدها

+ کامنت‌ها و فرمت‌بندی

+ ماژولار بودن

+ KISS

+ YAGNI

+ DRY

+ SOLID

+ تیغ اوکام (Occam's Razor)

 اهداف یادگیری شما برای این فصل به شرح زیر است:

+ درک اینکه چرا کدهای بد تأثیر منفی بر پروژه‌ها می‌گذارند.

+ درک اینکه چگونه کدهای خوب تأثیر مثبتی بر پروژه‌ها دارند.

+ درک اینکه چگونه استانداردهای کدنویسی کیفیت کد را بهبود می‌بخشند و چگونه آنها را اعمال کنید.

+ درک اینکه چگونه اصول کدنویسی کیفیت نرم‌افزار را ارتقا می‌دهند.

+ درک اینکه چگونه متدولوژی‌ها به توسعه کدهای تمیز کمک می‌کنند.

+ پیاده‌سازی استانداردهای کدنویسی.

+ انتخاب راه‌حل‌هایی با کمترین فرضیات ممکن.

+ کاهش تکرار کد و نوشتن کد SOLID.

## الزامات فنی

برای کار بر روی کدهای این فصل، باید Visual Studio 2019 Community Edition یا نسخه‌های بالاتر را دانلود و نصب کنید. این IDE را می‌توانید از <https://visualstudio.microsoft.com/> دانلود کنید.

کدهای این کتاب در <https://github.com/PacktPublishing/Clean-Code-in-C-> قرار دارند. من همه آنها را در یک solution واحد با هر فصل به عنوان یک پوشه solution قرار داده‌ام. کدهای مربوط به هر فصل را در پوشه فصل مربوطه پیدا خواهید کرد. اگر پروژه‌ای را اجرا می‌کنید، به یاد داشته باشید که آن را به عنوان پروژه Startup تعیین کنید.

## کد خوب در مقابل کد بد

هم کد خوب و هم کد بد کامپایل می‌شوند. این اولین چیزی است که باید درک کرد. نکته بعدی این است که کد بد به دلیلی بد است و به همین ترتیب، کد خوب نیز به دلیلی خوب است. بیایید در جدول مقایسه‌ای زیر به برخی از این دلایل نگاهی بیندازیم:

<div align="center">
  
  ![Conventions-UsedThis-Book](../../../assets/image/01/Table%201-1.png)
  
</div>

همینطور است! در بخش‌های بعدی، به این خواهیم پرداخت که چگونه این ویژگی‌ها و تفاوت‌های بین کدهای خوب و بد، بر عملکرد کد شما تأثیر می‌گذارند.

## کد بد

اکنون نگاهی اجمالی به هر یک از شیوه‌های کدنویسی بد که قبلاً فهرست کردیم خواهیم داشت و به طور خاص توضیح می‌دهیم که هر یک از این شیوه‌ها چگونه بر کد شما تأثیر می‌گذارند.

## تورفتگی نامناسب (Improper indentation)

تورفتگی نامناسب می‌تواند باعث شود خواندن کد واقعاً دشوار شود، به خصوص اگر متدها بزرگ باشند. برای اینکه کد برای انسان‌ها به راحتی قابل خواندن باشد، به تورفتگی مناسب نیاز داریم. اگر کد فاقد تورفتگی صحیح باشد، تشخیص اینکه کدام قسمت از کد متعلق به کدام بلوک است، بسیار دشوار خواهد بود.

به طور پیش‌فرض، Visual Studio 2019 کد شما را هنگام بسته شدن پرانتزها و براکت‌ها (آکولادها) به درستی فرمت و تورفتگی می‌دهد. اما گاهی اوقات، به اشتباه کد را فرمت می‌کند تا به شما هشدار دهد که کدی که نوشته‌اید حاوی یک استثنا است. اما اگر از یک ویرایشگر متن ساده استفاده می‌کنید، باید فرمت‌بندی خود را به صورت دستی انجام دهید.

کد دارای تورفتگی نادرست همچنین زمان‌بر برای تصحیح است و هدر دادن ناامیدکننده زمان برنامه‌نویسی است، در حالی که به راحتی می‌توان از آن اجتناب کرد. بیایید به یک مثال کد ساده نگاه کنیم:

```C#

public void DoSomething()
{
    for (var i = 0; i < 1000; i++)
    {
        var productCode = $"PRC000{i}";
        //...implementation
    }
}
```

کد بالا آنقدر هم خوب به نظر نمی‌رسد، با این حال هنوز قابل خواندن است. اما هرچه خطوط کد بیشتری اضافه کنید، خواندن کد دشوارتر می‌شود.

جا انداختن یک براکت بسته بسیار آسان است. اگر کد شما به درستی تورفتگی نداشته باشد، یافتن براکت گم‌شده بسیار دشوارتر می‌شود، زیرا نمی‌توانید به راحتی تشخیص دهید که کدام بلوک کد براکت بسته‌اش را گم کرده است.

## کامنت‌هایی که بدیهیات را بیان می‌کنند (Comments that state the obvious)

من دیده‌ام که برنامه‌نویسان واقعاً از کامنت‌هایی که بدیهیات را بیان می‌کنند عصبانی می‌شوند، زیرا آنها را تحقیرآمیز می‌دانند. در بحث‌های برنامه‌نویسی که من در آنها شرکت کرده‌ام، برنامه‌نویسان اظهار داشته‌اند که چقدر از کامنت‌ها بیزارند و چگونه معتقدند که کد باید خود-مستندساز (self-documenting) باشد.

من احساسات آنها را درک می‌کنم. اگر می‌توانید کد را بدون کامنت بخوانید، مانند زمانی که یک کتاب را می‌خوانید و آن را درک می‌کنید، پس آن یک قطعه کد واقعاً خوب است. اگر یک متغیر به عنوان رشته (string) اعلان شده است، پس چرا کامنتی مانند // string اضافه کنید؟ بیایید به یک مثال نگاه کنیم:

```C#

public int _value; // This is used for storing integer values.
```

در اینجا می‌دانیم که value یک عدد صحیح را توسط نوع int خود نگه می‌دارد. بنابراین واقعاً نیازی به بیان بدیهیات نیست. تنها کاری که انجام می‌دهید هدر دادن زمان و انرژی و شلوغ کردن کد است.

## کامنت‌هایی که کد بد را توجیه می‌کنند (Comments that excuse bad code)

ممکن است مهلت تنگی برای رسیدگی داشته باشید، اما کامنت‌هایی مانند // I know this code sucks but hey at least it works! واقعاً وحشتناک هستند. این کار را نکنید. این نشان‌دهنده عدم حرفه‌ای‌گری است و می‌تواند واقعاً باعث نارضایتی همکاران برنامه‌نویس شود.

اگر واقعاً برای اینکه چیزی را به سرعت کارساز کنید تحت فشار هستید، یک تیکت بازسازی (refactor ticket) ایجاد کنید و آن را به عنوان بخشی از یک کامنت TODO اضافه کنید، مانند // TODO: PBI23154 Refactor Code to meet company coding practices. سپس شما یا سایر توسعه‌دهندگانی که برای کار روی بدهی فنی (technical debt) تعیین شده‌اند، می‌توانند آن آیتم بک‌لاگ محصول (Product Backlog Item - PBI) را برداشته و کد را بازسازی (refactor) کنند.

در اینجا یک مثال دیگر آورده شده است:

```C#

...
int value = GetDataValue(); // This sometimes causes a divide by zero error. Don't know why!
...
```

این یکی واقعاً بد است. بسیار خب، از اینکه به ما اطلاع دادید خطاهای تقسیم بر صفر در اینجا رخ می‌دهند، متشکریم. اما آیا یک تیکت باگ (bug ticket) ایجاد کرده‌اید؟ آیا سعی کرده‌اید به ریشه مشکل برسید و آن را برطرف کنید؟ اگر هر کسی که فعالانه روی پروژه کار می‌کند به آن کد دست نزند، چگونه متوجه می‌شوند که کد مشکل‌دار در آنجا وجود دارد؟

در حداقل حالت، حداقل باید یک کامنت // TODO: در محل داشته باشید. سپس حداقل کامنت در لیست وظایف (Task List) ظاهر می‌شود تا توسعه‌دهندگان مطلع شده و روی آن کار کنند.

## خطوط کد کامنت‌شده (Commented-out lines of code)

اگر برای امتحان کردن چیزی، خطوط کد را کامنت می‌کنید (comment out)، اشکالی ندارد. اما اگر قصد دارید از کد جایگزین به جای کد کامنت‌شده استفاده کنید، قبل از اینکه آن را چک‌این کنید (check it in)، کد کامنت‌شده را حذف کنید. یک یا دو خط کامنت‌شده آنقدر هم بد نیست. اما وقتی خطوط زیادی از کد کامنت‌شده دارید، حواس‌پرتی ایجاد می‌کند و نگهداری کد را دشوار می‌کند؛ حتی می‌تواند منجر به سردرگمی شود:

```C#

/* No longer used as has been replaced by DoSomethinElse().
public void DoSomething()
{
    // ...implementation...
}
*/
```

چرا؟ فقط چرا؟ اگر جایگزین شده و دیگر مورد نیاز نیست، پس فقط آن را حذف کنید. اگر کد شما در سیستم کنترل نسخه (version control) است و نیاز دارید متد را برگردانید، همیشه می‌توانید تاریخچه فایل را مشاهده کرده و متد را برگردانید.

## سازماندهی نامناسب فضای نام‌ها (Improper organization of namespaces)

هنگام استفاده از فضاهای نام (namespaces)، کدهایی را که باید در جای دیگری باشند، در آن نگنجانید. این کار می‌تواند یافتن کد صحیح را به خصوص در پایگاه‌های کد بزرگ، بسیار دشوار یا غیرممکن کند. بیایید به این مثال نگاه کنیم:

```C#

namespace MyProject.TextFileMonitor
{
    + public class Program { ... }
    + public class DateTime { ... }
    + public class FileMonitorService { ... }
    + public class Cryptography { ... }
}
```

می‌بینیم که تمام کلاس‌های موجود در کد بالا تحت یک فضای نام قرار دارند. با این حال، ما این فرصت را داریم که سه فضای نام دیگر برای سازماندهی بهتر این کد اضافه کنیم:

+ MyProject.TextFileMonitor.Core: کلاس‌های هسته (Core) که اعضای متداول را تعریف می‌کنند، مانند کلاس DateTime ما، در اینجا قرار خواهند گرفت.

+ MyProject.TextFileMonitor.Services: تمام کلاس‌هایی که به عنوان سرویس عمل می‌کنند، مانند FileMonitorService، در این فضای نام قرار خواهند گرفت.

+ MyProject.TextFileMonitor.Security: تمام کلاس‌های مرتبط با امنیت، از جمله کلاس Cryptography در مثال ما، در این فضای نام قرار خواهند گرفت.

## قوانین نام‌گذاری بد (Bad naming conventions)

در دوران برنامه‌نویسی Visual Basic 6، از نشانه‌گذاری مجارستانی (Hungarian Notation) استفاده می‌کردیم. یادم می‌آید وقتی برای اولین بار به Visual Basic 1.0 تغییر برنامه دادم از آن استفاده می‌کردم. دیگر نیازی به استفاده از نشانه‌گذاری مجارستانی نیست. به علاوه، کد شما را زشت می‌کند. بنابراین به جای استفاده از نام‌هایی مانند lblName، txtName یا btnSave، روش مدرن استفاده از NameLabel، NameTextBox و SaveButton است.

استفاده از نام‌های مرموز و نام‌هایی که به نظر نمی‌رسد با هدف کد مطابقت داشته باشند، می‌تواند خواندن کد را نسبتاً دشوار کند. ihridx به چه معناست؟ به معنای Human Resources Index و یک عدد صحیح است. واقعاً! از استفاده از نام‌هایی مانند mystring، myint و mymethod خودداری کنید. چنین نام‌هایی واقعاً کاربردی ندارند.

همچنین از استفاده از آندرلاین بین کلمات در یک نام، مانند Bad_Programmer، خودداری کنید. این می‌تواند باعث فشار بصری برای توسعه‌دهندگان شود و خواندن کد را دشوار کند. کافیست آندرلاین را حذف کنید.

از یک قرارداد کدنویسی برای متغیرها در سطح کلاس و سطح متد استفاده نکنید. این می‌تواند تشخیص محدوده یک متغیر را دشوار کند. یک قرارداد خوب برای نام‌گذاری متغیرها استفاده از حالت شتری (camel case) برای نام متغیرها مانند alienSpawn، و حالت پاسکال (Pascal case) برای نام متد، کلاس، ساختار (struct) و اینترفیس (interface) مانند EnemySpawnGenerator است.

با پیروی از قرارداد نام‌گذاری متغیر خوب، باید بین متغیرهای محلی (local variables) (آنهایی که در یک سازنده یا متد قرار دارند) و متغیرهای عضو (member variables) (آنهایی که در بالای کلاس خارج از سازنده‌ها و متدها قرار می‌گیرند) با پیشوندگذاری متغیرهای عضو با یک آندرلاین تمایز قائل شوید. من از این به عنوان یک قرارداد کدنویسی در محل کار استفاده کرده‌ام و واقعاً خوب کار می‌کند و به نظر می‌رسد برنامه‌نویسان این قرارداد را دوست دارند.

## کلاس‌هایی که چندین کار انجام می‌دهند (Classes that do multiple jobs)

یک کلاس خوب باید فقط یک کار را انجام دهد. داشتن کلاسی که به پایگاه داده متصل می‌شود، داده‌ها را دریافت می‌کند، آن داده‌ها را دستکاری می‌کند، یک گزارش را بارگذاری می‌کند، داده‌ها را به گزارش اختصاص می‌دهد، گزارش را نمایش می‌دهد، گزارش را ذخیره می‌کند، گزارش‌ها را چاپ می‌کند و گزارش را اکسپورت می‌کند، کارهای زیادی انجام می‌دهد. باید آن را به کلاس‌های کوچک‌تر و بهتر سازمان‌یافته بازسازی (refactored) کرد. کلاس‌های جامع مانند این برای خواندن بسیار آزاردهنده هستند. من شخصاً آنها را دلهره‌آور می‌یابم. اگر با چنین کلاس‌هایی مواجه شدید، قابلیت‌ها را به بخش‌ها (regions) سازماندهی کنید. سپس کد موجود در آن بخش‌ها را به کلاس‌های جدیدی منتقل کنید که یک کار را انجام می‌دهند.

بیایید به مثالی از کلاسی که چندین کار را انجام می‌دهد نگاه کنیم:

```C#

public class DbAndFileManager
{
    #region Database Operations
    [ 13 ]
    Coding Standards and Principles in C#
    Chapter 1
    public void OpenDatabaseConnection() { throw new
        NotImplementedException(); }
    public void CloseDatabaseConnection() { throw new
        NotImplementedException(); }
    public int ExecuteSql(string sql) { throw new
        NotImplementedException(); }
    public SqlDataReader SelectSql(string sql) { throw new
        NotImplementedException(); }
    public int UpdateSql(string sql) { throw new
        NotImplementedException(); }
    public int DeleteSql(string sql) { throw new
        NotImplementedException(); }
    public int InsertSql(string sql) { throw new
        NotImplementedException(); }
    #endregion
    #region File Operations
    public string ReadText(string filename) { throw new
        NotImplementedException(); }
    public void WriteText(string filename, string text) { throw new
        NotImplementedException(); }
    public byte[] ReadFile(string filename) { throw new
        NotImplementedException(); }
    public void WriteFile(string filename, byte[] binaryData) { throw new
        NotImplementedException(); }
    #endregion
}
```

همانطور که در کد بالا می‌بینید، کلاس دو کار اصلی انجام می‌دهد: عملیات پایگاه داده و عملیات فایل را انجام می‌دهد. اکنون کد به طور مرتب در بخش‌های (regions) نام‌گذاری شده صحیح سازماندهی شده است که برای جداسازی منطقی کد در یک کلاس استفاده می‌شوند. اما اصل مسئولیت واحد (Single Responsibility Principle - SRP) نقض شده است. ما باید با بازسازی این کد شروع کنیم تا عملیات پایگاه داده را به کلاسی جداگانه، مانند DatabaseManager، منتقل کنیم.

سپس، عملیات پایگاه داده را از کلاس DbAndFileManager حذف می‌کنیم، فقط عملیات فایل را باقی می‌گذاریم و سپس کلاس DbAndFileManager را به FileManager تغییر نام می‌دهیم. همچنین باید فضای نام هر فایل را در نظر بگیریم و اینکه آیا باید تغییر کند تا DatabaseManager در فضای نام Data و FileManager در فضای نام FileSystem (یا معادل‌های آنها در برنامه شما) قرار گیرد.

کد زیر نتیجه استخراج کد پایگاه داده از کلاس DbAndFileManager به کلاس جداگانه خود و در فضای نام صحیح است:

```C#

using System;
using System.Data.SqlClient;
namespace CH01_CodingStandardsAndPrinciples.GoodCode.Data
{
    public class DatabaseManager
    {
        #region Database Operations
        public void OpenDatabaseConnection() { throw new
            NotImplementedException(); }
        public void CloseDatabaseConnection() { throw new
            NotImplementedException(); }
        public int ExecuteSql(string sql) { throw new
            NotImplementedException(); }
        public SqlDataReader SelectSql(string sql) { throw new
            NotImplementedException(); }
        public int UpdateSql(string sql) { throw new
            NotImplementedException(); }
        public int DeleteSql(string sql) { throw new
            NotImplementedException(); }
        public int InsertSql(string sql) { throw new
            NotImplementedException(); }
        #endregion
    }
}
```

بازسازی کد سیستم فایل منجر به کلاس FileManager در فضای نام FileSystem می‌شود، همانطور که در کد زیر نشان داده شده است:

```C#

using System;
namespace CH01_CodingStandardsAndPrinciples.GoodCode.FileSystem
{
    public class FileManager
    {
        #region File Operations
        public string ReadText(string filename) { throw new
            NotImplementedException(); }
        public void WriteText(string filename, string text) { throw new
            NotImplementedException(); }
        public byte[] ReadFile(string filename) { throw new
            NotImplementedException(); }
        [ 15 ]
        Coding Standards and Principles in C#
        Chapter 1
        public void WriteFile(string filename, byte[] binaryData) { throw
            new NotImplementedException(); }
        #endregion
    }
}
```

دیدیم که چگونه کلاس‌هایی که بیش از حد کار انجام می‌دهند را شناسایی کنیم و چگونه می‌توانیم آنها را بازسازی کنیم تا فقط یک کار را انجام دهند. اکنون بیایید این فرآیند را در مورد متدهایی که کارهای زیادی انجام می‌دهند، تکرار کنیم.

## متدهایی که کارهای زیادی انجام می‌دهند (Methods that do many things)

من خودم را بارها در متدهایی گم کرده‌ام که سطوح تورفتگی بسیار زیادی دارند و کارهای زیادی را در آن تورفتگی‌های مختلف انجام می‌دهند. ترکیبات (permutations) گیج‌کننده بودند. می‌خواستم کد را بازسازی کنم تا نگهداری آن آسان‌تر شود، اما سرپرستم این کار را ممنوع کرد. من به وضوح می‌توانستم ببینم که چگونه می‌توانست با تقسیم کردن کد به متدهای مختلف، متد کوچک‌تر شود.

وقت یک مثال است. در این مثال، متد یک رشته را می‌پذیرد. آن رشته سپس رمزگذاری (encrypted) و رمزگشایی (decrypted) می‌شود. همچنین طولانی است تا بتوانید ببینید چرا متدها باید کوچک نگه داشته شوند:

```C#

public string security(string plainText)
{
    try
    {
        byte[] encrypted;
        using (AesManaged aes = new AesManaged())
        {
            ICryptoTransform encryptor = aes.CreateEncryptor(Key, IV);
            using (MemoryStream ms = new MemoryStream())
                using (CryptoStream cs = new CryptoStream(ms, encryptor,
                    CryptoStreamMode.Write))
                {
                    using (StreamWriter sw = new StreamWriter(cs))
                        sw.Write(plainText);
                    encrypted = ms.ToArray();
                }
        }
        Console.WriteLine($"Encrypted data:
            {System.Text.Encoding.UTF8.GetString(encrypted)}");
        using (AesManaged aesm = new AesManaged())
        {
            ICryptoTransform decryptor = aesm.CreateDecryptor(Key, IV);
            using (MemoryStream ms = new MemoryStream(encrypted))
            {
                using (CryptoStream cs = new CryptoStream(ms, decryptor,
                    CryptoStreamMode.Read))
                {
                    using (StreamReader reader = new StreamReader(cs))
                        plainText = reader.ReadToEnd();
                }
            }
        }
        Console.WriteLine($"Decrypted data: {plainText}");
    }
    catch (Exception exp)
    {
        Console.WriteLine(exp.Message);
    }
    Console.ReadKey();
    return plainText;
}
```

همانطور که در متد بالا می‌بینید، ۱۰ خط کد دارد و خواندن آن دشوار است. به علاوه، بیش از یک کار را انجام می‌دهد. این کد را می‌توان به دو متد تقسیم کرد که هر یک یک وظیفه را انجام می‌دهند. یک متد یک رشته را رمزگذاری می‌کند و متد دیگر رشته را رمزگشایی می‌کند. این ما را به خوبی به این بحث می‌رساند که چرا متدها نباید بیش از ۱۰ خط کد داشته باشند.

## متدهای با بیش از ۱۰ خط کد (Methods with more than 10 lines of code)

متدهای بزرگ برای خواندن و درک کردن خوب نیستند. آن‌ها همچنین می‌توانند منجر به باگ‌هایی شوند که یافتنشان بسیار دشوار است. مشکل دیگر متدهای بزرگ این است که ممکن است هدف اصلی خود را از دست بدهند. وضعیت زمانی بدتر می‌شود که با متدهای بزرگی مواجه می‌شوید که بخش‌هایی از آن‌ها با کامنت‌ها جدا شده و کد در بخش‌ها (regions) پیچیده شده است.

اگر برای خواندن یک متد مجبور به اسکرول کردن هستید، پس بیش از حد طولانی است و می‌تواند منجر به استرس برنامه‌نویس و سوءتفسیر شود. این به نوبه خود می‌تواند به اصلاحاتی منجر شود که کد یا هدف، یا هر دو را از بین ببرد. متدها باید تا حد امکان کوچک باشند. اما باید از عقل سلیم نیز استفاده کرد، زیرا می‌توان موضوع متدهای کوچک را تا حد اغراق‌آمیز پیش برد تا جایی که بیش از حد شود. کلید دستیابی به تعادل صحیح، اطمینان از بسیار واضح بودن هدف متد و پیاده‌سازی مختصر آن است.

کد قبلی یک مثال خوب برای این است که چرا باید متدها را کوچک نگه داشت. متدهای کوچک به راحتی قابل خواندن و درک هستند. معمولاً، اگر کد شما از ۱۰ خط فراتر رود، ممکن است بیش از حد انتظار عمل کند. مطمئن شوید که متدهای شما هدف خود را نام‌گذاری می‌کنند، مانند OpenDatabaseConnection() و CloseDatabaseConnection()، و به اهداف خود پایبند باشند و از آن‌ها منحرف نشوند.

اکنون به پارامترهای متدها خواهیم پرداخت.

## متدهای با بیش از دو پارامتر (Methods with more than two parameters)

متدهای با پارامترهای زیاد تمایل دارند کمی دست و پا گیر شوند. علاوه بر دشواری در خواندن، انتقال یک مقدار به پارامتر اشتباه و شکستن ایمنی نوع (type safety) بسیار آسان است.

تست (testing) متدها با افزایش تعداد پارامترها به طور فزاینده‌ای پیچیده‌تر می‌شوند، دلیل اصلی آن این است که شما جایگشت‌های بیشتری برای اعمال در سناریوهای تست (test cases) خود دارید. ممکن است یک مورد استفاده را از دست بدهید که باعث ایجاد مشکل در فاز عملیاتی (production) خواهد شد.

## استفاده از استثناها برای کنترل جریان برنامه (Using exceptions to control program flow)

استفاده از استثناها (Exceptions) برای کنترل جریان برنامه (program flow) ممکن است هدف کد را پنهان کند. آن‌ها همچنین می‌توانند منجر به نتایج غیرمنتظره و ناخواسته شوند. این واقعیت که کد شما برای انتظار یک یا چند استثنا برنامه‌ریزی شده است، نشان‌دهنده اشتباه بودن طراحی شماست. یک سناریوی معمول که در فصل ۵، "مدیریت استثنا (Exception Handling)" با جزئیات بیشتر پوشش داده شده است.

یک سناریوی معمول زمانی است که یک کسب‌وکار از استثناهای قوانین تجاری (Business Rule Exceptions - BREs) استفاده می‌کند. یک متد عملی را با انتظار اینکه یک استثنا پرتاب شود، انجام می‌دهد. جریان برنامه توسط اینکه آیا استثنا پرتاب می‌شود یا خیر، تعیین خواهد شد. راه بسیار بهتر، استفاده از ساختارهای زبان (language constructs) موجود برای انجام اعتبارسنجی‌ها (validation checks) است که یک مقدار بولین (Boolean) را برمی‌گرداند.

کد زیر استفاده از یک BRE را برای کنترل جریان برنامه نشان می‌دهد:

```C#

public void BreFlowControlExample(BusinessRuleException bre)
{
    switch (bre.Message)
    {
        case "OutOfAcceptableRange":
            DoOutOfAcceptableRangeWork();
            break;
        default:
            DoInAcceptableRangeWork();
            break;
    }
}
```

متد BusinessRuleException را می‌پذیرد. بسته به پیام در استثنا، BreFlowControlExample() یا متد DoOutOfAcceptableRangeWork() را فراخوانی می‌کند یا متد DoInAcceptableRangeWork() را.

راه بسیار بهتر برای کنترل جریان از طریق منطق بولین (Boolean logic) است. بیایید به متد BetterFlowControlExample() زیر نگاه کنیم:

```C#

public void BetterFlowControlExample(bool isInAcceptableRange)
{
    if (isInAcceptableRange)
        DoInAcceptableRangeWork();
    else
        DoOutOfAcceptableRangeWork();
}
```

در متد BetterFlowControlExample()، یک مقدار بولین به متد پاس داده می‌شود. مقدار بولین برای تعیین مسیر اجرا استفاده می‌شود. اگر شرط در محدوده قابل قبول باشد، DoInAcceptableRangeWork() فراخوانی می‌شود. در غیر این صورت، متد DoOutOfAcceptableRangeWork() فراخوانی می‌شود.

در ادامه، کدی را که خواندن آن دشوار است، بررسی خواهیم کرد.

## کدی که خواندن آن دشوار است (Code that is difficult to read)

کدهایی مانند کد لازانیا (lasagna code) و کد اسپاگتی (spaghetti code) واقعاً برای خواندن یا دنبال کردن دشوار هستند. متدهای با نام‌گذاری بد نیز می‌توانند آزاردهنده باشند زیرا می‌توانند هدف متد را پنهان (obfuscate) کنند. متدها زمانی بیشتر پنهان می‌شوند که بزرگ باشند و متدهای مرتبط با تعدادی متد نامرتبط از هم جدا شده باشند.

کد لازانیا (Lasagna code)، که معمولاً با نام ارجاع غیرمستقیم (indirection) شناخته می‌شود، به لایه‌های انتزاع (abstraction) اشاره دارد که در آن چیزی به جای عمل، با نام ارجاع داده می‌شود. لایه‌بندی به طور گسترده در برنامه‌نویسی شی‌گرا (Object-Oriented Programming - OOP) و با اثرگذاری خوب استفاده می‌شود. با این حال، هرچه ارجاع غیرمستقیم بیشتر استفاده شود، کد می‌تواند پیچیده‌تر شود. این می‌تواند برای برنامه‌نویسان جدید در یک پروژه، درک و همگام شدن با کد را بسیار دشوار کند. بنابراین باید بین ارجاع غیرمستقیم و سهولت درک، تعادلی برقرار شود.

کد اسپاگتی (Spaghetti code) به مجموعه‌ای درهم‌تنیده از کدهای با اتصال محکم (tightly coupled) و انسجام پایین (low cohesion) اشاره دارد. نگهداری، بازسازی، توسعه و بازطراحی چنین کدهایی بسیار دشوار است. هرچند از جنبه مثبت، چون از نظر برنامه‌نویسی بیشتر روال‌گرا (procedural) است، خواندن و دنبال کردن آن می‌تواند بسیار آسان باشد. یادم می‌آید زمانی که به عنوان یک برنامه‌نویس تازه‌کار روی یک برنامه GIS با VB6 کار می‌کردم که به شرکت‌ها فروخته می‌شد و برای اهداف بازاریابی استفاده می‌شد. مدیر فنی من و برنامه‌نویسان ارشدش قبلاً سعی کرده بودند نرم‌افزار را بازطراحی کنند و شکست خورده بودند. بنابراین آن‌ها مسئولیت را به من سپردند تا برنامه را بازطراحی کنم. اما من در آن زمان در تحلیل و طراحی نرم‌افزار مهارت نداشتم، بنابراین من هم شکست خوردم.

کد بیش از حد پیچیده بود که نمی‌شد آن را دنبال کرد و به آیتم‌های مرتبط گروه‌بندی کرد، و بیش از حد بزرگ بود. با نگاه به گذشته، بهتر بود لیستی از هر کاری که برنامه انجام می‌دهد تهیه می‌کردم، لیست را بر اساس ویژگی‌ها گروه‌بندی می‌کردم و سپس لیستی از الزامات را بدون حتی نگاه کردن به کد، تهیه می‌کردم.

بنابراین درس من در بازطراحی نرم‌افزار این است که به هر قیمتی از نگاه کردن به کد خودداری کنم. همه کارهایی که برنامه انجام می‌دهد و قابلیت‌های جدیدی که باید شامل شود را یادداشت کنید. لیست را به مجموعه‌ای از الزامات نرم‌افزاری (software requirements) با وظایف، تست‌ها و معیارهای پذیرش (acceptance criteria) مرتبط تبدیل کنید، و سپس بر اساس مشخصات (specifications) برنامه‌نویسی کنید.

## کدی که اتصال محکم (Tightly Coupled) دارد

کدی که اتصال محکمی دارد، تست کردن، توسعه دادن یا اصلاح آن دشوار است. همچنین استفاده مجدد از کدی که وابسته به کدهای دیگر درون یک سیستم است، سخت می‌باشد.

یک مثال از اتصال محکم، زمانی است که به جای ارجاع به یک اینترفیس (interface)، به یک کلاس کانکریت (concrete class) در پارامتر ارجاع می‌دهید. هنگام ارجاع به یک کلاس کانکریت، هر تغییری در آن کلاس به طور مستقیم بر کلاسی که به آن ارجاع می‌دهد، تأثیر می‌گذارد. بنابراین اگر یک کلاس اتصال به پایگاه داده برای یک مشتری دارید که به SQL Server متصل می‌شود، و سپس مشتری دیگری را جذب می‌کنید که نیاز به پایگاه داده Oracle دارد، آنگاه کلاس کانکریت باید برای آن مشتری خاص و پایگاه داده اوراکل او تغییر یابد. این منجر به دو نسخه از کد خواهد شد.

هرچه تعداد مشتریان بیشتر باشد، نسخه‌های بیشتری از کد مورد نیاز است. این به زودی غیرقابل نگهداری و کابوسی واقعی برای نگهداری می‌شود. تصور کنید که کلاس اتصال به پایگاه داده شما ۱۰۰,۰۰۰ مشتری مختلف دارد که از ۱ از ۳۰ نوع مختلف کلاس استفاده می‌کنند، و همه آن‌ها یک باگ یکسان دارند که شناسایی شده و بر همه آن‌ها تأثیر می‌گذارد. این یعنی ۳۰ کلاس باید همان اصلاح را دریافت کنند، تست شوند، بسته‌بندی شده و دیپلو (deployed) شوند. این یک هزینه نگهداری بسیار زیاد و از نظر مالی بسیار گران است.

این سناریوی خاص را می‌توان با ارجاع به یک نوع اینترفیس (interface type) و سپس استفاده از یک فکتوری پایگاه داده (database factory) برای ساخت شیء اتصال مورد نیاز، برطرف کرد. سپس رشته اتصال (connection string) را می‌توان در یک فایل پیکربندی (configuration file) توسط مشتری تنظیم کرد و به فکتوری پاس داد. فکتوری سپس یک کلاس اتصال کانکریت تولید می‌کند که یک اینترفیس اتصال را برای نوع خاص پایگاه داده مشخص شده در رشته اتصال پیاده‌سازی می‌کند.

در اینجا یک مثال بد از کد با اتصال محکم آورده شده است:

```C#

public class Database
{
    private SqlServerConnection _databaseConnection;
    public Database(SqlServerConnection databaseConnection)
    
    {
        _databaseConnection = databaseConnection;
    }
}
```

همانطور که از مثال می‌بینید، کلاس پایگاه داده ما به استفاده از SQL Server وابسته است و برای پذیرش هر نوع پایگاه داده دیگری نیاز به تغییر هاردکد (hardcoded) خواهد داشت. ما در فصل‌های بعدی، بازسازی کد را با مثال‌های کد واقعی پوشش خواهیم داد.

## انسجام پایین (Low Cohesion)

انسجام پایین (Low cohesion) شامل کدهای نامرتبطی است که وظایف مختلفی را انجام می‌دهند و همگی با هم گروه‌بندی شده‌اند. یک مثال می‌تواند یک کلاس ابزار (utility class) باشد که شامل تعدادی متد ابزاری مختلف برای مدیریت تاریخ‌ها، متن، اعداد، انجام ورودی و خروجی فایل، اعتبارسنجی داده (data validation) و رمزگذاری و رمزگشایی (encryption and decryption) است.

## اشیاء سرگردان (Hanging Around) در حافظه

هنگامی که اشیاء در حافظه سرگردان می‌مانند، می‌توانند منجر به نشت حافظه (memory leaks) شوند.

متغیرهای استاتیک (Static variables) می‌توانند به چندین روش منجر به نشت حافظه شوند. اگر از DependencyObject یا INotifyPropertyChanged استفاده نمی‌کنید، در واقع در حال مشترک شدن در رویدادها (subscribing to events) هستید. Common Language Runtime (CLR) با استفاده از رویداد ValueChanged از طریق رویداد PropertyDescriptors AddValueChanged، یک ارجاع قوی (strong reference) ایجاد می‌کند که منجر به ذخیره PropertyDescriptor می‌شود که به شیء‌ای که به آن متصل است، ارجاع می‌دهد.

مگر اینکه اشتراک‌گذاری (unsubscribe) خود را لغو کنید، در نهایت با نشت حافظه مواجه خواهید شد. همچنین با استفاده از متغیرهای استاتیک که به اشیایی ارجاع می‌دهند که آزاد نمی‌شوند، با نشت حافظه مواجه خواهید شد. هر شیئی که توسط یک متغیر استاتیک ارجاع داده می‌شود، توسط جمع‌آوری‌کننده زباله (garbage collector) به عنوان "عدم جمع‌آوری" علامت‌گذاری می‌شود. این به این دلیل است که متغیرهای استاتیک که به اشیاء ارجاع می‌دهند، ریشه‌های جمع‌آوری زباله (Garbage Collection (GC) roots) هستند، و هر چیزی که یک ریشه GC باشد توسط جمع‌آوری‌کننده زباله به عنوان "عدم جمع‌آوری" علامت‌گذاری می‌شود.

هنگامی که از متدهای ناشناس (anonymous methods) استفاده می‌کنید که اعضای کلاس (class members) را گرفتن (capture) می‌کنند، نمونه کلاس ارجاع داده می‌شود. این باعث می‌شود که ارجاع به نمونه کلاس تا زمانی که متدهای ناشناس زنده هستند، زنده بماند.

هنگام استفاده از کد مدیریت‌نشده (unmanaged code - COM)، اگر اشیاء مدیریت‌شده و مدیریت‌نشده را آزاد نکنید و هر حافظه‌ای را به طور صریح آزاد (deallocate) نکنید، با نشت حافظه مواجه خواهید شد.

کدی که به طور نامحدود کش (cache) می‌کند بدون استفاده از ارجاعات ضعیف (weak references)، حذف کش استفاده‌نشده، یا محدود کردن اندازه کش، در نهایت با کمبود حافظه مواجه خواهد شد.

اگر بخواهید ارجاعاتی به شیء در یک نخ (thread) ایجاد کنید که هرگز پایان نمی‌یابد، نیز با نشت حافظه مواجه خواهید شد.

اشتراک‌های رویداد (Event subscriptions) که ناشناس نیستند، کلاس‌ها را ارجاع می‌دهند. تا زمانی که این رویدادها مشترک بمانند، اشیاء در حافظه باقی خواهند ماند. بنابراین مگر اینکه از رویدادها در زمانی که نیازی به آن‌ها نیست، لغو اشتراک کنید، احتمالاً با نشت حافظه مواجه خواهید شد.

## استفاده از متد Finalize()

در حالی که فاینالایزرها (finalizers) می‌توانند به آزادسازی منابع (resources) از اشیایی که به درستی دور انداخته نشده‌اند (disposed of) کمک کنند و از نشت حافظه جلوگیری کنند، اما دارای تعدادی معایب (drawbacks) هستند.

شما نمی‌دانید فاینالایزرها چه زمانی فراخوانی خواهند شد. آنها توسط جمع‌آوری‌کننده زباله همراه با تمام وابستگان در گراف به نسل بعدی ارتقا می‌یابند و تا زمانی که جمع‌آوری‌کننده زباله تصمیم نگیرد، جمع‌آوری نخواهند شد. این بدان معناست که اشیاء می‌توانند برای مدت طولانی در حافظه باقی بمانند. خطاهای کمبود حافظه (Out-of-memory exceptions) ممکن است با استفاده از فاینالایزرها رخ دهد، زیرا می‌توانید اشیاء را سریع‌تر از آنکه جمع‌آوری زباله شوند، ایجاد کنید.

## مهندسی بیش از حد (Over-engineering)

مهندسی بیش از حد (Over-engineering) می‌تواند یک کابوس مطلق باشد. بزرگترین دلیل آن این است که به عنوان یک انسان معمولی، پیشروی (wading through) در یک سیستم عظیم، تلاش برای درک آن، نحوه استفاده از آن و اینکه هر چیز کجا قرار می‌گیرد، یک فرآیند زمان‌بر است. به خصوص زمانی که هیچ مستنداتی وجود ندارد، شما تازه وارد سیستم هستید، و حتی افرادی که مدت‌ها طولانی‌تر از شما از آن استفاده کرده‌اند، قادر به پاسخگویی به سوالات شما نیستند.

این می‌تواند عامل اصلی استرس باشد زمانی که انتظار می‌رود با مهلت‌های تعیین شده روی آن کار کنید.

### یاد بگیرید ساده باشید، احمق! (Learn to Keep It Simple, Stupid - KISS)

یک مثال خوب از این موضوع در یکی از جاهایی است که من کار کرده‌ام. من باید یک تست برای یک برنامه وب (web app) می‌نوشتم که JSON را از یک سرویس می‌پذیرفت، به یک کودک اجازه می‌داد یک تست انجام دهد و سپس امتیاز نهایی را به سرویس دیگری منتقل می‌کرد. من از OOP، SOLID یا DRY استفاده نکردم، همانطور که طبق سیاست شرکت باید انجام می‌دادم. اما با استفاده از KISS و برنامه‌نویسی روال‌گرا (procedural programming) با رویدادها در یک بازه زمانی بسیار کوتاه، کار را انجام دادم. به دلیل آن جریمه شدم و مجبور شدم آن را با استفاده از پخش‌کننده تست (test player) خودشان بازنویسی کنم.

بنابراین شروع به یادگیری پخش‌کننده تست آن‌ها کردم. هیچ مستنداتی وجود نداشت، از اصول DRY آن‌ها پیروی نمی‌کرد، و افراد بسیار کمی اگر کسی آن را واقعاً درک می‌کرد. به جای چند روز، مانند سیستم جریمه‌شده من، نسخه جدید من که باید از سیستم آن‌ها استفاده می‌کرد، هفته‌ها طول کشید تا ساخته شود زیرا کاری را که من نیاز داشتم انجام نمی‌داد، و اجازه نداشتم آن را اصلاح کنم تا کاری را که نیاز داشتم انجام دهد. بنابراین من کند شدم در حالی که منتظر بودم کسی کاری را که لازم بود انجام دهد.

اولین راه‌حل من الزامات کسب‌وکار (business requirements) را برآورده کرد و یک قطعه کد مستقل بود که به هیچ چیز دیگری اهمیت نمی‌داد. راه‌حل دوم الزامات فنی (technical requirements) تیم توسعه را برآورده کرد. پروژه طولانی‌تر از مهلت تعیین شده ادامه یافت. هر پروژه‌ای که از مهلت خود تجاوز می‌کند (overshoots its deadline)، هزینه بیشتری نسبت به برنامه‌ریزی شده به کسب‌وکار تحمیل می‌کند.

نکته دیگری که می‌خواهم در مورد سیستم جریمه‌شده خود بگویم این بود که بسیار ساده‌تر و قابل درک‌تر از سیستم جدیدتر بود که برای استفاده از پخش‌کننده تست عمومی بازنویسی شد.

شما همیشه مجبور نیستید از OOP، SOLID و DRY پیروی کنید. گاهی اوقات عدم پیروی از آن‌ها به صرفه است. به هر حال، می‌توانید زیباترین سیستم OOP را بنویسید. اما در زیر کاپوت، کد شما به کد روال‌گرا تبدیل می‌شود که به آنچه کامپیوتر می‌فهمد نزدیک‌تر است!

## عدم وجود بخش‌ها (Regions) در کلاس‌های بزرگ

کلاس‌های بزرگ با بخش‌های زیاد، خواندن و دنبال کردنشان بسیار دشوار است، به خصوص زمانی که متدهای مرتبط با هم گروه‌بندی نشده‌اند. بخش‌ها برای گروه‌بندی اعضای مشابه درون یک کلاس بزرگ بسیار خوب هستند. اما اگر از آن‌ها استفاده نکنید، هیچ فایده‌ای ندارند!

## کد با هدف گمشده (Lost-intention code)

اگر در حال مشاهده یک کلاس هستید و چندین کار را انجام می‌دهد، چگونه می‌دانید هدف اصلی آن چه بوده است؟ برای مثال، اگر به دنبال یک متد تاریخ هستید و آن را در یک کلاس فایل در فضای نام ورودی/خروجی کد خود پیدا می‌کنید، آیا متد تاریخ در مکان صحیح قرار دارد؟ خیر. آیا برای سایر توسعه‌دهندگانی که کد شما را نمی‌شناسند، یافتن آن متد دشوار خواهد بود؟ البته که همینطور است. به این کد نگاهی بیندازید:

```C#

public class MyClass
{
    public void MyMethod()
    {
        // ...implementation...
    }
    public DateTime AddDates(DateTime date1, DateTime date2)
    [ 23 ]
    Coding Standards and Principles in C#
    Chapter 1
    {
    }
        //...implementation...
    public Product GetData(int id)
    {
        //...implementation...
    }
}
```

هدف این کلاس چیست؟ نام آن هیچ نشانی نمی‌دهد، و MyMethod چه کاری انجام می‌دهد؟ همچنین به نظر می‌رسد کلاس در حال دستکاری تاریخ و دریافت داده محصول است. متد AddDates باید در کلاسی باشد که منحصراً برای مدیریت تاریخ‌ها است. و متد GetData باید در مدل ویو (view model) محصول باشد.

## افشای مستقیم اطلاعات (Directly exposing information)

کلاس‌هایی که اطلاعات را به طور مستقیم افشا می‌کنند، بد هستند. جدا از ایجاد اتصال محکم (tight coupling) که می‌تواند منجر به باگ شود، اگر بخواهید نوع اطلاعات را تغییر دهید، باید نوع آن را در هر جایی که استفاده شده است، تغییر دهید. همچنین، اگر بخواهید قبل از انتساب، اعتبارسنجی داده (data validation) انجام دهید چه؟ در اینجا مثالی آورده شده است:

```C#

public class Product
{
    public int Id;
    public int Name;
    public int Description;
    public string ProductCode;
    public decimal Price;
    public long UnitsInStock
}
```

در کد بالا، اگر می‌خواستید UnitsInStock را از نوع long به نوع int تغییر دهید، باید کد را در هر جایی که به آن ارجاع داده شده است، تغییر می‌دادید. همین کار را باید برای ProductCode نیز انجام می‌دادید. اگر کدهای محصول جدید باید از یک فرمت سخت‌گیرانه پیروی می‌کردند، نمی‌توانستید کدهای محصول را اعتبارسنجی کنید اگر رشته مستقیماً توسط کلاس فراخواننده قابل انتساب بود.

## کد خوب (Good code)

حالا که می‌دانید چه کارهایی را نباید انجام داد، وقت آن است که به اختصار به برخی از شیوه‌های کدنویسی خوب نگاه کنیم تا بتوانیم کدی دلپذیر و با عملکرد بالا بنویسیم.

## تورفتگی مناسب (Proper indentation)

وقتی از تورفتگی مناسب (proper indentation) استفاده می‌کنید، خواندن کد بسیار آسان‌تر می‌شود. با تورفتگی می‌توانید تشخیص دهید که بلوک‌های کد (code blocks) کجا شروع و به پایان می‌رسند و کدام کد متعلق به آن بلوک‌های کد است:

```C#

public void DoSomething()
{
    for (var i = 0; i < 1000; i++)
    {
        var productCode = $"PRC000{i}";
        //...implementation
    }
}
```

در مثال ساده بالا، کد زیبا به نظر می‌رسد و قابل خواندن است. شما می‌توانید به وضوح ببینید که هر بلوک کد کجا شروع و به پایان می‌رسد.

## کامنت‌های معنادار (Meaningful comments)

کامنت‌های معنادار (Meaningful comments) کامنت‌هایی هستند که نیت برنامه‌نویس را بیان می‌کنند. چنین کامنت‌هایی زمانی مفید هستند که کد صحیح باشد اما ممکن است به راحتی توسط هر کسی که تازه با کد آشنا شده است، یا حتی توسط خود برنامه‌نویس در چند هفته آینده، درک نشود. چنین کامنت‌هایی می‌توانند واقعاً کمک‌کننده باشند.

## کامنت‌های مستندسازی API (API documentation comments)

یک API خوب، API است که دارای مستندات خوب و قابل فهمی باشد. کامنت‌های API (API comments)، کامنت‌های XML (XML comments) هستند که می‌توان از آنها برای تولید مستندات HTML (HTML documentation) استفاده کرد. مستندات HTML برای توسعه‌دهندگانی که می‌خواهند از API شما استفاده کنند، مهم است. هرچه مستندات بهتر باشد، احتمال اینکه توسعه‌دهندگان بیشتری بخواهند از API شما استفاده کنند، بیشتر است. در اینجا مثالی آورده شده است:

```C#

/// <summary>
/// Create a new <see cref="KustoCode"/> instance from the text and
/// globals. Does not perform
/// semantic analysis.
/// </summary>
/// <param name="text">The code text</param>
/// <param name="globals">
///   The globals to use for parsing and semantic analysis. Defaults to
///   <see langword="null"/>
/// </param>
public static KustoCode Parse(string text, GlobalState globals = null) {
... }
```

این گزیده از پروژه زبان پرس‌وجوی کاستو (Kusto Query Language) نمونه خوبی از یک کامنت مستندسازی API است.

## سازماندهی مناسب با استفاده از فضای نام‌ها (Proper organization using namespaces)

کدی که به درستی سازماندهی شده و در فضاهای نام (namespaces) مناسب قرار گرفته باشد، می‌تواند مقدار زیادی از زمان توسعه‌دهندگان را هنگام جستجو برای یک قطعه کد خاص، صرفه‌جویی کند. به عنوان مثال، اگر به دنبال کلاس‌ها و متدهایی هستید که به تاریخ و زمان مربوط می‌شوند، ایده خوبی است که یک فضای نام به نام DateTime، یک کلاس به نام Time برای متدهای مرتبط با زمان، و یک کلاس به نام Date برای متدهای مرتبط با تاریخ داشته باشید.

مثال زیر نمونه‌ای از سازماندهی مناسب فضای نام‌ها است:
  ![Conventions-UsedThis-Book](../../assets/image/01/Table%201-2.png)

## قوانین نام‌گذاری خوب (Good naming conventions)

پیروی از قوانین نام‌گذاری C# مایکروسافت (Microsoft C# naming conventions) خوب است. از حالت پاسکال (Pascal casing) برای فضاهای نام (namespaces)، کلاس‌ها (classes)، اینترفیس‌ها (interfaces)، enumها (enums) و متدها (methods) استفاده کنید. از حالت شتری (camel case) برای نام متغیرها و نام آرگومان‌ها استفاده کنید، و مطمئن شوید که متغیرهای عضو را با یک آندرلاین پیشوندگذاری کنید.

به این مثال کد نگاهی بیندازید:

```C#

using System;
using System.Text.RegularExpressions;
namespace CompanyName.ProductName.RegEx
{
    /// <summary>
    /// An extension class for providing regular expression extensions
    /// methods.
    /// </summary>
    public static class RegularExpressions
    {
        private static string _preprocessed;
        public static string RegularExpression { get; set; }
        public static bool IsValidEmail(this string email)
        {
            // <summary>
            // Email address: RFC 2822 Format.
            // Matches a normal email address. Does not check the
            // top-level domain.
            // Requires the "case insensitive" option to be ON.
            // </summary>
            var exp = @"\A(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.
             [a-z0-9!#$%&'*+/=?^_`{|}~-]+)@(?:[a-z0-9](?:[a-z0-9-]
             [a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?)\Z";
            bool isEmail = Regex.IsMatch(email, exp, RegexOptions.IgnoreCase);
            return isEmail;
        // ... rest of the implementation ...
        }
    }
}
```

این مثال‌ها مناسبی از قوانین نام‌گذاری برای فضاهای نام، کلاس‌ها، متغیرهای عضو، کلاس‌ها، پارامترها و متغیرهای محلی را نشان می‌دهد.

## کلاس‌هایی که تنها یک کار انجام می‌دهند (Classes that only do one job)

یک کلاس خوب، کلاسی است که تنها یک کار را انجام می‌دهد. وقتی کلاس را می‌خوانید، هدف آن واضح است. تنها کدی که باید در آن کلاس باشد، در آن کلاس قرار دارد و هیچ چیز دیگری نیست.

## متدهایی که یک کار انجام می‌دهند (Methods that do one thing)

متدها باید فقط یک کار را انجام دهند. شما نباید متدی داشته باشید که بیش از یک کار انجام دهد، مانند رمزگشایی یک رشته و انجام جایگزینی رشته. نیت یک متد باید واضح باشد. متدهایی که فقط یک کار را انجام می‌دهند بیشتر مستعد کوچک بودن، خوانا بودن و هدفمند بودن هستند.

## متدهایی با کمتر از ۱۰ خط، و ترجیحاً حداکثر ۴ خط (Methods with less than 10 lines, and preferably no more than 4)

در حالت ایده‌آل، باید متدهایی داشته باشید که بیش از ۴ خط کد نباشند. با این حال، این همیشه امکان‌پذیر نیست، بنابراین باید تلاش کنید متدهایی داشته باشید که حداکثر ۱۰ خط طول داشته باشند تا خواندن و نگهداری آن‌ها آسان باشد.

## متدهایی با حداکثر دو پارامتر (Methods with no more than two parameters)

بهتر است متدهایی با هیچ پارامتری نداشته باشید، اما داشتن یک یا دو پارامتر مشکلی ندارد. اگر شروع به داشتن بیش از دو پارامتر کردید، باید در مورد مسئولیت کلاس و متدهای خود فکر کنید: آیا آنها بیش از حد مسئولیت بر عهده می‌گیرند؟ اگر نیاز به بیش از دو پارامتر دارید، بهتر است یک شیء را پاس دهید.

هر متدی با بیش از دو پارامتر می‌تواند خواندن و دنبال کردن آن دشوار شود. داشتن حداکثر دو پارامتر کد را خوانا می‌کند، و یک پارامتر واحد که یک شیء است، بسیار خواناتر از متدی با چندین پارامتر است.

## استفاده صحیح از استثناها (Proper use of exceptions)

هرگز از استثناها (exceptions) برای کنترل جریان برنامه (program flow) استفاده نکنید. شرایط رایجی را که ممکن است باعث ایجاد استثنا شوند، به گونه‌ای مدیریت کنید که استثنایی ایجاد یا پرتاب نشود. یک کلاس خوب به گونه‌ای طراحی شده است که می‌توانید از استثناها جلوگیری کنید.

با استفاده از استثناهای try/catch/finally، از استثناها بازیابی کنید و/یا منابع را آزاد کنید. هنگام گرفتن استثناها، از استثناهای خاصی استفاده کنید که ممکن است در کد شما پرتاب شوند، تا اطلاعات دقیق‌تری برای ثبت یا کمک به مدیریت استثنا داشته باشید.

گاهی اوقات، استفاده از انواع استثنای از پیش تعریف شده .NET (predefined .NET exception types) همیشه امکان‌پذیر نیست. در چنین مواردی، تولید استثناهای سفارشی (custom exceptions) خود ضروری خواهد بود. کلاس‌های استثنای سفارشی خود را با کلمه Exception پسوندگذاری کنید، و مطمئن شوید که سه سازنده (constructors) زیر را شامل می‌شوند:

+ Exception(): از مقادیر پیش‌فرض استفاده می‌کند.

+ Exception(string): یک پیام رشته‌ای را می‌پذیرد.

+ Exception(string, exception): یک پیام رشته‌ای و یک استثنای درونی را می‌پذیرد.

اگر مجبور به پرتاب استثناها هستید، کدهای خطا را برنگردانید، بلکه استثناهایی با اطلاعات معنادار برگردانید.

## کدی که خوانا است (Code that is readable)

هرچه کد خواناتر باشد، توسعه‌دهندگان بیشتری از کار با آن لذت خواهند برد. چنین کدی آسان‌تر یاد گرفته و با آن کار می‌شود. با آمد و رفت توسعه‌دهندگان در یک پروژه، تازه‌کارها قادر خواهند بود کد را با تلاش کمتری بخوانند، گسترش دهند و نگهداری کنند. کد خوانا همچنین کمتر مستعد باگ و ناامنی است.

## کدی که اتصال سست (Loosely Coupled) دارد

کد با اتصال سست (Loosely coupled code) آسان‌تر تست و بازسازی می‌شود. همچنین می‌توانید کد با اتصال سست را در صورت نیاز آسان‌تر عوض و جابه‌جا (swap and change) کنید. قابلیت استفاده مجدد کد (code reuse) یکی دیگر از مزایای کد با اتصال سست است.

بیایید از مثال بد قبلی خود یعنی یک پایگاه داده که اتصال SQL Server به آن پاس داده می‌شود، استفاده کنیم. می‌توانیم همان کلاس را با ارجاع به یک اینترفیس (interface) به جای یک نوع کانکریت (concrete type)، با اتصال سست بسازیم. بیایید به یک مثال خوب از بازسازی مثال بد قبلی نگاهی بیندازیم:

```C#

public class Database
{
    private IDatabaseConnection _databaseConnection;
    public Database(IDatabaseConnection databaseConnection)
    {
        _databaseConnection = datbaseConnection;
    }
}
```

همانطور که در این مثال نسبتاً پایه می‌بینید، تا زمانی که کلاس پاس‌داده‌شده اینترفیس IDatabaseConnection را پیاده‌سازی کند، می‌توانیم هر کلاسی را برای هر نوع اتصال به پایگاه داده‌ای پاس دهیم. بنابراین اگر باگی در کلاس اتصال SQL Server پیدا کنیم، فقط مشتریان SQL Server تحت تأثیر قرار می‌گیرند. این بدان معناست که مشتریان با پایگاه داده‌های مختلف به کار خود ادامه خواهند داد، و ما فقط باید کد را برای مشتریان SQL Server در همان یک کلاس اصلاح کنیم. این سربار نگهداری را کاهش می‌دهد و بنابراین هزینه کلی نگهداری را کاهش می‌دهد.

## انسجام بالا (High Cohesion)

عملکرد مشترکی (Common functionality) که به درستی با هم گروه‌بندی شده باشد، به عنوان انسجام بالا (highly cohesive) شناخته می‌شود. چنین کدی به راحتی قابل یافتن است. به عنوان مثال، اگر به فضای نام Microsoft System.Diagnostics نگاه کنید، متوجه خواهید شد که فقط شامل کدی است که به عیب‌یابی (diagnostics) مربوط می‌شود. شامل کردن کد مجموعه‌ها و سیستم فایل در فضای نام Diagnostics منطقی نخواهد بود.

## اشیاء به طور تمیز دور انداخته می‌شوند (Objects are cleanly disposed of)

هنگام استفاده از کلاس‌های قابل دور انداختن (disposable classes)، همیشه باید متد Dispose() را برای دور انداختن تمیز هر منبعی که در حال استفاده است، فراخوانی کنید. این به خنثی کردن احتمال نشت حافظه (memory leaks) کمک می‌کند.

مواقعی وجود دارد که ممکن است نیاز باشد یک شیء را null کنید تا از محدوده (scope) خارج شود. یک مثال می‌تواند یک متغیر استاتیک باشد که ارجاعی به شیء‌ای که دیگر نیازی به آن ندارید، نگه می‌دارد.

دستور using (using statement) نیز یک راه تمیز خوب برای استفاده از اشیاء قابل دور انداختن است، زیرا وقتی شیء دیگر در محدوده نباشد، به طور خودکار دور انداخته می‌شود، بنابراین نیازی به فراخوانی صریح متد Dispose() نیست. بیایید به کد زیر نگاهی بیندازیم:

```C#

using (var unitOfWork = new UnitOfWork())
{
    // Perform unit of work here.
}
// At this point the unit of work object has been disposed of.
```

کد یک شیء قابل دور انداختن را در دستور using تعریف می‌کند و کاری را که باید بین براکت‌های باز و بسته انجام دهد، انجام می‌دهد. شیء به طور خودکار قبل از خروج از براکت‌ها دور انداخته می‌شود. و بنابراین نیازی به فراخوانی دستی متد Dispose() نیست، زیرا به طور خودکار فراخوانی می‌شود.

## اجتناب از متد Finalize() (Avoiding the Finalize() method)

هنگام استفاده از منابع مدیریت‌نشده (unmanaged resources)، بهتر است اینترفیس IDisposable (IDisposable interface) را پیاده‌سازی کنید و از استفاده از متد Finalize() خودداری کنید. هیچ تضمینی وجود ندارد که فاینالایزرها چه زمانی اجرا شوند. آن‌ها ممکن است همیشه به ترتیبی که انتظار دارید یا زمانی که انتظار دارید اجرا نشوند. در عوض، بهتر و قابل اطمینان‌تر است که منابع مدیریت‌نشده را در متد Dispose() دور بیندازید.

## سطح مناسب انتزاع (The right level of abstraction)

شما زمانی سطح مناسب انتزاع (right level of abstraction) را دارید که فقط آنچه را که نیاز به افشا دارد به سطح بالاتر افشا می‌کنید و در پیاده‌سازی گم نمی‌شوید.

اگر متوجه شدید که در جزئیات پیاده‌سازی گم می‌شوید، پس بیش از حد انتزاع (over-abstracted) کرده‌اید. اگر متوجه شدید که چندین نفر باید همزمان در یک کلاس کار کنند، پس کمتر انتزاع (under-abstracted) کرده‌اید. در هر دو مورد، برای رساندن انتزاع به سطح صحیح، بازسازی (refactoring) لازم خواهد بود.

## استفاده از regions در کلاس‌های بزرگ (Using regions in large classes)

Regions برای گروه‌بندی آیتم‌ها در یک کلاس بزرگ بسیار مفید هستند زیرا می‌توانند جمع شوند. خواندن یک کلاس بزرگ و مجبور شدن به پرش بین متدها می‌تواند بسیار دلهره‌آور باشد، بنابراین گروه‌بندی متدهایی که یکدیگر را در کلاس فراخوانی می‌کنند، راه خوبی برای گروه‌بندی آن‌ها است. سپس می‌توان متدها را در هنگام کار بر روی یک قطعه کد، در صورت نیاز جمع (collapsed) و گسترش (expanded) داد.

همانطور که از آنچه تاکنون بررسی کرده‌ایم می‌بینید، شیوه‌های کدنویسی خوب، کدی را ایجاد می‌کنند که بسیار خواناتر و نگهداری آن آسان‌تر است. اکنون به نیاز به استانداردهای کدنویسی و اصول همراه با برخی از متدولوژی‌های نرم‌افزاری (software methodologies) مانند SOLID و DRY نگاهی خواهیم انداخت.

## نیاز به استانداردهای کدنویسی، اصول و متدولوژی‌ها (The need for coding standards, principles, and methodologies)

امروزه اکثر نرم‌افزارها توسط چندین تیم از برنامه‌نویسان نوشته می‌شوند. همانطور که می‌دانید، همه ما روش‌های منحصر به فرد خود را در کدنویسی داریم و همه ما شکلی از ایدئولوژی برنامه‌نویسی (programming ideology) را دنبال می‌کنیم. شما به راحتی می‌توانید مباحث برنامه‌نویسی را در مورد پارادایم‌های مختلف توسعه نرم‌افزار (various software development paradigms) پیدا کنید. اما اجماع بر این است که اگر همه ما به مجموعه مشخصی از استانداردهای کدنویسی (coding standards)، اصول (principles) و متدولوژی‌ها (methodologies) پایبند باشیم، کارمان به عنوان برنامه‌نویس آسان‌تر می‌شود.

بیایید آنچه را که منظورمان از این‌هاست، با جزئیات بیشتری بررسی کنیم.

## استانداردهای کدنویسی (Coding standards)

استانداردهای کدنویسی مجموعه‌ای از بایدها و نبایدها (dos and don'ts) را مشخص می‌کنند که باید به آن‌ها پایبند بود. چنین استانداردهایی را می‌توان از طریق ابزارهایی مانند FxCop و به صورت دستی از طریق بررسی‌های کد همتا (peer code reviews) اعمال کرد. همه شرکت‌ها استانداردهای کدنویسی خاص خود را دارند که باید به آن‌ها پایبند باشند. اما آنچه در دنیای واقعی خواهید یافت این است که وقتی کسب‌وکار انتظار دارد مهلتی رعایت شود، آن استانداردهای کدنویسی ممکن است نادیده گرفته شوند، زیرا مهلت می‌تواند مهم‌تر از کیفیت واقعی کد شود. این معمولاً با اضافه کردن هر بازسازی (refactoring) مورد نیاز به لیست باگ‌ها به عنوان بدهی فنی (technical debt) که باید پس از انتشار رفع شود، اصلاح می‌شود.

مایکروسافت استانداردهای کدنویسی خاص خود را دارد، و در بیشتر مواقع این‌ها استانداردهای پذیرفته‌شده‌ای هستند که برای برآوردن نیازهای هر کسب‌وکار تغییر داده می‌شوند. در اینجا چند نمونه از استانداردهای کدنویسی که به صورت آنلاین یافت می‌شوند آورده شده است:

+ <https://www.c-sharpcorner.com/UploadFile/ankurmalik123/C-Sharp-coding-standards/>
+ <https://www.dofactory.com/reference/csharp-coding-standards>
+ <https://blog.submain.com/coding-standards-c-developers-need/>

هنگامی که افراد در تیم‌ها یا درون یک تیم به استانداردهای کدنویسی پایبند هستند، پایگاه کد (code base) شما یکپارچه می‌شود. یک پایگاه کد یکپارچه بسیار آسان‌تر خوانده، گسترش یافته و نگهداری می‌شود. همچنین احتمال خطا در آن کمتر است. و اگر خطاهایی وجود داشته باشد، احتمال یافتن آن‌ها آسان‌تر است، زیرا کد از مجموعه استانداردی از دستورالعمل‌ها پیروی می‌کند که همه توسعه‌دهندگان به آن پایبند هستند.

## اصول کدنویسی (Coding principles)

اصول کدنویسی (Coding principles) مجموعه‌ای از دستورالعمل‌ها برای نوشتن کد با کیفیت بالا (high-quality code)، تست (testing) و رفع اشکال (debugging) آن کد، و انجام نگهداری (maintenance) روی کد است. اصول می‌تواند بین برنامه‌نویسان و تیم‌های برنامه‌نویسی متفاوت باشد.

حتی اگر یک برنامه‌نویس تنها باشید، با تعریف اصول کدنویسی خود و پایبندی به آن‌ها، خدمت شایانی به خود خواهید کرد. اگر در یک تیم کار می‌کنید، توافق بر سر مجموعه‌ای از استانداردهای کدنویسی برای آسان‌تر کردن کار روی کد مشترک، بسیار سودمند است.

در سراسر این کتاب، مثال‌هایی از اصول کدنویسی مانند SOLID، YAGNI، KISS و DRY را خواهید دید که همگی با جزئیات توضیح داده خواهند شد. اما در حال حاضر، SOLID مخفف اصل مسئولیت واحد (Single Responsibility Principle)، اصل باز-بسته (Open-Closed Principle)، جایگزینی لیسکوف (Liskov Substitution)، اصل تفکیک اینترفیس (Interface Segregation Principle) و اصل وارونگی وابستگی (Dependency Inversion Principle) است. YAGNI مخفف "You Ain't Gonna Need It" (شما به آن نیاز نخواهید داشت) است. KISS مخفف "Keep It Simple, Stupid" (ساده نگهش دار، احمق) است و DRY مخفف "Don't Repeat Yourself" (خودت را تکرار نکن) است.

## متدولوژی‌های کدنویسی (Coding methodologies)

متدولوژی‌های کدنویسی (Coding methodologies) فرآیند توسعه نرم‌افزار را به تعدادی فاز از پیش تعریف شده تقسیم می‌کنند. هر فاز تعدادی گام مرتبط با خود خواهد داشت. توسعه‌دهندگان و تیم‌های توسعه مختلف متدولوژی‌های کدنویسی خاص خود را خواهند داشت که از آن‌ها پیروی می‌کنند. هدف اصلی متدولوژی‌های کدنویسی، روان‌سازی فرآیند از مفهوم اولیه (initial concept)، از طریق فاز کدنویسی (coding phase)، تا فازهای استقرار (deployment) و نگهداری (maintenance) است.

در این کتاب، با توسعه مبتنی بر تست (Test-Driven Development - TDD) و توسعه مبتنی بر رفتار (Behavioral-Driven Development - BDD) با استفاده از SpecFlow، و برنامه‌نویسی جنبه‌گرا (Aspect-Oriented Programming - AOP) با استفاده از PostSharp آشنا خواهید شد.

## قراردادهای کدنویسی (Coding conventions)

بهترین کار این است که قراردادهای کدنویسی C# مایکروسافت (Microsoft C# coding conventions) را پیاده‌سازی کنید. می‌توانید آن‌ها را در مستندات مایکروسافت بررسی کنید.

با پذیرش قراردادهای کدنویسی مایکروسافت، تضمین می‌شوید که کد را در یک قالب رسمی پذیرفته‌شده و توافق‌شده بنویسید. این قراردادهای کدنویسی C# به افراد کمک می‌کند تا بر خواندن کد شما تمرکز کنند و زمان کمتری را صرف تمرکز بر طرح‌بندی (layout) کنند. اساساً، استانداردهای کدنویسی مایکروسافت بهترین شیوه‌ها (best practices) را ترویج می‌کنند.

## ماژولار بودن (Modularity)

تقسیم برنامه‌های بزرگ به ماژول‌های کوچک‌تر (smaller modules) بسیار منطقی است. ماژول‌های کوچک آسان‌تر تست می‌شوند، به راحتی قابل استفاده مجدد هستند و می‌توانند مستقل از سایر ماژول‌ها کار کنند. ماژول‌های کوچک نیز آسان‌تر گسترش یافته و نگهداری می‌شوند.

یک برنامه ماژولار (modular program) را می‌توان به مجموعه‌های (assemblies) مختلف و فضاهای نام (namespaces) مختلف در آن مجموعه‌ها تقسیم کرد. کار بر روی برنامه‌های ماژولار در محیط‌های تیمی نیز بسیار آسان‌تر است زیرا تیم‌های مختلف می‌توانند روی ماژول‌های مختلف کار کنند.

در یک پروژه، کد با اضافه کردن پوشه‌هایی (folders) که فضای نام‌ها را منعکس می‌کنند، ماژولار می‌شود. یک فضای نام باید فقط حاوی کدی باشد که به نام آن مربوط می‌شود. بنابراین، به عنوان مثال، اگر یک فضای نام به نام FileSystem دارید، آنگاه انواع مرتبط با فایل‌ها و دایرکتوری‌ها باید در آن پوشه قرار گیرند. به همین ترتیب، اگر یک فضای نام به نام Data دارید، آنگاه فقط انواع مرتبط با داده و منابع داده (data sources) باید در آن فضای نام قرار گیرند.

یکی دیگر از جنبه‌های زیبای ماژولار سازی صحیح (correct modularization) این است که اگر ماژول‌ها را کوچک و ساده نگه دارید، خواندن آن‌ها آسان است. بیشتر زندگی یک برنامه‌نویس، به جز کدنویسی، صرف خواندن و درک کد می‌شود. بنابراین هرچه کد کوچک‌تر و به درستی ماژولار شود، خواندن و درک کد آسان‌تر می‌شود. این منجر به درک بیشتر کد و بهبود پذیرش و استفاده توسعه‌دهنده از کد می‌شود.

## KISS (Keep It Simple, Stupid)

شما ممکن است نابغه فوق‌العاده (super genius) دنیای برنامه‌نویسی کامپیوتر باشید. شما ممکن است کدی تولید کنید که آنقدر جذاب (sexy) است که سایر برنامه‌نویسان تنها می‌توانند با تحسین به آن خیره شوند و در نهایت روی صفحه‌کلید خود آب دهان بریزند. اما آیا آن برنامه‌نویسان دیگر فقط با نگاه کردن به کد، می‌فهمند که کد چیست؟ اگر آن کد را ۱۰ هفته بعد پیدا کردید، زمانی که عمیقاً در کوهی از کدهای مختلف با مهلت‌های تعیین‌شده فرو رفته‌اید، آیا می‌توانید با وضوح مطلق توضیح دهید که کد شما چه کاری انجام می‌دهد و منطق پشت انتخاب روش کدنویسی شما چیست؟ و آیا تا به حال به این فکر کرده‌اید که ممکن است مجبور باشید در آینده نیز روی آن کد کار کنید؟

آیا تا به حال کدی را برنامه‌نویسی کرده‌اید، سپس آن را رها کرده‌اید و بعد از چند روز دوباره به آن نگاه کرده‌اید و با خود فکر کرده‌اید، "این آشغال را من ننوشتم، نوشتم؟!" "چه فکری می‌کردم!؟" من می‌دانم که خودم مقصر این بوده‌ام و برخی از همکاران سابقم نیز چنین بوده‌اند.

هنگام برنامه‌نویسی، ضروری است که کد را ساده و در فرمت قابل خواندن توسط انسان (human-readable format) نگه دارید تا حتی برنامه‌نویسان تازه‌کار نیز بتوانند آن را درک کنند. اغلب تازه‌کاران در معرض کد قرار می‌گیرند تا آن را بخوانند، درک کنند و سپس نگهداری کنند. هرچه کد پیچیده‌تر باشد، طول می‌کشد تا تازه‌کاران با آن آشنا شوند. حتی افراد ارشد نیز می‌توانند با سیستم‌های پیچیده تا جایی که کار را ترک کرده و به دنبال کاری در جای دیگری باشند که برای مغز و رفاهشان کمتر طاقت‌فرسا باشد، دست و پنجه نرم کنند.

به عنوان مثال، اگر روی یک وب‌سایت ساده کار می‌کنید، از خود چند سوال بپرسید. آیا واقعاً نیاز به استفاده از میکروسرویس‌ها (microservices) دارد؟ آیا پروژه براونفیلد (brownfield project) که روی آن کار می‌کنید واقعاً پیچیده است؟ آیا می‌توان آن را ساده کرد تا نگهداری آن آسان‌تر شود؟ هنگام توسعه یک سیستم جدید، حداقل تعداد بخش‌های متحرک (moving parts) که برای نوشتن یک راه‌حل قوی (robust)، قابل نگهداری (maintainable) و مقیاس‌پذیر (scalable) که عملکرد خوبی دارد، نیاز دارید، چیست؟

## YAGNI (You Ain't Gonna Need It)

YAGNI (You Ain't Gonna Need It) یک رشته (discipline) در دنیای چابک (agile) برنامه‌نویسی است که حکم می‌کند یک برنامه‌نویس نباید هیچ کدی را اضافه کند تا زمانی که کاملاً به آن نیاز باشد. یک برنامه‌نویس صادق تست‌های شکست‌خورده (failing tests) را بر اساس یک طراحی می‌نویسد، سپس به اندازه کافی کد تولیدی (production code) می‌نویسد تا تست‌ها کار کنند، و در نهایت، کد را برای حذف هرگونه تکرار (duplication) بازسازی (refactor) می‌کند. با استفاده از متدولوژی توسعه نرم‌افزار YAGNI (YAGNI software development methodology)، کلاس‌ها، متدها و خطوط کلی کد خود را در حداقل مطلق نگه می‌دارید.

هدف اصلی YAGNI جلوگیری از مهندسی بیش از حد (over-engineering) سیستم‌های نرم‌افزاری توسط برنامه‌نویسان کامپیوتر است. اگر پیچیدگی لازم نیست، آن را اضافه نکنید. باید به یاد داشته باشید که فقط کدی را بنویسید که به آن نیاز دارید. کدی را که به آن نیاز ندارید ننویسید، و کدی را صرفاً برای آزمایش و یادگیری ننویسید. کد آزمایشی و یادگیری را در پروژه‌های sandbox (sandboxed projects) که به طور خاص برای آن اهداف هستند، نگه دارید.

## DRY (Don't Repeat Yourself)

من گفتم خودت را تکرار نکن (Don't Repeat Yourself)! اگر متوجه شدید که در چندین بخش، یک کد یکسان را می‌نویسید، این یک نامزد قطعی برای بازسازی (refactoring) است. باید به کد نگاه کنید تا ببینید آیا می‌توان آن را عمومی‌سازی (genericized) کرد و در یک کلاس کمکی (helper class) برای استفاده در سراسر سیستم یا در یک کتابخانه (library) برای استفاده توسط پروژه‌های دیگر قرار داد.

اگر یک قطعه کد یکسان در چندین مکان دارید، و متوجه شدید که کد دارای خطایی است و نیاز به اصلاح دارد، باید کد را در سایر مناطق نیز اصلاح کنید. در چنین شرایطی، نادیده گرفتن کدی که نیاز به اصلاح دارد، بسیار آسان است. نتیجه کدی است که با مشکل حل شده در برخی مناطق منتشر می‌شود، اما همچنان در مناطق دیگر وجود دارد.

به همین دلیل ایده خوبی است که کد تکراری را به محض مواجهه با آن حذف کنید، زیرا اگر این کار را نکنید ممکن است در آینده مشکلات بیشتری ایجاد کند.

## SOLID

SOLID مجموعه‌ای از پنج اصل طراحی (design principles) است که قصد دارند نرم‌افزار را آسان‌تر درک و نگهداری کنند. کد نرم‌افزار باید آسان خوانده و گسترش یابد بدون نیاز به اصلاح بخش‌هایی از کد موجود. پنج اصل طراحی SOLID به شرح زیر هستند:

+ اصل مسئولیت واحد (Single Responsibility Principle): کلاس‌ها و متدها باید تنها یک مسئولیت واحد را انجام دهند. تمام عناصری که یک مسئولیت واحد را تشکیل می‌دهند باید با هم گروه‌بندی و کپسوله‌سازی (encapsulated) شوند.

+ اصل باز/بسته (Open/Closed Principle): کلاس‌ها و متدها باید برای گسترش (extension) باز باشند و برای اصلاح (modification) بسته باشند. هنگامی که تغییری در نرم‌افزار لازم است، باید بتوانید نرم‌افزار را بدون اصلاح هیچ یک از کدها گسترش دهید.

+ جایگزینی لیسکوف (Liskov Substitution): تابع شما یک اشاره‌گر (pointer) به یک کلاس پایه (base class) دارد. باید بتواند از هر کلاسی که از کلاس پایه مشتق شده است بدون اطلاع از آن استفاده کند.

+ اصل تفکیک اینترفیس (Interface Segregation Principle): هنگامی که اینترفیس‌های بزرگی دارید، مشتریانی که از آن‌ها استفاده می‌کنند ممکن است به تمام متدها نیاز نداشته باشند. بنابراین، با استفاده از اصل تفکیک اینترفیس (ISP)، متدها را به اینترفیس‌های مختلف استخراج (extract) می‌کنید. این بدان معناست که به جای داشتن یک اینترفیس بزرگ، چندین اینترفیس کوچک دارید. کلاس‌ها می‌توانند اینترفیس‌هایی را پیاده‌سازی کنند که فقط متدهای مورد نیازشان را دارند.

+ اصل وارونگی وابستگی (Dependency Inversion Principle): هنگامی که یک ماژول سطح بالا (high-level module) دارید، نباید به هیچ ماژول سطح پایین (low-level modules) وابسته باشد. باید بتوانید آزادانه بین ماژول‌های سطح پایین جابه‌جا شوید بدون اینکه ماژول سطح بالایی که از آن‌ها استفاده می‌کند تحت تأثیر قرار گیرد. هم ماژول‌های سطح بالا و هم سطح پایین باید به انتزاعات (abstractions) وابسته باشند.

یک انتزاع (abstraction) نباید به جزئیات وابسته باشد، بلکه جزئیات باید به انتزاعات وابسته باشند.

هنگامی که متغیرها را اعلان می‌کنید، همیشه باید از انواع استاتیک (static types) مانند یک اینترفیس (interface) یا کلاس انتزاعی (abstract class) استفاده کنید. سپس کلاس‌های کانکریت (concrete classes) که اینترفیس را پیاده‌سازی می‌کنند یا از کلاس انتزاعی ارث می‌برند، می‌توانند به متغیر انتساب داده شوند.

## تیغ اوکام (Occam's Razor)

تیغ اوکام (Occam's Razor) بیان می‌کند: "موجودیت‌ها را نباید بدون ضرورت تکثیر کرد." به عبارت دیگر، این به طور اساسی به این معنی است که ساده‌ترین راه‌حل به احتمال زیاد راه‌حل صحیح است. بنابراین، در توسعه نرم‌افزار (software development)، نقض اصل تیغ اوکام با فرضیات غیرضروری (unnecessary assumptions) و به کارگیری نا-ساده‌ترین راه‌حل (least simple solution) برای یک مسئله نرم‌افزاری انجام می‌شود.

پروژه‌های نرم‌افزاری (Software projects) معمولاً بر اساس مجموعه‌ای از حقایق (facts) و فرضیات (assumptions) بنا می‌شوند. برخورد با حقایق آسان است اما فرضیات چیز دیگری هستند. هنگام ارائه یک راه‌حل پروژه نرم‌افزاری برای یک مشکل، شما معمولاً مشکل و راه‌حل‌های بالقوه را به صورت تیمی مورد بحث قرار می‌دهید. هنگام انتخاب یک راه‌حل، همیشه باید پروژه‌ای را با کمترین فرضیات (least assumptions) انتخاب کنید زیرا این دقیق‌ترین انتخاب برای پیاده‌سازی خواهد بود. اگر چند فرضیه منطقی وجود داشته باشد، هرچه فرضیات بیشتری را مجبور باشید بپذیرید، احتمال اینکه راه‌حل طراحی شما معیوب (flawed) باشد، بیشتر است.

پروژه‌ای با اجزای متحرک کمتر (less moving parts)، مشکلات کمتری خواهد داشت. بنابراین، با کوچک نگه داشتن پروژه‌ها با حداقل موجودیت‌ها با عدم ساخت فرضیات مگر اینکه ضروری باشند، و فقط با حقایق سر و کار داشتن، به اصل تیغ اوکام پایبند هستید.

## خلاصه (Summary)

در این فصل، شما با کد خوب (good code) و کد بد (bad code) آشنا شدید و امیدواریم اکنون درک کنید که چرا کد خوب مهم است. همچنین لینک قراردادهای کدنویسی C# مایکروسافت (Microsoft C# coding conventions) به شما ارائه شده است تا بتوانید از بهترین شیوه‌های مایکروسافت (Microsoft best practices) برای کدنویسی پیروی کنید (اگر قبلاً این کار را نمی‌کردید).

شما همچنین به طور خلاصه با متدولوژی‌های مختلف نرم‌افزاری (various software methodologies) از جمله DRY، KISS، SOLID، YAGNI و تیغ اوکام (Occam's Razor) آشنا شدید.

با استفاده از ماژولار بودن (modularity)، مزایای ماژولار کردن کد (modularizing code) با استفاده از فضاهای نام (namespaces) و مجموعه‌ها (assemblies) را مشاهده کردید. چنین مزایایی شامل توانایی تیم‌های مستقل برای کار بر روی ماژول‌های مستقل (independent modules)، و قابلیت استفاده مجدد کد (code reusability) و قابلیت نگهداری (maintainability) است.

در فصل بعدی، به بررسی‌های کد همتا (peer code reviews) خواهیم پرداخت. آن‌ها ممکن است گاهی ناخوشایند باشند، اما بررسی‌های کد همتا به کنترل برنامه‌نویسان کمک می‌کنند تا مطمئن شوند که آن‌ها به روش کدنویسی شرکت (company coding procedure) پایبند هستند.

## سوالات (Questions)

1. برخی از پیامدهای کد بد چیست؟

2. برخی از پیامدهای کد خوب چیست؟

3. برخی از مزایای نوشتن کد ماژولار چیست؟

4. کد DRY چیست؟

5. چرا هنگام نوشتن کد باید KISS را رعایت کنید؟

6. مخفف SOLID به چه معناست؟

7. YAGNI را توضیح دهید.

8. تیغ اوکام چیست؟

## مطالعه بیشتر (Further reading)

+ Adaptive Code: Agile coding with design patterns and SOLID principles, Second Edition by Gary McLean Hall

+ Hands-On Design Patterns with C# and .NET Core by Jeffrey Chilberto and Gaurav Aroraa

+ Building Maintainable Software, C# Edition by Rob can der Leek, Pascal can Eck, Gijs Wijnholds, Sylvan Rigal, and Joost Visser

+ اطلاعات خوب در مورد ضد الگوهای نرم‌افزاری (software anti-patterns)، شامل لیستی طولانی از ضد الگوها، را می‌توانید در مقدمه‌ای بر مهندسی نرم‌افزار / معماری / ضد الگوها در Wikibooks پیدا کنید.<https://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Architecture/Anti-Patterns>.

+ اطلاعات خوب در مورد الگوهای طراحی (design patterns)، با لیستی از الگوهای طراحی که به نمودارها (diagrams) و کد منبع پیاده‌سازی (implementation source code) لینک می‌شوند، را می‌توانید در الگوی طراحی نرم‌افزار در Wikipedia پیدا کنید.<https://en.wikipedia.org/wiki/Software_design_pattern>.
