---
layout: layout.njk
title: Span<T> ู Memory<T>
---
# ูุตู ุจุณุช  ู ุณูู:  Span<T> ู Memory<T>

ุณุงุฎุชุงุฑูุง `Span<T>` ู `Memory<T>` ุจูโุนููุงู ููุงูโูุง ุณุทุญ ูพุงู ุฑู ฺฉ ุขุฑุงูุ ุฑุดุชู ุง ูุฑ ุจููฺฉ ูพูุณุชูโุง ุงุฒ ุญุงูุธู ูุฏุฑุชโุดุฏู ุง ุบุฑูุฏุฑุชโุดุฏู ุนูู ูโฺฉููุฏ. ูุฏู ุงุตู ุขูโูุง ฺฉูฺฉ ุจู ุจุฑุฎ ุงููุงุน ูฺฉุฑูุจูููโุณุงุฒโูุง ุงุณุชโุจูโูฺู ููุดุชู ฺฉุฏ ุจุง ุชุฎุตุต ุญุฏุงูู ุญุงูุธู ฺฉู ุชุฎุตุตโูุง ุญุงูุธู ูุฏุฑุชโุดุฏู ุฑุง ุจู ุญุฏุงูู ูโุฑุณุงูุฏ (ู ุฏุฑ ูุชุฌู ูุดุงุฑ ุฑู **garbage collector** ุฑุง ฺฉุงูุด ูโุฏูุฏ)ุ ุจุฏูู ุงูฺฉู ูุงุฒ ุจุงุดุฏ ฺฉุฏ ุฎูุฏ ุฑุง ุจุฑุง ุงููุงุน ูุฎุชูู ูุฑูุฏ ุชฺฉุฑุงุฑ ฺฉูุฏ.

ุขูโูุง ููฺูู ุงูฺฉุงู **slicing** ุฑุง ูุฑุงูู ูโฺฉููุฏโฺฉุงุฑ ุจุง ุจุฎุด ุงุฒ ุขุฑุงูุ ุฑุดุชู ุง ุจููฺฉ ุญุงูุธู ุจุฏูู ุงุฌุงุฏ ฺฉ ูุณุฎู ฺฉูพ.

`Span<T>` ู `Memory<T>` ุจูโูฺู ุฏุฑ **ููุงุท ุฏุงุบ ุนููฺฉุฑุฏ** ููุฏ ูุณุชูุฏุ ูุงููุฏ **ASP.NET Core processing pipeline** ุง ฺฉ **JSON parser** ฺฉู ุจู ฺฉ ูพุงฺฏุงู ุฏุงุฏู ุดุกโฺฏุฑุง ุณุฑูุณ ูโุฏูุฏ.

ุงฺฏุฑ ุฏุฑ ฺฉ API ุจุง ุงู ููุนโูุง ููุงุฌู ุดุฏุฏ ู ูุงุฒ ุจู ูุฒุงุง ุจุงูููู ุนููฺฉุฑุฏ ุขูโูุง ูุฏุงุฑุฏุ ูโุชูุงูุฏ ุจูโุณุงุฏฺฏ ุจู ุดฺฉู ุฒุฑ ุจุง ุขูโูุง ฺฉุงุฑ ฺฉูุฏ:

* ููุช ูุชุฏ ุงูุชุธุงุฑ ฺฉ `Span<T>`, `ReadOnlySpan<T>`, `Memory<T>` ุง `ReadOnlyMemory<T>` ุฏุงุฑุฏุ ุจู ุฌุง ุขู ฺฉ ุขุฑุงู ุงุฑุณุงู ฺฉูุฏุ ุนู `T[]`. (ุงู ุจู ูุทู **ุนููฺฏุฑูุง ุชุจุฏู ุถูู** ููฺฉู ุงุณุช.)
* ุจุฑุง ุชุจุฏู ุงุฒ ฺฉ **span/memory** ุจู ุขุฑุงูุ ูุชุฏ `ToArray` ุฑุง ูุฑุงุฎูุงู ฺฉูุฏ. ู ุงฺฏุฑ `T` ุงุฒ ููุน `char` ุจุงุดุฏุ `ToString` span/memory ุฑุง ุจู ุฑุดุชู ุชุจุฏู ูโฺฉูุฏ.

ุงุฒ **C# 12** ุจู ุจุนุฏุ ูโุชูุงูุฏ ุงุฒ **collection initializers** ุจุฑุง ุงุฌุงุฏ spanูุง ูุฒ ุงุณุชูุงุฏู ฺฉูุฏ.

---

ุจูโุทูุฑ ูุดุฎุตุ `Span<T>` ุฏู ฺฉุงุฑ ุงูุฌุงู ูโุฏูุฏ:

* ฺฉ **ุฑุงุจุท ุขุฑุงูโูุงููุฏ ูุดุชุฑฺฉ** ุฑู ุขุฑุงูโูุง ูุฏุฑุชโุดุฏูุ ุฑุดุชูโูุง ู ุญุงูุธู ูพุดุชุจุงูโุดุฏู ุชูุณุท ุงุดุงุฑูโฺฏุฑ ูุฑุงูู ูโฺฉูุฏ. ุงู ุงูฺฉุงู ุฑุง ูโุฏูุฏ ุชุง ุงุฒ **stack-allocated** ู ุญุงูุธู ุบุฑูุฏุฑุชโุดุฏู ุงุณุชูุงุฏู ฺฉูุฏ ู ุงุฒ garbage collection ุงุฌุชูุงุจ ฺฉูุฏุ ุจุฏูู ุงูฺฉู ฺฉุฏ ุฎูุฏ ุฑุง ุชฺฉุฑุงุฑ ฺฉุฑุฏู ุง ุจุง ุงุดุงุฑูโฺฏุฑูุง ฺฉุงุฑ ฺฉูุฏ.
* ุงูฺฉุงู **slicing** ูุฑุงูู ูโฺฉูุฏ: ุจุฎุดโูุง ูุงุจู ุงุณุชูุงุฏู ูุฌุฏุฏ span ุฑุง ุจุฏูู ุงุฌุงุฏ ฺฉูพ ุฏุฑ ุงุฎุชุงุฑ ูโฺฏุฐุงุฑุฏ.

`Span<T>` ุชููุง ุงุฒ ุฏู ููุฏ ุชุดฺฉู ุดุฏู ุงุณุช: ฺฉ ุงุดุงุฑูโฺฏุฑ ู ฺฉ ุทูู. ุจู ููู ุฏููุ ููุท ูโุชูุงูุฏ ุจููฺฉโูุง **ูพูุณุชู ุญุงูุธู** ุฑุง ููุงุด ุฏูุฏ. (ุงฺฏุฑ ูุงุฒ ุจู ฺฉุงุฑ ุจุง ุญุงูุธู ุบุฑูพูุณุชู ุฏุงุฑุฏุ ฺฉูุงุณ `ReadOnlySequence<T>` ุจูโุนููุงู ฺฉ **linked list** ุฏุฑ ุฏุณุชุฑุณ ุงุณุช.)

ุงุฒ ุขูุฌุง ฺฉู `Span<T>` ูโุชูุงูุฏ ุญุงูุธู ุชุฎุตุตโุงูุชู ุฑู stack ุฑุง ุจูพูุดุงูุฏุ ูุญุฏูุฏุชโูุง ุจุฑ ูุญูู ุฐุฎุฑู ุง ุงูุชูุงู ูููููโูุง ูุฌูุฏ ุฏุงุฑุฏ (ฺฉู ุจุฎุด ุงุฒ ุขู ุจู ุฏูู ุงูฺฉู `Span<T>` ฺฉ **ref struct** ุงุณุช ุงุนูุงู ูโุดูุฏ).
`Memory<T>` ูุงููุฏ ฺฉ span ุนูู ูโฺฉูุฏ ุงูุง ุจุฏูู ุงู ูุญุฏูุฏุชโูุงุ ุจุง ุงู ุญุงู ููโุชูุงูุฏ ุญุงูุธู ุงุฎุชุตุงุตโุงูุชู ุฑู stack ุฑุง ุจูพูุดุงูุฏ. ุจุง ุงู ุญุงูุ `Memory<T>` ููฺูุงู ูุฒุช **slicing** ุฑุง ูุฑุงูู ูโฺฉูุฏ.

ูุฑ ุณุงุฎุชุงุฑ ุฏุงุฑุง ฺฉ ููุชุง **read-only** ุงุณุช (`ReadOnlySpan<T>` ู `ReadOnlyMemory<T>`). ุนูุงูู ุจุฑ ุฌููฺฏุฑ ุงุฒ ุชุบุฑุงุช ุบุฑุนูุฏุ ููุชุงุงู read-only ุนููฺฉุฑุฏ ุฑุง ุจุง ุฏุงุฏู ุขุฒุงุฏ ุจุดุชุฑ ุจู **compiler** ู **runtime** ุจุฑุง ุจูููโุณุงุฒ ุงูุฒุงุด ูโุฏููุฏ.

ุฎูุฏ **.NET** (ู **ASP.NET Core**) ุงุฒ ุงู ููุนโูุง ุจุฑุง ุจูุจูุฏ ฺฉุงุฑุง ุฏุฑ I/Oุ ุดุจฺฉูุ ูพุฑุฏุงุฒุด ุฑุดุชู ู **JSON parsing** ุงุณุชูุงุฏู ูโฺฉููุฏ.

ุชูุงูุง `Span<T>` ู `Memory<T>` ุฏุฑ ุงูุฌุงู **array slicing** ุจุงุนุซ ุดุฏู ุงุณุช ฺฉูุงุณ ูุฏู `ArraySegment<T>` ุจูุงุงุณุชูุงุฏู ุดูุฏ. ุจุฑุง ฺฉูฺฉ ุจู ูุฑฺฏููู ุงูุชูุงูุ **ุนููฺฏุฑูุง ุชุจุฏู ุถูู** ุงุฒ `ArraySegment<T>` ุจู ุชูุงู ุณุงุฎุชุงุฑูุง span/memory ู ุงุฒ `Memory<T>` ู `ReadOnlyMemory<T>` ุจู `ArraySegment<T>` ููุฌูุฏ ุงุณุช.

---

### โ๏ธ Spans ู Slicing

ุจุฑ ุฎูุงู ุขุฑุงูุ ฺฉ span ูโุชูุงูุฏ ุจูโุณุงุฏฺฏ **slice** ุดูุฏ ุชุง ุจุฎุดโูุง ูุฎุชูู ุฏุงุฏูโูุง ุฒุฑู ุฑุง ููุงุด ุฏูุฏุ ููุงูโุทูุฑ ฺฉู ุฏุฑ ุดฺฉู 23-1 ูุดุงู ุฏุงุฏู ุดุฏู ุงุณุช.

ุจุฑุง ูุซุงู ุนููุ ูุฑุถ ฺฉูุฏ ูโุฎูุงูุฏ ูุชุฏ ุจุฑุง ุฌูุนโุขูุฑ ุนูุงุตุฑ ฺฉ ุขุฑุงู ุงุฒ ุงุนุฏุงุฏ ุตุญุญ ุจููุณุฏ. ฺฉ ูพุงุฏูโุณุงุฒ ูฺฉุฑูุจูููโุดุฏูุ ุงุฒ LINQ ุงุฌุชูุงุจ ฺฉุฑุฏู ู ุงุฒ ุญููู `foreach` ุงุณุชูุงุฏู ูโฺฉูุฏ:

```csharp
int Sum (int[] numbers)
{
    int total = 0;
    foreach (int i in numbers) total += i;
    return total;
}
```

 <div align="center">

![Conventions-UsedThis-Book](../../../assets/image/23/Table-23-1.jpeg)
</div>

ุญุงูุง ุชุตูุฑ ฺฉูุฏ ฺฉู ูโุฎูุงูุฏ ููุท **ุจุฎุด ุงุฒ ุขุฑุงู** ุฑุง ุฌูุน ุจุฒูุฏ. ุฏุฑ ุงู ุญุงูุช ุฏู ฺฏุฒูู ุฏุงุฑุฏ:

* ุงุจุชุฏุง ุจุฎุด ููุฑุฏ ูุธุฑ ุขุฑุงู ุฑุง ุฏุฑ ฺฉ ุขุฑุงู ุฏฺฏุฑ ฺฉูพ ฺฉูุฏ
* ุง ูพุงุฑุงูุชุฑูุง ุงุถุงู ุจู ูุชุฏ ุงุถุงูู ฺฉูุฏ (ูุงููุฏ **offset** ู **count**)

ฺฏุฒูู ุงูู ูุงฺฉุงุฑุขูุฏ ุงุณุช ู ฺฏุฒูู ุฏูู ุจุงุนุซ ุดููุบ ู ูพฺุฏฺฏ ูโุดูุฏ (ุงู ูุดฺฉู ููุช ุจุฏุชุฑ ูโุดูุฏ ฺฉู ูุชุฏูุง ูุงุฒ ุฏุงุดุชู ุจุงุดูุฏ ุจุด ุงุฒ ฺฉ ุขุฑุงู ุฑุง ูุจูู ฺฉููุฏ).

`Span` ุงู ูุดฺฉู ุฑุง ุจูโุฎูุจ ุญู ูโฺฉูุฏ. ุชููุง ฺฉุงุฑ ฺฉู ุจุงุฏ ุงูุฌุงู ุฏูุฏ ุงู ุงุณุช ฺฉู ููุน ูพุงุฑุงูุชุฑ ุฑุง ุงุฒ `int[]` ุจู `ReadOnlySpan<int>` ุชุบุฑ ุฏูุฏ (ุจูู ฺฉุฏ ููุงู ูโูุงูุฏ):

```csharp
int Sum (ReadOnlySpan<int> numbers)
{
    int total = 0;
    foreach (int i in numbers) total += i;
    return total;
}
```

ูุง ุงุฒ `ReadOnlySpan<T>` ุจู ุฌุง `Span<T>` ุงุณุชูุงุฏู ฺฉุฑุฏู ฺูู ูุงุฒ ุจู ุชุบุฑ ุขุฑุงู ูุฏุงุฑู. ฺฉ **ุชุจุฏู ุถูู** ุงุฒ `Span<T>` ุจู `ReadOnlySpan<T>` ูุฌูุฏ ุฏุงุฑุฏุ ุจูุงุจุฑุงู ูโุชูุงูุฏ ฺฉ `Span<T>` ุฑุง ุจู ูุชุฏ ุจุฏูุฏ ฺฉู ุงูุชุธุงุฑ ฺฉ `ReadOnlySpan<T>` ุฏุงุฑุฏ.

ูโุชูุงูู ุงู ูุชุฏ ุฑุง ุจู ุดฺฉู ุฒุฑ ุชุณุช ฺฉูู:

```csharp
var numbers = new int[1000];
for (int i = 0; i < numbers.Length; i++) numbers[i] = i;
int total = Sum(numbers);
```

ูโุชูุงูู `Sum` ุฑุง ุจุง ุขุฑุงู ุตุฏุง ุจุฒูู ุฒุฑุง **ุชุจุฏู ุถูู** ุงุฒ `T[]` ุจู `Span<T>` ู `ReadOnlySpan<T>` ูุฌูุฏ ุฏุงุฑุฏ. ฺฏุฒูู ุฏฺฏุฑ ุงุณุชูุงุฏู ุงุฒ **ูุชุฏ extension** `AsSpan` ุงุณุช:

```csharp
var span = numbers.AsSpan();
```

ุดุงุฎุตโฺฏุฐุงุฑ (`indexer`) ุจุฑุง `ReadOnlySpan<T>` ุงุฒ ูฺฺฏ **ref readonly** ุฏุฑ C# ุงุณุชูุงุฏู ูโฺฉูุฏ ุชุง ูุณุชููุงู ุจู ุฏุงุฏูโูุง ุฒุฑู ุฏุณุชุฑุณ ูพุฏุง ฺฉูุฏ. ุงู ุงูฺฉุงู ุจุงุนุซ ูโุดูุฏ ูุชุฏ ูุง ุชูุฑุจุงู ุจู ููุงู ุฎูุจ ูุณุฎู ุงุตู ฺฉู ุงุฒ ุขุฑุงู ุงุณุชูุงุฏู ูโฺฉุฑุฏ ุนูู ฺฉูุฏ. ุงูุง ูุฒุช ุขู ุงู ุงุณุช ฺฉู ุญุงูุง ูโุชูุงูู ุขุฑุงู ุฑุง **slice** ฺฉูู ู ููุท ุจุฎุด ุงุฒ ุนูุงุตุฑ ุฑุง ุฌูุน ุจุฒููุ ุจูโุตูุฑุช ุฒุฑ:

```csharp
// ุฌูุน ตฐฐ ุนูุตุฑ ูุณุท ุขุฑุงู (ุดุฑูุน ุงุฒ ูููุนุช ฒตฐ):
int total = Sum(numbers.AsSpan(250, 500));
```

ุงฺฏุฑ ุงุฒ ูุจู ฺฉ `Span<T>` ุง `ReadOnlySpan<T>` ุฏุงุฑุฏุ ูโุชูุงูุฏ ุขู ุฑุง ุจุง ูุชุฏ `Slice` ุจุฑุด ุฏูุฏ:

```csharp
Span<int> span = numbers;
int total = Sum(span.Slice(250, 500));
```

ููฺูู ูโุชูุงูุฏ ุงุฒ **indices ู ranges ุฏุฑ C# 8** ุงุณุชูุงุฏู ฺฉูุฏ:

```csharp
Span<int> span = numbers;
Console.WriteLine(span[^1]);          // ุขุฎุฑู ุนูุตุฑ
Console.WriteLine(Sum(span[..10]));   // ฑฐ ุนูุตุฑ ุงูู
Console.WriteLine(Sum(span[100..]));  // ุงุฒ ุนูุตุฑ ฑฐฐ ุชุง ุงูุชูุง
Console.WriteLine(Sum(span[^5..]));   // ต ุนูุตุฑ ุขุฎุฑ
```

ุงฺฏุฑฺู `Span<T>` `IEnumerable<T>` ุฑุง ูพุงุฏูโุณุงุฒ ููโฺฉูุฏ (ฺูู ฺฉ **ref struct** ุงุณุช ู ููโุชูุงูุฏ ุงูุชุฑูุณโูุง ุฑุง ูพุงุฏูโุณุงุฒ ฺฉูุฏ)ุ ุงูุง ุงูฺฏู ุฑุง ูพุงุฏู ูโฺฉูุฏ ฺฉู ุงุฌุงุฒู ูโุฏูุฏ **foreach** ุฏุฑ C# ุฑู ุขู ฺฉุงุฑ ฺฉูุฏ (ุจู ุตูุญู ฒฐณ ูุฑุงุฌุนู ฺฉูุฏ).

---

### ๐ CopyTo ู TryCopyTo

ูุชุฏ `CopyTo` ุนูุงุตุฑ ฺฉ span (ุง `Memory<T>`) ุฑุง ุจู span ุฏฺฏุฑ ฺฉูพ ูโฺฉูุฏ. ุฏุฑ ูุซุงู ุฒุฑุ ููู ุนูุงุตุฑ `span x` ุฑุง ุฏุฑ `span y` ฺฉูพ ูโฺฉูู:

```csharp
Span<int> x = [1, 2, 3, 4];   // Collection expression
Span<int> y = new int[4];
x.CopyTo(y);
```

ุชูุฌู ฺฉูุฏ ฺฉู `x` ุจุง ฺฉ **collection expression** ููุฏุงุฑุฏู ุดุฏู ุงุณุช. **Collection expressions** (ุงุฒ C# 12) ูู ุชููุง ฺฉ ูุงูุจุฑ ููุฏ ูุณุชูุฏุ ุจูฺฉู ุฏุฑ ููุฑุฏ spanูุง ุงุฌุงุฒู ูโุฏููุฏ **ฺฉุงููพุงูุฑ ููุน ุฒุฑู ุฑุง ุงูุชุฎุงุจ ฺฉูุฏ**. ููุช ุชุนุฏุงุฏ ุนูุงุตุฑ ฺฉู ุงุณุชุ ฺฉุงููพุงูุฑ ููฺฉู ุงุณุช ุญุงูุธู ุฑุง ุฑู **stack** ุชุฎุตุต ุฏูุฏ (ุจู ุฌุง ุงุฌุงุฏ ุขุฑุงู) ุชุง ุงุฒ ุณุฑุจุงุฑ ุชุฎุตุต ุฑู heap ุฌููฺฏุฑ ฺฉูุฏ.

**Slicing** ุงู ูุชุฏ ุฑุง ุจุณุงุฑ ฺฉุงุฑุจุฑุฏโุชุฑ ูโฺฉูุฏ. ุฏุฑ ูุซุงู ุจุนุฏุ ูุตู ุงูู `span x` ุฑุง ุฏุฑ ูุตู ุฏูู `span y` ฺฉูพ ูโฺฉูู:

```csharp
Span<int> x = [1, 2, 3, 4];
Span<int> y = [10, 20, 30, 40];
x[..2].CopyTo(y[2..]);   // y ุงฺฉููู [10, 20, 1, 2]
```

ุงฺฏุฑ ูุถุง ฺฉุงู ุฏุฑ ููุตุฏ ูุฌูุฏ ูุฏุงุดุชู ุจุงุดุฏุ `CopyTo` **exception** ูพุฑุชุงุจ ูโฺฉูุฏุ ุฏุฑ ุญุงู ฺฉู `TryCopyTo` **false** ุจุฑูโฺฏุฑุฏุงูุฏ (ุจุฏูู ฺฉูพ ฺฉุฑุฏู ุนูุงุตุฑ).

ุณุงุฎุชุงุฑูุง span ููฺูู ูุชุฏูุง ุจุฑุง **Clear** ู **Fill** ู ููฺูู ูุชุฏ `IndexOf` ุจุฑุง ุฌุณุชุฌู ุนูุตุฑ ุฏุฑ span ุงุฑุงุฆู ูโุฏููุฏ.

---

### ๐ ุฌุณุชุฌู ุฏุฑ Spans

ฺฉูุงุณ `MemoryExtensions` ูุชุฏูุง ุชูุณุนู ูุชุนุฏุฏ ุจุฑุง ุฌุณุชุฌู ููุงุฏุฑ ุฏุฑ spanูุง ุงุฑุงุฆู ูโุฏูุฏุ ูุงููุฏ: `Contains`, `IndexOf`, `LastIndexOf`, `BinarySearch` ู ููฺูู ูุชุฏูุง ฺฉู spanูุง ุฑุง ุชุบุฑ ูโุฏููุฏุ ูุงููุฏ: `Fill`, `Replace`, `Reverse`.

ุงุฒ .NET 8ุ ูุชุฏูุง ูุฒ ุจุฑุง ุฌุณุชุฌู **ูุฑ ฺฉ ุงุฒ ฺูุฏ ููุฏุงุฑ** ูุฌูุฏ ุฏุงุฑุฏุ ูุงููุฏ: `ContainsAny`, `ContainsAnyExcept`, `IndexOfAny`, `IndexOfAnyExcept`.

ุจุง ุงู ูุชุฏูุง ูโุชูุงูุฏ ููุงุฏุฑ ููุฑุฏ ุฌุณุชุฌู ุฑุง ุจู ุตูุฑุช ฺฉ span ุง ุจู ุตูุฑุช ฺฉ ููููู `SearchValues<T>` (ุฏุฑ `System.Buffers`) ูุดุฎุต ฺฉูุฏุ ฺฉู ุจุง `SearchValues.Create` ุงุฌุงุฏ ูโุดูุฏ:

```csharp
ReadOnlySpan<char> span = "The quick brown fox jumps over the lazy dog.";
var vowels = SearchValues.Create("aeiou");
Console.WriteLine(span.IndexOfAny(vowels));   // 2
```

`SearchValues<T>` ุนููฺฉุฑุฏ ุฑุง ุจูุจูุฏ ูโุฏูุฏ ููุช ฺฉู ููููู ุฏุฑ ุฌุณุชุฌููุง ูุชุนุฏุฏ ุฏูุจุงุฑู ุงุณุชูุงุฏู ุดูุฏ.

ูโุชูุงูุฏ ุงุฒ ุงู ูุชุฏูุง ููฺฏุงู ฺฉุงุฑ ุจุง ุขุฑุงูโูุง ุง ุฑุดุชูโูุง ูุฒ ุงุณุชูุงุฏู ฺฉูุฏุ ฺฉุงู ุงุณุช `AsSpan()` ุฑู ุขุฑุงู ุง ุฑุดุชู ูุฑุงุฎูุงู ุดูุฏ.

### โ๏ธ ฺฉุงุฑ ุจุง ูุชู (Working with Text)

`Span`ูุง ุทูุฑ ุทุฑุงุญ ุดุฏูโุงูุฏ ฺฉู ุจุง ุฑุดุชูโูุง ุจูโุฎูุจ ฺฉุงุฑ ฺฉููุฏุ ฺฉู ุจูโุนููุงู `ReadOnlySpan<char>` ุฏุฑ ูุธุฑ ฺฏุฑูุชู ูโุดููุฏ. ูุชุฏ ุฒุฑ ุชุนุฏุงุฏ ฺฉุงุฑุงฺฉุชุฑูุง ูุงุตูู (whitespace) ุฑุง ุดูุงุฑุด ูโฺฉูุฏ:

```csharp
int CountWhitespace(ReadOnlySpan<char> s)
{
    int count = 0;
    foreach (char c in s)
        if (char.IsWhiteSpace(c))
            count++;
    return count;
}
```

ูโุชูุงูุฏ ฺูู ูุชุฏ ุฑุง ุจุง ฺฉ ุฑุดุชู ุตุฏุง ุจุฒูุฏ (ุจู ูุทู **ุนููฺฏุฑ ุชุจุฏู ุถูู**):

```csharp
int x = CountWhitespace("Word1 Word2");   // ุฏุฑุณุช ุงุณุช
```

ุง ุจุง ฺฉ **substring**:

```csharp
int y = CountWhitespace(someString.AsSpan(20, 10));
```

ูุชุฏ `ToString()` ฺฉ `ReadOnlySpan<char>` ุฑุง ุจู ุฑุดุชู ุชุจุฏู ูโฺฉูุฏ.

ูุชุฏูุง ุชูุณุนู (**Extension Methods**) ุชุถูู ูโฺฉููุฏ ฺฉู ุจุฑุฎ ุงุฒ ูุชุฏูุง ูพุฑฺฉุงุฑุจุฑุฏ ฺฉูุงุณ ุฑุดุชู ูุฒ ุจุฑุง `ReadOnlySpan<char>` ุฏุฑ ุฏุณุชุฑุณ ุจุงุดูุฏ:

```csharp
var span = "This ".AsSpan();                  // ReadOnlySpan<char>
Console.WriteLine(span.StartsWith("This"));   // True
Console.WriteLine(span.Trim().Length);        // 4
```

> ุชูุฌู ฺฉูุฏ ฺฉู ูุชุฏูุง ูุงููุฏ `StartsWith` ุงุฒ **ordinal comparison** ุงุณุชูุงุฏู ูโฺฉููุฏุ ุฏุฑ ุญุงู ฺฉู ูุชุฏูุง ูุนุงุฏู ุฏุฑ ฺฉูุงุณ ุฑุดุชู ุจูโุทูุฑ ูพุดโูุฑุถ ุงุฒ **culture-sensitive comparison** ุงุณุชูุงุฏู ูโฺฉููุฏ.

ูุชุฏูุง ูุงููุฏ `ToUpper` ู `ToLower` ุฏุฑ ุฏุณุชุฑุณ ูุณุชูุฏุ ุงูุง ุจุงุฏ ฺฉ **destination span** ุจุง ุทูู ููุงุณุจ ุจุฏูุฏ (ุงู ุงูฺฉุงู ุฑุง ูโุฏูุฏ ฺฉู ุชุตูู ุจฺฏุฑุฏ ุญุงูุธู ุฑุง ฺฺฏููู ู ฺฉุฌุง ุชุฎุตุต ุฏูุฏ).

ุจุฑุฎ ุงุฒ ูุชุฏูุง ุฑุดุชู ุฏุฑ ุฏุณุชุฑุณ ูุณุชูุฏุ ูุงููุฏ `Split` ฺฉู ฺฉ ุฑุดุชู ุฑุง ุจู ุขุฑุงูโุง ุงุฒ ฺฉููุงุช ุชูุณู ูโฺฉูุฏ. ุฏุฑ ูุงูุนุ ููุดุชู ูุนุงุฏู ูุณุชูู `string.Split` ุบุฑููฺฉู ุงุณุชุ ฺูู ููโุชูุงู ฺฉ ุขุฑุงู ุงุฒ spanูุง ุงุฌุงุฏ ฺฉุฑุฏ.

ุฏูู ุขู ุงู ุงุณุช ฺฉู spanูุง ุจูโุตูุฑุช **ref struct** ุชุนุฑู ุดุฏูโุงูุฏ ู ุชููุง ูโุชูุงููุฏ ุฑู **stack** ูุฌูุฏ ุฏุงุดุชู ุจุงุดูุฏ.
(ููุช ูโฺฏูู "ููุท ุฑู stack ูุฌูุฏ ุฏุงุฑุฏ"ุ ููุธูุฑ ุงู ุงุณุช ฺฉู ุฎูุฏ struct ุชููุง ุฑู stack ูโุชูุงูุฏ ูุฌูุฏ ุฏุงุดุชู ุจุงุดุฏ. ูุญุชูุง ฺฉู span ุจู ุขู ุงุดุงุฑู ูโฺฉูุฏ ูโุชูุงูุฏโู ุฏุฑ ุงู ููุฑุฏ ุฑู heapโูุฌูุฏ ุฏุงุดุชู ุจุงุดุฏ.)

---

ูุถุง ูุงู `System.Buffers.Text` ุดุงูู ููุนโูุง ุงุถุงู ุจุฑุง ฺฉุงุฑ ุจุง ูุชู ูุจุชู ุจุฑ span ุงุณุชุ ุงุฒ ุฌููู:

* `Utf8Formatter.TryFormat` ูุนุงุฏู `ToString` ุฑุง ุฑู ุงููุงุน ุณุงุฏู ู ุฏุงุฎู ูุงููุฏ `decimal`ุ `DateTime` ู ุบุฑู ุงูุฌุงู ูโุฏูุฏุ ุงูุง ุฎุฑูุฌ ุฑุง ุจู ฺฉ span ูโููุณุฏ ุจู ุฌุง ุงูฺฉู ุฑุดุชู ุจุณุงุฒุฏ.
* `Utf8Parser.TryParse` ูุนฺฉูุณ ุนูู ูโฺฉูุฏ ู ุฏุงุฏูโูุง ุฑุง ุงุฒ ฺฉ span ุจู ฺฉ ููุน ุณุงุฏู ุชุจุฏู ูโฺฉูุฏ.
* ููุน `Base64` ูุชุฏูุง ุจุฑุง ุฎูุงูุฏู/ููุดุชู ุฏุงุฏูโูุง base-64 ุงุฑุงุฆู ูโุฏูุฏ.

ุงุฒ .NET 8 ุจู ุจุนุฏุ ุงููุงุน ุนุฏุฏ ู ุชุงุฑุฎ/ุฒูุงู (ู ุณุงุฑ ุงููุงุน ุณุงุฏู) ุงูฺฉุงู **ูุฑูุช ู ูพุงุฑุณ ูุณุชูู UTF-8** ุฑุง ุงุฒ ุทุฑู ูุชุฏูุง ุฌุฏุฏ `TryFormat` ู `Parse/TryParse` ฺฉู ุฑู `Span<byte>` ุนูู ูโฺฉููุฏุ ุฏุงุฑูุฏ. ุงู ูุชุฏูุง ุฏุฑ **interface**ูุง `IUtf8SpanFormattable` ู `IUtf8SpanParsable<TSelf>` ุชุนุฑู ุดุฏูโุงูุฏ (ุฏูู ุงุฒ ูุงุจูุช C# 12 ุจุฑุง ุชุนุฑู ุงุนุถุง static abstract interface ุจูุฑู ูโุจุฑุฏ).

ูุชุฏูุง ุจูุงุฏ CLR ูุงููุฏ `int.Parse` ูุฒ ุจูโุฑูุฒุฑุณุงู ุดุฏูโุงูุฏ ุชุง `ReadOnlySpan<char>` ุฑุง ุจูพุฐุฑูุฏ.

---

### ๐พ Memory<T>

`Span<T>` ู `ReadOnlySpan<T>` ุจูโุตูุฑุช **ref struct** ุชุนุฑู ุดุฏูโุงูุฏ ุชุง ุจุดุชุฑู ูพุชุงูุณู ุจูููโุณุงุฒ ุฑุง ุฏุงุดุชู ุจุงุดูุฏ ู ุจุชูุงููุฏ ุจุง ุญุงูุธู ุชุฎุตุตโุงูุชู ุฑู stack ุจูโุทูุฑ ุงูู ฺฉุงุฑ ฺฉููุฏ (ููุงูโุทูุฑ ฺฉู ุฏุฑ ุจุฎุด ุจุนุฏ ุฎูุงูุฏ ุฏุฏ). ุงูุง ุงู ูุญุฏูุฏุชโูุง ุฑุง ูุฒ ุงุฌุงุฏ ูโฺฉูุฏ:

ุนูุงูู ุจุฑ ุงูฺฉู ุจุง ุขุฑุงูโูุง ฺูุฏุงู ุณุงุฒฺฏุงุฑ ูุณุชูุฏุ ููโุชูุงู ุงุฒ ุขูโูุง ุจูโุนููุงู ููุฏ ุฏุฑ ฺฉ ฺฉูุงุณ ุงุณุชูุงุฏู ฺฉุฑุฏ (ฺูู ุขูโูุง ุฑุง ุฑู heap ูุฑุงุฑ ูโุฏูุฏ). ุงู ูุญุฏูุฏุช ุจุงุนุซ ูโุดูุฏ ูุชูุงู ุขูโูุง ุฑุง ุฏุฑ **lambda expressions** ู ุจูโุนููุงู ูพุงุฑุงูุชุฑ ุฏุฑ **asynchronous methods**, **iterators** ู **asynchronous streams** ุงุณุชูุงุฏู ฺฉุฑุฏ:

```csharp
async void Foo(Span<int> notAllowed)   // ุฎุทุง ุฒูุงู ฺฉุงููพุงู!
```

(ุจู ุงุฏ ุฏุงุดุชู ุจุงุดุฏ ฺฉู ฺฉุงููพุงูุฑ ูุชุฏูุง async ู iterator ุฑุง ุจุง ููุดุชู ฺฉ **private state machine** ูพุฑุฏุงุฒุด ูโฺฉูุฏุ ุจูุงุจุฑุงู ูุฑ ูพุงุฑุงูุชุฑ ู ูุชุบุฑ ูุญู ุจู ููุฏ ุชุจุฏู ูโุดูุฏ. ููู ููุถูุน ุฏุฑ lambdaูุง ฺฉู ุฑู ูุชุบุฑูุง ุจุณุชู ูโุดููุฏ ูุฒ ุตุงุฏู ุงุณุช.)

ุณุงุฎุชุงุฑูุง `Memory<T>` ู `ReadOnlyMemory<T>` ุงู ูุญุฏูุฏุช ุฑุง ุฏูุฑ ูโุฒููุฏุ ู ูุงููุฏ span ุนูู ูโฺฉููุฏ ุงูุง ููโุชูุงููุฏ ุญุงูุธู stack ุฑุง ูพูุดุด ุฏููุฏุ ฺฉู ุงูฺฉุงู ุงุณุชูุงุฏู ุงุฒ ุขูโูุง ุฏุฑ ููุฏูุงุ lambdaูุงุ ูุชุฏูุง async ู ุบุฑู ุฑุง ูุฑุงูู ูโฺฉูุฏ.

ูโุชูุงูุฏ ฺฉ `Memory<T>` ุง `ReadOnlyMemory<T>` ุฑุง ุงุฒ ฺฉ ุขุฑุงู ุงุฒ ุทุฑู **ุชุจุฏู ุถูู** ุง ูุชุฏ extension `AsMemory()` ุจุฏุณุช ุขูุฑุฏ:

```csharp
Memory<int> mem1 = new int[] { 1, 2, 3 };
var mem2 = new int[] { 1, 2, 3 }.AsMemory();
```

ูโุชูุงู ุจูโุณุงุฏฺฏ ฺฉ `Memory<T>` ุง `ReadOnlyMemory<T>` ุฑุง ุจู `Span<T>` ุง `ReadOnlySpan<T>` ุชุจุฏู ฺฉุฑุฏ (ุงุฒ ุทุฑู **Span property**) ุชุง ูุงููุฏ ฺฉ span ุจุง ุขู ุชุนุงูู ุฏุงุดุชู ุจุงุดุฏ. ุงู ุชุจุฏู ฺฉุงุฑุขูุฏ ุงุณุช ู ูฺ ฺฉูพ ุงูุฌุงู ููโุฏูุฏ:

```csharp
async void Foo(Memory<int> memory)
{
    Span<int> span = memory.Span;
    ...
}
```

ููฺูู ูโุชูุงูุฏ ูุณุชููุงู ฺฉ `Memory<T>` ุง `ReadOnlyMemory<T>` ุฑุง ุจุง ูุชุฏ `Slice` ุง ุจุง ุงุณุชูุงุฏู ุงุฒ **C# range** ุจุฑุด ุฏูุฏ ู ุทูู ุขู ุฑุง ุจุง `Length` ุจุฑุฑุณ ฺฉูุฏ.

ุฑุงู ุฏฺฏุฑ ุจุฑุง ุจุฏุณุช ุขูุฑุฏู `Memory<T>`ุ ุงุฌุงุฑู ุขู ุงุฒ **MemoryPool** ุงุณุชุ ุจุง ุงุณุชูุงุฏู ุงุฒ ฺฉูุงุณ `System.Buffers.MemoryPool<T>`. ุงู ุฑูุด ูุงููุฏ **array pooling** ุนูู ูโฺฉูุฏ ู ุงุณุชุฑุงุชฺ ุฏฺฏุฑ ุจุฑุง ฺฉุงูุด ูุดุงุฑ ุฑู **garbage collector** ุงุฑุงุฆู ูโุฏูุฏ.

---

ฺฏูุชู ฺฉู ููโุชูุงู ูุนุงุฏู ูุณุชูู `string.Split` ุจุฑุง span ููุดุชุ ุฒุฑุง ููโุชูุงู ุขุฑุงูโุง ุงุฒ spanูุง ุงุฌุงุฏ ฺฉุฑุฏ. ุงู ูุญุฏูุฏุช ุจุฑุง `ReadOnlyMemory<char>` ุตุฏู ููโฺฉูุฏ:

```csharp
// ุชูุณู ฺฉ ุฑุดุชู ุจู ฺฉููุงุช
IEnumerable<ReadOnlyMemory<char>> Split(ReadOnlyMemory<char> input)
{
    int wordStart = 0;
    for (int i = 0; i <= input.Length; i++)
        if (i == input.Length || char.IsWhiteSpace(input.Span[i]))
        {
            yield return input[wordStart..i];   // Slice ุจุง ุนููฺฏุฑ range ุฏุฑ C#
            wordStart = i + 1;
        }
}
```

ุงู ุฑูุด ุจูโูุฑุงุชุจ ฺฉุงุฑุขูุฏุชุฑ ุงุฒ ูุชุฏ `Split` ุฑุดุชู ุงุณุช: ุจู ุฌุง ุงุฌุงุฏ ุฑุดุชูโูุง ุฌุฏุฏ ุจุฑุง ูุฑ ฺฉูููุ ุจุฑุดโูุง ุงุฒ ุฑุดุชู ุงุตู ุฑุง ุจุงุฒูโฺฏุฑุฏุงูุฏ:

```csharp
foreach (var slice in Split("The quick brown fox jumps over the lazy dog"))
{
    // slice ฺฉ ReadOnlyMemory<char> ุงุณุช
}
```

ูโุชูุงู ุจูโุณุงุฏฺฏ ฺฉ `Memory<T>` ุฑุง ุจู `Span<T>` ุชุจุฏู ฺฉุฑุฏ (ุงุฒ ุทุฑู **Span property**) ุงูุง ุจุฑุนฺฉุณ ุงู ฺฉุงุฑ ุงูฺฉุงูโูพุฐุฑ ูุณุช. ุจู ููู ุฏููุ ุจูุชุฑ ุงุณุช ูุชุฏูุง ุจููุณุฏ ฺฉู `Span<T>` ู `ReadOnlySpan<T>` ุฑุง ุจู ุฌุง `Memory<T>` ู `ReadOnlyMemory<T>` ุจูพุฐุฑูุฏ.

### โฉ Forward-Only Enumerators

ุฏุฑ ุจุฎุด ูุจูุ ุงุฒ `ReadOnlyMemory<char>` ุจูโุนููุงู ุฑุงูโุญู ุจุฑุง ูพุงุฏูโุณุงุฒ ูุชุฏ ุดุจู ุจู `string.Split` ุงุณุชูุงุฏู ฺฉุฑุฏู. ุงูุง ุจุง ฺฉูุงุฑ ฺฏุฐุงุดุชู `ReadOnlySpan<char>`ุ ุชูุงูุง **slicing** spanูุง ฺฉู ุฑู ุญุงูุธู ุบุฑูุฏุฑุชโุดุฏู ูพุดุชุจุงู ูโุดููุฏ ุฑุง ุงุฒ ุฏุณุช ุฏุงุฏู. ุจุงุฏ ุฏูุจุงุฑู ุจู `ReadOnlySpan<char>` ุจุฑฺฏุฑุฏู ู ุจุจูู ุขุง ูโุชูุงูู ุฑุงูโุญู ุฏฺฏุฑ ูพุฏุง ฺฉูู.

ฺฉ ฺฏุฒูู ููฺฉู ุงู ุงุณุช ฺฉู ูุชุฏ `Split` ุฑุง ุทูุฑ ุจููุณู ฺฉู **ranges** ุจุฑฺฏุฑุฏุงูุฏ:

```csharp
Range[] Split(ReadOnlySpan<char> input)
{
    int pos = 0;
    var list = new List<Range>();
    for (int i = 0; i <= input.Length; i++)
        if (i == input.Length || char.IsWhiteSpace(input[i]))
        {
            list.Add(new Range(pos, i));
            pos = i + 1;
        }
    return list.ToArray();
}
```

ุณูพุณ ูุฑุงุฎูุงู ูโุชูุงูุฏ ุงุฒ ุงู ranges ุจุฑุง **slice ฺฉุฑุฏู** span ุงุตู ุงุณุชูุงุฏู ฺฉูุฏ:

```csharp
ReadOnlySpan<char> source = "The quick brown fox";
foreach (Range range in Split(source))
{
    ReadOnlySpan<char> wordSpan = source[range];
    ...
}
```

ุงู ูพุดุฑูุช ุงุณุชุ ุงูุง ูููุฒ ฺฉุงูู ูุณุช. ฺฉ ุงุฒ ุฏูุงู ุงุณุชูุงุฏู ุงุฒ spans ุงุฌุชูุงุจ ุงุฒ ุชุฎุตุต ุญุงูุธู ุงุณุช. ุชูุฌู ฺฉูุฏ ฺฉู ูุชุฏ `Split` ูุง ฺฉ `List<Range>` ุงุฌุงุฏ ูโฺฉูุฏุ ุขุชูโูุง ุฑุง ุจู ุขู ุงุถุงูู ูโฺฉูุฏ ู ุณูพุณ ูุณุช ุฑุง ุจู ุขุฑุงู ุชุจุฏู ูโฺฉูุฏ. ุงู ุญุฏุงูู ุฏู ุชุฎุตุต ุญุงูุธู ู ฺฉ ุนููุงุช ฺฉูพ ุญุงูุธู ุงุฌุงุฏ ูโฺฉูุฏ.

ุฑุงูโุญู ุงู ุงุณุช ฺฉู ุงุฒ **forward-only enumerator** ุจู ุฌุง ูุณุช ู ุขุฑุงู ุงุณุชูุงุฏู ฺฉูู. ฺฉ enumerator ฺฉู ุฏุณุช ู ูพุงฺฏุฑ ุงุณุชุ ุงูุง ูโุชูุงู ุจุง ุงุณุชูุงุฏู ุงุฒ **struct** ุขู ุฑุง ุจุฏูู ุชุฎุตุต ุญุงูุธู ุณุงุฎุช:

```csharp
public readonly ref struct CharSpanSplitter
{
    readonly ReadOnlySpan<char> _input;
    public CharSpanSplitter(ReadOnlySpan<char> input) => _input = input;
    public Enumerator GetEnumerator() => new Enumerator(_input);

    public ref struct Enumerator   // Forward-only enumerator
    {
        readonly ReadOnlySpan<char> _input;
        int _wordPos;
        public ReadOnlySpan<char> Current { get; private set; }

        public Enumerator(ReadOnlySpan<char> input)
        {
            _input = input;
            _wordPos = 0;
            Current = default;
        }

        public bool MoveNext()
        {
            for (int i = _wordPos; i <= _input.Length; i++)
                if (i == _input.Length || char.IsWhiteSpace(_input[i]))
                {
                    Current = _input[_wordPos..i];
                    _wordPos = i + 1;
                    return true;
                }
            return false;
        }
    }
}

public static class CharSpanExtensions
{
    public static CharSpanSplitter Split(this ReadOnlySpan<char> input)
        => new CharSpanSplitter(input);
    public static CharSpanSplitter Split(this Span<char> input)
        => new CharSpanSplitter(input);
}
```

ู ูุญูู ูุฑุงุฎูุงู ุขู:

```csharp
var span = "the quick brown fox".AsSpan();
foreach (var word in span.Split())
{
    // word ฺฉ ReadOnlySpan<char> ุงุณุช
}
```

ุจุง ุชุนุฑู **Current** ู **MoveNext**ุ enumerator ูุง ูโุชูุงูุฏ ุจุง ุฏุณุชูุฑ `foreach` ุฏุฑ C# ฺฉุงุฑ ฺฉูุฏ. ูุงุฒ ุจู ูพุงุฏูโุณุงุฒ `IEnumerable<T>` ุง `IEnumerator<T>` ูุฏุงุฑู (ุฏุฑ ูุงูุน ููโุชูุงููุ ref structูุง ููโุชูุงููุฏ ุงูุชุฑูุณโูุง ุฑุง ูพุงุฏูโุณุงุฒ ฺฉููุฏ). ุฏุฑ ุงูุฌุง ูุง **abstraction** ุฑุง ูุฏุง **micro optimization** ฺฉุฑุฏูโุงู.

---

### ๐ก ฺฉุงุฑ ุจุง ุญุงูุธู stack ู unmanaged

ฺฉ ุชฺฉูฺฉ ููุซุฑ ุฏฺฏุฑ ุจุฑุง **micro-optimization** ฺฉุงูุด ูุดุงุฑ ุฑู **garbage collector** ุจุง ฺฉููู ฺฉุฑุฏู ุชุฎุตุต ุญุงูุธู ุฑู heap ุงุณุช. ุงู ุนู ุงุณุชูุงุฏู ุจุดุชุฑ ุงุฒ ุญุงูุธู **stack** ุง ุญุช ุญุงูุธู ุบุฑูุฏุฑุชโุดุฏู.

ูุนูููุงู ุงู ูุงุฒููุฏ ุจุงุฒููุณ ฺฉุฏ ุจุง ุงุดุงุฑูโฺฏุฑูุงุณุช. ุจุฑุง ูุซุงู ุฌูุนโุขูุฑ ุนูุงุตุฑ ฺฉ ุขุฑุงูุ ูุงุฒ ุงุณุช ูุณุฎู ุฏฺฏุฑ ุงุฒ ูุชุฏ ุจููุณู:

```csharp
unsafe int Sum(int* numbers, int length)
{
    int total = 0;
    for (int i = 0; i < length; i++) total += numbers[i];
    return total;
}
```

ู ุณูพุณ:

```csharp
int* numbers = stackalloc int[1000];   // ุชุฎุตุต ุขุฑุงู ุฑู stack
int total = Sum(numbers, 1000);
```

`Span` ุงู ูุดฺฉู ุฑุง ุญู ูโฺฉูุฏ: ูโุชูุงู ฺฉ `Span<T>` ุง `ReadOnlySpan<T>` ุฑุง ูุณุชููุงู ุงุฒ ฺฉ ุงุดุงุฑูโฺฏุฑ ุณุงุฎุช:

```csharp
int* numbers = stackalloc int[1000];
var span = new Span<int>(numbers, 1000);
```

ุง ุฏุฑ ฺฉ ูุฑุญูู:

```csharp
Span<int> numbers = stackalloc int[1000];
```

(ุชูุฌู: ุงู ูุงุฒ ุจู ุงุณุชูุงุฏู ุงุฒ `unsafe` ูุฏุงุฑุฏ.)

ูุชุฏ ูุจู `Sum` ุจุง `ReadOnlySpan<int>` ูุฒ ุจุฑุง spanูุง ุชุฎุตุตโุงูุชู ุฑู stack ุจู ููุงู ุฎูุจ ฺฉุงุฑ ูโฺฉูุฏ:

```csharp
int Sum(ReadOnlySpan<int> numbers)
{
    int total = 0;
    int len = numbers.Length;
    for (int i = 0; i < len; i++) total += numbers[i];
    return total;
}
```

ุงู ุฑูุด ุณู ูุฒุช ุฏุงุฑุฏ:

* ููุงู ูุชุฏ ุจุฑุง ุขุฑุงูโูุง ู ุญุงูุธู ุชุฎุตุตโุงูุชู ุฑู stack ฺฉุงุฑ ูโฺฉูุฏ
* ูโุชูุงู ุญุงูุธู stack ุฑุง ุจุง ุญุฏุงูู ุงุณุชูุงุฏู ุงุฒ ุงุดุงุฑูโฺฏุฑูุง ุงุณุชูุงุฏู ฺฉุฑุฏ
* span ูโุชูุงูุฏ slice ุดูุฏ

ฺฉุงููพุงูุฑ ุจู ุงูุฏุงุฒู ฺฉุงู ููุดููุฏ ุงุณุช ฺฉู ุงุฌุงุฒู ูุฏูุฏ ูุชุฏ ุจููุณุฏ ฺฉู ุญุงูุธู ุฑู stack ุชุฎุตุต ุฏูุฏ ู ุขู ุฑุง ุงุฒ ุทุฑู `Span<T>` ุง `ReadOnlySpan<T>` ุจู ูุฑุงุฎูุงููุฏู ุจุฑฺฏุฑุฏุงูุฏ.
(ุจุง ุงู ุญุงูุ ุฏุฑ ุณูุงุฑููุง ุฏฺฏุฑุ ูโุชูุงูุฏ ูุงููู ฺฉ `Span<T>` ุง `ReadOnlySpan<T>` ุจุฑฺฏุฑุฏุงูุฏ.)

ููฺูู ูโุชูุงูุฏ ุงุฒ spans ุจุฑุง ูพูุดุด ุญุงูุธูโุง ฺฉู ุงุฒ heap ุบุฑูุฏุฑุชโุดุฏู ุชุฎุตุต ุฏุงุฏูโุงุฏ ุงุณุชูุงุฏู ฺฉูุฏ. ูุซุงู ุฒุฑ:

```csharp
var source = "The quick brown fox".AsSpan();
var ptr = Marshal.AllocHGlobal(source.Length * sizeof(char));

try
{
    var unmanaged = new Span<char>((char*)ptr, source.Length);
    source.CopyTo(unmanaged);
    foreach (var word in unmanaged.Split())
        Console.WriteLine(word.ToString());
}
finally
{
    Marshal.FreeHGlobal(ptr);
}
```

ฺฉ ูุฒุช ุฌุงูุจ: **indexer** `Span<T>` ุจุฑุฑุณ ูุญุฏูุฏู ุงูุฌุงู ูโุฏูุฏ ู ุงุฒ overflow ุฌููฺฏุฑ ูโฺฉูุฏ. ุงู ูุญุงูุธุช ุชููุง ุฏุฑ ุตูุฑุช ุงุนูุงู ูโุดูุฏ ฺฉู `Span<T>` ุฑุง ุจูโุฏุฑุณุช ููุฏุงุฑุฏู ฺฉุฑุฏู ุจุงุดุฏุ ูุซูุงู ุงฺฏุฑ ุงุดุชุจุงูุงู ุทูู span ุฑุง ุฏู ุจุฑุงุจุฑ ฺฉูุฏุ ุงู ูุญุงูุธุช ุงุฒ ุจู ูโุฑูุฏ:

```csharp
var span = new Span<char>((char*)ptr, source.Length * 2); // ุฎุทุฑูุงฺฉ!
```

ููฺูู ูฺ ูุญุงูุธุช ุฏุฑ ุจุฑุงุจุฑ **dangling pointer** ูุฌูุฏ ูุฏุงุฑุฏุ ุจูุงุจุฑุงู ุจุงุฏ ูุฑุงูุจ ุจุงุดุฏ ูพุณ ุงุฒ ุขุฒุงุฏ ฺฉุฑุฏู ุญุงูุธู unmanaged ุจุง `Marshal.FreeHGlobal` ุจู span ุฏุณุชุฑุณ ูุฏุงุดุชู ุจุงุดุฏ.
